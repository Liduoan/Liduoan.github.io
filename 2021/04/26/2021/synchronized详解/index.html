<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="liduoan.efls">
    
    <title>
        
            synchronized详解 |
        
        liduoan修炼笔记
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="https://i.postimg.cc/MpmSbVgT/4-U-3-AU-6-0-R8-L6-K5658-H.jpg">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/fontawesome.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/regular.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/solid.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/brands.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"zh-CN","path":"search.json"}
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066cc","logo":"https://i.postimg.cc/MpmSbVgT/4-U-3-AU-6-0-R8-L6-K5658-H.jpg","favicon":"https://i.postimg.cc/MpmSbVgT/4-U-3-AU-6-0-R8-L6-K5658-H.jpg","avatar":"https://i.postimg.cc/MpmSbVgT/4-U-3-AU-6-0-R8-L6-K5658-H.jpg","font_size":null,"font_family":"STSong","hover":{"shadow":true,"scale":false},"first_screen":{"enable":true,"header_transparent":true,"background_img":"/images/bg.svg","description":"世之奇伟、瑰怪，非常之观，常在于险远 || 而人之所罕至焉，故非有志者不能至也","font_color":null,"hitokoto":false},"scroll":{"progress_bar":true,"percent":false}},"local_search":{"enable":true,"preload":true},"code_copy":{},"code_block":{"tools":{"enable":true,"style":"default"},"highlight_theme":"default"},"side_tools":{},"pjax":{"enable":true},"lazyload":{"enable":true},"comment":{"enable":false,"use":"valine","valine":{"appid":null,"appkey":null,"server_urls":null,"placeholder":null},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.8"},"waline":{"server_url":null,"reaction":false,"version":2}},"post":{"author_label":{"enable":true,"auto":true,"custom_label_list":["Trainee","Engineer","Architect"]},"word_count":{"enable":true,"wordcount":true,"min2read":true},"img_align":"left","copyright_info":true},"version":"3.6.1"}
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"}
    KEEP.language_code_block = {"copy":"复制代码","copied":"已复制","fold":"折叠代码块","folded":"已折叠"}
    KEEP.language_copy_copyright = {"copy":"复制版权信息","copied":"已复制","title":"原文标题","author":"原文作者","link":"原文链接"}
  </script>
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
                <a class="logo-image" href="/">
                    <img src="https://i.postimg.cc/MpmSbVgT/4-U-3-AU-6-0-R8-L6-K5658-H.jpg">
                </a>
            
            <a class="logo-title" href="/">
               liduoan修炼笔记
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            <div class="article-title">
                <span class="title-hover-animation">synchronized详解</span>
            </div>

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="https://i.postimg.cc/MpmSbVgT/4-U-3-AU-6-0-R8-L6-K5658-H.jpg">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">liduoan.efls</span>
                            
                                <span class="author-label">Lv4</span>
                            
                        </div>
                        <div class="meta-info">
                            
<div class="article-meta-info">
    <span class="article-date article-meta-item">
        
            <i class="fa-regular fa-calendar-plus"></i>&nbsp;
        
        <span class="pc">2021-04-26 22:07:11</span>
        <span class="mobile">2021-04-26 22:07</span>
    </span>
    
        <span class="article-update-date article-meta-item">
        <i class="fas fa-file-pen"></i>&nbsp;
        <span class="pc">2023-01-14 23:04:21</span>
    </span>
    
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/2021/">2021</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>5.1k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>19 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content keep-markdown-body">
                

                <span id="more"></span>

<h1 id="同步器"><a href="#同步器" class="headerlink" title="同步器"></a>同步器</h1><p>多线程编程中，可能出现多个线程同时访问同一个共享，可变资源的情况，这个资源我们称之为临界资源。</p>
<blockquote>
<p>共享：资源可以由多个线程同时访问</p>
</blockquote>
<blockquote>
<p>可变：资源可以在其生命周期内被修改</p>
</blockquote>
<p>由此，我们可以引出一个问题：</p>
<p>由于线程执行的过程是不可控的，所以需要采用同步机制来协同对象可变状态的访问。 </p>
<p>常见的解决线程并发安全问题的方式是<strong>序列化访问临界资源</strong></p>
<p>即在同一时刻只允许一个线程访问临界资源，也称作为同步互斥访问。</p>
<p>Java中提供了两种方式来实现同步互斥访问：<code>synchronized </code><strong>和</strong> <code>Lock</code></p>
<p>同步器的本质就是加锁，为了序列化访问临界资源</p>
<h1 id="synchronized原理详解"><a href="#synchronized原理详解" class="headerlink" title="synchronized原理详解"></a><strong>synchronized原理详解</strong></h1><p><strong>synchronized内置锁是一种对象锁(锁的是对象而非引用)，作用粒度是对象，可以用来实现对临界资源的同步互斥访问，是可重入的。</strong></p>
<p>加锁的方式：</p>
<p>1、同步实例方法，锁是当前实例对象</p>
<p>2、同步类方法，锁是当前类对象</p>
<p>3、同步代码块，锁是括号里面的对象</p>
<h2 id="Monitor监视器锁"><a href="#Monitor监视器锁" class="headerlink" title="Monitor监视器锁"></a><strong>Monitor监视器锁</strong></h2><p>任何一个对象都有一个Monitor与之关联，当且一个Monitor被持有后，它将处于锁定状态。</p>
<p>Synchronized在JVM里的实现都是 基于进入和退出Monitor对象来实现方法同步和代码块同步，虽然具体实现细节不一样，但是都可以通过成对的MonitorEnter和MonitorExit指令来实现。</p>
<h2 id="synchronized关键词的JVM指令"><a href="#synchronized关键词的JVM指令" class="headerlink" title="synchronized关键词的JVM指令"></a>synchronized关键词的JVM指令</h2><p>使用<code>synchronized</code>修饰代码块时，字节码后会被翻译成<strong>monitorenter</strong>和<strong>monitorexit</strong>两条指令分别在同步块逻辑代码的起始位置与结束位置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class version 51.0 (51)</span></span><br><span class="line"><span class="comment">// access flags 0x21</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Basic</span>/Thread1 &#123;</span><br><span class="line">  .........</span><br><span class="line">  <span class="comment">// access flags 0x9</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">main</span><span class="params">([Ljava/lang/String;)</span>V</span><br><span class="line">  ...........</span><br><span class="line">  <span class="comment">//!!!!!!!!!!!!!!</span></span><br><span class="line">    MONITORENTER</span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER <span class="number">38</span> L0</span><br><span class="line">    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;</span><br><span class="line">    LDC <span class="string">&quot;\u9501\u8fdb\u5165wait\u7b49\u5f85\u4e4b\u524d\u7684\u4ee3\u7801&quot;</span></span><br><span class="line">    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V</span><br><span class="line">   L7</span><br><span class="line">    LINENUMBER <span class="number">39</span> L7</span><br><span class="line">    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;</span><br><span class="line">    LDC <span class="string">&quot;\u9501\u8fdb\u5165wait\u7b49\u5f85\u4e4b\u540e\u7684\u4ee3\u7801&quot;</span></span><br><span class="line">    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V</span><br><span class="line">   L8</span><br><span class="line">    LINENUMBER <span class="number">40</span> L8</span><br><span class="line">    ALOAD <span class="number">2</span></span><br><span class="line">    <span class="comment">//!!!!!!!!!!!!!!!!!!!!!!!!</span></span><br><span class="line">    MONITOREXIT</span><br><span class="line">   L1</span><br><span class="line">    GOTO L9</span><br><span class="line">   L2</span><br><span class="line">   FRAME FULL [[Ljava/lang/String; java/lang/String java/lang/Object] [java/lang/Throwable]</span><br><span class="line">    ASTORE <span class="number">3</span></span><br><span class="line">    ALOAD <span class="number">2</span></span><br><span class="line">    <span class="comment">//!!!!!!!!!!!!!!!!!!!!!!!!</span></span><br><span class="line">    MONITOREXIT</span><br><span class="line">   L3</span><br><span class="line">   ..........................</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这两条指令对于不同的锁会有不同的操作。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/05/prOyt8lGUSz5YLE.jpg"
                      alt="Screenshot_61.jpg"
                ></p>
<p><strong>monitorenter</strong>：</p>
<p>每个对象都是一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：</p>
<p>1、<strong>如果monitor的进入数为0</strong>，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者；</p>
<p>2、<strong>如果线程已经占有该monitor</strong>，只是重新进入，则进入monitor的进入数加1；</p>
<p>3、<strong>如果其他线程已经占用了monitor</strong>，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权；</p>
<p><strong>monitorexit</strong>：</p>
<p>执行monitorexit的线程必须是object所对应的monitor的所有者。<strong>指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者</strong>。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。</p>
<p><strong>monitorexit，指令出现了两次，第1次为同步正常退出释放锁；第2次为发生异常退出释放锁</strong>；</p>
<p>通过上面两段描述，我们应该能很清楚的看出Synchronized的实现原理</p>
<p><strong>Synchronized的语义底层是通过一个monitor的对象来完成，其实wait&#x2F;notify等方法也依赖于monitor对象</strong>，这就是为什么只有在同步的块或者方法中才能调用wait&#x2F;notify等方法，<strong>否则会抛出<code>java.lang.IllegalMonitorStateException</code>的异常的原因</strong>。</p>
<p>而使用<code>synchronized</code>修饰方法时，JVM指令如下：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/04/zeLXxsqnD7rwHVk.jpg"
                      alt="Screenshot_60.jpg"
                ></p>
<h2 id="对象上的锁"><a href="#对象上的锁" class="headerlink" title="对象上的锁"></a>对象上的锁</h2><p>Synchronized一般有三种用法：</p>
<ol>
<li>锁类中的普通方法，锁的是当前实例对象(this)，多个实例对象对应多把锁</li>
<li>锁类中的静态方法，锁的是当前类的Class对象，只有唯一一把锁</li>
<li>锁类中普通方法的代码块，锁是<code>synchronized()</code>括号里面的对象，如果是静态对象只有唯一一把锁</li>
</ol>
<p>无论是哪种用法，锁的都是对象，那么到底怎么给一个Java对象加锁呢？</p>
<p>首先我们都知道<code>synchronized</code>是依靠Monitor进行加解锁的，而Monitor对象是存在于每个Java对象的对象头<code>Mark Word</code>中（存储的指针的指向）。</p>
<p><code>Synchronized</code>锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因，同时<code>notify/notifyAll/wait</code>等方法会使用到Monitor锁对象，所以必须在同步代码块中使用。</p>
<p>监视器Monitor有两种同步方式：互斥与协作。多线程环境下线程之间如果需要共享数据，需要解决互斥访问数据的问题，监视器可以确保监视器上的数据在同一时刻只会有一个线程在访问。</p>
<p>那么有个问题来了，我们知道synchronized加锁加在对象上，对象是如何记录锁状态的呢？</p>
<p><strong>答案是锁状态是被记录在每个对象的对象头（Mark Word）中，下面我们一起认识一下对象的内存布局</strong></p>
<h3 id="对象头结构"><a href="#对象头结构" class="headerlink" title="对象头结构"></a>对象头结构</h3><p>之前我们也介绍过，HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域，对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）：<img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/05/VU7IMCfrcFkiSag.jpg"
                      alt="Screenshot_62.jpg"
                ></p>
<p>HotSpot虚拟机的<strong>对象头</strong>包括两部分信息</p>
<p>其中第一部分是<strong>Mark Word</strong>，用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等，<strong>它是实现轻量级锁和偏向锁的关键</strong>。</p>
<p>这部分数据的长度在32位和64位的虚拟机中分别为32个和64个Bits</p>
<p>我们单以32位举例：</p>
<p>32位虚拟机的Mark Word</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/05/T6AR3LhsEocbiIj.jpg"
                      alt="Screenshot_64.jpg"
                ></p>
<p>Mark word确定了该对象的状态，我们可以通过上图看到，锁标志位为重量级锁的时候，才指向Monitor指针。</p>
<p>而在无锁  偏向锁  轻量级锁时，无锁状态时分代年龄等都记录在Markword</p>
<p>偏向锁的时候，就是线程ID和分代年龄等等。</p>
<p>那么锁升级的时候，那些信息大概是保存在其他地方了。</p>
<h2 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h2><p>在Mark Word字段表中，分别有无锁，偏向锁，轻量级锁和重量级锁，下面我们分别介绍。</p>
<h3 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h3><p>无锁状态对应Mark Word表中：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/04/27/eQr3bu7EfGqTgvk.jpg"
                      alt="Screenshot_54.jpg"
                ></p>
<p>无锁非常简单，一个对象在刚刚创建的时候它就是无锁状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Juc_PrintMarkWord</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="comment">//未出现任何获取锁的时候</span></span><br><span class="line">        System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对象头中的Mark Word内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无锁</span></span><br><span class="line">OFFSET  SIZE   TYPE DESCRIPTION         VALUE</span><br><span class="line">    <span class="number">0</span>     <span class="number">4</span>     (object header)        <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">1</span>)</span><br><span class="line">    <span class="number">4</span>     <span class="number">4</span>     (object header)        <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>锁标志为对应的是<strong>001</strong>，表示没有锁。【小端模式</p>
<h3 id="偏向锁-单线程"><a href="#偏向锁-单线程" class="headerlink" title="偏向锁(单线程)"></a>偏向锁(单线程)</h3><p>偏向锁，顾名思义就是偏向第一个获取到锁对象的线程，并且在运行过程中，<strong>只有一个线程会访问同步代码块，不存在多线程的场景</strong>，这种情况下加的就是偏向锁。偏向锁状态对应Mark Word表中：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/04/27/WvV8EJPdKDNpjLa.jpg"
                      alt="Screenshot_55.jpg"
                ></p>
<p>可以看到当对象持有偏向锁时，对象头中记录了持有该偏向锁的线程ID。我们来演示一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Juc_PrintMarkWord</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="comment">//未出现任何获取锁的时候</span></span><br><span class="line">        System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">        <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">            <span class="comment">// 获取一次锁之后</span></span><br><span class="line">            System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们预期的结果应该是第一次打印<strong>001</strong>，第二次打印<strong>101</strong>，可是结果却如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次打印：无锁</span></span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION           VALUE</span><br><span class="line">     <span class="number">0</span>     <span class="number">4</span>        (object header)       <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">1</span>)</span><br><span class="line">     <span class="number">4</span>     <span class="number">4</span>        (object header)       <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 第二次打印：轻量级锁</span></span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION      VALUE</span><br><span class="line">     <span class="number">0</span>     <span class="number">4</span>      (object header)    <span class="number">18</span> f8 e5 <span class="number">02</span> (<span class="number">00011000</span> <span class="number">11111000</span> <span class="number">11100101</span> <span class="number">00000010</span>) (<span class="number">48625688</span>)</span><br><span class="line">     <span class="number">4</span>     <span class="number">4</span>      (object header)    <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>不对啊，为什么直接变成轻量级锁了？难道不应该是偏向锁吗？</p>
<p>这是由于java对于偏向锁的启动是在启动几秒之后才激活导致的，因为JVM启动的过程中会有大量的同步块，且这些同步块都有竞争，如果一启动就启动偏向锁，会出现很多没有必要的锁升级和撤销，因此JVM选择直接将其设置为轻量级锁。</p>
<p>我们可以通过参数<code>-XX:BiasedLockingStartupDelay=0</code>参数，将偏向锁启动延迟设置为0，我们再启动一次看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次打印：匿名偏向锁</span></span><br><span class="line">OFFSET  SIZE   TYPE DESCRIPTION       VALUE</span><br><span class="line">     <span class="number">0</span>     <span class="number">4</span>       (object header)    <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000101</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">5</span>)</span><br><span class="line">     <span class="number">4</span>     <span class="number">4</span>       (object header)    <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次打印：偏向锁</span></span><br><span class="line">OFFSET  SIZE   TYPE DESCRIPTION      VALUE</span><br><span class="line">     <span class="number">0</span>     <span class="number">4</span>      (object header)    <span class="number">05</span> <span class="number">28</span> <span class="number">05</span> <span class="number">03</span> (<span class="number">00000101</span> <span class="number">00101000</span> <span class="number">00000101</span> <span class="number">00000011</span>) (<span class="number">50669573</span>)</span><br><span class="line">     <span class="number">4</span>     <span class="number">4</span>      (object header)    <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到，JVM一开始就将对象状态设置为偏向锁，这是因为它检测到了我们后面可能会以该对象为锁产生线程竞争。不过我们可以发现一开始，其对象头中并没有保存线程ID，因为还没有线程获取锁，我们将其称为<strong>匿名偏向锁</strong>。</p>
<p>之后又一个线程对获取了该锁，于是该对象头中就会记录该线程的ID。另外，通过参数<code>-XX:-UseBiasedLocking</code>可以关闭偏向锁，默认开启。</p>
<p>经过研究发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁(一些CAS操作)的代价而引入偏向锁。</p>
<p><strong>偏向锁的核心思想是：</strong></p>
<p>如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时， 无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。所以，对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。</p>
<p>但是对于<strong>不止一个线程访问锁</strong>的场合(无论有没有竞争)，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，而是升级为轻量级锁，如下图所示：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/05/Ci5YsZWc8pvU3Tw.jpg"
                      alt="Screenshot_65.jpg"
                ></p>
<p>当然，撤销偏向锁也是一个过程：需要在<strong>安全点</strong>暂停当前持有该偏向锁的线程，如果这时该线程还没有执行完同步代码块，则将锁升级为轻量级锁。</p>
<h3 id="轻量级锁-多个线程交替执行"><a href="#轻量级锁-多个线程交替执行" class="headerlink" title="轻量级锁(多个线程交替执行)"></a>轻量级锁(多个线程交替执行)</h3><p>倘若出现了多个线程，虚拟机并不会立即将锁升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段，此时 Mark Word 的结构也变为轻量级锁的结构：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/05/dWYhmPCQ1SR5DnE.jpg"
                      alt="Screenshot_66.jpg"
                ></p>
<p>我们来演示一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Juc_PrintMarkWord</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="comment">// 未出现任何获取锁的时候</span></span><br><span class="line">        System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">	    <span class="comment">// 线程1获取锁</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">                System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 线程2获取锁</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">                System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次输出：匿名偏向锁</span></span><br><span class="line">OFFSET  SIZE   TYPE DESCRIPTION         VALUE</span><br><span class="line">     <span class="number">0</span>     <span class="number">4</span>      (object header)      <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000101</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">5</span>)</span><br><span class="line">     <span class="number">4</span>     <span class="number">4</span>      (object header)      <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次输出：偏向锁(线程1持有)</span></span><br><span class="line">OFFSET  SIZE    TYPE DESCRIPTION       VALUE</span><br><span class="line">     <span class="number">0</span>     <span class="number">4</span>      (object header)    <span class="number">05</span> d8 b2 <span class="number">1f</span> (<span class="number">00000101</span> <span class="number">11011000</span> <span class="number">10110010</span> <span class="number">00011111</span>) (<span class="number">531814405</span>)</span><br><span class="line">     <span class="number">4</span>     <span class="number">4</span>      (object header)    <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三次输出：偏向锁(线程1持有)</span></span><br><span class="line">OFFSET  SIZE   TYPE DESCRIPTION         VALUE</span><br><span class="line">     <span class="number">0</span>     <span class="number">4</span>      (object header)    <span class="number">05</span> d8 b2 <span class="number">1f</span> (<span class="number">00000101</span> <span class="number">11011000</span> <span class="number">10110010</span> <span class="number">00011111</span>) (<span class="number">531814405</span>)</span><br><span class="line">     <span class="number">4</span>     <span class="number">4</span>      (object header)    <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第四次输出：轻量级锁(线程2持有)</span></span><br><span class="line">OFFSET  SIZE   TYPE DESCRIPTION         VALUE</span><br><span class="line">     <span class="number">0</span>     <span class="number">4</span>      (object header)    <span class="number">90</span> f0 <span class="number">94</span> <span class="number">1f</span> (<span class="number">10010000</span> <span class="number">11110000</span> <span class="number">10010100</span> <span class="number">00011111</span>) (<span class="number">529854608</span>)</span><br><span class="line">     <span class="number">4</span>     <span class="number">4</span>      (object header)    <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到，当线程2申请锁后，由于当前偏向锁中的线程ID不是自己的ID，因此升级为了轻量级锁。轻量级锁对应的Mark Word中除了锁标志位，还有一个**指向线程栈中锁记录的指针(pointer to Lock Record)**，那么这个锁记录(Lock Record)是什么？</p>
<p>当升级为轻量级锁后，Mark Word的结构会发生改变，原来Mark Word的内容会被拷贝至当前持有该锁的线程栈帧中的**锁记录(Lock Record)**区域，而Mark Word会变为指向这块区域的一个指针。如图所示：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/05/9u75zTiNYlKaFhg.jpg"
                      alt="Screenshot_67.jpg"
                ></p>
<p>Lock Record是线程帧栈中的一个内存区域，其中有两个重要的字段：</p>
<ul>
<li>_displaced_header：存放原来锁对象Mark Word的拷贝，用于CAS操作</li>
<li>owner：指向锁对象，便于找到哪个对象被锁住了</li>
</ul>
<p>简单来说，Mark Word中的指针用于找到哪个线程正持有该锁。如果有另一个线程要获取该轻量级锁，流程如下：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/05/iwP81IlE9y3VurL.jpg"
                      alt="Screenshot_69.jpg"
                ></p>
<p>可以看到，轻量级锁竞争的过程，其实主要就是锁对象Mark Word中锁记录指针修改的过程，如果修改失败，那么说明该锁对象正在被其他线程持有。自旋一会，依旧不能获得锁就会升级为重量级锁。这样看，轻量级锁的情况下一旦有竞争，就会升级为重量级锁，那轻量级锁的存在有什么意义呢？</p>
<p>轻量级锁能够提升程序性能的依据是<strong>对绝大部分的锁，在整个同步周期内都不存在竞争</strong>，注意这是经验数据。需要了解的是，轻量级锁所适应的场景是<strong>线程交替执行</strong>同步块的场合，如果存在同一时间访问同一锁的场合，即产生了锁的竞争，就会导致轻量级锁膨胀为重量级锁。 膨胀过程大致如下：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/05/1liYHjt5ozV8DpL.jpg"
                      alt="Screenshot_70.jpg"
                ></p>
<ol>
<li>线程2申请轻量级锁，发现锁记录指针指向线程1的栈帧，锁被线程1持有，发生了锁竞争，锁进行膨胀</li>
<li>线程2初始化Monitor对象，将锁记录指针修改为指向Monitor对象的指针</li>
<li>此时，线程1还在执行，因此Monitor的拥有者为线程1，而线程2进入等待队列</li>
<li>线程1执行完毕后，发现锁以及升级为重量级锁了，通过锁记录中的owner找到Monitor对象，进行重量级锁的释放流程</li>
</ol>
<h3 id="重量级锁-多线程存在竞争"><a href="#重量级锁-多线程存在竞争" class="headerlink" title="重量级锁(多线程存在竞争)"></a>重量级锁(多线程存在竞争)</h3><p>在轻量级锁的情况下，如果存在了多线程竞争锁，那锁就会升级为重量级锁，对象的Mark Word也会发生变化：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/05/o7svrghZ1Hk2u43.jpg"
                      alt="Screenshot_71.jpg"
                ></p>
<p>我们来演示一下重量级锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Juc_PrintMarkWord</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="comment">// 未出现任何获取锁的时候</span></span><br><span class="line">        System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">	    <span class="comment">// 线程1获取锁</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (a)&#123;</span><br><span class="line">                    System.out.println(ClassLayout.parseInstance(a).toPrintable());</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//让线程晚点死亡，造成锁的竞争</span></span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 线程2获取锁</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (a)&#123;</span><br><span class="line">                    System.out.println(ClassLayout.parseInstance(a).toPrintable());</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 线程1、2同时启动，产生锁竞争</span></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次输出:匿名偏向锁</span></span><br><span class="line">OFFSET  SIZE   TYPE DESCRIPTION          VALUE</span><br><span class="line">     <span class="number">0</span>     <span class="number">4</span>      (object header)       <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000101</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">5</span>)</span><br><span class="line">     <span class="number">4</span>     <span class="number">4</span>      (object header)       <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次输出:偏向锁</span></span><br><span class="line">OFFSET  SIZE   TYPE DESCRIPTION        VALUE</span><br><span class="line">     <span class="number">0</span>     <span class="number">4</span>      (object header)     <span class="number">05</span> <span class="number">98</span> e7 <span class="number">1f</span> (<span class="number">00000101</span> <span class="number">10011000</span> <span class="number">11100111</span> <span class="number">00011111</span>) (<span class="number">535271429</span>)</span><br><span class="line">     <span class="number">4</span>     <span class="number">4</span>      (object header)     <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三次输出：重量级锁</span></span><br><span class="line">OFFSET  SIZE   TYPE DESCRIPTION        VALUE</span><br><span class="line">     <span class="number">0</span>     <span class="number">4</span>      (object header)     a f5 e3 1c (<span class="number">01011010</span> <span class="number">11110101</span> <span class="number">11100011</span> <span class="number">00011100</span>) (<span class="number">484701530</span>)</span><br><span class="line">     <span class="number">4</span>     <span class="number">4</span>      (object header)     <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到，线程1、2同时启动后，会产生锁竞争，于是我们看到出现了重量级锁。之前我们能也介绍了，Mark Word中的指向锁记录的指针，会变成指向<strong>Monitor</strong>对象的指针。那这个Monitor对象是什么？它有什么用？</p>
<p>我们先来看看C++源码中对Monitor的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Monitor的结构体</span></span><br><span class="line">ObjectMonitor::<span class="built_in">ObjectMonitor</span>() &#123;  </span><br><span class="line">  _header       = <span class="literal">NULL</span>;    <span class="comment">// 对象头</span></span><br><span class="line">  _count        = <span class="number">0</span>;       </span><br><span class="line">  _waiters      = <span class="number">0</span>,  </span><br><span class="line">  _recursions   = <span class="number">0</span>;       <span class="comment">// 线程的重入次数</span></span><br><span class="line">  _object       = <span class="literal">NULL</span>;    </span><br><span class="line">  _owner        = <span class="literal">NULL</span>;    <span class="comment">// 标识拥有该monitor的线程，即持有锁的线程</span></span><br><span class="line">  _WaitSet      = <span class="literal">NULL</span>;    <span class="comment">// 等待线程的集合，调用object.wait()方法处于wait状态的线程处于其中</span></span><br><span class="line">                           <span class="comment">// 调用object.notify()方法后会进入_cxq或_EntryList中</span></span><br><span class="line">  _WaitSetLock  = <span class="number">0</span> ;  </span><br><span class="line">  _Responsible  = <span class="literal">NULL</span> ;  </span><br><span class="line">  _succ         = <span class="literal">NULL</span> ;  </span><br><span class="line">  _cxq          = <span class="literal">NULL</span> ;    <span class="comment">// 多线程竞争锁时，竞争线程首先进入的单向链表</span></span><br><span class="line">  FreeNext      = <span class="literal">NULL</span> ;  </span><br><span class="line">  _EntryList    = <span class="literal">NULL</span> ;    <span class="comment">// 所有在等待获取锁的线程的集合</span></span><br><span class="line">  _SpinFreq     = <span class="number">0</span> ;  </span><br><span class="line">  _SpinClock    = <span class="number">0</span> ;  </span><br><span class="line">  OwnerIsThread = <span class="number">0</span> ;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以把Monitor理解为一个同步工具，也可以描述为一种同步机制，它通常被描述为一个对象。</p>
<p>与一切皆对象一样，在Java虚拟机（HotSpot）中，Monitor是由ObjectMonitor实现的，它就是实现重量级锁的关键。</p>
<p>所有的状态为重量级锁的对象，其对象头中的指针都指向一个Monitor，那么所有线程针对这把锁的竞争、释放都是基于这个Monitor实现的。</p>
<p>我们来看看在重量级锁的级别下线程对锁的竞争：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/05/P2ylkgvSQboLxr8.jpg"
                      alt="Screenshot_72.jpg"
                ></p>
<p>我们看到了一个叫做<strong>自旋</strong>的操作，什么是自旋？</p>
<p>锁申请失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。</p>
<p>这是基于在大多数情况下，线程持有锁的时间都不会太长，如果直接挂起操作系统层面的线程可能会得不偿失，毕竟在我们之前介绍过的<strong>内核线程模型下，操作系统实现线程之间的切换时需要从用户态转换到内核态</strong>，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。</p>
<p>因此自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程循环重新申请锁。</p>
<p>在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起。我们可以通过下面的伪代码理解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设定自旋次数为10</span></span><br><span class="line">count = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 自旋</span></span><br><span class="line"><span class="keyword">while</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 申请成功</span></span><br><span class="line">    <span class="keyword">if</span>(加锁成功) <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 申请失败</span></span><br><span class="line">    count--;</span><br><span class="line">    <span class="comment">// 自旋10次后仍然申请失败</span></span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">0</span>) 阻塞线程;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行同步代码块</span></span><br></pre></td></tr></table></figure>

<p>当然，虽然通过自旋的方式可以在一定程度上减少用户态和内核态的切换，减少对操作系统中与线程相关的库函数调用，但是自旋的过程需要一直占用CPU，因此过度的自旋可能适得其反。</p>
<p>最后注意，在Java代码中，如果线程获得锁后调用<code>object.wait()</code>方法，则会将线程加入到Monitor对象的WaitSet中，当被<code>object.notify()</code>唤醒后，会将线程从WaitSet移动到 _cxq 或 _EntryList中去。</p>
<p>需要注意的是，当调用<code>wait</code>或<code>notify</code>方法时，<strong>如当前锁的状态是偏向锁或轻量级锁则会先膨胀成重量级锁</strong>。也就是说，<code>wait和notify</code>等方法依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用这些方法，否则会抛出<code>java.lang.IllegalMonitorStateException</code>的异常。</p>

            </div>

            
                <div class="post-copyright-info">
                    
<div class="article-copyright-info-container">
    <ul class="copyright-info-content">
        <li class="post-title">
            <span class="type">本文标题</span>：<span class="content">synchronized详解</span>
        </li>
        <li class="post-author">
            <span class="type">本文作者</span>：<span class="content">liduoan.efls</span>
        </li>
        <li class="post-time">
            <span class="type">创建时间</span>：<span class="content">2021-04-26 22:07:11</span>
        </li>
        <li class="post-link">
            <span class="type">本文链接</span>：<span class="content">2021/04/26/2021/synchronized详解/</span>
        </li>
        <li class="post-license">
            <span class="type">版权声明</span>：<span class="content">本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！</span>
        </li>
    </ul>
    <div class="copy-copyright-info flex-center tooltip" data-content="复制版权信息" data-offset-y="-2px">
        <i class="fa-solid fa-copy"></i>
    </div>
</div>

                </div>
            

            
                <ul class="post-tags-box">
                    
                        <li class="tag-item">
                            <a href="/tags/2021/">#2021</a>&nbsp;
                        </li>
                    
                </ul>
            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                               rel="prev"
                               href="/2021/04/29/2021/AQS%E5%BA%94%E7%94%A8%E4%B9%8BLock/"
                            >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                                <span class="title flex-center">
                                <span class="post-nav-title-item">AQS源码与Lock</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                               rel="next"
                               href="/2021/04/20/2021/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"
                            >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">并发编程及volatile详解</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                                <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                            </a>
                        </div>
                    
                </div>
            

            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%99%A8"><span class="nav-number">1.</span> <span class="nav-text">同步器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#synchronized%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3"><span class="nav-number">2.</span> <span class="nav-text">synchronized原理详解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Monitor%E7%9B%91%E8%A7%86%E5%99%A8%E9%94%81"><span class="nav-number">2.1.</span> <span class="nav-text">Monitor监视器锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized%E5%85%B3%E9%94%AE%E8%AF%8D%E7%9A%84JVM%E6%8C%87%E4%BB%A4"><span class="nav-number">2.2.</span> <span class="nav-text">synchronized关键词的JVM指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E4%B8%8A%E7%9A%84%E9%94%81"><span class="nav-number">2.3.</span> <span class="nav-text">对象上的锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%A4%B4%E7%BB%93%E6%9E%84"><span class="nav-number">2.3.1.</span> <span class="nav-text">对象头结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81%E5%8D%87%E7%BA%A7"><span class="nav-number">2.4.</span> <span class="nav-text">锁升级</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E9%94%81"><span class="nav-number">2.4.1.</span> <span class="nav-text">无锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%81%8F%E5%90%91%E9%94%81-%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.4.2.</span> <span class="nav-text">偏向锁(单线程)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81-%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%A7%E8%A1%8C"><span class="nav-number">2.4.3.</span> <span class="nav-text">轻量级锁(多个线程交替执行)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%98%E5%9C%A8%E7%AB%9E%E4%BA%89"><span class="nav-number">2.4.4.</span> <span class="nav-text">重量级锁(多线程存在竞争)</span></a></li></ol></li></ol></li></ol>
    </div>
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            
<footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
                <span>2020</span> -
            
            2023
            
                &nbsp;<i class="fas fa-heart icon-animate"></i>
                &nbsp;<a href="/">liduoan.efls</a>
            
        </div>
        
            <script async data-pjax
                    src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                
                
                    总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.6.1</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item flex-center toggle-show-toc">
                <i class="fas fa-list"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="close-popup-btn">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/dark-light-toggle.js"></script>




    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/code-block.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/lazyload.js"></script>


<div class="post-scripts pjax">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/post-helper.js"></script>
        
            <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/libs/anime.min.js"></script>
        
        
            <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/toc.js"></script>
        
    
</div>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
