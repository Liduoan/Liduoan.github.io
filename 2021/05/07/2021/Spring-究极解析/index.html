<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="liduoan.efls">
    
    <title>
        
            Spring 究极解析 |
        
        liduoan修炼笔记
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="https://i.postimg.cc/MpmSbVgT/4-U-3-AU-6-0-R8-L6-K5658-H.jpg">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/fontawesome.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/regular.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/solid.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/brands.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"zh-CN","path":"search.json"}
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066cc","logo":"https://i.postimg.cc/MpmSbVgT/4-U-3-AU-6-0-R8-L6-K5658-H.jpg","favicon":"https://i.postimg.cc/MpmSbVgT/4-U-3-AU-6-0-R8-L6-K5658-H.jpg","avatar":"https://i.postimg.cc/MpmSbVgT/4-U-3-AU-6-0-R8-L6-K5658-H.jpg","font_size":null,"font_family":"STSong","hover":{"shadow":true,"scale":false},"first_screen":{"enable":true,"header_transparent":true,"background_img":"/images/bg.svg","description":"世之奇伟、瑰怪，非常之观，常在于险远 || 而人之所罕至焉，故非有志者不能至也","font_color":null,"hitokoto":false},"scroll":{"progress_bar":true,"percent":false}},"local_search":{"enable":true,"preload":true},"code_copy":{},"code_block":{"tools":{"enable":true,"style":"default"},"highlight_theme":"default"},"side_tools":{},"pjax":{"enable":true},"lazyload":{"enable":true},"comment":{"enable":false,"use":"valine","valine":{"appid":null,"appkey":null,"server_urls":null,"placeholder":null},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.8"},"waline":{"server_url":null,"reaction":false,"version":2}},"post":{"author_label":{"enable":true,"auto":true,"custom_label_list":["Trainee","Engineer","Architect"]},"word_count":{"enable":true,"wordcount":true,"min2read":true},"img_align":"left","copyright_info":true},"version":"3.6.1"}
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"}
    KEEP.language_code_block = {"copy":"复制代码","copied":"已复制","fold":"折叠代码块","folded":"已折叠"}
    KEEP.language_copy_copyright = {"copy":"复制版权信息","copied":"已复制","title":"原文标题","author":"原文作者","link":"原文链接"}
  </script>
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
                <a class="logo-image" href="/">
                    <img src="https://i.postimg.cc/MpmSbVgT/4-U-3-AU-6-0-R8-L6-K5658-H.jpg">
                </a>
            
            <a class="logo-title" href="/">
               liduoan修炼笔记
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            <div class="article-title">
                <span class="title-hover-animation">Spring 究极解析</span>
            </div>

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="https://i.postimg.cc/MpmSbVgT/4-U-3-AU-6-0-R8-L6-K5658-H.jpg">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">liduoan.efls</span>
                            
                                <span class="author-label">Lv4</span>
                            
                        </div>
                        <div class="meta-info">
                            
<div class="article-meta-info">
    <span class="article-date article-meta-item">
        
            <i class="fa-regular fa-calendar-plus"></i>&nbsp;
        
        <span class="pc">2021-05-07 19:40:26</span>
        <span class="mobile">2021-05-07 19:40</span>
    </span>
    
        <span class="article-update-date article-meta-item">
        <i class="fas fa-file-pen"></i>&nbsp;
        <span class="pc">2023-01-14 23:04:34</span>
    </span>
    
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/2021/">2021</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>17.3k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>72 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content keep-markdown-body">
                

                <span id="more"></span>

<h1 id="Spring体系架构"><a href="#Spring体系架构" class="headerlink" title="Spring体系架构"></a>Spring体系架构</h1><p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/07/3ju5Fv7oixWAhbN.jpg"
                      alt="Screenshot_27.jpg"
                ></p>
<ol>
<li><strong>Core Container（核心容器）</strong></li>
</ol>
<p>该模块主要包含Core、Beans、Context和SpEL模块。其中Core和Beans是整个框架最基础的部分，提供**控制反转(IOC)<strong>和</strong>依赖注入(DI)**特性。这里最重要的概念就是BeanFactory，提供了以Factory模式的实现来消除对程序性单例模式。</p>
<ul>
<li>Core：模块主要包含Spring框架最基本的核心工具类，Core是其他组件的基础核心。</li>
<li>Beans：模块主要包含访问配置文件、创建&#x2F;管理Bean以及IOC&#x2F;DI相关的类。</li>
<li>Context：继承了Beans的特性，主要为Spring提供大量的扩展，如国际化、事件机制、资源加载等待。ApplicationContext接口是Context模块的关键。</li>
<li>SpEL：模块提供了一个强大的语言表达式。</li>
</ul>
<blockquote>
<p>回顾一下IOC和DI：</p>
<ul>
<li>IOC：反转控制，对象的控制权交给Spring的IOC容器管理，而不用我们通过<code>new</code>来创建，从而解耦。</li>
<li>DI：依赖注入，相对于反转控制更加具体的概念，某个对象需要依赖其它对象时，Spring会通过注入的方式将其所依赖的对象交给它使用。</li>
</ul>
</blockquote>
<ol>
<li><strong>AOP and Instrumentation</strong></li>
</ol>
<p>提供符合AOP Alliance标准的面向切面编程的实现，可以让你定义如方法拦截器和切点，从而降低程序之间的耦合性。 AspectJ模块提供了与<strong>AspectJ</strong>的集成。 而Instrumentation模块提供用于某些应用程序服务器的类工具支持和类加载器实现 。</p>
<ol>
<li><strong>Messaging</strong></li>
</ol>
<p>该模块具有来自Spring Integration项目的关键抽象，如Message、MessageChannel、MessageHandler等。它们构成基于消息的应用程序的基础。该模块还包括一组注释，用于将消息映射到方法，类似于基于Spring MVC注释的编程模型。</p>
<ol>
<li><strong>Data Access&#x2F;Integration</strong></li>
</ol>
<p>数据访问&#x2F;集成层由JDBC，ORM，OXM，JMS和事务模块组成。</p>
<ul>
<li>JDBC模块：提供了JDBC抽象层，从而无需进行繁琐的JDBC编码和数据库特定错误代码（不同数据代码可能不同）的解析。</li>
<li>事务模块：支持对实现特殊接口的类以及所有POJO（普通Java对象）进行编程和声明式事务管理。</li>
<li>ORM模块：该模块为当前流行的ORM（包括JPA，JDO和Hibernate）提供了集成层。使用ORM模块，可以将所有这些O&#x2F;R映射框架与Spring提供的所有功能结合使用，如前面提到的事务管理功能。</li>
<li>OXM模块：提供了一个抽象层，该抽象层支持Object&#x2F; XML映射实现，例如JAXB，Castor，XMLBeans，JiBX和XStream。JMS模块（Java Messaging Service）：包含用于生成和使用消息的功能。从Spring Framework 4.1开始，提供了与Spring­Messaging模块集成。</li>
</ul>
<ol>
<li><strong>Web</strong></li>
</ol>
<p>Web上下文模块建立在应用程序上下文模块之上，为基于Web的应用程序提供上下文支持。该模块包含Web、WebMVC、Web Socket和Web­Porlet模块。</p>
<ul>
<li>Web模块：提供了基本的面向Web的集成功能，如文件上传功能以及使用Servlet监听器和面向Web的应用程序上下文对IoC容器的初始化。</li>
<li>WebMVC模块（也称为Web­Servlet模块）：包含基于Spring的Model­View­Controller（MVC）支持和针对Web应用程序的Rest Web服务实现。</li>
<li>Web­Portlet 模块（也称为Web­Portlet模块）：提供Portlet环境中的MVC实现。</li>
</ul>
<ol>
<li><strong>Test</strong></li>
</ol>
<p>该模块支持使用JUnit或TestNG对Spring组件进行单元测试和集成测试。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/07/OHeCt7snk1K4Q8D.jpg"
                      alt="Screenshot_74.jpg"
                ></p>
<p>Spring最重要的概念是IOC 和 AOP，而其中IOC又是Spring中的根基。如果把Spring比作一棵树，那么IOC就是树根。</p>
<h1 id="SpringIOC源码整体流程"><a href="#SpringIOC源码整体流程" class="headerlink" title="SpringIOC源码整体流程"></a>SpringIOC源码整体流程</h1><p>本节我们会对SpringIOC整体流程的源码进行总体分析，主要介绍整体流程，很多细节的地方后续会单独做详细介绍。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在使用Spring时，你一定见过这几个段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过基于注解的ApplicationContext获取Bean</span></span><br><span class="line"><span class="type">AnnotationConfigApplicationContext</span> <span class="variable">applicationContext</span> </span><br><span class="line">    <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(MainConfig.class);</span><br><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过基于xml的ApplicationContext获取Bean</span></span><br><span class="line"><span class="type">ClassPathXmlApplicationContext</span> <span class="variable">xmlApplicationContext</span> </span><br><span class="line">    <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line"><span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> xmlApplicationContext.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过BeanFactory获取Bean</span></span><br><span class="line"><span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> </span><br><span class="line">    <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line"><span class="type">User</span> <span class="variable">user3</span> <span class="operator">=</span> beanFactory.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br></pre></td></tr></table></figure>

<p>通过ApplicationContext或者BeanFactory，我们可以传入Bean的名称，从而获取Spring容器中的指定对象。</p>
<p>那ApplicationContext和BeanFactory是什么？有什么用？两者有何异同？</p>
<p>我们先来看下面一张图：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/07/h7bD5mf2guAZQ4s.jpg"
                      alt="Screenshot_26.jpg"
                ></p>
<p>可以看到，BeanFactory是用于访问Spring核心容器的根接口，它采用了典型的<strong>简单工厂模式</strong>，是用于生产Bean的一个Bean工厂，其提供了生产Bean所需的最基本规则。</p>
<p>而ApplicationContext则是BeanFactory的一个子类，它是核心容器中Context的核心，继承了Beans的特性，为Spring提供了大量扩展。</p>
<p>主要是对BeanFactory进行了扩展处理！</p>
<h2 id="IOC的大致流程"><a href="#IOC的大致流程" class="headerlink" title="IOC的大致流程"></a>IOC的大致流程</h2><p>Spring中整个IOC的大致流程如下：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/07/X4TUqmcu2EBWOs3.jpg"
                      alt="Screenshot_75.jpg"
                ></p>
<p>大致流程可以描述为：</p>
<p>ApplicationContext通过读取，扫描，注册得到BeanDefinition_Map，再交付给BeanFactory，委托其生产Bean，最终得到Bean单例池【其实也是个<code>Map&lt;name,Bean&gt;</code>。</p>
<h3 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h3><p>BeanDefinition是Bean在Spring中的描述，有了BeanDefinition我们就可以创建Bean。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/07/pSu97CLEwoWP5aD.jpg"
                      alt="Screenshot_76.jpg"
                ></p>
<blockquote>
<p>关于在Idea中如何做出上图：</p>
<p>首先点击某个接口右键得到拓扑图</p>
<p>在拓扑图中点击接口 Ctrl + Alt + B</p>
<p>再 Ctrl + A 全选，Enter导入</p>
</blockquote>
<p>BeanDefinition接口是顶级基础接口，用来描述Bean，里面存放Bean元数据。</p>
<p>比如Bean类名、scope、属性、构造函数参数列表、依赖的bean、是否是单例类、是否是懒加载等一些列信息。BeanDefinition的操作如下：</p>
<ul>
<li><p><strong>BeanDefinitionRegistry接口</strong>：有增、查、删BeanDefinition的能力，一次只能注册一个BeanDefinition。</p>
<p>实现类有<code>SimpleBeanDefinitionRegistry</code>、<code>DefaultListableBeanFactory</code>、<code>GenericApplicationContext</code>等。</p>
<p>一般实现类里都都有一个用来存储BeanDefinition的Map结构。</p>
</li>
<li><p><strong>BeanDefinitionReader接口</strong>： 既可以使用<code>BeanDefinitionRegistry</code>构造，也可以通过<code>loadBeanDefinitions </code>把配置加载为多个BeanDefinition并注册到BeanDefinitionRegistry中。 </p>
<p>可以说是高效版本的BeanDefinitionRegistry。实现类有 <code>XmlBeanDefinitionReader</code>用于从xml中读取BeanDefinition，和<code>PropertiesBeanDefinitionReader</code>从Properties文件读取BeanDefinition。</p>
</li>
<li><p><strong>AnnotatedBeanDefinitionReader类</strong>：对带有注解的BeanDefinition进行注册。</p>
</li>
<li><p><strong>ClassPathBeanDefinitionScanner类</strong>：可以扫描到<code>@Component</code>、<code>@Repository</code>、<code>@Service</code>、<code>@Controller</code>注解的BeanDefinition注册到容器中。</p>
</li>
</ul>
<h3 id="ApplicationContext和BeanFactory"><a href="#ApplicationContext和BeanFactory" class="headerlink" title="ApplicationContext和BeanFactory"></a>ApplicationContext和BeanFactory</h3><p>看了IOC的大致流程，我们可以简单总结一下ApplicationContext和BeanFactory的异同点。ApplicationContext继承自BeanFactory，它们俩的关系相当于<strong>销售商和工厂的关系</strong>：</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>BeanFactory</th>
<th>ApplicationContext</th>
</tr>
</thead>
<tbody><tr>
<td>Bean实例化&#x2F;装配</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>集成的生命周期管理</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>自动注册 BeanPostProcessor 后置处理器</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>自动注册 BeanFactoryPostProcessor 后置处理器</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>便利的 MessageSource 访问 (国际化)</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>内置 ApplicationEvent 事件发布机制</td>
<td>No</td>
<td>Yes</td>
</tr>
</tbody></table>
<p>可以看到，BeanFactory唯一的职责就是生产Bean。而ApplicationContext提供了大量的扩展点，相对于BeanFactory来说功能更为强大。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="ApplicationContext的初始化"><a href="#ApplicationContext的初始化" class="headerlink" title="ApplicationContext的初始化"></a>ApplicationContext的初始化</h3><p>我们以AnnotationConfigApplicationContext(<strong>注解</strong>方式)为例来讲解IOC的流程(基于xml的流程会略有不同)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>   &#123;</span><br><span class="line">   <span class="comment">// 加载spring上下文</span></span><br><span class="line">   <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(MainConfig.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们点进去看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... annotatedClasses)</span> &#123;</span><br><span class="line">	<span class="comment">//调用构造函数</span></span><br><span class="line">	<span class="built_in">this</span>();</span><br><span class="line">	<span class="comment">//注册我们的配置类</span></span><br><span class="line">	register(annotatedClasses);</span><br><span class="line">	<span class="comment">//IOC容器刷新接口</span></span><br><span class="line">	refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到会先调用其父类的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">GenericApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 调用父类的构造函数,为ApplicationContext spring上下文对象初始beanFactory</span></span><br><span class="line"><span class="comment">	 * 为啥是DefaultListableBeanFactory？我们去看BeanFactory接口的时候</span></span><br><span class="line"><span class="comment">	 * 发DefaultListableBeanFactory是最底层的实现，功能是最全的</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">this</span>.beanFactory = <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们原先知晓<code>DefaultListableBeanFactory</code>是最底层的类，实现了<code>BeanFactory</code>。</p>
<p>那么我们接着走下面的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotationConfigApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 创建一个读取注解的Bean定义读取器</span></span><br><span class="line"><span class="comment">	 * 什么是bean定义？BeanDefinition</span></span><br><span class="line"><span class="comment">	 * 完成了spring内部BeanDefinition的注册（主要是后置处理器）</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">this</span>.reader = <span class="keyword">new</span> <span class="title class_">AnnotatedBeanDefinitionReader</span>(<span class="built_in">this</span>);</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 创建BeanDefinition扫描器</span></span><br><span class="line"><span class="comment">	 * 可以用来扫描包或者类，继而转换为bd</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * spring默认的扫描包不是这个scanner对象</span></span><br><span class="line"><span class="comment">	 * 而是自己new的一个ClassPathBeanDefinitionScanner</span></span><br><span class="line"><span class="comment">	 * spring在执行工程后置处理器ConfigurationClassPostProcessor时，去扫描包时会new一个ClassPathBeanDefinitionScanner</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 这里的scanner仅仅是为了程序员可以手动调用AnnotationConfigApplicationContext对象的scan方法</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">this</span>.scanner = <span class="keyword">new</span> <span class="title class_">ClassPathBeanDefinitionScanner</span>(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>OK这里我们再次分析</p>
<h4 id="BeanDefinitionReader初始化"><a href="#BeanDefinitionReader初始化" class="headerlink" title="BeanDefinitionReader初始化"></a>BeanDefinitionReader初始化</h4><p>首先进入他的初始化中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以看到registry其实就是AnnotationConfigApplicationContext实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotatedBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>(registry, getOrCreateEnvironment(registry));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotatedBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry, Environment environment)</span> &#123;</span><br><span class="line">	Assert.notNull(registry, <span class="string">&quot;BeanDefinitionRegistry must not be null&quot;</span>);</span><br><span class="line">	Assert.notNull(environment, <span class="string">&quot;Environment must not be null&quot;</span>);</span><br><span class="line">	<span class="comment">//把ApplicationContext对象赋值给AnnotatedBeanDefinitionReader</span></span><br><span class="line">       <span class="comment">//这里是MainConfig.class</span></span><br><span class="line">	<span class="built_in">this</span>.registry = registry;</span><br><span class="line">	<span class="comment">//用户处理条件注解 @Conditional os.name</span></span><br><span class="line">	<span class="built_in">this</span>.conditionEvaluator = <span class="keyword">new</span> <span class="title class_">ConditionEvaluator</span>(registry, environment, <span class="literal">null</span>);</span><br><span class="line">	<span class="comment">//注册一些内置的后置处理器</span></span><br><span class="line">	AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="built_in">this</span>.registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到Reader的初始化过程中，注册了Spring内置的后置处理器。</p>
<p>这个步骤非常关键，为后续解析Bean奠定了基础，这些内置的后置处理器是Spring中<strong>创世纪</strong>的类，因为其它所有Bean的实例化都离不开它们。下面我们就根据到AnnotationConfigUtils类中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerAnnotationConfigProcessors</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">	registerAnnotationConfigProcessors(registry, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册了一堆的后置处理器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">registerAnnotationConfigProcessors</span><span class="params">(</span></span><br><span class="line"><span class="params">		BeanDefinitionRegistry registry, <span class="meta">@Nullable</span> Object source)</span> &#123;</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; beanDefs = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/** 主要有以下几个后置处理器:</span></span><br><span class="line"><span class="comment">        * 1. 后置处理器ConfigurationClassPostProcessor负责处理配置类</span></span><br><span class="line"><span class="comment">        * 2. 后置处理器AutowiredAnnotationBeanPostProcessor用于解析<span class="doctag">@Autowired</span>注解</span></span><br><span class="line"><span class="comment">        * 3. 后置处理器CommonAnnotationBeanPostProcessor它负责解析</span></span><br><span class="line"><span class="comment">        *    <span class="doctag">@Resource</span>、<span class="doctag">@WebServiceRef</span>、<span class="doctag">@EJB</span>三个注解。</span></span><br><span class="line"><span class="comment">        * 4. EventListenerMethodProcessor负责处理<span class="doctag">@EvenListener</span>注解</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 我们选择一个举例：</span></span><br><span class="line">      <span class="comment">// 判断是否已经存在ConfigurationClassPostProcessor的Bean定义了</span></span><br><span class="line"><span class="keyword">if</span> (!registry.</span><br><span class="line">          containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">	<span class="comment">// 创建该类的BeanDefinition</span></span><br><span class="line">	<span class="type">RootBeanDefinition</span> <span class="variable">def</span> </span><br><span class="line">              <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(ConfigurationClassPostProcessor.class);</span><br><span class="line">	def.setSource(source);</span><br><span class="line">          <span class="comment">// 执行registerPostProcessor方法注册Bean</span></span><br><span class="line">	beanDefs.add(registerPostProcessor(registry, def, </span><br><span class="line">                        CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">// 省略后续的后置处理器的注册过程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> beanDefs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注册Bean的方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> BeanDefinitionHolder <span class="title function_">registerPostProcessor</span><span class="params">(</span></span><br><span class="line"><span class="params">		BeanDefinitionRegistry registry, RootBeanDefinition definition, String beanName)</span> &#123;</span><br><span class="line">	<span class="comment">//方法开始</span></span><br><span class="line">       <span class="comment">// ROLE_INFRASTRUCTURE代表这是spring内部的，并非用户定义的</span></span><br><span class="line">	definition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">       <span class="comment">// 调用DefaultListableBeanFactory的registerBeanDefinition方法</span></span><br><span class="line">	registry.registerBeanDefinition(beanName, definition);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(definition, beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="BeanDefinitionScanner的初始化"><a href="#BeanDefinitionScanner的初始化" class="headerlink" title="BeanDefinitionScanner的初始化"></a>BeanDefinitionScanner的初始化</h4><p>由于常规使用方式是不会用到ApplicationContext里面的扫描器scanner的，因为这里的scanner仅仅是为了程序员可以手动调用AnnotationConfigApplicationContext对象的<code>scan</code>方法去扫描包。所以这里就不看scanner是如何被实例化的了。</p>
<hr>
<p>继续回到构造方法！</p>
<p>我们已经走完了<code>this()</code>方法了，他的任务是帮助父类构造方法构建，完成<code>BeanFactory</code>的构造。</p>
<p>之后进行BeanDefinitionReader和BeanDefinitionScanner的初始化。</p>
<p>还记得我们最开始的那个图吗？</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/07/X4TUqmcu2EBWOs3.jpg"
                      alt="Screenshot_75.jpg"
                ></p>
<p>我们需要的三个类已经完成装载了。同时我们也知道在进行BeanDefinitionReader初始化的时候，进行了很重要的一些后置处理器的注册，便于在后面直接<code>getBean</code>生产出来。</p>
<p>那么在<code>ApplicationContext</code>的构造函数中，我们就到了下一个方法了！</p>
<h4 id="register-annotatedClasses"><a href="#register-annotatedClasses" class="headerlink" title="register(annotatedClasses)"></a>register(annotatedClasses)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... annotatedClasses)</span> &#123;</span><br><span class="line">	<span class="comment">//调用构造函数</span></span><br><span class="line">	<span class="built_in">this</span>();</span><br><span class="line">	<span class="comment">//注册我们的配置类</span></span><br><span class="line">	register(annotatedClasses);</span><br><span class="line">	<span class="comment">//IOC容器刷新接口</span></span><br><span class="line">	refresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Class&lt;?&gt;... annotatedClasses)</span> &#123;</span><br><span class="line">	Assert.notEmpty(annotatedClasses, <span class="string">&quot;At least one annotated class must be specified&quot;</span>);</span><br><span class="line">       <span class="comment">//调用BeanDefinitionReader来帮助注册</span></span><br><span class="line">	<span class="built_in">this</span>.reader.register(annotatedClasses);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们接着看读取器内的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Class&lt;?&gt;... annotatedClasses)</span> &#123;</span><br><span class="line">       <span class="comment">//如果多个配置类那就依次进行注册配置类</span></span><br><span class="line">	<span class="keyword">for</span> (Class&lt;?&gt; annotatedClass : annotatedClasses) &#123;</span><br><span class="line">		registerBean(annotatedClass);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBean</span><span class="params">(Class&lt;?&gt; annotatedClass)</span> &#123;</span><br><span class="line">	<span class="comment">//依旧调用</span></span><br><span class="line">       doRegisterBean(annotatedClass, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   &lt;T&gt; <span class="keyword">void</span> <span class="title function_">doRegisterBean</span><span class="params">(Class&lt;T&gt; annotatedClass, <span class="meta">@Nullable</span> Supplier&lt;T&gt; instanceSupplier, <span class="meta">@Nullable</span> String name,</span></span><br><span class="line"><span class="params">   <span class="meta">@Nullable</span> Class&lt;? extends Annotation&gt;[] qualifiers, BeanDefinitionCustomizer... definitionCustomizers)</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//存储@Configuration注解注释的类 得到对应的类定义</span></span><br><span class="line">       <span class="type">AnnotatedGenericBeanDefinition</span> <span class="variable">abd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotatedGenericBeanDefinition</span>(annotatedClass);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//判断是否需要跳过注解，spring中有一个@Condition注解，当不满足条件，这个bean就不会被解析</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="built_in">this</span>.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       abd.setInstanceSupplier(instanceSupplier);</span><br><span class="line">       <span class="comment">//解析bean的作用域，如果没有设置的话，默认为单例</span></span><br><span class="line">       <span class="type">ScopeMetadata</span> <span class="variable">scopeMetadata</span> <span class="operator">=</span> <span class="built_in">this</span>.scopeMetadataResolver.resolveScopeMetadata(abd);</span><br><span class="line">       abd.setScope(scopeMetadata.getScopeName());</span><br><span class="line">       <span class="comment">//获得beanName</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> (name != <span class="literal">null</span> ? name : <span class="built_in">this</span>.beanNameGenerator.generateBeanName(abd, <span class="built_in">this</span>.registry));</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//解析通用注解，填充到AnnotatedGenericBeanDefinition</span></span><br><span class="line">       <span class="comment">//解析的注解为Lazy，Primary，DependsOn，Role，Description</span></span><br><span class="line">       AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);</span><br><span class="line">       <span class="comment">//限定符处理</span></span><br><span class="line">       <span class="keyword">if</span> (qualifiers != <span class="literal">null</span>) &#123;</span><br><span class="line">       <span class="keyword">for</span> (Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; qualifier : qualifiers) &#123;</span><br><span class="line">           <span class="comment">//Primary注解</span></span><br><span class="line">           <span class="keyword">if</span> (Primary.class == qualifier) &#123;</span><br><span class="line">               abd.setPrimary(<span class="literal">true</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//Lazy注解</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (Lazy.class == qualifier) &#123;</span><br><span class="line">               abd.setLazyInit(<span class="literal">true</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               abd.addQualifier(<span class="keyword">new</span> <span class="title class_">AutowireCandidateQualifier</span>(qualifier));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (BeanDefinitionCustomizer customizer : definitionCustomizers) &#123;</span><br><span class="line">       customizer.customize(abd);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//再次封装为BeanDefinition</span></span><br><span class="line">       <span class="type">BeanDefinitionHolder</span> <span class="variable">definitionHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(abd, beanName);</span><br><span class="line">       definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="built_in">this</span>.registry);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//注册，最终会调用DefaultListableBeanFactory中的registerBeanDefinition方法去注册，</span></span><br><span class="line">       <span class="comment">//DefaultListableBeanFactory维护着一系列信息，比如beanDefinitionNames，beanDefinitionMap</span></span><br><span class="line">       <span class="comment">//beanDefinitionNames是一个List&lt;String&gt;,用来保存beanName</span></span><br><span class="line">       <span class="comment">//beanDefinitionMap是一个Map,用来保存beanName和beanDefinition</span></span><br><span class="line">       BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, <span class="built_in">this</span>.registry);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>到这里我们就大致了解了如何注册完配置类的了，主要依靠阅读器来帮助注册，然后一直往下走，确定注册的配置，如何加载、是否多个配置等等，最后依靠<code>registerBeanDefinition</code>完成在<code>BeanFactory</code>中的注册</p>
<p>到这，配置类就被解析为Bean定义注册完成了。</p>
<blockquote>
<p>@Condition注解怎么用？</p>
<p>@Condition注解一般会放在一个Bean上。@Condition中需要指定一个类，该类需要实现Condition接口并实现<code>matches()</code>方法，如果该方法返回false那么该Bean就不会被解析。</p>
</blockquote>
<h4 id="Refresh"><a href="#Refresh" class="headerlink" title="Refresh"></a>Refresh</h4><p>看到这里，Spring完成了实例化一个工厂、注册了一些内置的后置处理器和我们传进去的配置类。下面<code>refresh</code>方法才是真正的关键：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> &#123;</span><br><span class="line">   <span class="comment">// 调用无参构造函数，会先调用父类GenericApplicationContext的构造函数</span></span><br><span class="line">   <span class="built_in">this</span>();</span><br><span class="line">   <span class="comment">// 注册配置类</span></span><br><span class="line">   register(componentClasses);</span><br><span class="line">   <span class="comment">// IOC容器刷新接口，非常重要的方法</span></span><br><span class="line">   refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会调用到AbstractApplicationContext中的<code>refresh</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">      <span class="comment">// 刷新预处理</span></span><br><span class="line">      <span class="comment">// 保存了容器的启动时间、启动标志等信息</span></span><br><span class="line">      <span class="comment">// 还创建了一个早期事件监听器对象，和一个早期待发布的事件集合</span></span><br><span class="line">      <span class="comment">// 什么是【早期事件】？</span></span><br><span class="line">      <span class="comment">// 就是事件监听器还没有注册到多播器上的时候都称为早期事件</span></span><br><span class="line">	  <span class="comment">// 早期事件不需要手动发布，会自动发布，发布完早期事件就不存在了</span></span><br><span class="line">      prepareRefresh();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 最终获得DefaultListableBeanFactory</span></span><br><span class="line">      <span class="comment">// DefaultListableBeanFactory实现了ConfigurableListableBeanFactory接口</span></span><br><span class="line">      <span class="comment">// 1. 对于注解方式来说，这里几乎什么也没干，Bean定义的解析在后面的后置处理器中</span></span><br><span class="line">      <span class="comment">// 2. 对于xml方式来说，在这里解析Bean为Bean定义，是一种耦合的方式</span></span><br><span class="line">      <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 一些准备工作：</span></span><br><span class="line">      <span class="comment">// 1. 添加了两个Bean后置处理器</span></span><br><span class="line">      <span class="comment">//    (1) ApplicationContextAwareProcessor用于Bean初始化阶段执行一些Aware</span></span><br><span class="line">      <span class="comment">//    (2) ApplicationListenerDetector解析接口方式的事件监听器</span></span><br><span class="line">      <span class="comment">// 2. 还设置了忽略自动装配和允许自动装配的接口，比如：</span></span><br><span class="line">      <span class="comment">//    可以在Bean中@Autowired注入ApplicationContext，就是在这里设置的</span></span><br><span class="line">      <span class="comment">// 3. 注册了一些内部的Bean，这个无关紧要</span></span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 空方法，给子类实现</span></span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 调用BeanFactory的后置处理器ConfigurationClassPostProcessor处理配置类</span></span><br><span class="line">         <span class="comment">// 这是非常关键的一步，我们后续再详细分析</span></span><br><span class="line">         <span class="comment">// 这里就会将所有的Bean都封装为Bean定义</span></span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 实例化Bean的后置处理器（注意和BeanFactory的后置处理器区别）例如：</span></span><br><span class="line">         <span class="comment">// 1. AutowiredAnnotationBeanPostProcessor处理@Autowired注解修饰的bean并注入 			 // 2. RequiredAnnotationBeanPostProcessor处理被@Required注解修饰的方法 					 //	3. CommonAnnotationBeanPostProcessor处理@PreDestroy、@PostConstruct、	 </span></span><br><span class="line">         <span class="comment">//    @Resource等多个注解。</span></span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 初始化国际化资源，可忽略</span></span><br><span class="line">         initMessageSource();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 初始化事件多播器，后续再详细分析</span></span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 留个子类实现，SpringBoot从这个方法进行启动Tomcat</span></span><br><span class="line">         onRefresh();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 注册监听器，后续再详细分析</span></span><br><span class="line">         registerListeners();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 实例化剩余非懒加载的单例Bean（包括Bean的后置处理器）</span></span><br><span class="line">         <span class="comment">// 本结我们只简单看一下该方法，其它重要的我们单独分析</span></span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// refresh做完之后需要做的其他事情：</span></span><br><span class="line">         <span class="comment">// 1. 清除上下文资源缓存（如扫描中的ASM元数据）</span></span><br><span class="line">         <span class="comment">// 2. 初始化上下文的生命周期处理器，并刷新（找出Spring容器中实现了Lifecycle接口的bean并			  //	执行start()方法） </span></span><br><span class="line">         <span class="comment">// 3. 发布ContextRefreshedEvent事件告知对应的ApplicationListener进行响应的操作</span></span><br><span class="line">         <span class="comment">// SpringCloud是从这里启动的</span></span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">         destroyBeans();</span><br><span class="line">         <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line">         <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">         <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">         resetCommonCaches();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里完成了BeanFactory后置处理器的调用、Bean后置处理器的注册、有关事件和国际化的初始化配置，最后通过<code>finishBeanFactoryInitialization</code>实例化所有的单例Bean。本结我们只简单分析最后一步Bean的创建流程，其它重要的我们会单独分析。</p>
<hr>
<blockquote>
<p>题外话：源码真是折磨人，比AQS还折磨的多</p>
<p>下面是刚刚初始化的简略…简略图</p>
</blockquote>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/11/wTyru6ixVbev5nZ.jpg"
                      alt="Screenshot_77.jpg"
                ></p>
<p>现在我们接着看更下层的。</p>
<h3 id="Bean的创建"><a href="#Bean的创建" class="headerlink" title="Bean的创建"></a>Bean的创建</h3><p>ApplicationContext的初始化完毕，所有的Bean都被封装成Bean定义了，下面就由BeanFactory来实例化Bean。</p>
<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>这个流程从上面<code>refresh</code>中调用<code>finishBeanFactoryInitialization</code>方法开始：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">	<span class="comment">// 为我们的bean工厂创建类型转化器  Convert</span></span><br><span class="line">	<span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">			beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">		beanFactory.setConversionService(</span><br><span class="line">				beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	....</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">	beanFactory.setTempClassLoader(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//冻结所有的 bean 定义 ， 说明注册的 bean 定义将不被修改或任何进一步的处理</span></span><br><span class="line">       <span class="comment">//这里是为了防止后置处理器进行修改</span></span><br><span class="line">	beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//实例化剩余的单实例bean</span></span><br><span class="line">	beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们看<code>preInstantiateSingletons</code>来实例化Bean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Pre-instantiating singletons in &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取我们容器中所有bean定义的名称</span></span><br><span class="line">    <span class="comment">//得到了所有的Bean定义，下面进行实例化Bean</span></span><br><span class="line">    List&lt;String&gt; beanNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环我们所有的bean定义名称</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">        <span class="comment">//合并我们的bean定义，转换为统一的RootBeanDefinition类型(在)， 方便后续处理</span></span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * 根据bean定义判断是不是抽象的&amp;&amp; 不是单例的 &amp;&amp;不是懒加载的</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">        <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">            <span class="comment">//是不是工厂bean</span></span><br><span class="line">            <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">                <span class="comment">// 是factoryBean会先生成实际的bean  &amp;beanName 是用来获取实际bean的</span></span><br><span class="line">                <span class="comment">// FactoryBean通过getObject方法生成其他类型Bean的时候时</span></span><br><span class="line">                <span class="comment">// 如果BeanName前面加了&amp;符号，返回FactoryBean自身类型的对象</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">                <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">                    <span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">                    <span class="type">boolean</span> isEagerInit;</span><br><span class="line">                    <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">                        isEagerInit = AccessController.doPrivileged(</span><br><span class="line">                            (PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">                            ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">                            getAccessControlContext());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">                                       ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//上面都是一系列的判断</span></span><br><span class="line">                    <span class="comment">//调用真正的getBean的流程</span></span><br><span class="line">                    <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">                        getBean(beanName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">//非工厂Bean 就是普通的bean</span></span><br><span class="line">                <span class="comment">//其实现在是么有Bean的 有的只是Bean定义</span></span><br><span class="line">                <span class="comment">//当调用getBean时会获取Bean定义创建Bean</span></span><br><span class="line">                getBean(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//或有的bean的名称 ...........到这里所有的单实例的bean已经记载到单实例bean到缓存中</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">        <span class="comment">//从单例缓存池中获取所有的对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">singletonInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line">        <span class="comment">//判断当前的bean是否实现了SmartInitializingSingleton接口</span></span><br><span class="line">        <span class="comment">//这里会执行实现SmartInitializingSingleton接口的afterSingletonsInstantiated方法</span></span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="FactoryBean和BeanFactory"><a href="#FactoryBean和BeanFactory" class="headerlink" title="FactoryBean和BeanFactory"></a>FactoryBean和BeanFactory</h5><blockquote>
<p>FactoryBean和BeanFactory的区别：</p>
<ul>
<li>BeanFactory是<strong>Spring的核心Bean工厂</strong>，用于生产Bean。</li>
<li>FactoryBean是指实现了FactoryBean接口的Bean，是一种工厂Bean。它实现了<code>getObject()</code>方法返回其它自定义类型的Bean，Spring的IOC容器会调用其<code>getObject()</code>方法获取Bean。我们举一个例子：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FactoryBean类型的Bean</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;User&gt;&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// getObject方法中生产真正的Bean</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;liduoan&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> User.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建ApplicationContext</span></span><br><span class="line">    <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();</span><br><span class="line">    <span class="comment">// 获取User类型的Bean</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> ctx.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">    System.out.println(user.getName());</span><br><span class="line">    <span class="comment">// 获取Bean时加&amp;号，可以获得对应的FactoryBean类型的Bean</span></span><br><span class="line">    <span class="type">UserFactoryBean</span> <span class="variable">bean</span> <span class="operator">=</span> (UserFactoryBean) ctx.getBean(<span class="string">&quot;&amp;user&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一种典型的<strong>工厂模式</strong>，比如大家熟悉的<code>SqlSessionFactoryBean</code>就是这样一种工厂Bean。</p>
</blockquote>
<p>最后还是使用<code>getBean</code>来真正实例化<code>Bean</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="comment">// 调用doGetBean方法</span></span><br><span class="line">    <span class="keyword">return</span> doGetBean(name, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span><br><span class="line"><span class="params">                          <span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, <span class="type">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到真实的bean的名字</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> transformedBeanName(name);</span><br><span class="line">    Object bean;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先从容器缓存中获取Bean，拿到了直接返回，没有拿到再创建</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line">    <span class="comment">// 如果从缓存中获取到Bean</span></span><br><span class="line">    <span class="keyword">if</span> (sharedInstance != <span class="literal">null</span> &amp;&amp; args == <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 直接获取bean</span></span><br><span class="line">            bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有从缓存中获取到Bean</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是多例bean并且正在创建，则会抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取父工厂，SpringMVC中会用到</span></span><br><span class="line">        <span class="type">BeanFactory</span> <span class="variable">parentBeanFactory</span> <span class="operator">=</span> getParentBeanFactory();</span><br><span class="line">        <span class="comment">// 这里省略</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">            <span class="comment">// 将当前bean标记为正在创建</span></span><br><span class="line">            markBeanAsCreated(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">RootBeanDefinition</span> <span class="variable">mbd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line">            checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断DependsOn注解</span></span><br><span class="line">            <span class="comment">// @DependsOn:如果A依赖B，则B会被先加载</span></span><br><span class="line">            String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">            <span class="keyword">if</span> (dependsOn != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">                    ... </span><br><span class="line"></span><br><span class="line">                        registerDependentBean(dep, beanName);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 优先加载所有依赖的Bean</span></span><br><span class="line">                        getBean(dep);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 创建单例bean</span></span><br><span class="line">                <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">                    <span class="comment">// 调用DefaultSingletonBeanRegistry的getSingleton方法</span></span><br><span class="line">                    <span class="comment">// lambda表达式实现了ObjectFactory接口的getObject方法</span></span><br><span class="line">                    <span class="comment">// 将getObject方法方法作为参数传给getSingleton方法</span></span><br><span class="line">                    <span class="comment">// 在getSingleton方法中会调用这个getObject方法创建Bean</span></span><br><span class="line">                    sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// getSingleton回调createBean方法创建Bean</span></span><br><span class="line">                            <span class="comment">// 这里调用了第一个Bean的后置处理器</span></span><br><span class="line">                            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                            destroySingleton(beanName);</span><br><span class="line">                            <span class="keyword">throw</span> ex;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 省略代码</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> (T) bean;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<h5 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a>正式开始</h5><p>最后调用<code>createBean</code>完成创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">    <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用第一个bean后置处理器，此时bean还没有创建，这里可以阻止bean的创建</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">            <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果后置处理器创建了bean直接返回</span></span><br><span class="line">                <span class="keyword">return</span> bean;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">                                        <span class="string">&quot;BeanPostProcessor before instantiation of bean failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 否则由Spring来创建，这个doCreateBean方法才是真正的创建过程</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">beanInstance</span> <span class="operator">=</span> doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前面绕来绕去，终于来到了实例化Bean的地方</span></span><br><span class="line"><span class="comment">// 这个方法完成了bean的实例化、填充属性和初始化过程</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">    <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">BeanWrapper</span> <span class="variable">instanceWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        instanceWrapper = <span class="built_in">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 实例化bean：工厂方法、有参构造、无参构造</span></span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 属性赋值(调用setter方法)，这里完成了@Autowired的赋值</span></span><br><span class="line">            <span class="comment">// 触发bean后置处理器postProcessAfterInstantiation方法</span></span><br><span class="line">            populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">            <span class="comment">// 最后初始化，调用各种Aware和初始化方法</span></span><br><span class="line">            exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bean的初始化方法</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// invokeAwareMethods方法调用3个Aware</span></span><br><span class="line">            <span class="comment">// 1. BeanNameAware</span></span><br><span class="line">            <span class="comment">// 2. BeanClassLoaderAware</span></span><br><span class="line">            <span class="comment">// 3. BeanFactoryAware</span></span><br><span class="line">            invokeAwareMethods(beanName, bean);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">wrappedBean</span> <span class="operator">=</span> bean;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="literal">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        <span class="comment">// 这里会调用bean后置处理器的postProcessBeforeInitialization方法</span></span><br><span class="line">        <span class="comment">// 这里又会调用其余的一堆Aware</span></span><br><span class="line">        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// invokeInitMethods会调用Bean初始化的回调方法：</span></span><br><span class="line">        <span class="comment">// 1. 实现InitializingBean接口类的afterPropertiesSet方法</span></span><br><span class="line">        <span class="comment">// 2. initMethod指定的方法</span></span><br><span class="line">        invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mbd == <span class="literal">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">            <span class="comment">// 这里会调用后置处理器的PostProcessAfterInitialization方法</span></span><br><span class="line">            wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，Bean就实例化完成了，最后一步就是在DefaultSingletonBeanRegistry类中的<code>getSingleton</code>方法里，将创建完成的Bean放入单例池中。</p>
<p>Spring中Bean的生命周期如下：</p>
<ol>
<li>实例化Bean对象，这个时候Bean的对象是非常低级的，基本不能够被我们使用，因为连最基本的属性都没有设置，@Autowired注解都是没有解析的 。</li>
<li>填充属性，当做完这一步，Bean对象基本是完整的了，@Autowired注解已经解析完毕，依赖注入完成了。</li>
<li>如果Bean实现了BeanNameAware接口，则调用setBeanName方法。</li>
<li>如果Bean实现了BeanClassLoaderAware接口，则调用setBeanClassLoader方法。</li>
<li>如果Bean实现了BeanFactoryAware接口，则调用setBeanFactory方法。</li>
<li>调用BeanPostProcessor(Bean后置处理器)的postProcessBeforeInitialization方法。</li>
<li>如果Bean实现了InitializingBean接口，调用afterPropertiesSet方法。</li>
<li>如果Bean指定了initMethod方法，则调用Bean的initMethod指定的方法。</li>
<li>调用BeanPostProcessor(Bean后置处理器)的postProcessAfterInitialization方法。当进行到这一步，Bean已经被准备就绪了，一直停留在应用的上下文中，直到被销毁。</li>
<li>如果应用的上下文被销毁了，如果Bean实现了DisposableBean接口，则调用destroy方法，如果Bean指定了destoryMethod销毁方法也会被调用。</li>
</ol>
<h1 id="后置处理器解析"><a href="#后置处理器解析" class="headerlink" title="后置处理器解析"></a>后置处理器解析</h1><h2 id="基于XML的解析过程"><a href="#基于XML的解析过程" class="headerlink" title="基于XML的解析过程"></a>基于XML的解析过程</h2><p>基于XML的配置类解析过程和基于注解方式的有所不同，基于XML的配置类解析过程是一种<strong>耦合</strong>的解析方式，它没有使用到我们之前介绍的BeanFactory的后置处理器，也就是那些创世纪的类。XML方式配置类解析开始的地方在<code>refresh</code>方法中的此处：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xml是在这里解析Bean定义的，耦合方式</span></span><br><span class="line"><span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br></pre></td></tr></table></figure>

<p>主要流程就是通过XML的<strong>读取器</strong>读取XML配置文件，将其封装为Document对象，最后将其解析为Bean定义。</p>
<p>其中有一点需要注意。在XML配置方式中，我们经常使用这个注解(使用到了<code>context</code>命名空间)，像这样的注解会使用到<strong>命名空间</strong>。Spring在解析的过程中，会在<code>spring-context</code>模块的<code>META-INF/spring.handlers</code>文件中找到命名空间对应的处理器类，比如<code>context</code>命名空间的处理器如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Context命名空间处理器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContextNamespaceHandler</span> <span class="keyword">extends</span> <span class="title class_">NamespaceHandlerSupport</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">		registerBeanDefinitionParser(<span class="string">&quot;property-placeholder&quot;</span>, </span><br><span class="line">                                     <span class="keyword">new</span> <span class="title class_">PropertyPlaceholderBeanDefinitionParser</span>());</span><br><span class="line">		registerBeanDefinitionParser(<span class="string">&quot;property-override&quot;</span>, </span><br><span class="line">                                     <span class="keyword">new</span> <span class="title class_">PropertyOverrideBeanDefinitionParser</span>());</span><br><span class="line">		registerBeanDefinitionParser(<span class="string">&quot;annotation-config&quot;</span>,</span><br><span class="line">                                     <span class="keyword">new</span> <span class="title class_">AnnotationConfigBeanDefinitionParser</span>());</span><br><span class="line">        <span class="comment">// &lt;context:component-scan&gt;的解析器</span></span><br><span class="line">		registerBeanDefinitionParser(<span class="string">&quot;component-scan&quot;</span>, </span><br><span class="line">                                     <span class="keyword">new</span> <span class="title class_">ComponentScanBeanDefinitionParser</span>());</span><br><span class="line">		registerBeanDefinitionParser(<span class="string">&quot;load-time-weaver&quot;</span>, </span><br><span class="line">                                     <span class="keyword">new</span> <span class="title class_">LoadTimeWeaverBeanDefinitionParser</span>());</span><br><span class="line">		registerBeanDefinitionParser(<span class="string">&quot;spring-configured&quot;</span>, </span><br><span class="line">                                     <span class="keyword">new</span> <span class="title class_">SpringConfiguredBeanDefinitionParser</span>());</span><br><span class="line">		registerBeanDefinitionParser(<span class="string">&quot;mbean-export&quot;</span>, </span><br><span class="line">                                     <span class="keyword">new</span> <span class="title class_">MBeanExportBeanDefinitionParser</span>());</span><br><span class="line">		registerBeanDefinitionParser(<span class="string">&quot;mbean-server&quot;</span>,</span><br><span class="line">                                     <span class="keyword">new</span> <span class="title class_">MBeanServerBeanDefinitionParser</span>());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>&lt;context:component-scan&gt;</code>的解析器ComponentScanBeanDefinitionParser中，就会通过XML的<strong>扫描器</strong>进行包扫描，最后将所有的Bean解析为Bean定义完成注册。XML具体解析过程大家可以自己查看源码，本文不过多介绍。</p>
<h2 id="基于注解的解析过程"><a href="#基于注解的解析过程" class="headerlink" title="基于注解的解析过程"></a>基于注解的解析过程</h2><h3 id="BeanFactory后置处理器"><a href="#BeanFactory后置处理器" class="headerlink" title="BeanFactory后置处理器"></a>BeanFactory后置处理器</h3><p>相比于基于XML方式配置类的解析，基于注解的解析过程进行了解耦，通过<strong>BeanFactory的后置处理器</strong>进行解析，因此更高级一些。</p>
<p>BeanFactory的后置处理器主要有下面两个作用：</p>
<ul>
<li>修改Bean定义：实现<strong>BeanFactoryPostProcessor</strong>接口，并且实现postProcessBeanFactory方法，<strong>可以拿到BeanFactory对象，从而修改Bean定义</strong>。</li>
<li>注册Bean定义：实现<code>BeanFactoryPostProcessor</code>的子接口<strong>BeanDefinitionRegistryPostProcessor</strong>，并且实现<code>postProcessBeanDefinitionRegistry</code>方法，<strong>可以拿到BeanDefinitionRegistry对象</strong>，从而添加Bean定义。</li>
</ul>
<p>之前我们介绍了，在初始化扫描器Reader的时候会创建很多Spring内置的Bean工厂后置处理器，也就是创世纪的类。其中最最重要的是<strong>ConfigurationClassPostProcessor</strong>，它就是注解方式下解析配置类的Bean工厂后置处理器，没有它其它的Bean都不会存在。我么来看看它的结构：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/13/2gCJVhPfSoI6uQx.jpg"
                      alt="Screenshot_78.jpg"
                ></p>
<p>可以看到，<strong>BeanFactoryPostProcessor</strong>和<strong>BeanDefinitionRegistryPostProcessor</strong>它都实现了。另外它还实现了两个用于排序的接口，这两个接口主要用于决定执行顺序，在后续的代码中可以看到。</p>
<h3 id="后置处理器的执行顺序"><a href="#后置处理器的执行顺序" class="headerlink" title="后置处理器的执行顺序"></a>后置处理器的执行顺序</h3><p>让我们进入源码来看吧</p>
<p>首先我们知晓，在<code>this.reader = new AnnotatedBeanDefinitionReader(this);</code>中完成了一系列的后置处理器的定义。</p>
<p>接下来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用我们的bean工厂的后置处理器.</span></span><br><span class="line"><span class="comment">//1. 会在此将class扫描成beanDefinition  </span></span><br><span class="line"><span class="comment">//2.bean工厂的后置处理器调用getBean</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br></pre></td></tr></table></figure>

<p>它会调用<code>refresh</code>方法里的<code>invokeBeanFactoryPostProcessors</code>方法来完成后置处理器的执行</p>
<p>再次进去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">	<span class="comment">//  获取两处存储BeanFactoryPostProcessor的对象 传入供接下来的调用</span></span><br><span class="line">	<span class="comment">//  1.当前Bean工厂，</span></span><br><span class="line">       <span class="comment">//  2.和我们自己调用addBeanFactoryPostProcessor的自定义BeanFactoryPostProcessor</span></span><br><span class="line">       <span class="comment">//  注意到getBeanFactoryPostProcessors()是我们对</span></span><br><span class="line">       <span class="comment">//  context.addBeanFactoryPostProcessor(xxx);</span></span><br><span class="line">       <span class="comment">//  当我们使用了上述的方法，才会在getBeanFactoryPostProcessors()返回</span></span><br><span class="line">	PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line"></span><br><span class="line">	.........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面我们知道调用Bean工厂的后置处理器，里面的方法是Bean工厂和某个函数【大多数下这个参数为空</p>
<p>那接着走吧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeBeanFactoryPostProcessors</span><span class="params">(</span></span><br><span class="line"><span class="params">    ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用BeanDefinitionRegistryPostProcessor的后置处理器 Begin</span></span><br><span class="line">    <span class="comment">// 定义已处理的后置处理器</span></span><br><span class="line">    Set&lt;String&gt; processedBeans = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断我们的beanFactory实现了BeanDefinitionRegistry(实现了该结构就有注册和获取Bean定义的能力）</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class="line">        <span class="comment">//强行把我们的bean工厂转为BeanDefinitionRegistry，因为待会需要注册Bean定义</span></span><br><span class="line">        <span class="type">BeanDefinitionRegistry</span> <span class="variable">registry</span> <span class="operator">=</span> (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">        <span class="comment">//保存BeanFactoryPostProcessor类型的后置   BeanFactoryPostProcessor 提供修改</span></span><br><span class="line">        List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//保存BeanDefinitionRegistryPostProcessor类型的后置处理器 BeanDefinitionRegistryPostProcessor 提供注册</span></span><br><span class="line">        List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环我们传递进来的beanFactoryPostProcessors</span></span><br><span class="line">        .......</span><br><span class="line">            <span class="comment">//一般为空</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//定义一个集合用户保存当前准备创建的BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">            List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一步:去beanFactory容器中获取BeanDefinitionRegistryPostProcessor的bean的处理器名称</span></span><br><span class="line">        String[] postProcessorNames =</span><br><span class="line">            beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环筛选出来的匹配BeanDefinitionRegistryPostProcessor的类型名称</span></span><br><span class="line">        <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">            <span class="comment">//判断是否实现了PriorityOrdered接口的  如果是就最优先去调用</span></span><br><span class="line">            <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">                <span class="comment">//显示的调用getBean()的方式获取出该对象然后加入到currentRegistryProcessors集合中去</span></span><br><span class="line">                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">                <span class="comment">//同时也加入到processedBeans集合中去</span></span><br><span class="line">                processedBeans.add(ppName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对currentRegistryProcessors集合中BeanDefinitionRegistryPostProcessor进行排序</span></span><br><span class="line">        sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">        <span class="comment">// 把当前的加入到总的里面去</span></span><br><span class="line">        registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * 在这里典型的BeanDefinitionRegistryPostProcessor就是</span></span><br><span class="line"><span class="comment">			 ConfigurationClassPostProcessor</span></span><br><span class="line"><span class="comment">			 * 用于进行bean定义的加载 比如我们的包扫描，<span class="doctag">@import</span>  等等。。。。。。。。。</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">        <span class="comment">//这个方法很重要，后续再说</span></span><br><span class="line">        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">        <span class="comment">//调用完之后，马上clea掉</span></span><br><span class="line">        currentRegistryProcessors.clear();</span><br><span class="line">        <span class="comment">//-----调用内置实现PriorityOrdered接口ConfigurationClassPostProcessor完毕--优先级No1-End------</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//======================================================================================</span></span><br><span class="line">        <span class="comment">//实现了优先级最高的Bean后置处理器的调用</span></span><br><span class="line">        <span class="comment">//去容器中获取BeanDefinitionRegistryPostProcessor的bean的处理器名称（内置的和上面注册的）</span></span><br><span class="line">        postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//循环上一步获取的BeanDefinitionRegistryPostProcessor的类型名称</span></span><br><span class="line">        <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">            <span class="comment">//表示没有被处理过,且实现了Ordered接口的</span></span><br><span class="line">            <span class="comment">//!processedBeans.contains(ppName) 不在上面那个队列中</span></span><br><span class="line">            <span class="keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">                <span class="comment">//显示的调用getBean()的方式获取出该对象然后加入到currentRegistryProcessors集合中去</span></span><br><span class="line">                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">                <span class="comment">//同时也加入到processedBeans集合中去</span></span><br><span class="line">                processedBeans.add(ppName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对currentRegistryProcessors集合中BeanDefinitionRegistryPostProcessor进行排序</span></span><br><span class="line">        sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">        <span class="comment">//把他加入到用于保存到registryProcessors中</span></span><br><span class="line">        registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">        <span class="comment">//调用他的后置处理方法</span></span><br><span class="line">        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">        <span class="comment">//调用完之后，马上clea掉</span></span><br><span class="line">        currentRegistryProcessors.clear();</span><br><span class="line">        <span class="comment">//--------调用自定义Order接口BeanDefinitionRegistryPostProcessor完毕-优先级No2-End---</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用没有实现任何优先级接口的BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">        <span class="comment">//定义一个重复处理的开关变量 默认值为true</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">reiterate</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//第一次就可以进来</span></span><br><span class="line">        <span class="keyword">while</span> (reiterate) &#123;</span><br><span class="line">            <span class="comment">//进入循环马上把开关变量给改为false</span></span><br><span class="line">            reiterate = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//去容器中获取BeanDefinitionRegistryPostProcessor的bean的处理器名称</span></span><br><span class="line">            postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">            <span class="comment">//循环上一步获取的BeanDefinitionRegistryPostProcessor的类型名称</span></span><br><span class="line">            <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">                <span class="comment">//没有被处理过的</span></span><br><span class="line">                <span class="keyword">if</span> (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">                    <span class="comment">//显示的调用getBean()的方式获取出该对象然后加入到currentRegistryProcessors集合中去</span></span><br><span class="line">                    currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">                    <span class="comment">//同时也加入到processedBeans集合中去</span></span><br><span class="line">                    processedBeans.add(ppName);</span><br><span class="line">                    <span class="comment">//再次设置为true</span></span><br><span class="line">                    reiterate = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//对currentRegistryProcessors集合中BeanDefinitionRegistryPostProcessor进行排序</span></span><br><span class="line">            sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">            <span class="comment">//把他加入到用于保存到registryProcessors中</span></span><br><span class="line">            registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">            <span class="comment">//调用他的后置处理方法</span></span><br><span class="line">            invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">            <span class="comment">//进行clear</span></span><br><span class="line">            currentRegistryProcessors.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//------------调用没有实现任何优先级接口自定义BeanDefinitionRegistryPostProcessor完毕--End-----</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用 BeanDefinitionRegistryPostProcessor.postProcessBeanFactory方法</span></span><br><span class="line">        invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span><br><span class="line">        <span class="comment">//调用BeanFactoryPostProcessor 自设的（没有）</span></span><br><span class="line">        invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//若当前的beanFactory没有实现了BeanDefinitionRegistry 说明没有注册Bean定义的能力</span></span><br><span class="line">        <span class="comment">// 那么就直接调用BeanDefinitionRegistryPostProcessor.postProcessBeanFactory方法</span></span><br><span class="line">        invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------所有BeanDefinitionRegistryPostProcessor调用完毕--End----------------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//--------------------------处理BeanFactoryPostProcessor --Begin--------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取容器中所有的 BeanFactoryPostProcessor</span></span><br><span class="line">    String[] postProcessorNames =</span><br><span class="line">        beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存BeanFactoryPostProcessor类型实现了priorityOrdered</span></span><br><span class="line">    List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//保存BeanFactoryPostProcessor类型实现了Ordered接口的</span></span><br><span class="line">    List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//保存BeanFactoryPostProcessor没有实现任何优先级接口的</span></span><br><span class="line">    List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">        <span class="comment">//processedBeans包含的话，表示在上面处理BeanDefinitionRegistryPostProcessor的时候处理过了</span></span><br><span class="line">        <span class="keyword">if</span> (processedBeans.contains(ppName)) &#123;</span><br><span class="line">            <span class="comment">// skip - already processed in first phase above</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断是否实现了PriorityOrdered 优先级最高</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">            priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断是否实现了Ordered  优先级 其次</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">            orderedPostProcessorNames.add(ppName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有实现任何的优先级接口的  最后调用</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  排序</span></span><br><span class="line">    sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">    <span class="comment">// 先调用BeanFactoryPostProcessor实现了 PriorityOrdered接口的</span></span><br><span class="line">    invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//再调用BeanFactoryPostProcessor实现了 Ordered.</span></span><br><span class="line">    List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">        orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">    &#125;</span><br><span class="line">    sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">    invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用没有实现任何方法接口的</span></span><br><span class="line">    List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">        nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">    &#125;</span><br><span class="line">    invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class="line">    <span class="comment">//--------------------------处理BeanFactoryPostProcessor --End----------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear cached merged bean definitions since the post-processors might have</span></span><br><span class="line">    <span class="comment">// modified the original metadata, e.g. replacing placeholders in values...</span></span><br><span class="line">    beanFactory.clearMetadataCache();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//---- BeanFactoryPostProcessor和BeanDefinitionRegistryPostProcessor调用完毕 --End---------</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个方法稍微有点长，其中设计到Bean工厂后置处理器的执行顺序如下：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/13/xUqtjkP82VNcn4l.jpg"
                      alt="Screenshot_79.jpg"
                ></p>
<h3 id="解析配置类"><a href="#解析配置类" class="headerlink" title="解析配置类"></a>解析配置类</h3><p>介绍完了Bean工厂的后置处理器的执行顺序，我们就详细介绍ConfigurationClassPostProcessor后置处理器解析配置类的执行流程。</p>
<p>ConfigurationClassPostProcessor是Spring中唯一实现了PriorityOrdered接口的内置Bean工厂后置处理器，所以它会第一个被调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeBeanDefinitionRegistryPostProcessors</span><span class="params">(</span></span><br><span class="line"><span class="params">		Collection&lt;? extends BeanDefinitionRegistryPostProcessor&gt; postProcessors, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">	<span class="comment">//获取容器中的ConfigurationClassPostProcessor的后置处理器进行bean定义的扫描</span></span><br><span class="line">	<span class="keyword">for</span> (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) &#123;</span><br><span class="line">           <span class="comment">//在这里再调用处理</span></span><br><span class="line">		postProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">registryId</span> <span class="operator">=</span> System.identityHashCode(registry);</span><br><span class="line">       <span class="comment">//这里都是进行一些判断 不太重要</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">this</span>.registriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">				<span class="string">&quot;postProcessBeanDefinitionRegistry already called on this post-processor against &quot;</span> + registry);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">this</span>.factoriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">				<span class="string">&quot;postProcessBeanFactory already called on this post-processor against &quot;</span> + registry);</span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">	<span class="built_in">this</span>.registriesPostProcessed.add(registryId);</span><br><span class="line">	<span class="comment">//真正的解析我们的bean定义</span></span><br><span class="line">	processConfigBeanDefinitions(registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们认真看它内部的处理方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processConfigBeanDefinitions</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">	List&lt;BeanDefinitionHolder&gt; configCandidates = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       </span><br><span class="line">	<span class="comment">//获取IOC 容器中目前所有bean定义的名称</span></span><br><span class="line">	String[] candidateNames = registry.getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//循环我们的上一步获取的所有的bean定义信息</span></span><br><span class="line">	<span class="keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line">		<span class="comment">//通过bean的名称来获取我们的bean定义对象</span></span><br><span class="line">		<span class="type">BeanDefinition</span> <span class="variable">beanDef</span> <span class="operator">=</span> registry.getBeanDefinition(beanName);</span><br><span class="line">		<span class="comment">//判断是否有没有解析过</span></span><br><span class="line">		<span class="keyword">if</span> (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||</span><br><span class="line">				ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;Bean definition has already been processed as a configuration class: &quot;</span> + beanDef);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">           </span><br><span class="line">		<span class="comment">//进行正在的解析判断是不是完全的配置类 还是一个非正式的配置类</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, <span class="built_in">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">			<span class="comment">//满足添加 就加入到候选的配置类集合中</span></span><br><span class="line">			configCandidates.add(<span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(beanDef, beanName));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若没有找到配置类 直接返回</span></span><br><span class="line">	<span class="keyword">if</span> (configCandidates.isEmpty()) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//对我们的配置类进行Order排序</span></span><br><span class="line">	configCandidates.sort((bd1, bd2) -&gt; &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());</span><br><span class="line">		<span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());</span><br><span class="line">		<span class="keyword">return</span> Integer.compare(i1, i2);</span><br><span class="line">	&#125;);</span><br><span class="line">       <span class="comment">//==========================================================================</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建我们通过@CompentScan导入进来的bean name的生成器</span></span><br><span class="line">	<span class="comment">// 创建我们通过@Import导入进来的bean的名称</span></span><br><span class="line">	<span class="type">SingletonBeanRegistry</span> <span class="variable">sbr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">if</span> (registry <span class="keyword">instanceof</span> SingletonBeanRegistry) &#123;</span><br><span class="line">		sbr = (SingletonBeanRegistry) registry;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">this</span>.localBeanNameGeneratorSet) &#123;</span><br><span class="line">			<span class="type">BeanNameGenerator</span> <span class="variable">generator</span> <span class="operator">=</span> (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);</span><br><span class="line">			<span class="keyword">if</span> (generator != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="comment">//设置@CompentScan导入进来的bean的名称生成器(默认类首字母小写）也可以自己定义，一般不会</span></span><br><span class="line">				<span class="built_in">this</span>.componentScanBeanNameGenerator = generator;</span><br><span class="line">				<span class="comment">//设置@Import导入进来的bean的名称生成器(默认类首字母小写）也可以自己定义，一般不会</span></span><br><span class="line">				<span class="built_in">this</span>.importBeanNameGenerator = generator;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">this</span>.environment == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="built_in">this</span>.environment = <span class="keyword">new</span> <span class="title class_">StandardEnvironment</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建一个配置类解析器对象</span></span><br><span class="line">	<span class="type">ConfigurationClassParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConfigurationClassParser</span>(</span><br><span class="line">			<span class="built_in">this</span>.metadataReaderFactory, <span class="built_in">this</span>.problemReporter, <span class="built_in">this</span>.environment,</span><br><span class="line">			<span class="built_in">this</span>.resourceLoader, <span class="built_in">this</span>.componentScanBeanNameGenerator, registry);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//用于保存我们的配置类BeanDefinitionHolder放入上面筛选出来的配置类</span></span><br><span class="line">	Set&lt;BeanDefinitionHolder&gt; candidates = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(configCandidates);</span><br><span class="line">	<span class="comment">//用于保存我们的已经解析的配置类，长度默认为解析出来默认的配置类的集合长度</span></span><br><span class="line">	Set&lt;ConfigurationClass&gt; alreadyParsed = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(configCandidates.size());</span><br><span class="line"></span><br><span class="line">	<span class="comment">//do while 会进行第一次解析</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="comment">//真正的解析我们的配置类</span></span><br><span class="line">           <span class="comment">//！！！！！！！！！！！</span></span><br><span class="line">		parser.parse(candidates);</span><br><span class="line">		parser.validate();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//解析出来的配置类</span></span><br><span class="line">		Set&lt;ConfigurationClass&gt; configClasses = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(parser.getConfigurationClasses());</span><br><span class="line">		configClasses.removeAll(alreadyParsed);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Read the model and create bean definitions based on its content</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.reader == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="built_in">this</span>.reader = <span class="keyword">new</span> <span class="title class_">ConfigurationClassBeanDefinitionReader</span>(</span><br><span class="line">					registry, <span class="built_in">this</span>.sourceExtractor, <span class="built_in">this</span>.resourceLoader, <span class="built_in">this</span>.environment,</span><br><span class="line">					<span class="built_in">this</span>.importBeanNameGenerator, parser.getImportRegistry());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 此处才把@Bean的方法和@Import 注册到BeanDefinitionMap中</span></span><br><span class="line">		<span class="built_in">this</span>.reader.loadBeanDefinitions(configClasses);</span><br><span class="line">		<span class="comment">//加入到已经解析的集合中</span></span><br><span class="line">		alreadyParsed.addAll(configClasses);</span><br><span class="line"></span><br><span class="line">		candidates.clear();</span><br><span class="line">		<span class="comment">//判断我们ioc容器中的是不是&gt;候选原始的bean定义的个数</span></span><br><span class="line">		<span class="keyword">if</span> (registry.getBeanDefinitionCount() &gt; candidateNames.length) &#123;</span><br><span class="line">			<span class="comment">//获取所有的bean定义</span></span><br><span class="line">			String[] newCandidateNames = registry.getBeanDefinitionNames();</span><br><span class="line">			<span class="comment">//原始的老的候选的bean定义</span></span><br><span class="line">			Set&lt;String&gt; oldCandidateNames = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(Arrays.asList(candidateNames));</span><br><span class="line">			Set&lt;String&gt; alreadyParsedClasses = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">			<span class="comment">//赋值已经解析的</span></span><br><span class="line">			<span class="keyword">for</span> (ConfigurationClass configurationClass : alreadyParsed) &#123;</span><br><span class="line">				alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (String candidateName : newCandidateNames) &#123;</span><br><span class="line">				<span class="comment">//表示当前循环的还没有被解析过</span></span><br><span class="line">				<span class="keyword">if</span> (!oldCandidateNames.contains(candidateName)) &#123;</span><br><span class="line">					<span class="type">BeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> registry.getBeanDefinition(candidateName);</span><br><span class="line">					<span class="comment">//判断有没有被解析过</span></span><br><span class="line">					<span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, <span class="built_in">this</span>.metadataReaderFactory) &amp;&amp;</span><br><span class="line">							!alreadyParsedClasses.contains(bd.getBeanClassName())) &#123;</span><br><span class="line">						candidates.add(<span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(bd, candidateName));</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			candidateNames = newCandidateNames;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//存在没有解析过的 需要循环解析</span></span><br><span class="line">	<span class="keyword">while</span> (!candidates.isEmpty());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes</span></span><br><span class="line">	<span class="keyword">if</span> (sbr != <span class="literal">null</span> &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) &#123;</span><br><span class="line">		sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">this</span>.metadataReaderFactory <span class="keyword">instanceof</span> CachingMetadataReaderFactory) &#123;</span><br><span class="line">		<span class="comment">// Clear cache in externally provided MetadataReaderFactory; this is a no-op</span></span><br><span class="line">		<span class="comment">// for a shared cache since it&#x27;ll be cleared by the ApplicationContext.</span></span><br><span class="line">		((CachingMetadataReaderFactory) <span class="built_in">this</span>.metadataReaderFactory).clearCache();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面方法的主要逻辑大致如下：</p>
<ol>
<li>遍历Bean定义，获取所有配置类的Bean定义，并且根据是否加上@Configuration注解给其Bean定义添加<code>Full</code>或<code>Lite</code>属性。</li>
<li>通过ConfigurationClassParser的<code>parse</code>方法解析配置类，这是核心。</li>
<li>解析完后，如果发现解析出来了新的Bean定义，那么需要重复第 1 步直到所有的Bean都解析完成。</li>
</ol>
<p>下面我们就跟进到ConfigurationClassParser的<code>parse</code>方法，看看如何解析配置类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; configCandidates)</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 用于来保存延时的ImportSelectors，最最最著名的代表就是我们的SpringBoot自动装配的的类</span></span><br><span class="line"><span class="comment">    * AutoConfigurationImportSelector</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="built_in">this</span>.deferredImportSelectors = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 循环配置类</span></span><br><span class="line">    <span class="keyword">for</span> (BeanDefinitionHolder holder : configCandidates) &#123;</span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> holder.getBeanDefinition();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//真正的解析我们的bean定义 :通过注解元数据 解析</span></span><br><span class="line">            <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">                parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) &#123;</span><br><span class="line">                parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                parse(bd.getBeanClassName(), holder.getBeanName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">                <span class="string">&quot;Failed to parse configuration class [&quot;</span> + bd.getBeanClassName() + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理我们延时的DeferredImportSelectors w我们springboot就是通过这步进行记载spring.factories文件中的自定装配的对象</span></span><br><span class="line">    processDeferredImportSelectors();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">(AnnotationMetadata metadata, String beanName)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 第一步:把我们的配置类源信息和beanName包装成一个ConfigurationClass 对象</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    processConfigurationClass(<span class="keyword">new</span> <span class="title class_">ConfigurationClass</span>(metadata, beanName));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processConfigurationClass</span><span class="params">(ConfigurationClass configClass)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    ......</span><br><span class="line">        <span class="comment">// Recursively process the configuration class and its superclass hierarchy.递归处理配置类及其超类层次结构。</span></span><br><span class="line">        <span class="type">SourceClass</span> <span class="variable">sourceClass</span> <span class="operator">=</span> asSourceClass(configClass);</span><br><span class="line">    <span class="comment">//真正的进行配置类的解析</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//解析我们的配置类</span></span><br><span class="line">        sourceClass = doProcessConfigurationClass(configClass, sourceClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (sourceClass != <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 这里把解析出来的SourceClass放入configurationClasses中</span></span><br><span class="line">    <span class="comment">// 主要是@Import、@Bean、@ImportRosource等没有注册的Bean</span></span><br><span class="line">    <span class="built_in">this</span>.configurationClasses.put(configClass, configClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>层层向下，终于到了解析配置类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> SourceClass <span class="title function_">doProcessConfigurationClass</span><span class="params">(ConfigurationClass configClass, SourceClass sourceClass)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 这里终于开始解析配置类了，顺序如下：</span></span><br><span class="line">    <span class="comment">// @PropertySources-@ComponentScan-@Import-@ImportResource-@Bean</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Recursively process any member (nested) classes first</span></span><br><span class="line">    processMemberClasses(configClass, sourceClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理我们的@propertySource注解的</span></span><br><span class="line">    <span class="keyword">for</span> (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">        sourceClass.getMetadata(), PropertySources.class,</span><br><span class="line">        org.springframework.context.annotation.PropertySource.class)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.environment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">            processPropertySource(propertySource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Ignoring @PropertySource annotation on [&quot;</span> + sourceClass.getMetadata().getClassName() +</span><br><span class="line">                        <span class="string">&quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析我们的 @ComponentScan 注解</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//从我们的配置类上解析处ComponentScans的对象集合属性</span></span><br><span class="line">    Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">        sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);</span><br><span class="line">    <span class="comment">//开始判断是否有这个属性，有的话就解析</span></span><br><span class="line">    <span class="keyword">if</span> (!componentScans.isEmpty() &amp;&amp;</span><br><span class="line">        !<span class="built_in">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line">        <span class="comment">//循环解析 我们解析出来的AnnotationAttributes</span></span><br><span class="line">        <span class="keyword">for</span> (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//把我们扫描出来的类变为bean定义的集合 真正的解析</span></span><br><span class="line">            <span class="comment">//这里是@ComponentScan注解的核心</span></span><br><span class="line">            Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class="line">                <span class="built_in">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取到了扫描后的Bean定义</span></span><br><span class="line">            <span class="comment">//循环处理我们包扫描出来的bean定义</span></span><br><span class="line">            <span class="keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class="line">                <span class="comment">//获取Bean定义</span></span><br><span class="line">                <span class="type">BeanDefinition</span> <span class="variable">bdCand</span> <span class="operator">=</span> holder.getBeanDefinition().getOriginatingBeanDefinition();</span><br><span class="line">                <span class="comment">//判断空</span></span><br><span class="line">                <span class="keyword">if</span> (bdCand == <span class="literal">null</span>) &#123;</span><br><span class="line">                    bdCand = holder.getBeanDefinition();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//判断当前扫描出来的bean定义是不是一个配置类,若是的话 直接进行递归解析</span></span><br><span class="line">                <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, <span class="built_in">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">                    <span class="comment">//递归解析 因为@Component算是lite配置类</span></span><br><span class="line">                    parse(bdCand.getBeanClassName(), holder.getBeanName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 @Import annotations</span></span><br><span class="line">    processImports(configClass, sourceClass, getImports(sourceClass), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 @ImportResource annotations</span></span><br><span class="line">    <span class="type">AnnotationAttributes</span> <span class="variable">importResource</span> <span class="operator">=</span></span><br><span class="line">        AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);</span><br><span class="line">    <span class="keyword">if</span> (importResource != <span class="literal">null</span>) &#123;</span><br><span class="line">        String[] resources = importResource.getStringArray(<span class="string">&quot;locations&quot;</span>);</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">BeanDefinitionReader</span>&gt; readerClass = importResource.getClass(<span class="string">&quot;reader&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String resource : resources) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">resolvedResource</span> <span class="operator">=</span> <span class="built_in">this</span>.environment.resolveRequiredPlaceholders(resource);</span><br><span class="line">            configClass.addImportedResource(resolvedResource, readerClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 @Bean methods 获取到我们配置类中所有标注了@Bean的方法</span></span><br><span class="line">    Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (MethodMetadata methodMetadata : beanMethods) &#123;</span><br><span class="line">        configClass.addBeanMethod(<span class="keyword">new</span> <span class="title class_">BeanMethod</span>(methodMetadata, configClass));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理配置类接口 默认方法的@Bean</span></span><br><span class="line">    processInterfaces(configClass, sourceClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理配置类的父类的 ，循环再解析</span></span><br><span class="line">    <span class="keyword">if</span> (sourceClass.getMetadata().hasSuperClass()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">superclass</span> <span class="operator">=</span> sourceClass.getMetadata().getSuperClassName();</span><br><span class="line">        <span class="keyword">if</span> (superclass != <span class="literal">null</span> &amp;&amp; !superclass.startsWith(<span class="string">&quot;java&quot;</span>) &amp;&amp;</span><br><span class="line">            !<span class="built_in">this</span>.knownSuperclasses.containsKey(superclass)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.knownSuperclasses.put(superclass, configClass);</span><br><span class="line">            <span class="comment">// Superclass found, return its annotation metadata and recurse</span></span><br><span class="line">            <span class="keyword">return</span> sourceClass.getSuperClass();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有父类解析完成</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>绕了半天，终于看到我们熟悉的注解了！注解对应配置类的解析顺序如下：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/15/BmD2IMnZ3SHlJUj.jpg"
                      alt="Screenshot_80.jpg"
                ></p>
<h4 id="ComponentScan的解析"><a href="#ComponentScan的解析" class="headerlink" title="@ComponentScan的解析"></a>@ComponentScan的解析</h4><p>我们从刚刚来看，是如何进来的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> SourceClass <span class="title function_">doProcessConfigurationClass</span><span class="params">(ConfigurationClass configClass, SourceClass sourceClass)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    .......</span><br><span class="line">        <span class="comment">//解析我们的 @ComponentScan 注解</span></span><br><span class="line">        <span class="comment">//从我们的配置类上解析处ComponentScans的对象集合属性</span></span><br><span class="line">        Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">        sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!componentScans.isEmpty() &amp;&amp;</span><br><span class="line">        !<span class="built_in">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line">        <span class="comment">//循环解析 我们解析出来的AnnotationAttributes</span></span><br><span class="line">        <span class="keyword">for</span> (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//把我们扫描出来的类变为bean定义的集合 真正的解析</span></span><br><span class="line">            Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class="line">                <span class="built_in">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//循环处理我们包扫描出来的bean定义</span></span><br><span class="line">            <span class="keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class="line">                <span class="type">BeanDefinition</span> <span class="variable">bdCand</span> <span class="operator">=</span> holder.getBeanDefinition().getOriginatingBeanDefinition();</span><br><span class="line">                <span class="keyword">if</span> (bdCand == <span class="literal">null</span>) &#123;</span><br><span class="line">                    bdCand = holder.getBeanDefinition();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//判断当前扫描出来的bean定义是不是一个配置类,若是的话 直接进行递归解析</span></span><br><span class="line">                <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, <span class="built_in">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">                    <span class="comment">//递归解析 因为@Component算是lite配置类</span></span><br><span class="line">                    parse(bdCand.getBeanClassName(), holder.getBeanName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .....</span><br><span class="line">        <span class="comment">// 没有父类解析完成</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>很显然看到它是按如下的步骤进入的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把我们扫描出来的类变为bean定义的集合 真正的解析</span></span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class="line">			<span class="built_in">this</span>.componentScanParser.parse(componentScan,                              									sourceClass.getMetadata().getClassName());</span><br></pre></td></tr></table></figure>

<p>那么我们现在进入这个方法详细说说</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">parse</span><span class="params">(AnnotationAttributes componentScan, <span class="keyword">final</span> String declaringClass)</span> &#123;</span><br><span class="line">		<span class="comment">// 创建一个扫描器scanner</span></span><br><span class="line">       	<span class="comment">// 还记得在创建AnnotationConfigApplicationContext的时候创建的那个扫描器吗 </span></span><br><span class="line">      	<span class="comment">// 当时说了那个扫描器只是供程序员外部调用，这里就证明了</span></span><br><span class="line">   	    <span class="comment">// 在Spring内部，实际上执行扫描的只会是这里创建的scanner对象</span></span><br><span class="line">	<span class="type">ClassPathBeanDefinitionScanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathBeanDefinitionScanner</span>(<span class="built_in">this</span>.registry,</span><br><span class="line">			componentScan.getBoolean(<span class="string">&quot;useDefaultFilters&quot;</span>), <span class="built_in">this</span>.environment, <span class="built_in">this</span>.resourceLoader);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 判断是否重写了默认的命名规则</span></span><br><span class="line">	Class&lt;? <span class="keyword">extends</span> <span class="title class_">BeanNameGenerator</span>&gt; generatorClass = componentScan.getClass(<span class="string">&quot;nameGenerator&quot;</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="type">boolean</span> <span class="variable">useInheritedGenerator</span> <span class="operator">=</span> (BeanNameGenerator.class == generatorClass);</span><br><span class="line">	scanner.setBeanNameGenerator(useInheritedGenerator ? <span class="built_in">this</span>.beanNameGenerator :</span><br><span class="line">			BeanUtils.instantiateClass(generatorClass));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解析scopedProxy属性，该属性可以将Bean创建为JDK代理/CGLib代理</span></span><br><span class="line">	<span class="type">ScopedProxyMode</span> <span class="variable">scopedProxyMode</span> <span class="operator">=</span> componentScan.getEnum(<span class="string">&quot;scopedProxy&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (scopedProxyMode != ScopedProxyMode.DEFAULT) &#123;</span><br><span class="line">		scanner.setScopedProxyMode(scopedProxyMode);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		Class&lt;? <span class="keyword">extends</span> <span class="title class_">ScopeMetadataResolver</span>&gt; resolverClass = componentScan.getClass(<span class="string">&quot;scopeResolver&quot;</span>);</span><br><span class="line">		scanner.setScopeMetadataResolver(BeanUtils.instantiateClass(resolverClass));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	scanner.setResourcePattern(componentScan.getString(<span class="string">&quot;resourcePattern&quot;</span>));</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 解析includeFilters属性</span></span><br><span class="line">	<span class="keyword">for</span> (AnnotationAttributes filter : componentScan.getAnnotationArray(<span class="string">&quot;includeFilters&quot;</span>)) &#123;</span><br><span class="line">		<span class="keyword">for</span> (TypeFilter typeFilter : typeFiltersFor(filter)) &#123;</span><br><span class="line">               <span class="comment">// 当调用addIncludeFilter/addExcludeFilter时仅仅把定义的规则保存下来</span></span><br><span class="line">               <span class="comment">// 并没有真正去执行匹配过程</span></span><br><span class="line">			scanner.addIncludeFilter(typeFilter);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">       <span class="comment">// 解析excludeFilters属性</span></span><br><span class="line">	<span class="keyword">for</span> (AnnotationAttributes filter : componentScan.getAnnotationArray(<span class="string">&quot;excludeFilters&quot;</span>)) &#123;</span><br><span class="line">		<span class="keyword">for</span> (TypeFilter typeFilter : typeFiltersFor(filter)) &#123;</span><br><span class="line">			scanner.addExcludeFilter(typeFilter);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 是否懒加载</span></span><br><span class="line">	<span class="type">boolean</span> <span class="variable">lazyInit</span> <span class="operator">=</span> componentScan.getBoolean(<span class="string">&quot;lazyInit&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (lazyInit) &#123;</span><br><span class="line">		scanner.getBeanDefinitionDefaults().setLazyInit(<span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 拿到包路径basePackages</span></span><br><span class="line">	Set&lt;String&gt; basePackages = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">	String[] basePackagesArray = componentScan.getStringArray(<span class="string">&quot;basePackages&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (String pkg : basePackagesArray) &#123;</span><br><span class="line">		String[] tokenized = StringUtils.tokenizeToStringArray(<span class="built_in">this</span>.environment.resolvePlaceholders(pkg),</span><br><span class="line">				ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);</span><br><span class="line">		Collections.addAll(basePackages, tokenized);</span><br><span class="line">	&#125;</span><br><span class="line">       <span class="comment">/** 从下面的代码可以看出ComponentScans指定扫描目标，除了最常用的basePackages</span></span><br><span class="line"><span class="comment">         * 还有两种方式:</span></span><br><span class="line"><span class="comment">         * 1. 指定basePackageClasses，就是指定多个类，只要是与这几个类同级，</span></span><br><span class="line"><span class="comment">         *    或者在这几个类下级的都可以被扫描到，这种方式其实是spring比较推荐的，</span></span><br><span class="line"><span class="comment">         *    因为指定basePackages没有IDE的检查，容易出错，但是指定一个类</span></span><br><span class="line"><span class="comment">         *    就有IDE的检查了，不容易出错，经常会用一个空的类来作为basePackageClasses</span></span><br><span class="line"><span class="comment">         * 2. 直接不指定，默认会把与配置类同级，或者在配置类下级的作为扫描目标</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">	<span class="keyword">for</span> (Class&lt;?&gt; clazz : componentScan.getClassArray(<span class="string">&quot;basePackageClasses&quot;</span>)) &#123;</span><br><span class="line">		basePackages.add(ClassUtils.getPackageName(clazz));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (basePackages.isEmpty()) &#123;</span><br><span class="line">		basePackages.add(ClassUtils.getPackageName(declaringClass));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 把规则填充到排除规则，这里就把注册类自身当作排除规则，真正执行匹配的时候会把自身给排除</span></span><br><span class="line">	scanner.addExcludeFilter(</span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">AbstractTypeHierarchyTraversingFilter</span>(<span class="literal">false</span>, <span class="literal">false</span>) &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">matchClassName</span><span class="params">(String className)</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> declaringClass.equals(className);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">       <span class="comment">// 先把basePackages转为字符串数组的形式</span></span><br><span class="line">	<span class="comment">// 通过扫描器scanner的doScan扫描</span></span><br><span class="line">	<span class="keyword">return</span> scanner.doScan(StringUtils.toStringArray(basePackages));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到它的流程是</p>
<p>1、创建一个扫描器scanner</p>
<p>2、解析了一些属性，代理【特别includeFilters属性</p>
<p>3、然后通过扫描器scanner的doScan扫描</p>
<p>好的，我们接着进入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">doScan</span><span class="params">(String... basePackages)</span> &#123;</span><br><span class="line">   Assert.notEmpty(basePackages, <span class="string">&quot;At least one base package must be specified&quot;</span>);</span><br><span class="line">   <span class="comment">//最后也是返回一个Bean定义集合</span></span><br><span class="line">   <span class="comment">// 保存解析后的Bean定义集合</span></span><br><span class="line">   Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 循环需要扫描的包路径</span></span><br><span class="line">   <span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">      <span class="comment">// findCandidateComponents方法根据包名找到符合条件的BeanDefinition集合</span></span><br><span class="line">      Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">       </span><br><span class="line">      <span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">         <span class="comment">// 解析@Scope注解</span></span><br><span class="line">         <span class="type">ScopeMetadata</span> <span class="variable">scopeMetadata</span> <span class="operator">=</span> <span class="built_in">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">          </span><br><span class="line">         candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">         <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> <span class="built_in">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="built_in">this</span>.registry);</span><br><span class="line">         <span class="comment">// 下面的两个if都会进入</span></span><br><span class="line">         <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">            <span class="comment">// 内部会设置默认属性</span></span><br><span class="line">            postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">         &#125;</span><br><span class="line">          <span class="comment">// 如果是AnnotatedBeanDefinition，还会再设置一次值</span></span><br><span class="line">         <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">            <span class="comment">// 解析@Lazy注解</span></span><br><span class="line">            AnnotationConfigUtils.processCommonDefinitionAnnotations(</span><br><span class="line">                (AnnotatedBeanDefinition) candidate);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//把我们解析出来的组件bean定义注册到我们的IOC容器中（容器中没有才注册）</span></span><br><span class="line">         <span class="keyword">if</span> (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">            <span class="type">BeanDefinitionHolder</span> <span class="variable">definitionHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(candidate, beanName);</span><br><span class="line">            definitionHolder =</span><br><span class="line">                  AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="built_in">this</span>.registry);</span><br><span class="line">             </span><br><span class="line">            beanDefinitions.add(definitionHolder);</span><br><span class="line">            <span class="comment">// 最终来到这，完成bean定义的注册</span></span><br><span class="line">            registerBeanDefinition(definitionHolder, <span class="built_in">this</span>.registry);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到它的解析过程，new一个<code>Set&lt;BeanDefinitionHolder&gt;</code>，然后扫描包路径</p>
<p>对扫描后的Bean定义进行一些配置，最后添加到<code>beanDefinitions</code>，最后<code>registerBeanDefinition</code>完成注册。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;BeanDefinition&gt; <span class="title function_">findCandidateComponents</span><span class="params">(String basePackage)</span> &#123;</span><br><span class="line">    <span class="comment">// spring支持component索引技术，需要引入一个组件，因为大部分情况不会引入这个组件</span></span><br><span class="line">    <span class="comment">// 所以不会进入到这个if</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.componentsIndex != <span class="literal">null</span> &amp;&amp; indexSupportsIncludeFilters()) &#123;</span><br><span class="line">        <span class="keyword">return</span> addCandidateComponentsFromIndex(<span class="built_in">this</span>.componentsIndex, basePackage);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//调用scanCandidateComponents</span></span><br><span class="line">        <span class="keyword">return</span> scanCandidateComponents(basePackage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Set&lt;BeanDefinition&gt; <span class="title function_">scanCandidateComponents</span><span class="params">(String basePackage)</span> &#123;</span><br><span class="line">	Set&lt;BeanDefinition&gt; candidates = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 把传进来的basePackage字符串转换成文件路径的形式</span></span><br><span class="line">           <span class="comment">// com.xx -&gt; classpath*:com/xx/**/*.class</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">packageSearchPath</span> <span class="operator">=</span> ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +</span><br><span class="line">				resolveBasePackage(basePackage) + <span class="string">&#x27;/&#x27;</span> + <span class="built_in">this</span>.resourcePattern;</span><br><span class="line">        </span><br><span class="line">           <span class="comment">// 根据路径，获得符合要求的文件</span></span><br><span class="line">		Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">traceEnabled</span> <span class="operator">=</span> logger.isTraceEnabled();</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">debugEnabled</span> <span class="operator">=</span> logger.isDebugEnabled();</span><br><span class="line">		<span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">			<span class="keyword">if</span> (traceEnabled) &#123;</span><br><span class="line">				logger.trace(<span class="string">&quot;Scanning &quot;</span> + resource);</span><br><span class="line">			&#125;</span><br><span class="line">               <span class="comment">// 判断资源是否可读，并且不是一个目录</span></span><br><span class="line">			<span class="keyword">if</span> (resource.isReadable()) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">                       <span class="comment">//metadataReader元数据读取器，用来解析resource</span></span><br><span class="line">					<span class="type">MetadataReader</span> <span class="variable">metadataReader</span> <span class="operator">=</span> getMetadataReaderFactory().getMetadataReader(resource);</span><br><span class="line">					<span class="keyword">if</span> (isCandidateComponent(metadataReader)) &#123;</span><br><span class="line">						<span class="type">ScannedGenericBeanDefinition</span> <span class="variable">sbd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScannedGenericBeanDefinition</span>(metadataReader);</span><br><span class="line">						sbd.setSource(resource);</span><br><span class="line">                           <span class="comment">// 在isCandidateComponent方法内部会真正执行匹配规则</span></span><br><span class="line">                           <span class="comment">// 这里就会扫描到@Component对应的类</span></span><br><span class="line">                           <span class="comment">// 考虑排除、包含并且对接口、抽象类进行处理</span></span><br><span class="line">						<span class="comment">// 比如Mybatis要重写这个类，因为Mybatis接口也要扫描（@Mapper）</span></span><br><span class="line">						<span class="keyword">if</span> (isCandidateComponent(sbd)) &#123;</span><br><span class="line">							<span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">								logger.debug(<span class="string">&quot;Identified candidate component class: &quot;</span> + resource);</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="comment">// 最后加入集合</span></span><br><span class="line">							candidates.add(sbd);</span><br><span class="line">						&#125;</span><br><span class="line">			</span><br><span class="line">                  ....</span><br><span class="line">                      </span><br><span class="line">       <span class="comment">// 返回结果</span></span><br><span class="line">	<span class="keyword">return</span> candidates;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后我们来总结一下@ComponentScan的解析过程：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/06/01/3LUXrAGetvE9Rod.jpg"
                      alt="Screenshot_91.jpg"
                ></p>
<h1 id="循环依赖解决"><a href="#循环依赖解决" class="headerlink" title="循环依赖解决"></a>循环依赖解决</h1><h2 id="什么是循环依赖"><a href="#什么是循环依赖" class="headerlink" title="什么是循环依赖"></a>什么是循环依赖</h2><p>什么是循环依赖？请看下面代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanA</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BeanB beanB;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanB</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BeanA beanA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是循环依赖，A依赖B并且B依赖A。我们之前介绍了Spring中Bean的生命周期和创建流程，包括<strong>实例化、属性赋值和初始化</strong>三个阶段，最终Bean会被存入一级缓存中(单例池)。如果按照下面的流程会怎么样：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/25JhH1"><img  
                     lazyload
                     alt="image"
                     data-src="https://z3.ax1x.com/2021/06/12/25JhH1.jpg"
                      alt="25JhH1.jpg"
                ></a></p>
<p>很明显死循环了，这样是行不通的。Spring当然不会这么傻，Spring引入了<strong>三级缓存</strong>来解决循环依赖的问题，下面我们逐步介绍。</p>
<h2 id="三个缓存"><a href="#三个缓存" class="headerlink" title="三个缓存"></a>三个缓存</h2><h3 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h3><p>假设只有一级缓存，上面我们说了如果在初始化之后才将Bean放入一级缓存，那肯定会出现死循环，我们进行如下改进：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/25Y9C8"><img  
                     lazyload
                     alt="image"
                     data-src="https://z3.ax1x.com/2021/06/12/25Y9C8.jpg"
                      alt="25Y9C8.jpg"
                ></a></p>
<p>在实例化之后，直接把Bean加入一级缓存，每次获取Bean时先去一级缓存拿，如果拿到了就直接返回。这样可以吗？我们来走一遍流程：</p>
<ol>
<li>开始创建A，实例化完成后将A放入一级缓存</li>
<li>A开始属性赋值，发现依赖B，开始创建B</li>
<li>B实例化完成后，将B放入一级缓存</li>
<li>B开始属性赋值，发现依赖A，开始创建A</li>
<li>因为第2步，B可以从一级缓存拿到A，B完成属性赋值，接着完成初始化</li>
<li>B创建完成，回到A，A完成属性赋值，接着完成初始化</li>
</ol>
<blockquote>
<p>这里注意一下，实例化后就放入一级缓存，这时的Bean属于<strong>早期对象</strong>，因为还没有完成赋值等操作。但是由于创建过程中一直持有该Bean的引用，所以初始化完成后，一级缓存中的Bean会变为<strong>成熟对象</strong>。</p>
</blockquote>
<p>好像没问题了，解决了死循环，并且A、B都初始化成功！但是，这样设计无法保证<strong>多线程情况下的安全问题：</strong></p>
<ul>
<li>可能存在多个线程同时创建Bean，此时一个线程正在创建Bean时，如果另一个线程访问了一级缓存就会拿到不完整的Bean。</li>
<li>其实就是当我们一级缓存中有Bean_liduoan，然而我们某个线程发现有这个Bean，想使用Bean_liduoan.XXX()方法时，发现这个Bean是早期对象，很多东西都没有完成。</li>
</ul>
<p>那如何解决？可以通过加锁解决 (这里必须是<strong>可重入锁</strong>，不然会死锁)，但是由于只有一级缓存，无论怎么锁，一个线程创建Bean的时候就别的线程就没法从缓存中拿Bean，这样性能会大打折扣。我们看看Spring是如何解决的：</p>
<h3 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h3><p>Spring引入了二级缓存，来解决多线程下性能和并发安全的问题：</p>
<p><a target="_blank" rel="noopener" href="https://images.gitee.com/uploads/images/2020/1219/103319_1079b047_8183653.jpeg"><img  
                     lazyload
                     alt="image"
                     data-src="https://images.gitee.com/uploads/images/2020/1219/103319_1079b047_8183653.jpeg"
                      alt="输入图片说明"
                ></a></p>
<p>引入二级缓存后，<strong>一级缓存专门用来存放成熟的Bean，二级缓存专门用来存放早期的Bean</strong>。流程如下：</p>
<ol>
<li>首次<code>getBean(A)</code>时先从一级缓存中拿，第一次不能从二级缓存中拿，因为可能会拿到不成熟的Bean。如果没拿到下一步开始创建A。</li>
<li>实例化A完成后，将早期的A加入二级缓存，开始属性赋值，发现A依赖B。</li>
<li>通过<code>getBean(B)</code>开始递归创建B，先从一级缓存中拿，没有再从二级缓存中拿，没拿到下一步开始创建B。</li>
<li>实例化B完成后，将早期的B加入二级缓存，开始属性赋值，发现B依赖A。</li>
<li>又通过<code>getBean(A)</code>开始递归创建A，先从一级缓存中拿，没有再从二级缓存中拿，这里由于第2步，可以从二级缓存中拿到A。</li>
<li>B拿到A后完成属性赋值，接着完成实例化，B创建完成，加入一级缓存。</li>
<li>B创建完成后A完成属性赋值，接着完成实例化，A创建完成，加入一级缓存。</li>
</ol>
<blockquote>
<p>这里有一个问题：第1步、第3步和第5步怎么区别<code>getBean()</code>是只能从一级缓存中拿，还是可以到所有缓存中拿？</p>
<ol>
<li>加锁：当Bean正在创建的时候会通过<code>synchronized</code>加一把锁，访问二级、三级缓存的时候也会通过<code>synchronized</code>加同一把锁。这样当某个线程正在创建Bean的时候，其它线程是不能访问二、三级缓存的，只能访问一级缓存。</li>
<li>做标记：Spring中引入了一个存放<strong>正在创建的Bean</strong>的集合用于限制对二、三级缓存的访问，Bean开始创建时会加入这个集合。从缓存中获取Bean的时候，如果该Bean正在创建，也就是出现在了这个集合中 (说明出现循环依赖)，那么可以从所有缓存中拿，否则只能在一级缓存中拿。</li>
</ol>
<p>这样两点保证了不会出现在非创建阶段从二、三级缓存中获取到不完整Bean的情况。</p>
</blockquote>
<p>引入二级缓存后，锁加在Bean的创建过程，这样加锁<strong>不会影响别的线程从一级缓存中拿成熟的Bean</strong>。这样又解决了多线程下性能和并发安全的问题，完美！那真的一点问题都没有了吗？</p>
<p>如果<strong>存在AOP，需要对Bean进行动态代理</strong>，怎么办？首先考虑一下如果按照我们上面的设计方案，动态代理需要在哪里进行：</p>
<ul>
<li>在Bean初始化完成后代理行吗？<br>不行。因为如果A、B循环依赖，A在初始化完后才动态代理，由于动态代理会生成一个新的对象，那么B注入的将会是没有代理的A。</li>
<li>在Bean实例化之后、加入二级缓存前代理行吗？<br>这样加入二级缓存的就是代理对象，解决了上面一个问题。<strong>最后还需要注意，完成Bean初始化后，将二级缓存中代理过的对象移入一级缓存即可，防止一级缓存中存放的是未代理对象。</strong></li>
</ul>
<p>所以说，在Bean<strong>实例化之后、加入二级缓存前</strong>，如果需要动态代理就进行代理，然后将代理的对象存入二级缓存，这样其实是没问题的。如下图所示：</p>
<p><a target="_blank" rel="noopener" href="https://images.gitee.com/uploads/images/2020/1219/130048_afd90207_8183653.jpeg"><img  
                     lazyload
                     alt="image"
                     data-src="https://images.gitee.com/uploads/images/2020/1219/130048_afd90207_8183653.jpeg"
                      alt="输入图片说明"
                ></a>那为什么要加入三级缓存，三级缓存又是干什么的？</p>
<h3 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h3><p>通过我们上面的分析，二级缓存就可以解决循环依赖、多线程并发和AOP的所有问题。那么Spring引入三级缓存是为了什么？我们来看看三级缓存的里存的是什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 一级缓存 </span></span><br><span class="line"><span class="comment">  * 单例缓存池，用于保存所有成熟的Bean</span></span><br><span class="line"><span class="comment">  * key时Bean的名称，value是Bean实例</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 二级缓存</span></span><br><span class="line"><span class="comment">  * 用户缓存早期对象(对象属性还没有来得及进行赋值)</span></span><br><span class="line"><span class="comment">  * key是Bean的名称，value是Bean实例</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 三级缓存 </span></span><br><span class="line"><span class="comment">  * key是Bean的名，value是一个ObjectFactory</span></span><br><span class="line"><span class="comment">  * ObjectFactory是一个接口，这里存放的是一个接口的实现</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 该集合用户缓存当前正在创建Bean的名称</span></span><br><span class="line"><span class="comment">  * 用于限制对二级、三级缓存的访问：</span></span><br><span class="line"><span class="comment">  * 1. 从缓存拿Bean的时候，如果Bean名称在这个集合中，可以访问所有缓存</span></span><br><span class="line"><span class="comment">  * 2. 如果Bean名称不在这个集合中，只能访问一级缓存</span></span><br><span class="line"><span class="comment">  * 这样设计，防止在非创建阶段访问二三级缓存，从而导致获取到不完整的Bean</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; singletonsCurrentlyInCreation </span><br><span class="line">    = Collections.newSetFromMap(<span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">16</span>));</span><br></pre></td></tr></table></figure>

<p>一级缓存里存的是成熟对象，二级缓存里存的是早期对象，这个我们之前已经介绍过了。而三级缓存中存的是<strong>ObjectFactory</strong>，这是个什么东西？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数式接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ObjectFactory</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 该方法需要返回一个Bean</span></span><br><span class="line">   T <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，它是一个函数式接口，其中的方法是<code>getObject</code>。我们再来看看Spring是如何往三级缓存中添加元素的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// addSingletonFactory方法存入三级缓存：</span></span><br><span class="line"><span class="comment">// 把早期对象包装成一个ObjectFactory的实现存入三级缓存</span></span><br><span class="line"><span class="comment">// 实现方式是通过getEarlyBeanReference方法返回一个早期Bean</span></span><br><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br></pre></td></tr></table></figure>

<p>可以看到，Spring提供了一个新的思路：不往缓存中放对象，而是将对象封装成一个接口的实现，存入三级缓存。那么什么时候放？<strong>实例化完成后，不再向二级缓存中放早期对象，而是将早期对象封装成一个接口的实现存入三级缓存。从三级缓存中拿到这个实现后，通过执行该实现方法拿到早期对象或者【代理对象】，再存入二级缓存。</strong></p>
<p>所以说，动态代理的过程也被封装到ObjectFactory接口的实现中了。最终Spring里真正的流程如下图：</p>
<p><a target="_blank" rel="noopener" href="https://images.gitee.com/uploads/images/2020/1219/162042_4cd06685_8183653.jpeg"><img  
                     lazyload
                     alt="image"
                     data-src="https://images.gitee.com/uploads/images/2020/1219/162042_4cd06685_8183653.jpeg"
                      alt="输入图片说明"
                ></a></p>
<p>可以看到，<strong>三级缓存和二级缓存打了一个配合</strong>：三级缓存接口的实现方法行后得到的对象放入二级缓存。我们可以得到如下结论：</p>
<ul>
<li>一旦某个Bean出现在了二级缓存中，那么这个Bean一定出现了循环依赖。如果某个Bean没有循环依赖，三级缓存中这个Bean封装的方法实现根本不会被执行，因此一定不会出现在二级缓存中。</li>
</ul>
<p>关于之前我们说的动态代理，Spring将其一起封装到了三级缓存中的接口的实现方法中了，所以说，<strong>A的动态代理会先在它循环依赖的B中完成</strong>。但是如果A没有循环依赖怎么办？那A不就不会被动态代理了吗？所以说A初始化完成后还要再动态代理一次。</p>
<blockquote>
<p>介绍完了三级依赖，各位读者觉得三级依赖的作用是什么？</p>
<ul>
<li>更加简洁？并没有更加简洁，反而更加复杂了。</li>
<li>动态代理和创建Bean的过程解耦？并没有解耦，因为初始化完成后还是需要动态代理。</li>
<li>扩展性更强？Spring的Bean的后置处理器似乎和它也没啥关系。</li>
<li>延迟加载？只存接口实现而不存Bean，如果没有循环依赖就不会执行接口的实现。但是迟早要执行，所以也没什么用。</li>
</ul>
<p>那到底有什么用？你觉得有什么用就有什么用。</p>
</blockquote>
<h3 id="流程小结"><a href="#流程小结" class="headerlink" title="流程小结"></a>流程小结</h3><p>假如A、B循环依赖，从A的创建开始，流程如下：</p>
<table>
<thead>
<tr>
<th>阶段</th>
<th>一级缓存</th>
<th>二级缓存</th>
<th>三级缓存</th>
</tr>
</thead>
<tbody><tr>
<td>A开始实例化</td>
<td>空</td>
<td>空</td>
<td>空</td>
</tr>
<tr>
<td>A实例化完成</td>
<td>空</td>
<td>空</td>
<td>A封装的ObjectFactory接口的实现</td>
</tr>
<tr>
<td>A开始属性赋值，发现依赖B</td>
<td>空</td>
<td>空</td>
<td>A封装的ObjectFactory接口的实现</td>
</tr>
<tr>
<td>B开始实例化</td>
<td>空</td>
<td>空</td>
<td>A封装的ObjectFactory接口的实现</td>
</tr>
<tr>
<td>B实例化完成</td>
<td>空</td>
<td>空</td>
<td>A封装的ObjectFactory接口的实现、B封装的ObjectFactory接口的实现</td>
</tr>
<tr>
<td>B开始属性赋值，发现依赖A</td>
<td>空</td>
<td>空</td>
<td>A封装的ObjectFactory接口的实现、B封装的ObjectFactory接口的实现</td>
</tr>
<tr>
<td>从三级缓存中拿到A封装的ObjectFactory接口的实现并且执行</td>
<td>空</td>
<td>早期A（或者动态代理的A）</td>
<td>B封装的ObjectFactory接口的实现</td>
</tr>
<tr>
<td>B完成属性赋值</td>
<td>空</td>
<td>早期A（或者动态代理的A）</td>
<td>B封装的ObjectFactory接口的实现</td>
</tr>
<tr>
<td>B完成初始化</td>
<td>成熟B</td>
<td>早期A（或者动态代理的A）</td>
<td>空</td>
</tr>
<tr>
<td>A完成属性赋值</td>
<td>成熟B</td>
<td>早期A（或者动态代理的A）</td>
<td>空</td>
</tr>
<tr>
<td>A完成初始化</td>
<td>成熟A、成熟B</td>
<td>空</td>
<td>空</td>
</tr>
</tbody></table>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>之前我们已经介绍过了Bean的大致创建流程，从AbstractBeanFactory的<code>getBean</code>方法开始：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">      <span class="comment">// 真正的获取bean的逻辑doGetBean</span></span><br><span class="line">      <span class="keyword">return</span> doGetBean(name, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span><br><span class="line"><span class="params">		<span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, <span class="type">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获得Bean的转换获得Bean的名称，因为传入的可能是工厂Bean的名称</span></span><br><span class="line">	<span class="keyword">final</span> <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> transformedBeanName(name);</span><br><span class="line">	Object bean;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// getSingleton尝试去缓存中获取对象，这个方法非常重要</span></span><br><span class="line">	<span class="type">Object</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sharedInstance != <span class="literal">null</span> &amp;&amp; args == <span class="literal">null</span>) &#123;</span><br><span class="line">	</span><br><span class="line">           ...</span><br><span class="line">               </span><br><span class="line">		<span class="comment">// 如果获取到了，下面的方法处理工厂Bean的情况，之后会直接返回</span></span><br><span class="line">		bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="literal">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 这里可以看出Spring只能解决单例对象的循环依赖，不能解决构多例</span></span><br><span class="line">		<span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 判断AbstractBeanFacotry工厂是否有父工厂</span></span><br><span class="line"><span class="comment">		 * (一般情况下是没有父工厂因为abstractBeanFactory直接是抽象类,不存在父工厂)</span></span><br><span class="line"><span class="comment">		 * 只有和SpringMvc整合的时才会有父子容器的概念，这里不过多介绍</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="type">BeanFactory</span> <span class="variable">parentBeanFactory</span> <span class="operator">=</span> getParentBeanFactory();</span><br><span class="line">		</span><br><span class="line">           ...</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 处理dependsOn的依赖(这个不是我们所谓的循环依赖)</span></span><br><span class="line">			String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">				<span class="keyword">if</span> (dependsOn != <span class="literal">null</span>) &#123;</span><br><span class="line">				</span><br><span class="line">                    ... </span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 创建单例bean</span></span><br><span class="line">			<span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">				<span class="comment">// 调用DefaultSingletonBeanRegistry的getSingleton方法</span></span><br><span class="line">				<span class="comment">// lambda表达式实现了ObjectFactory接口的getObject方法</span></span><br><span class="line">                   <span class="comment">// 将getObject方法方法作为参数传给getSingleton方法</span></span><br><span class="line">				<span class="comment">// 在getSingleton方法中会调用这个getObject方法创建Bean</span></span><br><span class="line">				sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						<span class="comment">// 回调后执行createBean进入创建bean的逻辑</span></span><br><span class="line">						<span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">						<span class="comment">// 创建bean的过程中发生异常,需要销毁关于当前bean的所有信息</span></span><br><span class="line">						destroySingleton(beanName);</span><br><span class="line">						<span class="keyword">throw</span> ex;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">				bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先看看DefaultSingletonBeanRegistry中的<code>getSingleton</code>方法，这个方法是从缓存中获取Bean，非常重要：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">      <span class="comment">// 接着调用</span></span><br><span class="line">      <span class="keyword">return</span> getSingleton(beanName, <span class="literal">true</span>);java</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;</span><br><span class="line">	<span class="comment">// 1. 尝试去一级缓存拿Bean，拿到了就直接返回</span></span><br><span class="line">	<span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 若在一级缓存中没有获取到对象，并且该Bean正在创建(出现了循环依赖)</span></span><br><span class="line"><span class="comment">	 * 如果满足了上面两个条件，才可以去二级、三级缓存中拿</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">           <span class="comment">// 这里加锁了</span></span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">			<span class="comment">// 2.尝试去二级缓存中获取对象(早期对象)</span></span><br><span class="line">			singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">			<span class="comment">// 二级缓存中也没有获取到对象</span></span><br><span class="line">               <span class="comment">// 并且allowEarlyReference为true</span></span><br><span class="line">               <span class="comment">// 3.那么从三级缓存中拿</span></span><br><span class="line">               <span class="comment">// (这个参数是上一个方法传进来的，用于控制对三级缓存的访问)</span></span><br><span class="line">			<span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">				<span class="comment">// 直接从三级缓存中获取ObjectFactory接口的实现</span></span><br><span class="line">				ObjectFactory&lt;?&gt; singletonFactory </span><br><span class="line">                       = <span class="built_in">this</span>.singletonFactories.get(beanName);</span><br><span class="line">				<span class="comment">// 4.如果从三级缓存中获取到对象不为空</span></span><br><span class="line">				<span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">				    <span class="comment">/** 执行实现ObjectFactory接口的getObject方法</span></span><br><span class="line"><span class="comment">					  * 又会调用到getEarlyBeanReference()来进行后置处理</span></span><br><span class="line"><span class="comment">					  * 返回的可能就是原早期对象，或者是一个动态代理后的代理对象</span></span><br><span class="line"><span class="comment">					  */</span></span><br><span class="line">					singletonObject = singletonFactory.getObject();</span><br><span class="line">					<span class="comment">// 把早期对象/或者代理对象放置在二级缓存</span></span><br><span class="line">					<span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">					<span class="comment">// 把包装对象从三级缓存中删除掉</span></span><br><span class="line">					<span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到从缓存中获取Bean的流程和我们之前分析的一样：如果Bean不是正在创建，只能去一级缓存中拿；如果Bean正在创建(出现循环依赖)，可以去所有缓存中去拿。在三级缓存中拿到ObjectFactory接口的实现的方法，执行后，将获取到的对象放入二级缓存。</p>
<p>那如果三级缓存中都没有呢？那就要开始创建Bean了，我们回到DefaultSingletonBeanRegistry中的<code>getSingleton</code>方法，注意这个<code>getSingleton</code>方法和上面的不一样！请看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数singletonFactory是传进来的lambda表达式</span></span><br><span class="line">   <span class="comment">// 它实现了ObjectFactory接口的getObject方法，该方法中会进行回调</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;</span><br><span class="line">      Assert.notNull(beanName, <span class="string">&quot;Bean name must not be null&quot;</span>);</span><br><span class="line">      <span class="comment">// 加锁</span></span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">         <span class="comment">// 尝试从一级缓存中获取对象</span></span><br><span class="line">         <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">         <span class="comment">// 如果没获取到</span></span><br><span class="line">         <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">             </span><br><span class="line">            ...</span><br><span class="line">                </span><br><span class="line">           <span class="comment">/** beforeSingletonCreation方法</span></span><br><span class="line"><span class="comment">             * 标记当前的Bean正在创建，就是将Bean的名称假如singletonsCurrentlyInCreation集合</span></span><br><span class="line"><span class="comment">             * 这里标记后，上面从二级、三级缓存中拿这个对象的条件就满足了</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            beforeSingletonCreation(beanName);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">newSingleton</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">recordSuppressedExceptions</span> <span class="operator">=</span> (<span class="built_in">this</span>.suppressedExceptions == <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">               <span class="built_in">this</span>.suppressedExceptions = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 回调传入的lambda表达式</span></span><br><span class="line">               <span class="comment">// 这个过程其实是调用AbstractAutowireCapableBeanFactory的createBean方法</span></span><br><span class="line">               singletonObject = singletonFactory.getObject();</span><br><span class="line">               newSingleton = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">               ...</span><br><span class="line"></span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                  <span class="built_in">this</span>.suppressedExceptions = <span class="literal">null</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 后置处理</span></span><br><span class="line">               <span class="comment">// 主要做的事情就是把Bean从正在创建的集合中移除</span></span><br><span class="line">               afterSingletonCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">               <span class="comment">// 将Bean加入缓存中</span></span><br><span class="line">               <span class="comment">// 方法的逻辑就是加入一级，并且从二级、三级缓存中移除</span></span><br><span class="line">               addSingleton(beanName, singletonObject);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> singletonObject;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>回调传入的lambda表达式，从而调用AbstractAutowireCapableBeanFactory的<code>createBean</code>方法，我们接着往下走：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">protected</span> Object <span class="title function_">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">         <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         logger.debug(<span class="string">&quot;Creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">RootBeanDefinition</span> <span class="variable">mbdToUse</span> <span class="operator">=</span> mbd;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 确保此时的 bean 已经被解析了</span></span><br><span class="line">      Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">      <span class="keyword">if</span> (resolvedClass != <span class="literal">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="literal">null</span>) &#123;</span><br><span class="line">         mbdToUse = <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(mbd);</span><br><span class="line">         mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Prepare method overrides.</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          </span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 执行第1个bean后置处理器</span></span><br><span class="line">         <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">         <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">               <span class="string">&quot;BeanPostProcessor before instantiation of bean failed&quot;</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// doCreateBean才是真正的创建我们的bean的实例对象的过程</span></span><br><span class="line">         <span class="type">Object</span> <span class="variable">beanInstance</span> <span class="operator">=</span> doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">         <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;    </span><br><span class="line">         ...</span><br><span class="line">   &#125;</span><br><span class="line">       </span><br><span class="line">      </span><br><span class="line">   <span class="comment">// doCreateBean就是真正Bean创建的逻辑</span></span><br><span class="line">   <span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">		<span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// BeanWrapper是对Bean的包装</span></span><br><span class="line">	<span class="type">BeanWrapper</span> <span class="variable">instanceWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">		<span class="comment">// 从没有完成的FactoryBean中移除</span></span><br><span class="line">		instanceWrapper = <span class="built_in">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (instanceWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 1.实例化bean</span></span><br><span class="line">		instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 从beanWrapper中获取早期对象</span></span><br><span class="line">	<span class="keyword">final</span> <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> instanceWrapper.getWrappedInstance();</span><br><span class="line">	Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">	<span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">		mbd.resolvedTargetType = beanType;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">	<span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// 进行后置处理@AutoWired、@Value的注解的预解析</span></span><br><span class="line">				applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">						<span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">			&#125;</span><br><span class="line">			mbd.postProcessed = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 存放到三级缓存中</span></span><br><span class="line"><span class="comment">	 * 条件如下：</span></span><br><span class="line"><span class="comment">	 * 1. 是单例</span></span><br><span class="line"><span class="comment">	 * 2. 该Bean正在创建</span></span><br><span class="line"><span class="comment">	 * 3. allowCircularReferences为true</span></span><br><span class="line"><span class="comment">	 *    可以通过ApplicationContext的setAllowCircularReferences方法对其设置</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">boolean</span> <span class="variable">earlySingletonExposure</span> <span class="operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="built_in">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">			isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">	<span class="comment">// 上述条件满足</span></span><br><span class="line">	<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line">					<span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 2.存入三级缓存的是一个接口的实现</span></span><br><span class="line">		<span class="comment">// 把早期对象包装成一个ObjectFactory接口的实现</span></span><br><span class="line">           <span class="comment">// 实现了getObject方法，该方法内部调用getEarlyBeanReference方法</span></span><br><span class="line">		addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize the bean instance.</span></span><br><span class="line">	<span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 3.属性赋值，这里会涉及到循环依赖</span></span><br><span class="line">		populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">		<span class="comment">// 4.进行对象初始化操作(在这里可能生成代理对象)</span></span><br><span class="line">		exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">			<span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">					mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 是早期对象暴露</span></span><br><span class="line">	<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">		<span class="comment">// 去缓存中获取到我们的对象，由于传递的allowEarlyReference是false </span></span><br><span class="line">	    <span class="comment">// 只能在一级二级缓存中去获取</span></span><br><span class="line">		<span class="type">Object</span> <span class="variable">earlySingletonReference</span> <span class="operator">=</span> getSingleton(beanName, <span class="literal">false</span>);</span><br><span class="line">		<span class="comment">// 能够获取到,说明出现了循环依赖</span></span><br><span class="line">		<span class="keyword">if</span> (earlySingletonReference != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 经过后置处理初始化后的Bean和早期的Bean引用还相等的话</span></span><br><span class="line">               <span class="comment">// 表示当前的Bean没有代理，用从二级缓存中获取到Bean的覆盖当前Bean</span></span><br><span class="line">			<span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">				exposedObject = earlySingletonReference;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 处理依赖的Bean</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">				...</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register bean as disposable.</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 注册销毁的Bean的销毁接口</span></span><br><span class="line">		registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">				mbd.getResourceDescription(), beanName, <span class="string">&quot;Invalid destruction signature&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，Bean就创建完成了，最终会放入一级缓存中。在这个过程中，有几点需要说明：</p>
<ol>
<li>构造方法中的循环依赖无法解决，因为构造完后Bean才被封装放入三级缓存(&#96;&#96;)</li>
<li>多例的Bean是不会存在缓存中的，也无法解决循环依赖</li>
<li>工厂方法和@Bean标注的方法(@Bean标注的方法也是工厂方法)也无法解决循环依赖</li>
<li>setter方法注入(&#96;&#96;)和@Autowired可以解决循环依赖，因为实例化之后才执行setter方法和@Autowired注入</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><a target="_blank" rel="noopener" href="https://images.gitee.com/uploads/images/2020/1224/165929_56e3d91d_8183653.jpeg"><img  
                     lazyload
                     alt="image"
                     data-src="https://images.gitee.com/uploads/images/2020/1224/165929_56e3d91d_8183653.jpeg"
                      alt="输入图片说明"
                ></a></p>
<hr>
<p>看不下去了 等过段事件再看spring</p>
<p>2021.6.1</p>

            </div>

            
                <div class="post-copyright-info">
                    
<div class="article-copyright-info-container">
    <ul class="copyright-info-content">
        <li class="post-title">
            <span class="type">本文标题</span>：<span class="content">Spring 究极解析</span>
        </li>
        <li class="post-author">
            <span class="type">本文作者</span>：<span class="content">liduoan.efls</span>
        </li>
        <li class="post-time">
            <span class="type">创建时间</span>：<span class="content">2021-05-07 19:40:26</span>
        </li>
        <li class="post-link">
            <span class="type">本文链接</span>：<span class="content">2021/05/07/2021/Spring-究极解析/</span>
        </li>
        <li class="post-license">
            <span class="type">版权声明</span>：<span class="content">本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！</span>
        </li>
    </ul>
    <div class="copy-copyright-info flex-center tooltip" data-content="复制版权信息" data-offset-y="-2px">
        <i class="fa-solid fa-copy"></i>
    </div>
</div>

                </div>
            

            
                <ul class="post-tags-box">
                    
                        <li class="tag-item">
                            <a href="/tags/2021/">#2021</a>&nbsp;
                        </li>
                    
                </ul>
            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                               rel="prev"
                               href="/2021/05/17/2021/SpringMvc%E7%A9%B6%E6%9E%81%E8%A7%A3%E6%9E%90/"
                            >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                                <span class="title flex-center">
                                <span class="post-nav-title-item">SpringMvc究极解析</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                               rel="next"
                               href="/2021/05/03/2021/CountDownLatch-Semaphore/"
                            >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">CountDownLatch&amp;Semaphore</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                                <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                            </a>
                        </div>
                    
                </div>
            

            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">Spring体系架构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SpringIOC%E6%BA%90%E7%A0%81%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">SpringIOC源码整体流程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">2.1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IOC%E7%9A%84%E5%A4%A7%E8%87%B4%E6%B5%81%E7%A8%8B"><span class="nav-number">2.2.</span> <span class="nav-text">IOC的大致流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BeanDefinition"><span class="nav-number">2.2.1.</span> <span class="nav-text">BeanDefinition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ApplicationContext%E5%92%8CBeanFactory"><span class="nav-number">2.2.2.</span> <span class="nav-text">ApplicationContext和BeanFactory</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">2.3.</span> <span class="nav-text">源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ApplicationContext%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">2.3.1.</span> <span class="nav-text">ApplicationContext的初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#BeanDefinitionReader%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">BeanDefinitionReader初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BeanDefinitionScanner%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">2.3.1.2.</span> <span class="nav-text">BeanDefinitionScanner的初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#register-annotatedClasses"><span class="nav-number">2.3.1.3.</span> <span class="nav-text">register(annotatedClasses)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Refresh"><span class="nav-number">2.3.1.4.</span> <span class="nav-text">Refresh</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bean%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">2.3.2.</span> <span class="nav-text">Bean的创建</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">准备工作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#FactoryBean%E5%92%8CBeanFactory"><span class="nav-number">2.3.2.1.1.</span> <span class="nav-text">FactoryBean和BeanFactory</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AD%A3%E5%BC%8F%E5%BC%80%E5%A7%8B"><span class="nav-number">2.3.2.1.2.</span> <span class="nav-text">正式开始</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8%E8%A7%A3%E6%9E%90"><span class="nav-number">3.</span> <span class="nav-text">后置处理器解析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8EXML%E7%9A%84%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="nav-number">3.1.</span> <span class="nav-text">基于XML的解析过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="nav-number">3.2.</span> <span class="nav-text">基于注解的解析过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BeanFactory%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8"><span class="nav-number">3.2.1.</span> <span class="nav-text">BeanFactory后置处理器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-number">3.2.2.</span> <span class="nav-text">后置处理器的执行顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90%E9%85%8D%E7%BD%AE%E7%B1%BB"><span class="nav-number">3.2.3.</span> <span class="nav-text">解析配置类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ComponentScan%E7%9A%84%E8%A7%A3%E6%9E%90"><span class="nav-number">3.2.3.1.</span> <span class="nav-text">@ComponentScan的解析</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E8%A7%A3%E5%86%B3"><span class="nav-number">4.</span> <span class="nav-text">循环依赖解决</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="nav-number">4.1.</span> <span class="nav-text">什么是循环依赖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E4%B8%AA%E7%BC%93%E5%AD%98"><span class="nav-number">4.2.</span> <span class="nav-text">三个缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="nav-number">4.2.1.</span> <span class="nav-text">一级缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="nav-number">4.2.2.</span> <span class="nav-text">二级缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="nav-number">4.2.3.</span> <span class="nav-text">三级缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B%E5%B0%8F%E7%BB%93"><span class="nav-number">4.2.4.</span> <span class="nav-text">流程小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="nav-number">4.3.</span> <span class="nav-text">源码解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">4.4.</span> <span class="nav-text">总结</span></a></li></ol></li></ol>
    </div>
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            
<footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
                <span>2020</span> -
            
            2023
            
                &nbsp;<i class="fas fa-heart icon-animate"></i>
                &nbsp;<a href="/">liduoan.efls</a>
            
        </div>
        
            <script async data-pjax
                    src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                
                
                    总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.6.1</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item flex-center toggle-show-toc">
                <i class="fas fa-list"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="close-popup-btn">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/dark-light-toggle.js"></script>




    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/code-block.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/lazyload.js"></script>


<div class="post-scripts pjax">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/post-helper.js"></script>
        
            <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/libs/anime.min.js"></script>
        
        
            <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/toc.js"></script>
        
    
</div>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
