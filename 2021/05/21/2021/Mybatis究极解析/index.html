<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="liduoan.efls">
    
    <title>
        
            Mybatis究极解析 |
        
        liduoan修炼笔记
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="https://i.postimg.cc/MpmSbVgT/4-U-3-AU-6-0-R8-L6-K5658-H.jpg">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/fontawesome.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/regular.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/solid.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/brands.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"zh-CN","path":"search.xml"}
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066cc","logo":"https://i.postimg.cc/MpmSbVgT/4-U-3-AU-6-0-R8-L6-K5658-H.jpg","favicon":"https://i.postimg.cc/MpmSbVgT/4-U-3-AU-6-0-R8-L6-K5658-H.jpg","avatar":"https://i.postimg.cc/MpmSbVgT/4-U-3-AU-6-0-R8-L6-K5658-H.jpg","font_size":null,"font_family":"STSong","hover":{"shadow":true,"scale":false},"first_screen":{"enable":true,"header_transparent":true,"background_img":"/images/bg.svg","description":"世之奇伟、瑰怪，非常之观，常在于险远 || 而人之所罕至焉，故非有志者不能至也","font_color":null,"hitokoto":false},"scroll":{"progress_bar":true,"percent":false}},"local_search":{"enable":true,"preload":true},"code_copy":{},"code_block":{"tools":{"enable":true,"style":"default"},"highlight_theme":"default"},"side_tools":{},"pjax":{"enable":true},"lazyload":{"enable":true},"comment":{"enable":false,"use":"valine","valine":{"appid":null,"appkey":null,"server_urls":null,"placeholder":null},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.8"},"waline":{"server_url":null,"reaction":false,"version":2}},"post":{"author_label":{"enable":true,"auto":true,"custom_label_list":["Trainee","Engineer","Architect"]},"word_count":{"enable":true,"wordcount":true,"min2read":true},"img_align":"left","copyright_info":true},"version":"3.6.1"}
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"}
    KEEP.language_code_block = {"copy":"复制代码","copied":"已复制","fold":"折叠代码块","folded":"已折叠"}
    KEEP.language_copy_copyright = {"copy":"复制版权信息","copied":"已复制","title":"原文标题","author":"原文作者","link":"原文链接"}
  </script>
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
                <a class="logo-image" href="/">
                    <img src="https://i.postimg.cc/MpmSbVgT/4-U-3-AU-6-0-R8-L6-K5658-H.jpg">
                </a>
            
            <a class="logo-title" href="/">
               liduoan修炼笔记
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            <div class="article-title">
                <span class="title-hover-animation">Mybatis究极解析</span>
            </div>

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="https://i.postimg.cc/MpmSbVgT/4-U-3-AU-6-0-R8-L6-K5658-H.jpg">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">liduoan.efls</span>
                            
                                <span class="author-label">Lv4</span>
                            
                        </div>
                        <div class="meta-info">
                            
<div class="article-meta-info">
    <span class="article-date article-meta-item">
        
            <i class="fa-regular fa-calendar-plus"></i>&nbsp;
        
        <span class="pc">2021-05-21 15:39:28</span>
        <span class="mobile">2021-05-21 15:39</span>
    </span>
    
        <span class="article-update-date article-meta-item">
        <i class="fas fa-file-pen"></i>&nbsp;
        <span class="pc">2023-01-14 23:05:05</span>
    </span>
    
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/2021/">2021</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>9.4k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>42 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content keep-markdown-body">
                

                <span id="more"></span>

<h1 id="Mybatis回顾"><a href="#Mybatis回顾" class="headerlink" title="Mybatis回顾"></a>Mybatis回顾</h1><p>MyBatis是一个持久层（ORM）框架，使用简单，学习成本较低。可以执行自己手写的SQL语句，比较灵活。但</p>
<p>是MyBatis的自动化程度不高，移植性也不高，有时从一个数据库迁移到另外一个数据库的时候需要自己修改配</p>
<p>置，所以称只为半自动ORM框架。<a class="link"   target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/configuration.html" >官方文档链接<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="传统JDBC和Mybatis相比的弊病"><a href="#传统JDBC和Mybatis相比的弊病" class="headerlink" title="传统JDBC和Mybatis相比的弊病"></a>传统JDBC和Mybatis相比的弊病</h2><p><strong>传统的JDBC的操作过程大致分为如下几步：</strong></p>
<ol>
<li>通过<code>Class.forName()</code>加载驱动</li>
<li>通过<code>DriverManager.getConnection()</code>创建连接</li>
<li>获取sql执行者<code>prepareStatement</code>并且通过其<code>execute</code>执行sql</li>
<li>通过sql执行者的<code>getResultSet</code>方法获取结果集<code>ResultSet</code>进行解析</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost/liduoan&quot;</span>,</span><br><span class="line">                                                      <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> statement.executeQuery(<span class="string">&quot;select * from user&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取驱动—创建连接—执行SQL—获取结果集</p>
<p>上述也称之为四大组件</p>
<p><strong>传统JDBC的问题如下：</strong></p>
<ul>
<li>数据库连接创建、释放频繁造成资源浪费，从而影响系统性能，使用数据库连接池可以解决问题。</li>
<li>sql语句在java代码中硬编码，实际应用中sql的变化可能较大，造成代码维护不方便。</li>
<li>使用<code>preparedStatement</code>向有占位符传递参数存在硬编码问题，因为sql中的where子句的条件不确定，</li>
</ul>
<p>同样是修改不方便。</p>
<ul>
<li>对结果集中解析存在硬编码问题，sql的变化导致解析代码的变化，系统维护不方便。</li>
</ul>
<p><strong>mybatis对传统JDBC的解决方案</strong></p>
<ul>
<li>在mybatis配置文件<code>SqlMapConfig.xml</code>中配置数据连接池，使用连接池管理数据库链接。</li>
<li>将Sql语句配置在<strong>映射配置文件</strong>中与java代码分离。</li>
<li>Mybatis自动将java对象映射至sql语句，通过statement中的<code>parameterType</code>定义输入参数的类型。</li>
<li>Mybatis自动将sql执行结果映射至java对象，通过statement中的<code>resultType</code>定义输出结果的类型。</li>
</ul>
<h2 id="Mybatis使用"><a href="#Mybatis使用" class="headerlink" title="Mybatis使用"></a>Mybatis使用</h2><p><a class="link"   target="_blank" rel="noopener" href="https://liduoan.github.io/2021/03/19/Mybatis/" >具体看这篇博客<i class="fas fa-external-link-alt"></i></a></p>
<h1 id="Mybatis源码分析"><a href="#Mybatis源码分析" class="headerlink" title="Mybatis源码分析"></a>Mybatis源码分析</h1><h2 id="解析配置文件"><a href="#解析配置文件" class="headerlink" title="解析配置文件"></a>解析配置文件</h2><p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/22/xfLTbFH8zm5IuAC.jpg"
                      alt="Screenshot_90.jpg"
                ></p>
<p>我们知晓使用Mybatis的时候时先从以下两句代码开始的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将mybatis配置文件读取至流中</span></span><br><span class="line"><span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> Resources.getResourceAsReader(resource);</span><br><span class="line"><span class="comment">// 通过SqlSessionFactoryBuilder的build方法构建SqlSessionFactory工厂</span></span><br><span class="line"><span class="comment">// 这里会解析mybatis配置文件</span></span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(reader);</span><br></pre></td></tr></table></figure>

<p>我们看到先获取一个读取器，然后委托给<code>SqlSessionFactoryBuilder()</code>来执行<code>build</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlSessionFactoryBuilder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一步</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(Reader reader)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> build(reader, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第二步</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(Reader reader, String environment, Properties properties)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建一个XMLConfigBuilder，用于解析mybatis的全局配置文件</span></span><br><span class="line">            <span class="type">XMLConfigBuilder</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLConfigBuilder</span>(reader, environment, properties);</span><br><span class="line">  		    <span class="comment">// 通过XMLConfigBuilder的parse方法进行解析</span></span><br><span class="line">      		<span class="comment">// 解析完成后得到一个Configuration对象，接着调用build方法</span></span><br><span class="line">            <span class="comment">// 这里返回Configuration 再来个build()</span></span><br><span class="line">            <span class="keyword">return</span> build(parser.parse());</span><br><span class="line">        &#125;..</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                ...</span><br><span class="line">                    reader.close();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第三步  </span></span><br><span class="line">    <span class="comment">// 到这里配置文件已经解析成了Configuration</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(Configuration config)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultSqlSessionFactory</span>(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要就是解析Mybatis的配置文件到一个Configuration对象中，然后就返回一个SqlSessionFactory对象。</p>
<h3 id="XMLConfigBuilder"><a href="#XMLConfigBuilder" class="headerlink" title="XMLConfigBuilder"></a>XMLConfigBuilder</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">XMLConfigBuilder</span><span class="params">(Reader reader, String environment, Properties props)</span> &#123;</span><br><span class="line">    <span class="comment">//调用自己的方法,new了一个XPathParser  XMLMapperEntityResolver</span></span><br><span class="line">    <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">XPathParser</span>(reader, <span class="literal">true</span>, props, <span class="keyword">new</span> <span class="title class_">XMLMapperEntityResolver</span>()), environment, props);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">XMLConfigBuilder</span><span class="params">(XPathParser parser, String environment, Properties props)</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用父类的BaseBuilder的构造方法:给</span></span><br><span class="line"><span class="comment">     * configuration赋值</span></span><br><span class="line"><span class="comment">     * typeAliasRegistry别名注册器赋值</span></span><br><span class="line"><span class="comment">     * TypeHandlerRegistry赋值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">Configuration</span>());</span><br><span class="line">    ErrorContext.instance().resource(<span class="string">&quot;SQL Mapper Configuration&quot;</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把props绑定到configuration的props属性上</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">this</span>.configuration.setVariables(props);</span><br><span class="line">    <span class="built_in">this</span>.parsed = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">this</span>.environment = environment;</span><br><span class="line">    <span class="built_in">this</span>.parser = parser;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Configuration <span class="title function_">parse</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 若已经解析过了 就抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (parsed) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Each XMLConfigBuilder can only be used once.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置解析标志位</span></span><br><span class="line">    parsed = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析我们的mybatis-config.xml的</span></span><br><span class="line"><span class="comment">     * 节点</span></span><br><span class="line"><span class="comment">     * &lt;configuration&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;/configuration&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    parseConfiguration(parser.evalNode(<span class="string">&quot;/configuration&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> configuration;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析全局配置文件</span></span><br><span class="line"><span class="comment">// 传入的参数是&lt;configuration&gt;根节点，所有节点都会被XNode对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseConfiguration</span><span class="params">(XNode root)</span> &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 解析&lt;properties&gt;节点</span></span><br><span class="line"><span class="comment">      * 解析到Configuration的variables属性中</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     propertiesElement(root.evalNode(<span class="string">&quot;properties&quot;</span>));</span><br><span class="line">       </span><br><span class="line">     <span class="comment">// 解析&lt;settings&gt;节点</span></span><br><span class="line">     <span class="type">Properties</span> <span class="variable">settings</span> <span class="operator">=</span> settingsAsProperties(root.evalNode(<span class="string">&quot;settings&quot;</span>));</span><br><span class="line">       </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 解析VFS基本没有用过该属性：</span></span><br><span class="line"><span class="comment">      * VFS含义是虚拟文件系统，主要是通过程序能够方便读取本地文件系统、FTP文件系统等系统中的文件资源。</span></span><br><span class="line"><span class="comment">      * Mybatis中提供了VFS这个配置，主要是通过该配置可以加载自定义的虚拟文件系统应用程序。</span></span><br><span class="line"><span class="comment">      * 解析到Configuration的vfsImpl属性中</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     loadCustomVfs(settings);</span><br><span class="line">       </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 解析 MyBatis 所用日志的具体实现，未指定时将自动查找。</span></span><br><span class="line"><span class="comment">      * SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING |</span></span><br><span class="line"><span class="comment">        STDOUT_LOGGING | NO_LOGGING</span></span><br><span class="line"><span class="comment">      * 解析到Configuration的logImpl属性中</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     loadCustomLogImpl(settings);</span><br><span class="line">       </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 解析别名</span></span><br><span class="line"><span class="comment">      * 解析到Configuration的typeAliasRegistry.typeAliases属性中</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     typeAliasesElement(root.evalNode(<span class="string">&quot;typeAliases&quot;</span>));</span><br><span class="line">       </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 解析插件(比如分页插件)</span></span><br><span class="line"><span class="comment">      * mybatis自带的四个Executor、ParameterHandler、ResultSetHandler、StatementHandler </span></span><br><span class="line"><span class="comment">      * 解析到Configuration的interceptorChain.interceptors属性中</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     pluginElement(root.evalNode(<span class="string">&quot;plugins&quot;</span>));</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 解析对象工厂</span></span><br><span class="line">     objectFactoryElement(root.evalNode(<span class="string">&quot;objectFactory&quot;</span>));</span><br><span class="line">     objectWrapperFactoryElement(root.evalNode(<span class="string">&quot;objectWrapperFactory&quot;</span>));</span><br><span class="line">     reflectorFactoryElement(root.evalNode(<span class="string">&quot;reflectorFactory&quot;</span>));</span><br><span class="line">     <span class="comment">// 设置settings和默认值</span></span><br><span class="line">     <span class="comment">// 这个方法里可以看到所有的settings选项和默认值</span></span><br><span class="line">     settingsElement(settings);</span><br><span class="line">       </span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 解析mybatis环境environments</span></span><br><span class="line"><span class="comment">      * 解析到Configuration的environment属性中</span></span><br><span class="line"><span class="comment">      * 在集成spring情况下由spring-mybatis提供数据源和事务工厂</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     environmentsElement(root.evalNode(<span class="string">&quot;environments&quot;</span>));</span><br><span class="line">       </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 解析数据库厂商databaseIdProvider</span></span><br><span class="line"><span class="comment">      * 解析到Configuration的databaseId属性中</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     databaseIdProviderElement(root.evalNode(<span class="string">&quot;databaseIdProvider&quot;</span>));</span><br><span class="line">       </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 解析类型处理器节点typeHandlers</span></span><br><span class="line"><span class="comment">      * 解析到Configuration的typeHandlerRegistry.typeHandlerMap属性中</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     typeHandlerElement(root.evalNode(<span class="string">&quot;typeHandlers&quot;</span>));</span><br><span class="line">       </span><br><span class="line">     <span class="comment">// 解析&lt;mappers&gt;节点，最重要</span></span><br><span class="line">     mapperElement(root.evalNode(<span class="string">&quot;mappers&quot;</span>));</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Error parsing SQL Mapper Configuration. Cause: &quot;</span> + e, e);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>解析的流程就是按照我们全局配置文件的结构来的，其中最重要的就是解析<code>mappers</code>节点下的sql映射文件</p>
<h3 id="解析插件"><a href="#解析插件" class="headerlink" title="解析插件"></a>解析插件</h3><p>插件的解析在<code>parseConfiguration</code>方法的<code>pluginElement</code>中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数传入的时&lt;plugins&gt;标签封装的XNode节点</span></span><br><span class="line"><span class="comment">// pluginElement(root.evalNode(&quot;plugins&quot;));</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pluginElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//开始看子节点</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         &lt;plugins&gt;</span></span><br><span class="line"><span class="comment">        	&lt;plugin interceptor=&quot;&quot;&gt;&lt;/plugin&gt;</span></span><br><span class="line"><span class="comment">   		 &lt;/plugins&gt;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;	</span><br><span class="line">            <span class="type">String</span> <span class="variable">interceptor</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;interceptor&quot;</span>);</span><br><span class="line">            <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> child.getChildrenAsProperties();</span><br><span class="line">            <span class="comment">// 将interceptor指定的类进行实例化，得到一个Interceptor拦截器对象</span></span><br><span class="line">            <span class="type">Interceptor</span> <span class="variable">interceptorInstance</span> <span class="operator">=</span> (Interceptor) resolveClass(interceptor).getDeclaredConstructor().newInstance();</span><br><span class="line">            interceptorInstance.setProperties(properties);</span><br><span class="line">            <span class="comment">// 将拦截器添加到configuration中</span></span><br><span class="line">            configuration.addInterceptor(interceptorInstance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插件的解析过程很简单，就是将其解析为拦截器Interceptor对象后存入Configuration中。</p>
<h3 id="解析Mapper映射文件"><a href="#解析Mapper映射文件" class="headerlink" title="解析Mapper映射文件"></a>解析Mapper映射文件</h3><p>映射文件的解析在XMLConfigBuilder类的<code>mapperElement</code>方法里</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mapperElement(root.evalNode(&quot;mappers&quot;));</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mapperElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 获取我们mappers节点下的一个一个的mapper节点</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">        <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 判断我们mapper是不是通过批量注册的</span></span><br><span class="line"><span class="comment">         * &lt;package name=&quot;com.tuling.mapper&quot;&gt;&lt;/package&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;package&quot;</span>.equals(child.getName())) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">mapperPackage</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                configuration.addMappers(mapperPackage);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">/**</span></span><br><span class="line"><span class="comment">               * 判断从classpath下读取我们的mapper</span></span><br><span class="line"><span class="comment">               * &lt;mapper resource=&quot;mybatis/mapper/EmployeeMapper.xml&quot;/&gt;</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;resource&quot;</span>);</span><br><span class="line">               <span class="comment">/**</span></span><br><span class="line"><span class="comment">               * 判断是不是从我们的网络资源读取(或者本地磁盘得)</span></span><br><span class="line"><span class="comment">               * &lt;mapper url=&quot;D:/mapper/EmployeeMapper.xml&quot;/&gt;</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">               <span class="comment">/**</span></span><br><span class="line"><span class="comment">               * 解析这种类型(要求接口和xml在同一个包下)</span></span><br><span class="line"><span class="comment">               * &lt;mapper class=&quot;com.tuling.mapper.DeptMapper&quot;&gt;&lt;/mapper&gt;</span></span><br><span class="line"><span class="comment">               *</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">mapperClass</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;class&quot;</span>);</span><br><span class="line"></span><br><span class="line">               <span class="comment">/**</span></span><br><span class="line"><span class="comment">               * 我们得mappers节点只配置了</span></span><br><span class="line"><span class="comment">               * &lt;mapper resource=&quot;mybatis/mapper/EmployeeMapper.xml&quot;/&gt;</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">                <span class="keyword">if</span> (resource != <span class="literal">null</span> &amp;&amp; url == <span class="literal">null</span> &amp;&amp; mapperClass == <span class="literal">null</span>) &#123;</span><br><span class="line">                    ErrorContext.instance().resource(resource);</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 把我们的文件读取出一个流</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 创建读取XmlMapper构建器对象,用于来解析我们的mapper.xml文件</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="type">XMLMapperBuilder</span> <span class="variable">mapperParser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLMapperBuilder</span>(inputStream, configuration, resource, configuration.getSqlFragments());</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 真正的解析我们的mapper.xml配置文件(说白了就是来解析我们的sql)</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    mapperParser.parse();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="literal">null</span> &amp;&amp; url != <span class="literal">null</span> &amp;&amp; mapperClass == <span class="literal">null</span>) &#123;</span><br><span class="line">                    ErrorContext.instance().resource(url);</span><br><span class="line">                    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getUrlAsStream(url);</span><br><span class="line">                    <span class="type">XMLMapperBuilder</span> <span class="variable">mapperParser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLMapperBuilder</span>(inputStream, configuration, url, configuration.getSqlFragments());</span><br><span class="line">                    mapperParser.parse();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="literal">null</span> &amp;&amp; url == <span class="literal">null</span> &amp;&amp; mapperClass != <span class="literal">null</span>) &#123;</span><br><span class="line">                    Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);</span><br><span class="line">                    configuration.addMapper(mapperInterface);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;A mapper element may only specify a url, resource or class, but not more than one.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这里我们可以看到Mapper的四种配置方式：</p>
<p>1、<code>&lt;package name=&quot;com.tuling.mapper&quot;&gt;&lt;/package&gt;</code>   批量加载mapper 直接扫描包</p>
<p>2、<code>&lt;mapper resource=&quot;mybatis/mapper/EmployeeMapper.xml&quot;/&gt;</code>  从classpath下读取我们的mapper</p>
<p>3、<code>&lt;mapper url=&quot;D:/mapper/EmployeeMapper.xml&quot;/&gt;</code>        从我们的网络资源读取(或者本地磁盘得)</p>
<p>4、<code>&lt;mapper class=&quot;com.tuling.mapper.DeptMapper&quot;&gt;&lt;/mapper&gt;</code>  解析这种类型(要求接口和xml在同一个包下)</p>
<p>简述下，分别是批量加载，classpath路径下，URL获取，同位置包</p>
<p>我们看到最后是调用<code>XMLMapperBuilder.parse()</code>方法</p>
<p>它是解析的Mapper文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.tuling.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span> &gt;</span><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- Mybatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;result&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.tuling.entity.User&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;BIGINT&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;user_name&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userName&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;create_time&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;DATE&quot;</span> <span class="attr">property</span>=<span class="string">&quot;createTime&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectById&quot;</span>  <span class="attr">resultMap</span>=<span class="string">&quot;result&quot;</span>     &gt;</span></span><br><span class="line">        select id,user_name,create_time from t_user where id=$&#123;param1&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;param1&gt;0&quot;</span>&gt;</span></span><br><span class="line">               and id=#&#123;param1&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们进入源码分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 判断当前的Mapper是否被加载过</span></span><br><span class="line">    <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">        <span class="comment">// 通过configurationElement解析映射文件</span></span><br><span class="line">        <span class="comment">// 传入根节点&lt;mapper&gt;封装成的XNode对象</span></span><br><span class="line">        configurationElement(parser.evalNode(<span class="string">&quot;/mapper&quot;</span>));</span><br><span class="line">        <span class="comment">// 把资源保存到Configuration对象中</span></span><br><span class="line">        configuration.addLoadedResource(resource);</span><br><span class="line">        bindMapperForNamespace();</span><br><span class="line">    &#125;</span><br><span class="line">    parsePendingResultMaps();</span><br><span class="line">    parsePendingCacheRefs();</span><br><span class="line">    parsePendingStatements();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解析对应mapper节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">configurationElement</span><span class="params">(XNode context)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//解析我们的namespace属性</span></span><br><span class="line">        <span class="comment">//&lt;mapper namespace=&quot;com.tuling.mapper.EmployeeMapper&quot;&gt;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">namespace</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;namespace&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (namespace == <span class="literal">null</span> || namespace.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Mapper&#x27;s namespace cannot be empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//保存我们当前的namespace  并且判断接口完全类名==namespace</span></span><br><span class="line">        builderAssistant.setCurrentNamespace(namespace);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 解析我们的缓存引用</span></span><br><span class="line"><span class="comment">        * 说明我当前的缓存引用和DeptMapper的缓存引用一致</span></span><br><span class="line"><span class="comment">        * &lt;cache-ref namespace=&quot;com.tuling.mapper.DeptMapper&quot;&gt;&lt;/cache-ref&gt;</span></span><br><span class="line"><span class="comment">        解析到org.apache.ibatis.session.Configuration#cacheRefMap</span></span><br><span class="line"><span class="comment">        &lt;当前namespace,ref-namespace&gt;</span></span><br><span class="line"><span class="comment">        异常下（引用缓存未使用缓存）:</span></span><br><span class="line"><span class="comment">        org.apache.ibatis.session.Configuration#incompleteCacheRefs</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//解析缓存引用</span></span><br><span class="line">        cacheRefElement(context.evalNode(<span class="string">&quot;cache-ref&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 解析我们的cache节点</span></span><br><span class="line"><span class="comment">        * &lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;&gt;&lt;/cache&gt;</span></span><br><span class="line"><span class="comment">        解析到：org.apache.ibatis.session.Configuration#caches</span></span><br><span class="line"><span class="comment">        org.apache.ibatis.builder.MapperBuilderAssistant#currentCache</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//解析缓存</span></span><br><span class="line">        cacheElement(context.evalNode(<span class="string">&quot;cache&quot;</span>));</span><br><span class="line">      </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 解析paramterMap节点(该节点mybaits3.5貌似不推荐使用了)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        parameterMapElement(context.evalNodes(<span class="string">&quot;/mapper/parameterMap&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 解析我们的resultMap节点</span></span><br><span class="line"><span class="comment">        * 解析到：org.apache.ibatis.session.Configuration#resultMaps</span></span><br><span class="line"><span class="comment">        *    异常 org.apache.ibatis.session.Configuration#incompleteResultMaps</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        resultMapElements(context.evalNodes(<span class="string">&quot;/mapper/resultMap&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 解析我们通过sql节点</span></span><br><span class="line"><span class="comment">        *  解析到org.apache.ibatis.builder.xml.XMLMapperBuilder#sqlFragments</span></span><br><span class="line"><span class="comment">        *   其实等于 org.apache.ibatis.session.Configuration#sqlFragments</span></span><br><span class="line"><span class="comment">        *   因为他们是同一引用，在构建XMLMapperBuilder 时把Configuration.getSqlFragments传进去了</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        sqlElement(context.evalNodes(<span class="string">&quot;/mapper/sql&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 解析我们的select | insert |update |delete节点</span></span><br><span class="line"><span class="comment">        * 解析到org.apache.ibatis.session.Configuration#mappedStatements</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// 猜测|在内部被认为是或语义</span></span><br><span class="line">        <span class="comment">// 解析select等节点</span></span><br><span class="line">        buildStatementFromContext(context.evalNodes(<span class="string">&quot;select|insert|update|delete&quot;</span>));</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Error parsing Mapper XML. The XML location is &#x27;&quot;</span> + resource + <span class="string">&quot;&#x27;. Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;、</span><br></pre></td></tr></table></figure>

<p>我们关注一下两个方法：二级缓存和解析Sql</p>
<h4 id="解析二级缓存"><a href="#解析二级缓存" class="headerlink" title="解析二级缓存"></a>解析二级缓存</h4><p>一级缓存是基于会话的，二级缓存是基于Mapper，或者说命名空间的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cacheElement(context.evalNode(&quot;cache&quot;));</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cacheElement</span><span class="params">(XNode context)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (context != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 解析cache节点的type属性</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;PERPETUAL&quot;</span>);</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Cache</span>&gt; typeClass = typeAliasRegistry.resolveAlias(type);</span><br><span class="line">    <span class="comment">// 获取缓存过期策略eviction属性,默认是LRU</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">eviction</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;eviction&quot;</span>, <span class="string">&quot;LRU&quot;</span>);</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Cache</span>&gt; evictionClass = typeAliasRegistry.resolveAlias(eviction);</span><br><span class="line">    <span class="comment">// 获取刷新间隔flushInterval</span></span><br><span class="line">    <span class="comment">// 属性可以被设置为任意的正整数，设置的值应该是一个以毫秒为单位的合理时间量</span></span><br><span class="line">    <span class="comment">// 默认情况是不设置，也就是没有刷新间隔，缓存仅仅会在调用语句时刷新</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">flushInterval</span> <span class="operator">=</span> context.getLongAttribute(<span class="string">&quot;flushInterval&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取缓存数量size</span></span><br><span class="line">    <span class="comment">// 属性可以被设置为任意正整数，要注意欲缓存对象的大小和运行环境中可用的内存资源，默认值是1024</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">size</span> <span class="operator">=</span> context.getIntAttribute(<span class="string">&quot;size&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取只读readonly，默认为false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">readWrite</span> <span class="operator">=</span> !context.getBooleanAttribute(<span class="string">&quot;readOnly&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">blocking</span> <span class="operator">=</span> context.getBooleanAttribute(<span class="string">&quot;blocking&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> context.getChildrenAsProperties();</span><br><span class="line">    <span class="comment">// 调用MapperBuilderAssistant的useNewCache方法</span></span><br><span class="line">    <span class="comment">// 创建一个新的缓存，并且把存节点加入到Configuration中</span></span><br><span class="line">    builderAssistant.useNewCache(typeClass, evictionClass, flushInterval, size, readWrite, blocking, props);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Cache <span class="title function_">useNewCache</span><span class="params">(Class&lt;? extends Cache&gt; typeClass,</span></span><br><span class="line"><span class="params">      Class&lt;? extends Cache&gt; evictionClass,</span></span><br><span class="line"><span class="params">      Long flushInterval,</span></span><br><span class="line"><span class="params">      Integer size,</span></span><br><span class="line"><span class="params">      <span class="type">boolean</span> readWrite,</span></span><br><span class="line"><span class="params">      <span class="type">boolean</span> blocking,</span></span><br><span class="line"><span class="params">      Properties props)</span> &#123;</span><br><span class="line">      <span class="comment">// 通过CacheBuilder构建二级缓存Cache</span></span><br><span class="line">      <span class="comment">// 又是生成器设计模式，分步骤创建复杂对象Cache</span></span><br><span class="line">    <span class="type">Cache</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CacheBuilder</span>(currentNamespace)</span><br><span class="line">        .implementation(valueOrDefault(typeClass, PerpetualCache.class))</span><br><span class="line">        .addDecorator(valueOrDefault(evictionClass, LruCache.class))</span><br><span class="line">        .clearInterval(flushInterval)</span><br><span class="line">        .size(size)</span><br><span class="line">        .readWrite(readWrite)</span><br><span class="line">        .blocking(blocking)</span><br><span class="line">        .properties(props)</span><br><span class="line">        .build();<span class="comment">//最后使用build生产chche</span></span><br><span class="line">    configuration.addCache(cache);<span class="comment">//添加到configuration中</span></span><br><span class="line">    currentCache = cache;</span><br><span class="line">    <span class="keyword">return</span> cache;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在构建二级缓存中使用了<strong>生成器设计模式</strong>和<strong>装饰器模式</strong>，作用分别是帮助构建复杂的对象，为类进行一些装饰【类似套娃。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Cache <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//构造方法比较困难，需要搞很多配置 一个简单的构造方法完成不了</span></span><br><span class="line">    <span class="comment">//设置默认的缓存实现类</span></span><br><span class="line">    setDefaultImplementations();</span><br><span class="line">    <span class="type">Cache</span> <span class="variable">cache</span> <span class="operator">=</span> newBaseCacheInstance(implementation, id);</span><br><span class="line">    <span class="comment">//设置chche属性</span></span><br><span class="line">    setCacheProperties(cache);</span><br><span class="line">    <span class="comment">// issue #352, do not apply decorators to custom caches</span></span><br><span class="line">    <span class="keyword">if</span> (PerpetualCache.class.equals(cache.getClass())) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;? <span class="keyword">extends</span> <span class="title class_">Cache</span>&gt; decorator : decorators) &#123;</span><br><span class="line">            <span class="comment">// 实例化所有装饰类</span></span><br><span class="line">            <span class="comment">// 这里会实例化LruCache类，装饰PerpetualCache</span></span><br><span class="line">            cache = newCacheDecoratorInstance(decorator, cache);</span><br><span class="line">            setCacheProperties(cache);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//LRU配置</span></span><br><span class="line">        cache = setStandardDecorators(cache);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!LoggingCache.class.isAssignableFrom(cache.getClass())) &#123;</span><br><span class="line">        cache = <span class="keyword">new</span> <span class="title class_">LoggingCache</span>(cache);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cache;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置默认实现类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setDefaultImplementations</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (implementation == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//默认实现类为PerpetualCache</span></span><br><span class="line">        implementation = PerpetualCache.class;</span><br><span class="line">        <span class="keyword">if</span> (decorators.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//向装饰器数据中添加LRU</span></span><br><span class="line">            decorators.add(LruCache.class);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置装饰器</span></span><br><span class="line"><span class="keyword">private</span> Cache <span class="title function_">setStandardDecorators</span><span class="params">(Cache cache)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">MetaObject</span> <span class="variable">metaCache</span> <span class="operator">=</span> SystemMetaObject.forObject(cache);</span><br><span class="line">        <span class="keyword">if</span> (size != <span class="literal">null</span> &amp;&amp; metaCache.hasSetter(<span class="string">&quot;size&quot;</span>)) &#123;</span><br><span class="line">            metaCache.setValue(<span class="string">&quot;size&quot;</span>, size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置缓存刷新间隔</span></span><br><span class="line">        <span class="keyword">if</span> (clearInterval != <span class="literal">null</span>) &#123;</span><br><span class="line">            cache = <span class="keyword">new</span> <span class="title class_">ScheduledCache</span>(cache);</span><br><span class="line">            <span class="comment">//ScheduledCache：调度缓存，负责定时清空缓存</span></span><br><span class="line">            ((ScheduledCache) cache).setClearInterval(clearInterval);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (readWrite) &#123;  </span><br><span class="line">            <span class="comment">//将LRU缓存 装饰到 Serialized缓存</span></span><br><span class="line">            <span class="comment">//SerializedCache：缓存序列化和反序列化存储</span></span><br><span class="line">            cache = <span class="keyword">new</span> <span class="title class_">SerializedCache</span>(cache); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 装饰成LoggingCache</span></span><br><span class="line">        cache = <span class="keyword">new</span> <span class="title class_">LoggingCache</span>(cache);</span><br><span class="line">        <span class="comment">// 装饰成SynchronizedCache</span></span><br><span class="line">        cache = <span class="keyword">new</span> <span class="title class_">SynchronizedCache</span>(cache);</span><br><span class="line">        <span class="keyword">if</span> (blocking) &#123;</span><br><span class="line">            cache = <span class="keyword">new</span> <span class="title class_">BlockingCache</span>(cache);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cache;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CacheException</span>(<span class="string">&quot;Error building standard cache decorators.  Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面看到，经过大量的装饰类，返回的是<code>SynchronizedCache</code>这个cache类。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://images.gitee.com/uploads/images/2021/0115/215838_2615c31d_8183653.jpeg"
                      alt="img"
                ></p>
<h4 id="解析动态sql"><a href="#解析动态sql" class="headerlink" title="解析动态sql"></a>解析动态sql</h4><p>其在<code>buildStatementFromContext(context.evalNodes(&quot;select|insert|update|delete&quot;));</code>方法中</p>
<p>是解析对应的<code>select|insert|update|delete</code>节点信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 解析sql语句标签，传入映射文件中的所有Sql语句标签对应的XNode集合</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildStatementFromContext</span><span class="params">(List&lt;XNode&gt; list)</span> &#123;</span><br><span class="line">   <span class="comment">//判断是否有配置数据库厂商ID</span></span><br><span class="line">   <span class="keyword">if</span> (configuration.getDatabaseId() != <span class="literal">null</span>) &#123;</span><br><span class="line">     buildStatementFromContext(list, configuration.getDatabaseId());</span><br><span class="line">   &#125;</span><br><span class="line">   buildStatementFromContext(list, <span class="literal">null</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildStatementFromContext</span><span class="params">(List&lt;XNode&gt; list, String requiredDatabaseId)</span> &#123;</span><br><span class="line">   <span class="comment">//循环我们的select|delte|insert|update节点</span></span><br><span class="line">   <span class="keyword">for</span> (XNode context : list) &#123;</span><br><span class="line">     <span class="comment">//创建一个xmlStatement的构建器对象</span></span><br><span class="line">     <span class="keyword">final</span> <span class="type">XMLStatementBuilder</span> <span class="variable">statementParser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLStatementBuilder</span>(configuration, builderAssistant, context, requiredDatabaseId);</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//调用parseStatementNode()方法</span></span><br><span class="line">       statementParser.parseStatementNode();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IncompleteElementException e) &#123;</span><br><span class="line">       configuration.addIncompleteStatement(statementParser);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseStatementNode</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 得到 insert|delte|update|select 标签的sqlId</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">   <span class="comment">//判断是否配置了数据库厂商</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">databaseId</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;databaseId&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//匹配当前数据库厂商ID是否匹配当前数据源厂商id</span></span><br><span class="line">   <span class="comment">//如果没有在insert等标签上设置id，那返回true</span></span><br><span class="line">   <span class="keyword">if</span> (!databaseIdMatchesCurrent(id, databaseId, <span class="built_in">this</span>.requiredDatabaseId)) &#123;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">     </span><br><span class="line">   <span class="comment">//获取节点名称select|insert|update|delete</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">nodeName</span> <span class="operator">=</span> context.getNode().getNodeName();</span><br><span class="line">     </span><br><span class="line">   <span class="comment">//根据nodeName 获得 SqlCommandType枚举</span></span><br><span class="line">   <span class="type">SqlCommandType</span> <span class="variable">sqlCommandType</span> <span class="operator">=</span> SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH));</span><br><span class="line">     </span><br><span class="line">   <span class="comment">//判断是否为select节点</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">isSelect</span> <span class="operator">=</span> sqlCommandType == SqlCommandType.SELECT;</span><br><span class="line">     </span><br><span class="line">   <span class="comment">//获取flushCache属性</span></span><br><span class="line">   <span class="comment">//默认值为isSelect的反值：查询：默认flushCache=false   增删改：默认flushCache=true</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">flushCache</span> <span class="operator">=</span> context.getBooleanAttribute(<span class="string">&quot;flushCache&quot;</span>, !isSelect);</span><br><span class="line">     </span><br><span class="line">   <span class="comment">//判断是否使用缓存</span></span><br><span class="line">   <span class="comment">//查询：默认useCache=true   增删改：默认useCache=false</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">useCache</span> <span class="operator">=</span> context.getBooleanAttribute(<span class="string">&quot;useCache&quot;</span>, isSelect);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//resultOrdered:  是否需要处理嵌套查询结果 group by (使用极少）</span></span><br><span class="line">   <span class="comment">//可以将比如 30条数据的三组数据  组成一个嵌套的查询结果</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">resultOrdered</span> <span class="operator">=</span> context.getBooleanAttribute(<span class="string">&quot;resultOrdered&quot;</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 解析我们的sql公用片段</span></span><br><span class="line"><span class="comment">    *     &lt;select id=&quot;qryEmployeeById&quot; resultType=&quot;Employee&quot; parameterType=&quot;int&quot;&gt;</span></span><br><span class="line"><span class="comment">             &lt;include refid=&quot;selectInfo&quot;&gt;&lt;/include&gt;</span></span><br><span class="line"><span class="comment">             employee where id=#&#123;id&#125;</span></span><br><span class="line"><span class="comment">          &lt;/select&gt;</span></span><br><span class="line"><span class="comment">       将 &lt;include refid=&quot;selectInfo&quot;&gt;&lt;/include&gt; 解析成sql语句 </span></span><br><span class="line"><span class="comment">       放在&lt;select&gt;Node的子节点中</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">// 解析重用的sql片段，就是通过&lt;sql&gt;标签设置的</span></span><br><span class="line">   <span class="comment">// 就是将&lt;include/&gt;标签指定的语句解析成sql语句</span></span><br><span class="line">   <span class="type">XMLIncludeTransformer</span> <span class="variable">includeParser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLIncludeTransformer</span>(configuration, builderAssistant);</span><br><span class="line">   includeParser.applyIncludes(context.getNode());</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 解析Sql语句标签的参数类型parameterType</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">parameterType</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;parameterType&quot;</span>);</span><br><span class="line">   <span class="comment">// 把参数类型字符串转化为class</span></span><br><span class="line">   Class&lt;?&gt; parameterTypeClass = resolveClass(parameterType);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取lang属性，查看sql是否支撑自定义语言</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">lang</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;lang&quot;</span>);</span><br><span class="line">   <span class="comment">// 获取自定义sql脚本语言驱动，默认为XMLLanguageDriver</span></span><br><span class="line">   <span class="type">LanguageDriver</span> <span class="variable">langDriver</span> <span class="operator">=</span> getLanguageDriver(lang);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 解析&lt;insert&gt;语句中的&lt;selectKey&gt;节点</span></span><br><span class="line">   <span class="comment">// 可以返回插入数据的id值，可用于实现oracle数据库的自增</span></span><br><span class="line">   processSelectKeyNodes(id, parameterTypeClass, langDriver);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Parse the SQL (pre: &lt;selectKey&gt; and &lt;include&gt; were parsed and removed)</span></span><br><span class="line">   <span class="comment">// 主键生成器</span></span><br><span class="line">   KeyGenerator keyGenerator;</span><br><span class="line">   <span class="comment">// 得到sqlID拼接上!selectKey字符串</span></span><br><span class="line">   <span class="comment">// 比如：selectById!selectKey</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">keyStatementId</span> <span class="operator">=</span> id + SelectKeyGenerator.SELECT_KEY_SUFFIX;</span><br><span class="line">   <span class="comment">// 命名空间拼接到keyStatementId中</span></span><br><span class="line">   <span class="comment">// 比如：com.jimmy.mapper.UserMapper.selectById!selectKey</span></span><br><span class="line">   keyStatementId = builderAssistant.applyCurrentNamespace(keyStatementId, <span class="literal">true</span>);</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *&lt;insert id=&quot;saveEmployee&quot; parameterType=&quot;com.tuling.entity.Employee&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;</span></span><br><span class="line"><span class="comment">    *判断我们全局的配置类configuration中是否包含以及解析过的组件生成器对象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//  判断我们全局的配置类configuration中是否包含以及解析过的主键生成器对象</span></span><br><span class="line">   <span class="keyword">if</span> (configuration.hasKeyGenerator(keyStatementId)) &#123;</span><br><span class="line">     keyGenerator = configuration.getKeyGenerator(keyStatementId);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 若我们配置了useGeneratedKeys 那么就去除useGeneratedKeys的配置值,</span></span><br><span class="line"><span class="comment">      * 否者就看我们的mybatis-config.xml配置文件中是配置了</span></span><br><span class="line"><span class="comment">      * &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;true&quot;&gt;&lt;/setting&gt; 默认是false</span></span><br><span class="line"><span class="comment">      * 并且判断sql操作类型是否为insert</span></span><br><span class="line"><span class="comment">      * 若是的话,那么使用的生成策略就是Jdbc3KeyGenerator.INSTANCE</span></span><br><span class="line"><span class="comment">      * 否则就是NoKeyGenerator.INSTANCE</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     keyGenerator = context.getBooleanAttribute(<span class="string">&quot;useGeneratedKeys&quot;</span>,</span><br><span class="line">         configuration.isUseGeneratedKeys() &amp;&amp; SqlCommandType.INSERT.equals(sqlCommandType))</span><br><span class="line">         ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 通过class org.apache.ibatis.scripting.xmltags.XMLLanguageDriver来解析我们的</span></span><br><span class="line"><span class="comment">    * sql脚本对象--解析SqlNode. </span></span><br><span class="line"><span class="comment">    * 注意，只是解析成一个个的SqlNode，并不会完全解析sql,因为这个时候参数都没确定，动态sql无法解析</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">// 通过XMLLanguageDriver来解析Sql语句标签，这里将Sql语句标签解析成一个个的SqlNode</span></span><br><span class="line">   <span class="comment">// 解析后封装，返回一个SqlSource对象</span></span><br><span class="line">   <span class="type">SqlSource</span> <span class="variable">sqlSource</span> <span class="operator">=</span> langDriver.createSqlSource(configuration, context, parameterTypeClass);</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取statementType属性值，它用于指定mybatis使用的statement类型</span></span><br><span class="line"><span class="comment">    * STATEMENT：Statement - 普通sql</span></span><br><span class="line"><span class="comment">    * PREPARED：PreparedStatement(默认) - 支持可变参数</span></span><br><span class="line"><span class="comment">    * CALLABLE：CallableStatement - 用于调用存储过程</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="type">StatementType</span> <span class="variable">statementType</span> <span class="operator">=</span> StatementType.valueOf(context.getStringAttribute(<span class="string">&quot;statementType&quot;</span>, StatementType.PREPARED.toString()));</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取fetchSize属性的值</span></span><br><span class="line"><span class="comment">    * 这是一个给驱动的提示，尝试让驱动程序每次批量返回的结果行数和这个设置值相等  </span></span><br><span class="line"><span class="comment">    * 很少会用到，默认值为未设置（unset）（依赖驱动）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="type">Integer</span> <span class="variable">fetchSize</span> <span class="operator">=</span> context.getIntAttribute(<span class="string">&quot;fetchSize&quot;</span>);</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取timeout属性的值</span></span><br><span class="line"><span class="comment">    * 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数</span></span><br><span class="line"><span class="comment">    * 默认值为未设置（unset）（依赖驱动）。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="type">Integer</span> <span class="variable">timeout</span> <span class="operator">=</span> context.getIntAttribute(<span class="string">&quot;timeout&quot;</span>);</span><br><span class="line">   <span class="comment">// 获取parameterMap属性的值，默认为未设置</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">parameterMap</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;parameterMap&quot;</span>);</span><br><span class="line">   <span class="comment">// 获取resultType属性的值，用于指定执行结果类型 </span></span><br><span class="line">   <span class="comment">// 注意如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身。</span></span><br><span class="line">   <span class="comment">// 可以使用 resultType 或 resultMap，但不能同时使用</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">resultType</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;resultType&quot;</span>);</span><br><span class="line">   <span class="comment">// 解析resultType的类型</span></span><br><span class="line">   Class&lt;?&gt; resultTypeClass = resolveClass(resultType);、</span><br><span class="line">   <span class="comment">// 解析resultMap，结果集映射</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">resultMap</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;resultMap&quot;</span>);</span><br><span class="line">   <span class="type">String</span> <span class="variable">resultSetType</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;resultSetType&quot;</span>);</span><br><span class="line">   <span class="type">ResultSetType</span> <span class="variable">resultSetTypeEnum</span> <span class="operator">=</span> resolveResultSetType(resultSetType);</span><br><span class="line">   <span class="keyword">if</span> (resultSetTypeEnum == <span class="literal">null</span>) &#123;</span><br><span class="line">     resultSetTypeEnum = configuration.getDefaultResultSetType();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 解析keyProperty和keyColumn属性，仅适用于insert和update语句</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">keyProperty</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;keyProperty&quot;</span>);</span><br><span class="line">   <span class="type">String</span> <span class="variable">keyColumn</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;keyColumn&quot;</span>);</span><br><span class="line">   <span class="type">String</span> <span class="variable">resultSets</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;resultSets&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 最后通过MapperBuilderAssistant的addMappedStatement方法</span></span><br><span class="line">   <span class="comment">// 将insert|delete|update|select节点构建成mappedStatment对象</span></span><br><span class="line">   builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,</span><br><span class="line">       fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,</span><br><span class="line">       resultSetTypeEnum, flushCache, useCache, resultOrdered,</span><br><span class="line">       keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>浏览完上述的代码，我们着重去看如何把sql语句解析成<strong>SqlSource</strong>对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SqlSource</span> <span class="variable">sqlSource</span> <span class="operator">=</span> </span><br><span class="line">    langDriver.createSqlSource(configuration, context, parameterTypeClass);</span><br></pre></td></tr></table></figure>

<p>我们去看对应的<code>XMLLanguageDriver</code>的<code>createSqlSource</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 方法实现说明:创建我们的sqlSource对象</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@author</span>:xsls</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> configuration:全局配置</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> script:脚本类型</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> parameterType:参数类型</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span>:</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@exception</span>:</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@date</span>:2019/9/6 16:10</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> SqlSource <span class="title function_">createSqlSource</span><span class="params">(Configuration configuration, XNode script, Class&lt;?&gt; parameterType)</span> &#123;</span><br><span class="line">   <span class="type">XMLScriptBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLScriptBuilder</span>(configuration, script, parameterType);</span><br><span class="line">     <span class="comment">//使用XMLScriptBuilder的parseScriptNode()</span></span><br><span class="line">   <span class="keyword">return</span> builder.parseScriptNode();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> SqlSource <span class="title function_">parseScriptNode</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 这里会将sql标签解析成一个SqlSource对象，如果是动态Sql就对应DynamicSqlSource。</span></span><br><span class="line"><span class="comment">    * SqlSource中的成员变量rootSqlNode就是sql解析出来的的根节点。</span></span><br><span class="line"><span class="comment">    * 比如我们映射配置文件案例中的sql就是动态sql，通过【递归】的方式会被解析为若干个SqlNode节点：</span></span><br><span class="line"><span class="comment">    * - MixedSqlNode对应&lt;SELECT&gt;（根节点）</span></span><br><span class="line"><span class="comment">    *   - StaticTextSqlNode对应Sql语句（二级节点）</span></span><br><span class="line"><span class="comment">    *   - WhereSqlNode对应&lt;WHERE&gt;（二级节点）</span></span><br><span class="line"><span class="comment">    *     - IfSqlNode对应&lt;IF&gt;（三级节点）</span></span><br><span class="line"><span class="comment">    *       - StaticTextSqlNode对应Sql语句（四级节点）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="type">MixedSqlNode</span> <span class="variable">rootSqlNode</span> <span class="operator">=</span> parseDynamicTags(context);</span><br><span class="line">   SqlSource sqlSource;</span><br><span class="line">   <span class="comment">//判断是否为动态SQL</span></span><br><span class="line">   <span class="keyword">if</span> (isDynamic) &#123;</span><br><span class="line">     <span class="comment">// 动态Sql源</span></span><br><span class="line">     <span class="comment">// 把刚刚的MixedSqlNode变为DynamicSqlSource，下面类似	</span></span><br><span class="line">     sqlSource = <span class="keyword">new</span> <span class="title class_">DynamicSqlSource</span>(configuration, rootSqlNode);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// 静态Sql源， 它会在这里解析</span></span><br><span class="line">     sqlSource = <span class="keyword">new</span> <span class="title class_">RawSqlSource</span>(configuration, rootSqlNode, parameterType);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> sqlSource;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 解析标签</span></span><br><span class="line"> <span class="keyword">protected</span> MixedSqlNode <span class="title function_">parseDynamicTags</span><span class="params">(XNode node)</span> &#123;</span><br><span class="line">   List&lt;SqlNode&gt; contents = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   <span class="comment">// 获得Sql语句标签(比如&lt;SELECT&gt;)的子节点  </span></span><br><span class="line">   <span class="type">NodeList</span> <span class="variable">children</span> <span class="operator">=</span> node.getNode().getChildNodes();  </span><br><span class="line">   <span class="comment">// 遍历子节点</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; children.getLength(); i++) &#123;</span><br><span class="line">     <span class="type">XNode</span> <span class="variable">child</span> <span class="operator">=</span> node.newXNode(children.item(i));</span><br><span class="line">     <span class="comment">// 如果是文本节点，比如sql语句和空行都是文本节点</span></span><br><span class="line">     <span class="keyword">if</span> (child.getNode().getNodeType() == Node.CDATA_SECTION_NODE || child.getNode().getNodeType() == Node.TEXT_NODE) &#123;</span><br><span class="line">       <span class="comment">// 获得sql文本  </span></span><br><span class="line">       <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> child.getStringBody(<span class="string">&quot;&quot;</span>); </span><br><span class="line">       <span class="comment">// 将sql文本封装为TextSqlNode</span></span><br><span class="line">       <span class="type">TextSqlNode</span> <span class="variable">textSqlNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextSqlNode</span>(data);</span><br><span class="line">       <span class="comment">// 如果sql文本中有$&#123;&#125;，就是算Dynamic</span></span><br><span class="line">       <span class="keyword">if</span> (textSqlNode.isDynamic()) &#123; </span><br><span class="line">         contents.add(textSqlNode);</span><br><span class="line">         <span class="comment">//这里设定为动态SQL</span></span><br><span class="line">         isDynamic = <span class="literal">true</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         contents.add(<span class="keyword">new</span> <span class="title class_">StaticTextSqlNode</span>(data));</span><br><span class="line">       &#125;</span><br><span class="line">     <span class="comment">// 如果不是文本节点，比如&lt;where&gt;&lt;if&gt;&lt;trim&gt;等动态节点</span></span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child.getNode().getNodeType() == Node.ELEMENT_NODE) &#123; <span class="comment">// issue #628</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">nodeName</span> <span class="operator">=</span> child.getNode().getNodeName();</span><br><span class="line">       <span class="comment">// 拿到一个NodeHandler节点处理器</span></span><br><span class="line">       <span class="type">NodeHandler</span> <span class="variable">handler</span> <span class="operator">=</span> nodeHandlerMap.get(nodeName);</span><br><span class="line">       <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Unknown element &lt;&quot;</span> + nodeName + <span class="string">&quot;&gt; in SQL statement.&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 通过节点处理器解析动态节点，不同的节点有不同的处理器</span></span><br><span class="line">       <span class="comment">// 比如：WhereHandler、IfHandler、TrimHandler等等</span></span><br><span class="line">       <span class="comment">// 这里会进行【递归】解析，将所有的节点都解析出来</span></span><br><span class="line">       handler.handleNode(child, contents); </span><br><span class="line">       <span class="comment">// 如果有这种动态节点，那说明是动态sql</span></span><br><span class="line">       isDynamic = <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MixedSqlNode</span>(contents);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">WhereHandler</span> <span class="keyword">implements</span> <span class="title class_">NodeHandler</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">WhereHandler</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="comment">// Prevent Synthetic Access</span></span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//handler.handleNode(child, contents);</span></span><br><span class="line">   <span class="comment">//这里调用这个完成解析where</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleNode</span><span class="params">(XNode nodeToHandle, List&lt;SqlNode&gt; targetContents)</span> &#123;</span><br><span class="line">     <span class="comment">//又是解析标签的调用</span></span><br><span class="line">     <span class="comment">//如果又遇到非文本节点 就继续递归</span></span><br><span class="line">     <span class="type">MixedSqlNode</span> <span class="variable">mixedSqlNode</span> <span class="operator">=</span> parseDynamicTags(nodeToHandle);</span><br><span class="line">     <span class="type">WhereSqlNode</span> <span class="variable">where</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WhereSqlNode</span>(configuration, mixedSqlNode);</span><br><span class="line">     targetContents.add(where);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>到这里Sql语句标签就解析完成了，我们简单总结一下Sql语句的解析过程：</p>
<ol>
<li>通过XMLStatementBuilder类的<code>parseStatementNode</code>方法解析Sql语句标签，包含若干属性和Sql语句。</li>
<li>通过XMLScriptBuilder类的<code>parseScriptNode</code>方法，通过递归的方式将Sql语句解析成若干个<strong>SqlNode</strong>节点，并且封装至<strong>SqlSource</strong>对象中。</li>
<li>最后将所有属性和Sql语句对应的SqlSource对象封装成<strong>MappedStatement</strong>对象，保存至Configuration的一个Map中，<code>key</code>就是Sql语句所属方法的全限定名。</li>
</ol>
<h2 id="SQL执行流程"><a href="#SQL执行流程" class="headerlink" title="SQL执行流程"></a>SQL执行流程</h2><p>我们使用生成器模式完成了<code>SqlSessionFactory</code>的构建，现在我们可以看后续的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlMapper.openSession();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行查询 底层执行jdbc</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User)session.selectOne(<span class="string">&quot;com.tuling.mapper.UserMapper.selectById&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/*UserMapper mapper = session.getMapper(UserMapper.class);</span></span><br><span class="line"><span class="comment">                System.out.println(mapper.getClass());</span></span><br><span class="line"><span class="comment">                User user = mapper.selectById(1L);*/</span></span><br><span class="line">    session.commit();</span><br><span class="line">    System.out.println(user.getUserName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进到到SqlSessionFactory的实现类DefaultSqlSessionFactory的<code>openSession</code>方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> SqlSession <span class="title function_">openSession</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> openSessionFromDataSource(configuration.getDefaultExecutorType(), <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 方法实现说明:从session中开启一个数据源</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@author</span>:xsls</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> execType:执行器类型</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> level:隔离级别</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span>:SqlSession</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@exception</span>:</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@date</span>:2019/9/9 13:38</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> SqlSession <span class="title function_">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="type">boolean</span> autoCommit)</span> &#123;</span><br><span class="line">    <span class="type">Transaction</span> <span class="variable">tx</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 获取环境变量</span></span><br><span class="line">      <span class="keyword">final</span> <span class="type">Environment</span> <span class="variable">environment</span> <span class="operator">=</span> configuration.getEnvironment();</span><br><span class="line">      <span class="comment">// 获取事务工厂</span></span><br><span class="line">      <span class="keyword">final</span> <span class="type">TransactionFactory</span> <span class="variable">transactionFactory</span> <span class="operator">=</span> getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">      tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 创建一个sql执行器【Executor对象】，这是一个核心对象</span></span><br><span class="line"><span class="comment">       * 一般情况下若的mybaits的全局配置文件的cacheEnabled为ture（开启二级缓存）</span></span><br><span class="line"><span class="comment">       * 就返回一个CachingExecutor,若关闭的话返回的就是一个SimpleExecutor</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">final</span> <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> configuration.newExecutor(tx, execType);</span><br><span class="line">      <span class="comment">//创建返回一个DeaultSqlSessoin对象返回</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultSqlSession</span>(configuration, executor, autoCommit);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      closeTransaction(tx); <span class="comment">// may have fetched a connection so lets call close()</span></span><br><span class="line">      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error opening session.  Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;          </span><br></pre></td></tr></table></figure>

<h3 id="创建Executor"><a href="#创建Executor" class="headerlink" title="创建Executor"></a>创建Executor</h3><p>上述代码中创建了一个Mybatis中的一大核心对象<strong>Executor</strong>。</p>
<p>Mybatis中有三种基本的Executor执行器的实现，<strong>SimpleExecutor</strong>、<strong>ReuseExecutor</strong>和<strong>BatchExecutor</strong>。</p>
<p>此外还有两种执行器CachingExecutor【二级缓存】、BaseExecutor【一级缓存】</p>
<p>这两者执行器实际上都是委托三个基本的执行器去执行的</p>
<p>可通过全局配置文件中的<code>defaultExecutorType</code>属性进行设置，默认值为<code>SIMPLE</code>。</p>
<ul>
<li>SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。</li>
<li>ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map内，供下一次使用。简言之，就是重复使用Statement对象。</li>
<li>BatchExecutor：执行update时（JDBC批处理不支持select），将所有sql都通过<code>addBatch</code>添加到批处理中，等待统一执行<code>executeBatch</code>，它缓存了多个Statement对象，每个Statement对象都是添加完毕后，等待逐一执行批处理。</li>
</ul>
<p>Executor的这些特点，都严格限制在SqlSession生命周期范围内。接着到Configuration类的<code>newExecutor</code>方法中分析一下Executor的创建过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Executor <span class="title function_">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> &#123;</span><br><span class="line">    <span class="comment">// 默认为SimpleExecutor</span></span><br><span class="line">    executorType = executorType == <span class="literal">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">    executorType = executorType == <span class="literal">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    <span class="comment">// 判断执行器的类型</span></span><br><span class="line">    <span class="comment">// 批量执行器BatchExecutor</span></span><br><span class="line">    <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> <span class="title class_">BatchExecutor</span>(<span class="built_in">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">        <span class="comment">//可重复使用的执行器</span></span><br><span class="line">        executor = <span class="keyword">new</span> <span class="title class_">ReuseExecutor</span>(<span class="built_in">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//简单的sql执行器对象</span></span><br><span class="line">        executor = <span class="keyword">new</span> <span class="title class_">SimpleExecutor</span>(<span class="built_in">this</span>, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断mybatis的全局配置文件是否开启缓存</span></span><br><span class="line">    <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">        <span class="comment">//把当前的简单的执行器包装成一个CachingExecutor</span></span><br><span class="line">        <span class="comment">//装饰器模式</span></span><br><span class="line">        executor = <span class="keyword">new</span> <span class="title class_">CachingExecutor</span>(executor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用InterceptorChain的pluginAll方法</span></span><br><span class="line">    <span class="comment">// 会调用所有拦截器对象的plugin方法，这里会将Executor进行动态代理</span></span><br><span class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里传入的target是Executor</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">pluginAll</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">  <span class="comment">// 之前解析配置文件时将所有的plugin解析为Interceptor</span></span><br><span class="line">  <span class="comment">// 这里遍历所有的Interceptor  </span></span><br><span class="line">  <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">    <span class="comment">// 调用Interceptor的plugin方法</span></span><br><span class="line">    <span class="comment">// 可能返回一个代理对象</span></span><br><span class="line">    <span class="comment">// 由于可能会存在多个插件，所以这里会形成代理中套代理的情况</span></span><br><span class="line">    target = interceptor.plugin(target);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义插件类实现Interceptor接口的plugin方法</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">plugin</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">    <span class="comment">// 接口中默认的实现是调用Plugin的wrap方法</span></span><br><span class="line">    <span class="comment">// 这里基本不会修改，按照默认的即可</span></span><br><span class="line">    <span class="keyword">return</span> Plugin.wrap(target, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 参数target是Executor对象，interceptor是自定义插件对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">wrap</span><span class="params">(Object target, Interceptor interceptor)</span> &#123;</span><br><span class="line">    <span class="comment">// 获得interceptor配置的@Signature的type</span></span><br><span class="line">    Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);</span><br><span class="line">    <span class="comment">// 当前代理类型 为Execcutor的子类</span></span><br><span class="line">    Class&lt;?&gt; type = target.getClass();</span><br><span class="line">    <span class="comment">// 根据当前target的类型和@signature中指定的type进行配对</span></span><br><span class="line">    <span class="comment">// 如果配对成功则可以进行动态代理</span></span><br><span class="line">    Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);</span><br><span class="line">    <span class="comment">//匹配成功</span></span><br><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">            type.getClassLoader(),</span><br><span class="line">            interfaces,</span><br><span class="line">            <span class="comment">// invocationHandler传入的是一个Plugin对象</span></span><br><span class="line">            <span class="comment">// 说明调用代理对象时执行的invoke方法就在Plugin类中实现</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Plugin</span>(target, interceptor, signatureMap));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有匹配上，那就返回原target对象</span></span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，Executor对象就创建完了，最后将其设置到<code>DefaultSqlSession</code>对象中并返回。</p>
<p> <strong>简单总结</strong></p>
<ul>
<li>拿到SqlSessionFactory对象后，会调用SqlSessionFactory的openSesison方法，这个方法会创建一个Sql执行器（Executor），这个Sql执行器会代理你配置的拦截器方法。</li>
<li>获得上面的Sql执行器后，会创建一个SqlSession（默认使用DefaultSqlSession）,这个SqlSession中也包含了Configration对象，所以通过SqlSession也能拿到全局配置；</li>
<li>获得SqlSession对象后就能执行各种CRUD方法了。</li>
</ul>
<h3 id="执行Sql"><a href="#执行Sql" class="headerlink" title="执行Sql"></a>执行Sql</h3><p>我们就拿案例中的<code>selectOne</code>为例，分析执行Sql的流程。找到DefaultSqlSession的<code>selectOne</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 方法实现说明:查询我们当个对象</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@author</span>:xsls</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> statement:我们的statementId(com.tuling.mapper.EmployeeMapper.findOne)</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> parameter:调用时候的参数</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span>: T 返回结果</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@exception</span>:</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@date</span>:2019/9/9 20:26</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">selectOne</span><span class="params">(String statement, Object parameter)</span> &#123;</span><br><span class="line"><span class="comment">// 调用的selectList</span></span><br><span class="line">   List&lt;T&gt; list = <span class="built_in">this</span>.selectList(statement, parameter);</span><br><span class="line">   <span class="comment">//若查询出来有且有一个一个对象，直接返回要给</span></span><br><span class="line">   <span class="keyword">if</span> (list.size() == <span class="number">1</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">     <span class="comment">//查询多个 抛出异常</span></span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TooManyResultsException</span>(<span class="string">&quot;Expected one result (or null) to be returned by selectOne(), but found: &quot;</span> + list.size());</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">selectList</span><span class="params">(String statement, Object parameter)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">this</span>.selectList(statement, parameter, RowBounds.DEFAULT);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">//通过我们的statement去我们的全局配置类中获取MappedStatement</span></span><br><span class="line">     <span class="type">MappedStatement</span> <span class="variable">ms</span> <span class="operator">=</span> configuration.getMappedStatement(statement);</span><br><span class="line">      <span class="comment">// 通过执行器Executor去执行sql对象MappedStatement</span></span><br><span class="line">      <span class="comment">// 首先通过wrapCollection方法包装参数</span></span><br><span class="line">      <span class="comment">// 在二级缓存默认开启的情况下调用的是CachingExecutor的query方法</span></span><br><span class="line">     <span class="keyword">return</span> executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">     <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error querying database.  Cause: &quot;</span> + e, e);</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     ErrorContext.instance().reset();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> Object <span class="title function_">wrapCollection</span><span class="params">(<span class="keyword">final</span> Object object)</span> &#123;</span><br><span class="line">   <span class="comment">//若我们的参数类型是Collection</span></span><br><span class="line">   <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Collection) &#123;</span><br><span class="line">     StrictMap&lt;Object&gt; map = <span class="keyword">new</span> <span class="title class_">StrictMap</span>&lt;&gt;();</span><br><span class="line">     <span class="comment">//把他key为collection存放到map中</span></span><br><span class="line">     map.put(<span class="string">&quot;collection&quot;</span>, object);</span><br><span class="line">     <span class="comment">//若我们参数类型是list类型  把key为list作为集合存放到map中</span></span><br><span class="line">     <span class="keyword">if</span> (object <span class="keyword">instanceof</span> List) &#123;</span><br><span class="line">       map.put(<span class="string">&quot;list&quot;</span>, object);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> map;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object != <span class="literal">null</span> &amp;&amp; object.getClass().isArray()) &#123;</span><br><span class="line">     <span class="comment">//若是数组，存放key为array的map中</span></span><br><span class="line">     StrictMap&lt;Object&gt; map = <span class="keyword">new</span> <span class="title class_">StrictMap</span>&lt;&gt;();</span><br><span class="line">     map.put(<span class="string">&quot;array&quot;</span>, object);</span><br><span class="line">     <span class="keyword">return</span> map;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> object;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们跟进CachingExecutor的<code>query</code>方法：</p>
<blockquote>
<p>注意：如果有拦截器匹配的话，这里的CachingExecutor就是代理对象，那么首先会执行拦截器中的<code>intercept</code>方法。后续还有三个对象StatementHandler、ResultSetHandler和ParameterHandler也是同样的道理。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="comment">// 调用MappedStatement的getBoundSql方法解析Sql语句</span></span><br><span class="line">    <span class="comment">// 因为之前我们将动态Sql解析成一个个SqlNode节点，这里需要根据参数进行拼装</span></span><br><span class="line">    <span class="comment">// 通过SQLNode使用责任链的方式解析SQL</span></span><br><span class="line">    <span class="comment">// 方法中会通过SqlSource对象从根节点开始调用所有SqlNode节点的apply方法</span></span><br><span class="line">    <span class="comment">// 会解析 #&#123;&#125; 和 OGNL 表达式等信息，最后拼装得到一个最终的Sql语句BoundSql</span></span><br><span class="line">    <span class="type">BoundSql</span> <span class="variable">boundSql</span> <span class="operator">=</span> ms.getBoundSql(parameterObject);</span><br><span class="line">    <span class="comment">//缓存的KEY</span></span><br><span class="line">    <span class="type">CacheKey</span> <span class="variable">key</span> <span class="operator">=</span> createCacheKey(ms, parameterObject, rowBounds, boundSql);</span><br><span class="line">    <span class="keyword">return</span> query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span></span><br><span class="line">    <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="comment">//判断是否开启了二级缓存</span></span><br><span class="line">    <span class="type">Cache</span> <span class="variable">cache</span> <span class="operator">=</span> ms.getCache();</span><br><span class="line">    <span class="comment">//如果开启了</span></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断是否需要刷新缓存</span></span><br><span class="line">        flushCacheIfRequired(ms);</span><br><span class="line">        <span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">            ensureNoOutParams(ms, boundSql);</span><br><span class="line">            <span class="comment">// 先去二级缓存中获取</span></span><br><span class="line">            <span class="comment">// TransactionalCacheManager的getObject方法，责任链模式调用：</span></span><br><span class="line">            <span class="comment">// TransactionalCache-&gt;SychronizedCahche-&gt;LoggingCache-&gt;SerializedCache</span></span><br><span class="line">            <span class="comment">// -&gt;(ScheduldeCache-&gt;)LruCache-&gt;PerpetaulCache 之前我们已经介绍过了</span></span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 二级缓存中没有获取到</span></span><br><span class="line">            <span class="keyword">if</span> (list == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 通过查询一级缓存和数据库去查询</span></span><br><span class="line">                <span class="comment">// 这里会调用SimpleExecutor父类BaseExecutor的query方法</span></span><br><span class="line">                list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">                <span class="comment">// 查询到结果后加入二级缓存中</span></span><br><span class="line">                tcm.putObject(cache, key, list); <span class="comment">// issue #578 and #116</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有开启二级缓存,直接去查询</span></span><br><span class="line">    <span class="keyword">return</span> delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们第一次去的时候，二级缓存中必然查询不到，需要委托<code>SimpleExecutor</code>来帮助查询，而在<code>SimpleExecutor</code>中是没有重写查询方法的，需要交付给其父类<code>BaseExecutor</code>的query方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"></span><br><span class="line">    ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing a query&quot;</span>).object(ms.getId());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//已经关闭，则抛出 ExecutorException 异常</span></span><br><span class="line">    <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutorException</span>(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果queryStack为零并且配置了清空本地缓存</span></span><br><span class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">        <span class="comment">//清空本地缓存</span></span><br><span class="line">        clearLocalCache();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;E&gt; list;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 从一级缓存中，获取查询结果</span></span><br><span class="line">        queryStack++;</span><br><span class="line">        list = resultHandler == <span class="literal">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 从一级缓存中获取到，则进行处理</span></span><br><span class="line">        <span class="keyword">if</span> (list != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 通过handleLocallyCachedOutputParameters进行处理</span></span><br><span class="line">            handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获得不到，则从数据库中查询</span></span><br><span class="line">            list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        queryStack--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (DeferredLoad deferredLoad : deferredLoads) &#123;</span><br><span class="line">            deferredLoad.load();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// issue #601</span></span><br><span class="line">        deferredLoads.clear();</span><br><span class="line">        <span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">            <span class="comment">// issue #482</span></span><br><span class="line">            clearLocalCache();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去数据库中查询</span></span><br><span class="line"><span class="keyword">private</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">queryFromDatabase</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    List&lt;E&gt; list;</span><br><span class="line">    localCache.putObject(key, EXECUTION_PLACEHOLDER);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用doQuery方法</span></span><br><span class="line">        list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        localCache.removeObject(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向一级缓存中获取值</span></span><br><span class="line">    localCache.putObject(key, list);</span><br><span class="line">    <span class="keyword">if</span> (ms.getStatementType() == StatementType.CALLABLE) &#123;</span><br><span class="line">        localOutputParameterCache.putObject(key, parameter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数据库查询"><a href="#数据库查询" class="headerlink" title="数据库查询"></a>数据库查询</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取Configuration对象</span></span><br><span class="line">    <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> ms.getConfiguration();</span><br><span class="line">    <span class="comment">// 创建StatementHandler对象，这也是Mybatis的一个核心对象</span></span><br><span class="line">    <span class="comment">// 这里同样会根据插件进行代理，过程和Executor一样</span></span><br><span class="line">    <span class="comment">// 具体实现类是RoutingStatementHandler，它默认包装了PreparedStatementHandler</span></span><br><span class="line">    <span class="comment">// 另外内部还封装了ParameterHandler和ResultSetHandler</span></span><br><span class="line">    <span class="type">StatementHandler</span> <span class="variable">handler</span> <span class="operator">=</span> configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    <span class="comment">// 调用prepareStatement方法，得到一个PreparedStatement</span></span><br><span class="line">    stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">    <span class="comment">// 调用RoutingStatementHandler的query方法得到查询结果</span></span><br><span class="line">    <span class="comment">// 这里的RoutingStatementHandler可能是代理对象，首先需要调用拦截器</span></span><br><span class="line">    <span class="keyword">return</span> handler.query(stmt, resultHandler);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 追后关闭Statement</span></span><br><span class="line">    closeStatement(stmt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用prepareStatement方法，得到一个PreparedStatement</span></span><br><span class="line">  <span class="keyword">private</span> Statement <span class="title function_">prepareStatement</span><span class="params">(StatementHandler handler, Log statementLog)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    Statement stmt;</span><br><span class="line">    <span class="comment">// 通过事务管理器获取数据库连接Connection</span></span><br><span class="line">    <span class="comment">// 默认是JdbcTransaction即&lt;transactionManager type=&quot;JDBC&quot;/&gt;</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> getConnection(statementLog);</span><br><span class="line">    <span class="comment">// 调用RoutingStatementHandler的prepare方法</span></span><br><span class="line">    stmt = handler.prepare(connection, transaction.getTimeout());</span><br><span class="line">    handler.parameterize(stmt);</span><br><span class="line">    <span class="keyword">return</span> stmt;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>接着来到RoutingStatementHandler类中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Statement <span class="title function_">prepare</span><span class="params">(Connection connection, Integer transactionTimeout)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="comment">// 这里的delegate默认是PreparedStatementHandler，调用它的prepare方法</span></span><br><span class="line">  <span class="keyword">return</span> delegate.prepare(connection, transactionTimeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="comment">// 调用PreparedStatementHandler的query方法</span></span><br><span class="line">  <span class="keyword">return</span> delegate.query(statement, resultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终来到PreparedStatementHandler类中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Statement <span class="title function_">prepare</span><span class="params">(Connection connection, Integer transactionTimeout)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  ErrorContext.instance().sql(boundSql.getSql());</span><br><span class="line">  <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 实例化Statement对象，默认为PreparedStatement</span></span><br><span class="line">    statement = instantiateStatement(connection);</span><br><span class="line">    <span class="comment">// 设置超时时间</span></span><br><span class="line">    setStatementTimeout(statement, transactionTimeout);</span><br><span class="line">    setFetchSize(statement);</span><br><span class="line">    <span class="keyword">return</span> statement;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    closeStatement(statement);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    closeStatement(statement);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutorException</span>(<span class="string">&quot;Error preparing statement.  Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//SimpleStatementHandler的方法</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> (PreparedStatement) statement;</span><br><span class="line">  <span class="comment">// 通过PreparedStatement的execute方法执行</span></span><br><span class="line">  ps.execute();</span><br><span class="line">  <span class="comment">// 通过ResultSetHandler的handleResultSets处理结果集</span></span><br><span class="line">  <span class="keyword">return</span> resultSetHandler.handleResultSets(ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是基于<code>StatementId</code>方式执行Sql语句的大致流程。</p>
<h4 id="插件的调用"><a href="#插件的调用" class="headerlink" title="插件的调用"></a>插件的调用</h4><p>插件的主要拦截Executor、StatementHandler、ResultSetHandler和ParameterHandler这四个对象的方法，如果有插件匹配这四个对象，则在创建这些对象的时候会进行JDK动态代理，代理的过程在上述创建Executor的流程中已经分析了。</p>
<p>另外，比如说有多个插件匹配了Executor，那么会对Executor进行层层代理，最终得到一个经过多层代理的对象。我们再回顾一下创建动态代理的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数target是Executor对象，interceptor是自定义插件对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">wrap</span><span class="params">(Object target, Interceptor interceptor)</span> &#123;</span><br><span class="line">    <span class="comment">// 获得interceptor配置的@Signature的type</span></span><br><span class="line">    Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);</span><br><span class="line">    <span class="comment">// 当前代理类型 为Execcutor的子类</span></span><br><span class="line">    Class&lt;?&gt; type = target.getClass();</span><br><span class="line">    <span class="comment">// 根据当前target的类型和@signature中指定的type进行配对</span></span><br><span class="line">    <span class="comment">// 如果配对成功则可以进行动态代理</span></span><br><span class="line">    Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);</span><br><span class="line">    <span class="comment">//匹配成功</span></span><br><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">            type.getClassLoader(),</span><br><span class="line">            interfaces,</span><br><span class="line">            <span class="comment">// invocationHandler传入的是一个Plugin对象</span></span><br><span class="line">            <span class="comment">// 说明调用代理对象时执行的invoke方法就在Plugin类中实现</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Plugin</span>(target, interceptor, signatureMap));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有匹配上，那就返回原target对象</span></span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们就拿Executor举例，创建动态代理时<code>invocationHandler</code>参数传入的是一个Plugin对象，那说明调用代理对象时执行的<code>invoke</code>方法就在Plugin类中实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass());</span><br><span class="line">    <span class="keyword">if</span> (methods != <span class="literal">null</span> &amp;&amp; methods.contains(method)) &#123;</span><br><span class="line">      <span class="comment">// 调用当前拦截器interceptor的intercept方法</span></span><br><span class="line">      <span class="comment">// interceptor是Plugin的成员变量</span></span><br><span class="line">      <span class="keyword">return</span> interceptor.intercept(<span class="keyword">new</span> <span class="title class_">Invocation</span>(target, method, args));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过method.invoke执行被代理对象target的对应方法，target是Plugin的成员变量</span></span><br><span class="line">    <span class="comment">// 如果被代理对象target仍然是一个代理对象，表示后续还有拦截器需要执行</span></span><br><span class="line">    <span class="comment">// 那么又会回到这个方法，执行下一个拦截器</span></span><br><span class="line">    <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到Mybatis中如果对于同一个拦截对象存在多个插件，那么他的调用是<strong>从最外层代理对象开始，不断调用内层代理对象的过程。所以定义在最前面的插件执行顺序排在最后。</strong>、Mybatis执行的整体流程图如下：</p>
<p><a target="_blank" rel="noopener" href="https://images.gitee.com/uploads/images/2021/0117/104806_4db6c279_8183653.jpeg"><img  
                     lazyload
                     alt="image"
                     data-src="https://images.gitee.com/uploads/images/2021/0117/104806_4db6c279_8183653.jpeg"
                      alt="输入图片说明"
                ></a></p>

            </div>

            
                <div class="post-copyright-info">
                    
<div class="article-copyright-info-container">
    <ul class="copyright-info-content">
        <li class="post-title">
            <span class="type">本文标题</span>：<span class="content">Mybatis究极解析</span>
        </li>
        <li class="post-author">
            <span class="type">本文作者</span>：<span class="content">liduoan.efls</span>
        </li>
        <li class="post-time">
            <span class="type">创建时间</span>：<span class="content">2021-05-21 15:39:28</span>
        </li>
        <li class="post-link">
            <span class="type">本文链接</span>：<span class="content">2021/05/21/2021/Mybatis究极解析/</span>
        </li>
        <li class="post-license">
            <span class="type">版权声明</span>：<span class="content">本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！</span>
        </li>
    </ul>
    <div class="copy-copyright-info flex-center tooltip" data-content="复制版权信息" data-offset-y="-2px">
        <i class="fa-solid fa-copy"></i>
    </div>
</div>

                </div>
            

            
                <ul class="post-tags-box">
                    
                        <li class="tag-item">
                            <a href="/tags/2021/">#2021</a>&nbsp;
                        </li>
                    
                </ul>
            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                               rel="prev"
                               href="/2021/06/02/2021/Zookeeper/"
                            >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                                <span class="title flex-center">
                                <span class="post-nav-title-item">Zookeeper</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                               rel="next"
                               href="/2021/05/17/2021/SpringMvc%E7%A9%B6%E6%9E%81%E8%A7%A3%E6%9E%90/"
                            >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">SpringMvc究极解析</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                                <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                            </a>
                        </div>
                    
                </div>
            

            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Mybatis%E5%9B%9E%E9%A1%BE"><span class="nav-number">1.</span> <span class="nav-text">Mybatis回顾</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9FJDBC%E5%92%8CMybatis%E7%9B%B8%E6%AF%94%E7%9A%84%E5%BC%8A%E7%97%85"><span class="nav-number">1.1.</span> <span class="nav-text">传统JDBC和Mybatis相比的弊病</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mybatis%E4%BD%BF%E7%94%A8"><span class="nav-number">1.2.</span> <span class="nav-text">Mybatis使用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">2.</span> <span class="nav-text">Mybatis源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="nav-number">2.1.</span> <span class="nav-text">解析配置文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#XMLConfigBuilder"><span class="nav-number">2.1.1.</span> <span class="nav-text">XMLConfigBuilder</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90%E6%8F%92%E4%BB%B6"><span class="nav-number">2.1.2.</span> <span class="nav-text">解析插件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90Mapper%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6"><span class="nav-number">2.1.3.</span> <span class="nav-text">解析Mapper映射文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">解析二级缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90%E5%8A%A8%E6%80%81sql"><span class="nav-number">2.1.3.2.</span> <span class="nav-text">解析动态sql</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">2.2.</span> <span class="nav-text">SQL执行流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BAExecutor"><span class="nav-number">2.2.1.</span> <span class="nav-text">创建Executor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A7%E8%A1%8CSql"><span class="nav-number">2.2.2.</span> <span class="nav-text">执行Sql</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">数据库查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%92%E4%BB%B6%E7%9A%84%E8%B0%83%E7%94%A8"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">插件的调用</span></a></li></ol></li></ol></li></ol></li></ol>
    </div>
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            
<footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
                <span>2020</span> -
            
            2023
            
                &nbsp;<i class="fas fa-heart icon-animate"></i>
                &nbsp;<a href="/">liduoan.efls</a>
            
        </div>
        
            <script async data-pjax
                    src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                
                
                    总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.6.1</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item flex-center toggle-show-toc">
                <i class="fas fa-list"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="close-popup-btn">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/dark-light-toggle.js"></script>




    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/code-block.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/lazyload.js"></script>


<div class="post-scripts pjax">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/post-helper.js"></script>
        
            <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/libs/anime.min.js"></script>
        
        
            <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/toc.js"></script>
        
    
</div>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
