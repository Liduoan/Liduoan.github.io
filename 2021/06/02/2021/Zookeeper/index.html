<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="liduoan.efls">
    
    <title>
        
            Zookeeper |
        
        liduoan修炼笔记
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="https://i.postimg.cc/MpmSbVgT/4-U-3-AU-6-0-R8-L6-K5658-H.jpg">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/fontawesome.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/regular.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/solid.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/brands.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"zh-CN","path":"search.xml"}
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066cc","logo":"https://i.postimg.cc/MpmSbVgT/4-U-3-AU-6-0-R8-L6-K5658-H.jpg","favicon":"https://i.postimg.cc/MpmSbVgT/4-U-3-AU-6-0-R8-L6-K5658-H.jpg","avatar":"https://i.postimg.cc/MpmSbVgT/4-U-3-AU-6-0-R8-L6-K5658-H.jpg","font_size":null,"font_family":"STSong","hover":{"shadow":true,"scale":false},"first_screen":{"enable":true,"header_transparent":true,"background_img":"/images/bg.svg","description":"世之奇伟、瑰怪，非常之观，常在于险远 || 而人之所罕至焉，故非有志者不能至也","font_color":null,"hitokoto":false},"scroll":{"progress_bar":true,"percent":false}},"local_search":{"enable":true,"preload":true},"code_copy":{},"code_block":{"tools":{"enable":true,"style":"default"},"highlight_theme":"default"},"side_tools":{},"pjax":{"enable":true},"lazyload":{"enable":true},"comment":{"enable":false,"use":"valine","valine":{"appid":null,"appkey":null,"server_urls":null,"placeholder":null},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.8"},"waline":{"server_url":null,"reaction":false,"version":2}},"post":{"author_label":{"enable":true,"auto":true,"custom_label_list":["Trainee","Engineer","Architect"]},"word_count":{"enable":true,"wordcount":true,"min2read":true},"img_align":"left","copyright_info":true},"version":"3.6.1"}
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"}
    KEEP.language_code_block = {"copy":"复制代码","copied":"已复制","fold":"折叠代码块","folded":"已折叠"}
    KEEP.language_copy_copyright = {"copy":"复制版权信息","copied":"已复制","title":"原文标题","author":"原文作者","link":"原文链接"}
  </script>
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
                <a class="logo-image" href="/">
                    <img src="https://i.postimg.cc/MpmSbVgT/4-U-3-AU-6-0-R8-L6-K5658-H.jpg">
                </a>
            
            <a class="logo-title" href="/">
               liduoan修炼笔记
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            <div class="article-title">
                <span class="title-hover-animation">Zookeeper</span>
            </div>

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="https://i.postimg.cc/MpmSbVgT/4-U-3-AU-6-0-R8-L6-K5658-H.jpg">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">liduoan.efls</span>
                            
                                <span class="author-label">Lv4</span>
                            
                        </div>
                        <div class="meta-info">
                            
<div class="article-meta-info">
    <span class="article-date article-meta-item">
        
            <i class="fa-regular fa-calendar-plus"></i>&nbsp;
        
        <span class="pc">2021-06-02 18:13:54</span>
        <span class="mobile">2021-06-02 18:13</span>
    </span>
    
        <span class="article-update-date article-meta-item">
        <i class="fas fa-file-pen"></i>&nbsp;
        <span class="pc">2023-01-14 23:04:17</span>
    </span>
    
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/2021/">2021</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>12.7k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>50 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content keep-markdown-body">
                

                <span id="more"></span>

<h1 id="Zookeeper简介"><a href="#Zookeeper简介" class="headerlink" title="Zookeeper简介"></a>Zookeeper简介</h1><p>官方文档上这么解释Zookeeper，它是一个分布式协调框架，是Apache Hadoop 的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。 比如在早期的Dubbo中，通场使用Zookeeper作为注册中心。</p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>官方的解释有点抽象，我们暂时可以理解为Zookeeper是一个用于存储少量数据的基于内存的数据库，主要有如下两个核心的概念：<strong>文件系统数据结构</strong> 和 <strong>监听通知机制</strong>。</p>
<h3 id="文件系统数据结构"><a href="#文件系统数据结构" class="headerlink" title="文件系统数据结构"></a>文件系统数据结构</h3><p>Zookeeper维护一个类似文件系统的树型数据结构：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/06/02/1ZP6j9iLYwOEVGk.jpg"
                      alt="Screenshot_92.jpg"
                ></p>
<p>每个子目录项都被称作为 **znode(目录节点)**，和文件系统类似，我们能够自由的增加、删除znode，在一个znode下增加、删除子znode。 有以下几种类型的znode：</p>
<ul>
<li><strong>PERSISTENT­持久化目录节点</strong></li>
</ul>
<p>客户端与zookeeper断开连接后，该节点依旧存在，只要不手动删除该节点，将永远存在。</p>
<ul>
<li><strong>PERSISTENT_SEQUENTIAL­持久化顺序编号目录节点</strong></li>
</ul>
<p>客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号。</p>
<ul>
<li><strong>EPHEMERAL­临时目录节点</strong></li>
</ul>
<p>客户端与zookeeper断开连接后，该节点被删除。</p>
<ul>
<li><strong>EPHEMERAL_SEQUENTIAL­临时顺序编号目录节点</strong></li>
</ul>
<p>客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号。</p>
<ul>
<li><strong>Container 节点</strong></li>
</ul>
<p>3.5.3 版本新增，如果Container节点下面没有子节点，则Container节点在未来会被Zookeeper自动清除，定时任务默认60s检查一次。</p>
<ul>
<li><strong>TTL 节点</strong></li>
</ul>
<p>默认禁用，只能通过配置jvm参数<code>zookeeper.extendedTypesEnabled=true</code>开启，定时节点，到期会被自动删除，但是并不准确。</p>
<blockquote>
<p>Zookeeper由java编写，很多参数只能通过jvm参数配置，配置的地方在启动脚本<code>zkServer.sh</code>中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在ZOOMAIN中配置jvm参数</span></span><br><span class="line">ZOOMAIN=&quot;-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.local.only=$JMXLOCALONLY org.apache.zookeeper.server.quorum.QuorumPeerMain&quot;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/06/02/B7mAyL53I62QOV8.jpg"
                      alt="Screenshot_93.jpg"
                ></p>
<h3 id="监听通知机制"><a href="#监听通知机制" class="headerlink" title="监听通知机制"></a>监听通知机制</h3><p>客户端可以向Zookeeper服务器注册监听它关心的事件，Zookeeper提供了三种监听方式:</p>
<ol>
<li>可以注册对某个节点的监听，则当这个节点被删除，或者被修改时，对应的客户端将被通知。</li>
<li>可以注册对某个目录的监听，则当这个目录有子节点被创建，或者有子节点被删除，对应的客户端将被通知。</li>
<li>可以注册某个目录的递归子节点进行监听，则当这个目录下面的任意子节点有目录结构的变化（有子节点被创建，或被删除）或者根节点有数据变化时，对应的客户端将被通知。【是每个子节点都监听 并不是向2中一样某个目录出现事件就移除。</li>
</ol>
<p>注意：<strong>所有的通知都是一次性的，及无论是对节点还是对目录进行的监听，一旦触发，对应的监听即被移除。而递归子节点，监听是对所有子节点的，所以，每个子节点下面的事件同样只会被触发一次。如果需要一直监听，则需要不断添加监听。</strong></p>
<h2 id="Zookeeper应用场景"><a href="#Zookeeper应用场景" class="headerlink" title="Zookeeper应用场景"></a>Zookeeper应用场景</h2><ol>
<li>分布式配置中心</li>
<li>分布式注册中心</li>
<li>分布式锁</li>
<li>分布式队列</li>
<li>集群选举</li>
<li>分布式屏障</li>
<li>发布&#x2F;订阅</li>
</ol>
<h1 id="Zookeeper基本使用"><a href="#Zookeeper基本使用" class="headerlink" title="Zookeeper基本使用"></a>Zookeeper基本使用</h1><h2 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h2><p>Zookeeper需要java环境，首先确保至少安装了jdk8环境：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载zookeeper安装包</span></span><br><span class="line">wget https://mirror.bit.edu.cn/apache/zookeeper/zookeeper‐3.5.8/apache‐zookeepe r‐3.5.8‐bin.tar.gz </span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压安装包</span></span><br><span class="line">tar ‐zxvf apache‐zookeeper‐3.5.8‐bin.tar.gz </span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入目录</span></span><br><span class="line"><span class="built_in">cd</span> apache‐zookeeper‐3.5.8‐bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将conf目录中提供的配置文件复制一份，名字可以随意取</span></span><br><span class="line"><span class="built_in">cp</span> zoo_sample.cfg zoo.cfg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过zkServer.sh脚本启动zookeeper，指定配置文件</span></span><br><span class="line">bin/zkServer.sh start conf/zoo.cfg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过zkCli.sh脚本启动客户端，可以通过-server参数指定主机和IP</span></span><br><span class="line">bin/zkCli.sh ‐server ip:port</span><br></pre></td></tr></table></figure>

<h2 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h2><h3 id="Zookeeper集群简介"><a href="#Zookeeper集群简介" class="headerlink" title="Zookeeper集群简介"></a>Zookeeper集群简介</h3><p>Zookeeper 集群模式一共有三种类型的角色：</p>
<ul>
<li><strong>Leader</strong>: 处理所有的事务请求（读写请求，一个集群中只能有一个Leader。</li>
<li><strong>Follower</strong>：只能处理读请求，同时作为 Leader的候选节点，即如果Leader宕机，Follower节点要参与到新的Leader选举中，有可能成为新的Leader节点。</li>
<li><strong>Observer</strong>：只能处理读请求，不参与事务请求的过半机制和Leader选举。</li>
</ul>
<h3 id="集群配置文件"><a href="#集群配置文件" class="headerlink" title="集群配置文件"></a>集群配置文件</h3><p>本文在一台机器上启动四个Zookeeper实例组成集群，包括一个Leader、两个Follower和一个Obsrver。如果在不同的机器上搭建只需要修改IP即可。</p>
<ul>
<li>修改配置文件<code>zoo.cfg</code></li>
</ul>
<p>将<code>zoo.cfg</code>复制4份，取不同的文件名，进行如下配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 由于是在同一台机器上搭建，所以每个配置文件这两项都要不同</span></span><br><span class="line">dataDir=/usr/local/zookeeper/zookeeper‐1/data</span><br><span class="line">clientPort=2181 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 在结尾加上集群中四个节点的信息(不能有空格！！)</span></span><br><span class="line">server.1=localhost:2001:3001:participant <span class="comment"># participant可以不用写默认就是</span></span><br><span class="line">server.2=localhost:2002:3002:participant </span><br><span class="line">server.3=localhost:2003:3003:participant </span><br><span class="line">server.4=localhost:2004:3004:observer</span><br></pre></td></tr></table></figure>

<p>配置文件中参数配置说明</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>tickTime</td>
<td>用于配置Zookeeper中最小时间单位的长度。</td>
</tr>
<tr>
<td>initLimit</td>
<td>用于配置Leader服务器等待Follower启动，并完成数据同步的时间（initLimit*tickTime）。Follower服务器再启动过程中，会与Leader建立连接并完成数据的同步，从而确定自己对外提供服务的起始状态。Leader服务器允许Follower在initLimit时间内完成这个工作。</td>
</tr>
<tr>
<td>syncLimit</td>
<td>Leader与Follower心跳检测的最大延时时间（syncLimit*tickTime）</td>
</tr>
<tr>
<td>dataDir</td>
<td>Zookeeper保存数据的目录，默认情况下Zookeeper将写数据的日志文件也保存在这个目录里。</td>
</tr>
<tr>
<td>clientPort</td>
<td>客户端连接 Zookeeper 服务器的端口，Zookeeper 会监听这个端口，接受客户端的访问请求。</td>
</tr>
<tr>
<td>server.A&#x3D;B：C：D：E</td>
<td>其中A是一个数字，表示这个服务器的ID；B是这个服务器的ip地址；C 表示的是这个服务器与集群中的Leader服务器交换信息的端口；D是进行选举的端口，用来执行选举时服务器相互通信。如果需要通过添加不参与集群选举以及事务请求的过半机制的Observer节点，可以在E的位置添加observer标识。</td>
</tr>
</tbody></table>
<ul>
<li>创建节点标识文件</li>
</ul>
<p>在每个节点配置的<code>dataDir</code>目录下创建<code>myid</code>文件，内容分别为1、2、3、4四个数字，表示各个节点的id。</p>
<ul>
<li>查看集群状态</li>
</ul>
<p>启动四个节点，通过<code>zkServer.sh status</code>命令指定配置文件查看节点状态，可以看到Zookeeper集群会自动选出一个节点作为Leader</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/06/03/DqmvHT1eSWUaEB8.jpg"
                      alt="Screenshot_95.jpg"
                ></p>
<h3 id="集群动态配置-新"><a href="#集群动态配置-新" class="headerlink" title="集群动态配置(新)"></a>集群动态配置(新)</h3><p>Zookeeper 3.5.0 以前，Zookeeper集群角色要发生改变的话，只能通过停掉所有的Zookeeper服务，修改集群配置，重启服务来完成，这样集群服务将有一段不可用的状态。为了应对高可用需求，Zookeeper 3.5.0 提供了支持动态扩容&#x2F;缩容的新特性。但是通过客户端API可以变更服务端集群状态是件很危险的事情，所以在Zookeeper 3.5.3 版本要用动态配置，需要开启<strong>超级管理员身份</strong>。如果是在一个安全的环境也可以通过配置jvm参数<code>-Dzookeeper.skipACL=yes</code>来避免配置维护ACL权限配置。</p>
<ul>
<li>首先开启超级管理员身份或者跳过ACL。</li>
<li>修改配置文件<code>zoo.cfg</code></li>
</ul>
<ol>
<li>去除端口号<code>clientPort</code>配置项</li>
<li>配置<code>reconfigEnabled</code>为true</li>
<li>通过<code>dynamicConfigFile</code>指定动态配置文件的路径，注意需要指定文件名，如<code>zoo1_re.cfg.dynamic</code></li>
</ol>
<ul>
<li>创建配置文件<code>zoo1_re.cfg.dynamic</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server.1=192.168.74.88:2001:3001:participant;192.168.74.88:2181</span><br><span class="line">server.2=192.168.74.88:2002:3002:participant;192.168.74.88:2182 </span><br><span class="line">server.3=192.168.74.88:2003:3003:participant;192.168.74.88:2183 </span><br><span class="line">server.4=192.168.74.88:2004:3004:observer;192.168.74.88:2184</span><br></pre></td></tr></table></figure>

<ul>
<li>接着按照如上步骤修改剩余3台服务器配置</li>
<li>启动所有的服务器后，连接上任意一台，即可开始操作</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看集群配置</span></span><br><span class="line">config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 该节点存储了集群信息</span></span><br><span class="line">get /zookeeper/config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除serverId为3的机器</span></span><br><span class="line">reconfig ‐remove 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加机器</span></span><br><span class="line">reconfig ‐add server.3=192.168.74.88:2003:3003:participant;192.168.74.88:2183</span><br></pre></td></tr></table></figure>

<h2 id="命令行操作Zookeeper"><a href="#命令行操作Zookeeper" class="headerlink" title="命令行操作Zookeeper"></a>命令行操作Zookeeper</h2><p>登陆后，通过<code>help</code>命令可以查看Zookeeper所有命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ZooKeeper -server host:port cmd args</span><br><span class="line">        addauth scheme auth</span><br><span class="line">        close </span><br><span class="line">        config [-c] [-w] [-s]</span><br><span class="line">        connect host:port</span><br><span class="line">        create [-s] [-e] [-c] [-t ttl] path [data] [acl]</span><br><span class="line">        delete [-v version] path</span><br><span class="line">        deleteall path</span><br><span class="line">        delquota [-n|-b] path</span><br><span class="line">        get [-s] [-w] path</span><br><span class="line">        getAcl [-s] path</span><br><span class="line">        <span class="built_in">history</span> </span><br><span class="line">        listquota path</span><br><span class="line">        <span class="built_in">ls</span> [-s] [-w] [-R] path</span><br><span class="line">        ls2 path [watch]</span><br><span class="line">        printwatches on|off</span><br><span class="line">        quit </span><br><span class="line">        reconfig [-s] [-v version] [[-file path] | [-members serverID=host:port1:port2;port3[,...]*]] | [-add serverId=host:port1:port2;port3[,...]]* [-remove serverId[,...]*]</span><br><span class="line">        redo cmdno</span><br><span class="line">        removewatches path [-c|-d|-a] [-l]</span><br><span class="line">        rmr path</span><br><span class="line">        <span class="built_in">set</span> [-s] [-v version] path data</span><br><span class="line">        setAcl [-s] [-v version] [-R] path acl</span><br><span class="line">        setquota -n|-b val path</span><br><span class="line">        <span class="built_in">stat</span> [-w] path</span><br><span class="line">        <span class="built_in">sync</span> path</span><br></pre></td></tr></table></figure>

<h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><p>通过如下命令创建节点：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create [‐s] [‐e] [‐c] [‐t ttl] path [data] [acl]</span><br><span class="line"><span class="comment"># -s: 顺序节点 </span></span><br><span class="line"><span class="comment"># -e: 临时节点 </span></span><br><span class="line"><span class="comment"># -c: 容器节点 </span></span><br><span class="line"><span class="comment"># -t: 可以给节点添加过期时间ttl，默认禁用，需要通过系统参数启用</span></span><br><span class="line"><span class="comment"># path: 必须要写，节点的路径</span></span><br><span class="line"><span class="comment"># data: 创建节点时可以给节点添加数据</span></span><br><span class="line"><span class="comment"># acl: 用于权限控制</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Zookeeper中没有相对路径的说法，所有的路径都必须以<code>/</code>开头。</p>
</blockquote>
<ul>
<li>创建持久化节点</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create /test somedata</span><br></pre></td></tr></table></figure>

<p>没有加任何可选节点类型的参数，创建的就是持久化节点。</p>
<ul>
<li>创建临时节点</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create ‐e /test somedata</span><br></pre></td></tr></table></figure>

<p>临时节点不能有子节点。</p>
<ul>
<li>创建顺序节点</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create ‐s /test/ data</span><br></pre></td></tr></table></figure>

<p>创建顺序节点时可以不写节点名称，Zookeeper会自动在节点名称后添加10位的序号，序号依次递增。当然也可以传入一个节点名称作为前缀。</p>
<ul>
<li>创建容器节点</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create ‐c /test</span><br></pre></td></tr></table></figure>

<p>容器节点主要用来容纳子节点，如果没有给其创建子节点，容器节点表现和持久化节点一样，如果给容器节点创建了子节点，后续又把子节点清空，那么容器节点也会被Zookeeper删除。</p>
<ul>
<li>创建子节点</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create /test/test‐sub</span><br></pre></td></tr></table></figure>

<p>由于Zookeeper中没有相对路径的概念，所以所有的路径都必须以<code>/</code>开头，从头开始写。</p>
<h3 id="修改节点"><a href="#修改节点" class="headerlink" title="修改节点"></a>修改节点</h3><p>Zookeeper中只能修改节点数据，而不能修改节点名称：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加-v参数可传入version版本号，如果版本不匹配则修改失败</span></span><br><span class="line"><span class="built_in">set</span> [-v version] /test somenewdata</span><br></pre></td></tr></table></figure>

<h3 id="查看节点"><a href="#查看节点" class="headerlink" title="查看节点"></a>查看节点</h3><ul>
<li>查看子节点</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加上-R参数可以递归查看所有子节点</span></span><br><span class="line"><span class="built_in">ls</span> [-R] /test</span><br></pre></td></tr></table></figure>

<ul>
<li>查看节点数据</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get /test</span><br></pre></td></tr></table></figure>

<ul>
<li>查看节点状态</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stat</span> /test</span><br></pre></td></tr></table></figure>

<p>节点状态包含如下信息：</p>
<ol>
<li>cZxid：创建znode的事务ID（Zxid的值）。</li>
<li>mZxid：最后修改znode的事务ID。</li>
<li>pZxid：最后添加或删除子节点的事务ID（子节点列表发生变化才会发生改变）。</li>
<li>time：znode创建时间。</li>
<li>mtime：znode最近修改时间。</li>
<li>dataVersion：znode的当前数据版本。</li>
<li>cversion：znode的子节点结果集版本（一个节点的子节点增加、删除都会影响这个版本）。</li>
<li>aclVersion：表示对此znode的acl版本。</li>
<li>ephemeralOwner：znode是临时znode时，表示znode所有者的 session ID。 如果znode不是临时znode，则该字段设置为零。</li>
<li>dataLength：znode数据字段的长度。numChildren：znode的子znode的数量。</li>
</ol>
<ul>
<li>查看节点状态信息同时查看数据</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get -s /test</span><br></pre></td></tr></table></figure>

<blockquote>
<p>根据状态数据中的版本号，可以实现<strong>乐观锁</strong>的功能，应用于并发修改数据的场景：</p>
<ol>
<li>客户端先通过<code>get -s</code>命令获取数据和版本信息</li>
<li>接着通过<code>set -v</code>修改数据时候把版本号带上</li>
</ol>
<p>在执行上面set命令前，如果有别的客户端修改了数据，Zookeeper会递增版本号， 这时如果再用以前的版本号去修改则会修改失败。</p>
</blockquote>
<h3 id="创建监听"><a href="#创建监听" class="headerlink" title="创建监听"></a>创建监听</h3><p>Zookeeper事件类型如下：</p>
<ol>
<li>None: 连接建立事件</li>
<li>NodeCreated： 节点创建</li>
<li>NodeDeleted： 节点删除</li>
<li>NodeDataChanged：节点数据变化</li>
<li>NodeChildrenChanged：子节点列表变化</li>
<li>DataWatchRemoved：节点监听被移除</li>
<li>ChildWatchRemoved：子节点监听被移除</li>
</ol>
<p>Zookeeper中，无论是何种监听方式，对于每个不同路径的节点都只能监听一次事件，之后事件将被移除。</p>
<ul>
<li>对节点的监听</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注册监听的同时获取数据 </span></span><br><span class="line">get ‐w /test </span><br><span class="line"></span><br><span class="line"><span class="comment"># 对节点进行监听，且获取元数据信息</span></span><br><span class="line"><span class="built_in">stat</span> ‐w /test</span><br></pre></td></tr></table></figure>

<p>当节点被修改时会接收到事件，并且事件会被移除。</p>
<ul>
<li>对目录的监听</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -w /test</span><br></pre></td></tr></table></figure>

<p>对某个目录添加监听时，仅仅针对其子节点（不能递归监听）的添加或者删除，而不会监听数据变化。且事件一旦触发，对应的监听也会被移除。</p>
<ul>
<li>对目录递归的监听</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -R -w /test</span><br></pre></td></tr></table></figure>

<p>对目录进行递归监听，可以递归监听其中的所有节点的添加或者删除。每个不同路径的节点可以监听一次。</p>
<ul>
<li>移除监听</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">removewatches /test</span><br></pre></td></tr></table></figure>

<h3 id="ACL权限控制"><a href="#ACL权限控制" class="headerlink" title="ACL权限控制"></a>ACL权限控制</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Zookeeper的ACL( Access Control List ) 权限控制，可以控制节点的读写操作，保证数据的安全性。Zookeeper 的ACL权限设置分为 3 部分组成：</p>
<p><strong>权限模式</strong>（Scheme）、<strong>授权对象</strong>（ID）、<strong>权限信息</strong>（Permission）。</p>
<p>最终组成一条类似<code>scheme:id:permission</code>格式的ACL请求信息。下面我们具体看一下这 3 部分代表什么意思：</p>
<ul>
<li><strong>权限模式（Scheme）</strong></li>
</ul>
<p>用来设置 ZooKeeper 服务器进行权限验证的方式。ZooKeeper 的权限验证方式大体分为两种类型：</p>
<ol>
<li><strong>范围验证</strong>。所谓的范围验证就是说 ZooKeeper 可以针对一个 IP 或者一段 IP 地址授予某种权限。比如我们可以让一个 IP 地址为<code>192.168.74.77</code>的机器对服务器上的某个数据节点具有写入的权限。或者也可以通过<code>192.168.74.77/24</code>给一段 IP 地址的机器赋权。</li>
<li><strong>口令验证</strong>。也就是用户名密码的方式。在 ZooKeeper 中这种验证方式是 Digest 认证，而 Digest 这种认证方式首先在客户端传送<code>username:password</code>这种形式的权限表示符后，ZooKeeper 服务端会对密码部分使用 SHA-1 和 BASE64 算法进行加密，以保证安全性。还有一种 Super 权限模式，Super可以认为是一种特殊的 Digest 认证。具有 Super 权限的客户端可以对 ZooKeeper 上的任意数据节点进行任意操作。</li>
</ol>
<ul>
<li><strong>授权对象（ID）</strong></li>
</ul>
<p>授权对象就是说我们要把权限赋予谁，而对应于 4 种不同的权限模式来说，如果我们选择采用 IP 方式，使用的授权对象可以是一个 IP 地址或 IP 地址段；而如果使用 Digest 或 Super 方式，则对应于一个用户名。另外如果是 World 模式，是授权系统中所有的用户。</p>
<ul>
<li><strong>权限信息（Permission）</strong></li>
</ul>
<p>权限就是指我们可以在数据节点上执行的操作种类，在 ZooKeeper 中已经定义好的权限有 5 种：</p>
<ol>
<li>数据节点（c: create）创建权限，授予权限的对象可以在数据节点下创建子节点；</li>
<li>数据节点（w: wirte）更新权限，授予权限的对象可以更新该数据节点；</li>
<li>数据节点（r: read）读取权限，授予权限的对象可以读取该节点的内容以及子节点的列表信息；</li>
<li>数据节点（d: delete）删除权限，授予权限的对象可以删除该数据节点的子节点；</li>
<li>数据节点（a: admin）管理者权限，授予权限的对象可以对该数据节点体进行 ACL 权限设置。</li>
</ol>
<blockquote>
<p>可以通过配置jvm参数<code>zookeeper.skipACL=yes</code>，使ACL不再进行权限检测。</p>
</blockquote>
<h4 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h4><ul>
<li>Digest 密文认证方式</li>
</ul>
<p>首先先通过如下命令对密码进行加密，在Linux命令行输入即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># user表示用户名,password表示密码</span></span><br><span class="line"><span class="built_in">echo</span> -n liduoan:123456 | openssl dgst -binary -sha1 | openssl <span class="built_in">base64</span></span><br><span class="line">nPDrrZYJrye2xSzRMayVFW17lXI=</span><br><span class="line"><span class="comment"># 假设用户名密码为liduoan:123456得到的结果为PoFrAp0Ngx6FWzLetiQRKMMWXDA=</span></span><br></pre></td></tr></table></figure>

<p>接着开始创建ACL，格式为<code>模式:用户名:加密后的密码:权限</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以在创建节点的时候就创建ACL，此时必须传入节点数据，否则会将acl信息当成数据</span></span><br><span class="line">create /test somedate digest:liduoan:nPDrrZYJrye2xSzRMayVFW17lXI=:cdrwa</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过setAcl命令给节点设置ACL</span></span><br><span class="line">setAcl /test digest:liduoan:nPDrrZYJrye2xSzRMayVFW17lXI=:cdrwa</span><br></pre></td></tr></table></figure>

<p>这样就添加ACL成功了，只有对应的用户才有访问该节点的权限。现在访问该节点，会报如下错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.zookeeper.KeeperException<span class="variable">$NoAuthException</span>: KeeperErrorCode = NoAuth <span class="keyword">for</span> /zk-node</span><br></pre></td></tr></table></figure>

<p>要通过如下命令进行授权信息添加后，才能访问该节点：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addauth digest liduoan:123456</span><br></pre></td></tr></table></figure>

<ul>
<li>Auth 明文认证方式</li>
</ul>
<p>口令验证的另一种方式是明文认证，可以直接添加授权信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addauth digest liduoan:654321</span><br></pre></td></tr></table></figure>

<p>注册完后可以直接使用明文授权，格式为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意模式为auth</span></span><br><span class="line">create /test somedate auth:liduoan:654321:cdwra</span><br></pre></td></tr></table></figure>

<ul>
<li>IP授权模式</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建节点时授权</span></span><br><span class="line">create /test somedate ip:192.168.74.88:cdwra</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过setAcl命令授权</span></span><br><span class="line">setAcl /test ip:192.168.74.88:cdwra</span><br></pre></td></tr></table></figure>

<p>多个ip可以用逗号分隔。</p>
<ul>
<li>Super超级管理员模式</li>
</ul>
<p>在Super模式下超级管理员用户可以对Zookeeper上的节点进行任何的操作，需要通过jvm参数开启：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zookeeper.DigestAuthenticationProvider.superDigest=&lt;用户名&gt;:&lt;加密后的密码&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>查询ACL信息</li>
</ul>
<p>可以通过如下命令查询节点的ACL信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getACL /test</span><br></pre></td></tr></table></figure>

<h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>Zookeeper数据的组织形式为一个类似文件系统的数据结构，而这些数据都是存储在内存中的，所以可以认为Zookeeper是一个基于内存的小型数据库。Zookeeper有两种持久化文件：</p>
<h4 id="事务日志log"><a href="#事务日志log" class="headerlink" title="事务日志log"></a>事务日志log</h4><p>针对每一次客户端的事务操作，Zookeeper都会将他们记录到事务日志中，当然，Zookeeper也会将数据变更应用到内存数据库中。我们可以在zookeeper的主配置文件<code>zoo.cfg</code>中配置内存中的数据持久化目录，也就是事务日志的存储路径<code>dataLogDir</code>， 如果没有配置该项，那么事务日志将存储到<code>dataDir</code>配置的目录。Zookeeper提供了格式化工具可以进行数据查看事务日志数据：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最后一项为log日志文件的路径</span></span><br><span class="line">java -classpath .:slf4j-api-1.7.25.jar:zookeeper-3.5.8.jar:zookeeper-jute-3.5.8.jar org.apache.zookeeper.server.LogFormatter /tmp/zookeeper/version-2/log.1</span><br></pre></td></tr></table></figure>

<p>执行结果如下所示：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/06/02/sHgwJIcFAVvxEye.jpg"
                      alt="Screenshot_94.jpg"
                ></p>
<p>从左到右分别记录了操作时间、客户端会话ID、CXID、ZXID、操作类型、节点路径、节点数据（用<code>#+ascii码</code>表示）、节点版本。</p>
<p>Zookeeper进行事务日志文件操作的时候会频繁进行磁盘IO操作，事务日志的不断追加写操作会触发底层磁盘IO为文件开辟新的磁盘块，即磁盘Seek。因此，为了提升磁盘IO的效率，Zookeeper在创建事务日志文件的时候就进行文件空间的预分配，即在创建文件的时候，就向操作系统申请一块大一点的磁盘块。这个预分配的磁盘大小可以通过jvm参数<code>zookeeper.preAllocSize</code>进行配置。</p>
<p>事务日志文件名为 <code>log.当前最大事务ID</code>，因为日志文件是顺序写入的，所以我们可以根据日志文件名找到对应事务。如果文件满了会创建新的日志文件继续写入。</p>
<h4 id="数据快照snapshot"><a href="#数据快照snapshot" class="headerlink" title="数据快照snapshot"></a>数据快照snapshot</h4><p>数据快照用于记录Zookeeper服务器上某一时刻的全量数据，并将其写入到指定的磁盘文件中。可以通过配置文件中的<code>snapCount</code>配置每间隔多少个事务请求生成快照，数据存储在<code>dataDir</code>指定的目录中。</p>
<p>Zookeeper为了避免集群中所有机器在同一时间进行快照，实际的快照生成时机可能和配置文件中配置的有所不同，实际是经过<code>snapCount/2 + Random(1,snapCount/2)</code> 个事务数时开始快照。Zookeeper提供了格式化工具可以进行数据查看快照数据：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最后一项为snapshot快照文件的路径</span></span><br><span class="line">java -classpath :slf4j-api-1.7.25.jar:zookeeper-3.5.8.jar:zookeeper-jute-3.5.8.jar org.apache.zookeeper.server.SnapshotFormatter /tmp/zookeeper/version-2/snapshot.0</span><br></pre></td></tr></table></figure>

<p>快照数据文件名为同样为<code>snapshot.当前最大事务ID</code>。如果文件满了会创建新的快照文件继续写入。</p>
<blockquote>
<p>有了事务日志，为啥还要快照数据快照？</p>
<p><strong>Zookeeper中的事务日志与数据快照的关系，类似于Redis中RDB与AOF的关系。</strong>数据快照是达到某种设定条件下的内存全量数据，主要是为了快速恢复，而事务日志文件是每次事务请求都会进行追加的操作。所以通常快照数据是反应当时内存数据的状态，而事务日志是更全面的数据。所以恢复数据的时候，可以先恢复快照数据，再通过增量恢复事务日志中的数据即可。</p>
</blockquote>
<h2 id="客户端使用"><a href="#客户端使用" class="headerlink" title="客户端使用"></a>客户端使用</h2><h3 id="Zookeeper原生客户端"><a href="#Zookeeper原生客户端" class="headerlink" title="Zookeeper原生客户端"></a>Zookeeper原生客户端</h3><p>Zookeeper官方的客户端没有和服务端代码分离，他们为同一个jar文件，所以我们直接引入Zookeeper的maven即可，这里版本请保持与服务端版本一致，不然会有很多兼容性的问题：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="创建客户端实例"><a href="#创建客户端实例" class="headerlink" title="创建客户端实例"></a>创建客户端实例</h4><p>在操作Zookeeper之前，首先需要创建一个Zookeeper客户端实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZkTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Zookeeper客户端</span></span><br><span class="line">    ZooKeeper zooKeeper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建一个countDownLatch</span></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 创建一个Zookeeper中的监听器Watcher，用于监听连接事件 </span></span><br><span class="line">        <span class="type">Watcher</span> <span class="variable">watcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Watcher</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="comment">// 实现监听器的process方法</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(WatchedEvent watchedEvent)</span> &#123;</span><br><span class="line">                <span class="comment">// 获取事件的类型</span></span><br><span class="line">                Event.<span class="type">EventType</span> <span class="variable">type</span> <span class="operator">=</span> watchedEvent.getType();</span><br><span class="line">                <span class="comment">// 获取事件状态</span></span><br><span class="line">                Event.<span class="type">KeeperState</span> <span class="variable">state</span> <span class="operator">=</span> watchedEvent.getState();</span><br><span class="line">                <span class="comment">// 如果类型为None并且事件状态为SyncConnected表示连接成功</span></span><br><span class="line">                <span class="keyword">if</span> (type == Event.EventType.None &amp;&amp; state == Event.KeeperState.SyncConnected) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;连接成功！&quot;</span>);</span><br><span class="line">                    <span class="comment">// 主线程放行</span></span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 创建客户端实例ZooKeeper</span></span><br><span class="line">        zooKeeper = <span class="keyword">new</span> <span class="title class_">ZooKeeper</span>(<span class="string">&quot;192.168.74.88&quot;</span>, <span class="number">30</span> * <span class="number">1000</span>, watcher);</span><br><span class="line">        log.info(<span class="string">&quot;正在连接！&quot;</span>);</span><br><span class="line">        <span class="comment">// 主线程等待客户端连接完成后再往下继续运行</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Zookeeper客户端的连接是异步的，发送请求与接收事件通知由<strong>sendThread</strong>和<strong>eventThread</strong>两个线程完成，所以想要主线程等待连接完成后再往下走，需要等待客户端连接成功后才能放行。</p>
</blockquote>
<p>创建Zookeeper客户端实例包括以下参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>*connectString</td>
<td>ZooKeeper服务器列表，由英文逗号分开的 host:port 字符串组成。另外，也可以在其中设置客户端连接上ZooKeeper后的根目录，这样该客户端连接上ZooKeeper服务器之后，所有对ZooKeeper的操作都会基于这个根目录。</td>
</tr>
<tr>
<td>*sessionTimeout</td>
<td>会话的超时时间，是一个以毫秒为单位的整型值。在ZooKeeper中有会话的概念，在一个会话周期内，ZooKeeper客户端和服务器之间会通过心跳检测机制来维持会话的有效性，一旦在sessionTimeout时间内没有进行有效的心跳检测，会话就会失效。</td>
</tr>
<tr>
<td>*watcher</td>
<td>ZooKeeper允许客户端在构造方法中传入一个接口Watcher的实现类对象来作为默认的 Watcher事件通知处理器。该参数可以设置为null以表明不需要设置默认的Watcher处理器。</td>
</tr>
<tr>
<td>canBeReadOnly</td>
<td>这是一个boolean类型的参数，用于标识当前会话是否支持只读模式。默认情况下，ZooKeeper集群中一个机器如果和集群中过半及以上机器失去了网络连接，那么这个机器将不再处理客户端请求（包括读写请求)。但是在某些使用场景下，当ZooKeeper服务器发生此类故障的时候，我们还是希望ZooKeeper服务器能够提供读服务，可以将其设置为true。</td>
</tr>
<tr>
<td>sessionId</td>
<td>会话ID</td>
</tr>
<tr>
<td>sessionPassword</td>
<td>会话秘钥，与会话ID两个参数能够唯一确定一个会话，同时客户端使用这两个参数可以实现客户端会话复用，从而达到恢复会话的效果。</td>
</tr>
</tbody></table>
<h4 id="创建节点-1"><a href="#创建节点-1" class="headerlink" title="创建节点"></a>创建节点</h4><ul>
<li>同步创建</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createNode</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 通过create方法创建节点</span></span><br><span class="line">    <span class="comment">// 参数：节点路径、节点数据、ACL、节点类型</span></span><br><span class="line">    zooKeeper.create(<span class="string">&quot;/test&quot;</span>,</span><br><span class="line">                     <span class="string">&quot;liduoan&quot;</span>.getBytes(), </span><br><span class="line">                     ZooDefs.Ids.OPEN_ACL_UNSAFE,</span><br><span class="line">                     CreateMode.PERSISTENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>异步创建</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createNode</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException &#123;</span><br><span class="line">    zooKeeper.create(<span class="string">&quot;/test&quot;</span>,</span><br><span class="line">            <span class="string">&quot;liduoan&quot;</span>.getBytes(),</span><br><span class="line">            ZooDefs.Ids.OPEN_ACL_UNSAFE,</span><br><span class="line">            CreateMode.PERSISTENT,</span><br><span class="line">            <span class="comment">// 传入异步回调接口的实现，这里选择StringCallback接口</span></span><br><span class="line">            <span class="comment">// 参数：结果返回码、节点路径、上下文、节点名称(和路径一样，除非是顺序节点)</span></span><br><span class="line">            (rc, path, ctx, name) -&gt; log.info(<span class="string">&quot;rc &#123;&#125;,path &#123;&#125;,ctx &#123;&#125;,name &#123;&#125;&quot;</span>, rc, path, ctx, name),</span><br><span class="line">            <span class="comment">// 上下文String类型</span></span><br><span class="line">            <span class="string">&quot;context&quot;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修改节点-1"><a href="#修改节点-1" class="headerlink" title="修改节点"></a>修改节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 创建一个节点状态对象，用于接收节点状态信息</span></span><br><span class="line">    <span class="type">Stat</span> <span class="variable">stat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stat</span>();</span><br><span class="line">    <span class="comment">// 通过getData方法获取节点</span></span><br><span class="line">    <span class="comment">// 参数：节点路径、Watcher监听器、节点状态对象</span></span><br><span class="line">    <span class="type">byte</span>[] data = zooKeeper.getData(<span class="string">&quot;/test&quot;</span>, <span class="literal">false</span>, stat);</span><br><span class="line">    <span class="comment">// 通过setData方法获取节点</span></span><br><span class="line">    <span class="comment">// 参数：节点路径、节点数据、版本号</span></span><br><span class="line">    zooKeeper.setData(<span class="string">&quot;/test&quot;</span>, <span class="string">&quot;liduoan&quot;</span>.getBytes(),stat.getVersion());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异步修改方式和创建一样。</p>
<h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 通过delete方法删除节点</span></span><br><span class="line">    <span class="comment">// 参数：节点路径、版本号(-1代表匹配所有版本号)</span></span><br><span class="line">    zooKeeper.delete(<span class="string">&quot;/test&quot;</span>, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异步删除方式和创建一样。</p>
<h4 id="创建监听-1"><a href="#创建监听-1" class="headerlink" title="创建监听"></a>创建监听</h4><p>Zookeeper中的监听是一次性的，如果想要对同一个节点进行持续监听，每次接收到事件后都需要重新添加监听。在Zookeeper原生客户端中需要我们自己完成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listen</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 创建状态对象</span></span><br><span class="line">    <span class="type">Stat</span> <span class="variable">state</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stat</span>();</span><br><span class="line">    <span class="comment">// 创建监听器</span></span><br><span class="line">    <span class="type">Watcher</span> <span class="variable">watcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Watcher</span>() &#123;</span><br><span class="line">        <span class="meta">@SneakyThrows</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(WatchedEvent event)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (event.getType() == Event.EventType.NodeDataChanged</span><br><span class="line">                    &amp;&amp; event.getState() == Event.KeeperState.SyncConnected) &#123;</span><br><span class="line">	<span class="comment">// 监听到节点数据变化后，重新添加监听</span></span><br><span class="line">                <span class="type">byte</span>[] data = zooKeeper.getData(<span class="string">&quot;/test&quot;</span>, <span class="built_in">this</span>, state);</span><br><span class="line">                log.info(<span class="string">&quot;data &#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>(data));     </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 获取节点数据，添加监听器</span></span><br><span class="line">    <span class="type">byte</span>[] data = zooKeeper.getData(<span class="string">&quot;/test&quot;</span>, watcher, state);</span><br><span class="line">    log.info(<span class="string">&quot;data &#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>(data));</span><br><span class="line">    Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上代码就可以实现对<code>/test</code>节点数据的持续监听。</p>
<h3 id="Curator客户端"><a href="#Curator客户端" class="headerlink" title="Curator客户端"></a>Curator客户端</h3><p>Curator是一套由Netflix公司开源的，Java语言编程的ZooKeeper客户端框架，Curator项目是现在ZooKeeper客户端中使用最多，对ZooKeeper版本支持最好的第三方客户端，并推荐使用，Curator把我们平时常用的很多ZooKeeper服务开发功能做了封装，例如<strong>Leader选举、分布式计数器、分布式锁</strong>。</p>
<p>这就减少了技术人员在使用ZooKeeper时的大部分底层细节开发工作。在会话重新连接、Watch反复注册、多种异常处理等使用场景中，用原生的ZooKeeper处理比较复杂。而在使用 Curator 时，由于其对这些功能都做了高度的封装，使用起来更加简单，不但减少了开发时间，而且增强了程序的可靠性。 在项目中导入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--包括 curator-framework 包：该包是对ZooKeeper底层API的一些封装</span></span><br><span class="line"><span class="comment">    另一个是 curator-recipes 包：</span></span><br><span class="line"><span class="comment">该包封装了一些ZooKeeper服务的高级特性，如Cache事件监听、选举、分布式锁、分布式 Barrier--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-x-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="创建客户端实例-1"><a href="#创建客户端实例-1" class="headerlink" title="创建客户端实例"></a>创建客户端实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">zkdemo</span> &#123;</span><br><span class="line">    CuratorFramework curatorFramework;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">         <span class="comment">//创建重试策略</span></span><br><span class="line">         <span class="type">RetryPolicy</span> <span class="variable">retryPolicy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExponentialBackoffRetry</span>(<span class="number">5000</span>, <span class="number">30</span>);</span><br><span class="line">         <span class="comment">//构建者模式</span></span><br><span class="line">         curatorFramework = CuratorFrameworkFactory.builder()</span><br><span class="line">                 <span class="comment">//服务器地址</span></span><br><span class="line">                 .connectString(<span class="string">&quot;192.168.93.128:2181&quot;</span>)</span><br><span class="line">                 <span class="comment">//重试策略</span></span><br><span class="line">                 .retryPolicy(retryPolicy)</span><br><span class="line">                 <span class="comment">//会话过期事件</span></span><br><span class="line">                 .sessionTimeoutMs(<span class="number">30</span> * <span class="number">1000</span>)</span><br><span class="line">                 <span class="comment">//会话超时事件</span></span><br><span class="line">                 .connectionTimeoutMs(<span class="number">5000</span>)</span><br><span class="line">                 <span class="comment">//是否支持只读模式</span></span><br><span class="line">                 .canBeReadOnly(<span class="literal">true</span>)</span><br><span class="line">                 .build();</span><br><span class="line">         curatorFramework.getConnectionStateListenable().addListener(</span><br><span class="line">                 (Client, newState) -&gt; &#123;</span><br><span class="line">                     <span class="keyword">if</span> (newState == ConnectionState.CONNECTED) &#123;</span><br><span class="line">                         log.info(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">         );</span><br><span class="line">         <span class="comment">//启动客户端 连接服务器</span></span><br><span class="line">         curatorFramework.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建Curator客户端的参数和Zookeeper原生客户端差不多，其中多了两项</p>
<ul>
<li><strong>重试策略</strong></li>
</ul>
<table>
<thead>
<tr>
<th>策略名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ExponentialBackoffRetry</td>
<td>重试一组次数，重试之间的睡眠时间增加</td>
</tr>
<tr>
<td>RetryNTimes</td>
<td>重试最大次数</td>
</tr>
<tr>
<td>RetryOneTime</td>
<td>只重试一次</td>
</tr>
<tr>
<td>RetryUntilElapsed</td>
<td>在给定的时间结束之前重试</td>
</tr>
</tbody></table>
<p>当客户端异常退出或者与服务端失去连接的时候，可以通过设置客户端重新连接ZooKeeper服务端。</p>
<p>而 Curator 提供 一次重试、多次重试等不同种类的实现方式。</p>
<p>在Curator内部，可以通过判断服务器返回keeperException的状态代码来判断是否进行重试处理，如果返回的是<code>OK</code>表示一切操作都没有问题，而<code>SYSTEMERROR</code>表示系统或服务端错误。</p>
<ul>
<li><strong>超时时间</strong></li>
</ul>
<p>Curator客户端创建过程中，有两个超时时间的设置。一个是<code>sessionTimeoutMs</code>会话超时时间，用来设置该条会话在ZooKeeper服务端的失效时间。</p>
<p>另一个是<code>connectionTimeoutMs</code>客户端创建会话的超时时间，用来限制客户端发起一个会话连接到接收ZooKeeper服务端应答的时间。可以理解为参数<code>sessionTimeoutMs</code> 作用在服务端，而<code>connectionTimeoutMs</code>作用在客户端。</p>
<h4 id="创建节点-2"><a href="#创建节点-2" class="headerlink" title="创建节点"></a>创建节点</h4><p>Curator中采用了流式编程的风格，创建节点的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createNode</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> curatorFramework</span><br><span class="line">        .create()</span><br><span class="line">        <span class="comment">// protection模式，防止由于异常导致僵尸节点</span></span><br><span class="line">        <span class="comment">// 会给节点加上一个uuid,可以失败重试并且防止多次创建</span></span><br><span class="line">        .withProtection() </span><br><span class="line">        .withMode(CreateMode.PERSISTENT)</span><br><span class="line">        <span class="comment">//节点名为/test</span></span><br><span class="line">        .forPath(<span class="string">&quot;/test&quot;</span>);</span><br><span class="line">    log.info(<span class="string">&quot;path &#123;&#125;&quot;</span>, path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，Curator可以直接一次性创建带层级结构的节点，而Zookeeper原生客户端不可以：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createNode</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> curatorFramework</span><br><span class="line">        .create()</span><br><span class="line">        .creatingParentsIfNeeded()</span><br><span class="line">        .withMode(CreateMode.PERSISTENT)</span><br><span class="line">        .forPath(<span class="string">&quot;/test/test-son&quot;</span>);</span><br><span class="line">    <span class="comment">//和单一节点一致的做法</span></span><br><span class="line">    log.info(<span class="string">&quot;path &#123;&#125;&quot;</span>, path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getData</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123; </span><br><span class="line">    <span class="comment">// 在forPath之前可以通过usingWatcher添加Watcher监听，和Zookeeper原生客户端用法一致</span></span><br><span class="line">    <span class="type">byte</span>[] bytes = curatorFramework.getData().forPath(<span class="string">&quot;/test&quot;</span>); </span><br><span class="line">    log.info(<span class="string">&quot;get data from node :&#123;&#125;&quot;</span>,<span class="keyword">new</span> <span class="title class_">String</span>(bytes)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修改节点-2"><a href="#修改节点-2" class="headerlink" title="修改节点"></a>修改节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123; </span><br><span class="line">    <span class="comment">//参数为 路径  数据Bytes</span></span><br><span class="line">    curatorFramework.setData().forPath(<span class="string">&quot;/test&quot;</span>,<span class="string">&quot;newdata!&quot;</span>.getBytes()); </span><br><span class="line">    <span class="type">byte</span>[] bytes = curatorFramework.getData().forPath(<span class="string">&quot;/test&quot;</span>); </span><br><span class="line">    log.info(<span class="string">&quot;get data from node :&#123;&#125;&quot;</span>,<span class="keyword">new</span> <span class="title class_">String</span>(bytes));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除节点-1"><a href="#删除节点-1" class="headerlink" title="删除节点"></a>删除节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    </span><br><span class="line">    curatorFramework</span><br><span class="line">        .delete()</span><br><span class="line">        <span class="comment">// guaranteed方法起到一个保障删除成功的作用，其底层工作方式是：</span></span><br><span class="line">        <span class="comment">// 只要该客户端的会话有效，就会在后台持续发起删除请求，直到该数据节点在服务端被删除</span></span><br><span class="line">        .guaranteed() </span><br><span class="line">        <span class="comment">// deletingChildrenIfNeeded方法以递归的方式直接删除其子节点，以及子节点的子节点...</span></span><br><span class="line">        .deletingChildrenIfNeeded()</span><br><span class="line">        <span class="comment">//对这一路径服务</span></span><br><span class="line">        .forPath(<span class="string">&quot;/test&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="异步接口"><a href="#异步接口" class="headerlink" title="异步接口"></a>异步接口</h4><p>Curator引入了<strong>BackgroundCallback</strong>接口，用来处理服务器端返回来的信息，这个处理过程是在异步线程中调用，默认在Zookeeper原生客户端的<strong>EventThread</strong>中调用，也可以自定义线程池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testThreadPool</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	<span class="comment">// 创建线程池</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 异步获取数据，可传入自定义的线程池</span></span><br><span class="line">    curatorFramework.getData()</span><br><span class="line">        .inBackground(</span><br><span class="line">        	(client, event) -&gt; &#123;</span><br><span class="line">        		log.info(<span class="string">&quot; background: &#123;&#125;&quot;</span>, event);</span><br><span class="line">    		&#125;</span><br><span class="line">        	,executorService</span><br><span class="line">    ).forPath(<span class="string">&quot;/test&quot;</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Curator-Caches（过时）"><a href="#Curator-Caches（过时）" class="headerlink" title="Curator Caches（过时）"></a>Curator Caches（过时）</h4><p>Curator引入了Cache来实现对Zookeeper服务端事件监听，Cache事件监听可以理解为一个本地缓存视图与远程Zookeeper视图的对比过程。并且Cache提供了反复注册的功能。</p>
<p>Cache 分为两类注册类型：节点监听和子节点监听。</p>
<ul>
<li>NodeCache对某一个节点进行监听</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nodeCache</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 创建NodeCache</span></span><br><span class="line">    <span class="type">NodeCache</span> <span class="variable">nodeCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NodeCache</span>(curatorFramework, <span class="string">&quot;/test&quot;</span>);</span><br><span class="line">    <span class="comment">// 添加NodeCacheListener监听器</span></span><br><span class="line">    nodeCache.getListenable().addListener(() -&gt; &#123;</span><br><span class="line">        <span class="type">byte</span>[] bytes = curatorFramework.getData().forPath(<span class="string">&quot;/test&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;data &#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>(bytes));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 启动NodeCache</span></span><br><span class="line">    nodeCache.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>PathChildrenCache 会对子节点进行监听，但是不会对二级子节点进行监听：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pathChildrenCache</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 创建PathChildrenCache</span></span><br><span class="line">    <span class="type">PathChildrenCache</span> <span class="variable">pathChildrenCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PathChildrenCache</span>(curatorFramework, <span class="string">&quot;/test&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 添加PathChildrenCacheListener监听器</span></span><br><span class="line">    pathChildrenCache.getListenable().addListener((client,event) -&gt; &#123;</span><br><span class="line">        log.info(<span class="string">&quot;event &#123;&#125;&quot;</span>, event);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 如果设置为true则在首次启动时就会缓存节点内容到Cache中</span></span><br><span class="line">    pathChildrenCache.start(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>TreeCache使用一个内部类TreeNode来维护这个一个树结构。并将这个树结构与Zookeeper节点进行了映射。所以TreeCache可以监听当前节点下所有节点的事件：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">treeCache</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 创建TreeCache</span></span><br><span class="line">    <span class="type">TreeCache</span> <span class="variable">treeCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeCache</span>(curatorFramework, <span class="string">&quot;/test&quot;</span>);</span><br><span class="line">    <span class="comment">// 添加TreeCacheListener监听器</span></span><br><span class="line">    treeCache.getListenable().addListener((client,event) -&gt; &#123;</span><br><span class="line">        log.info(<span class="string">&quot;event &#123;&#125;&quot;</span>, event);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 启动TreeCache</span></span><br><span class="line">    treeCache.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Zookeeper实战场景"><a href="#Zookeeper实战场景" class="headerlink" title="Zookeeper实战场景"></a>Zookeeper实战场景</h1><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>与Redis一样，Zookeeper也可以实现分布式锁：</p>
<ul>
<li>Redis中通过<code>SETNX</code>命令可以保证只有一个请求可以成功设置key</li>
<li>Zookeeper中所有的节点都不能被重复创建</li>
</ul>
<p>所以说，在Zookeeper实现的分布式锁中，获取锁的过程就是创建节点的过程。</p>
<h3 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h3><p>Zookeeper实现非公平锁的流程大致如下图所示：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/06/05/CSDR5W3EHLnXFBZ.jpg"
                      alt="Screenshot_96.jpg"
                ></p>
<p>获取锁失败的客户端，可以通过Zookeeper的事件监听机制，监听锁节点，一旦锁节点被删除就可以监听到事件，开始继续获取锁。</p>
<p>上述的实现看似很完美，但是在并发问题比较严重的情况下，性能会下降的比较厉害。</p>
<p>主要原因是，所有的连接都在对同一个节点进行监听，当服务器检测到删除事件时，要通知所有的连接，所有的连接同时收到事件，再次并发竞争，这就是<strong>羊群效应</strong>。</p>
<p>这种加锁方式是<strong>非公平锁</strong>的具体实现，非公平锁的羊群效应很难避免，那么可以采取公平锁。</p>
<h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><p>想要实现公平锁，必须要能够实现对所有客户端进行排序。</p>
<p>Redis中的List结构可以实现队列，那么对应Zookeeper中的<strong>顺序节点</strong>也可以实现排序的功能：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/06/05/Cq28SRIrUzmeXPk.jpg"
                      alt="Screenshot_97.jpg"
                ></p>
<ol>
<li>所有的请求到达Zookeeper后首先在锁节点下创建一个顺序节点</li>
<li>判断自己的节点是不是最小节点，如果是则获取锁成功</li>
<li>如果不是最小节点，则获取锁失败，并且<strong>监听前一个结点</strong></li>
<li>获得锁的客户端释放锁后，删除自己的顺序结点，后一个客户端会监听到该事件，重复第2步获取锁</li>
</ol>
<p>借助于临时顺序节点加上事件监听的巧妙设计，可以避免同时多个节点的并发竞争锁，缓解了服务端压力。这种实现方式所有加锁请求都进行排队加锁，是<strong>公平锁</strong>的具体实现。</p>
<h4 id="Curator源码分析"><a href="#Curator源码分析" class="headerlink" title="Curator源码分析"></a>Curator源码分析</h4><p>Curator客户端实现了公平锁，使用方法也很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建InterProcessMutex对象，它就是公平锁类</span></span><br><span class="line"><span class="comment">// 需要传入两个参数：CuratorFramework客户端对象、lock结点名称</span></span><br><span class="line"><span class="type">InterProcessMutex</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterProcessMutex</span>(curatorFramework, <span class="string">&quot;/lock&quot;</span>);</span><br><span class="line"><span class="comment">// 获取锁，可传入超时时间，如果在指定时间内还没有获取到锁就会返回失败</span></span><br><span class="line">lock.acquire();</span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line">lock.release();</span><br></pre></td></tr></table></figure>

<p>接着看看<code>acquire</code>获取锁的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 调用internalLock方法，没有传入超时时间就是-1</span></span><br><span class="line">    <span class="keyword">if</span> ( !internalLock(-<span class="number">1</span>, <span class="literal">null</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(</span><br><span class="line">            <span class="string">&quot;Lost connection while trying to acquire lock: &quot;</span> + basePath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">internalLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">currentThread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从缓存threadData尝试获取当前线程</span></span><br><span class="line">    <span class="comment">// threadData在后续有解释</span></span><br><span class="line">    <span class="type">LockData</span> <span class="variable">lockData</span> <span class="operator">=</span> threadData.get(currentThread);</span><br><span class="line">    <span class="comment">// 如果获取到了，说明是锁【重入】，不是第一次进入了</span></span><br><span class="line">    <span class="keyword">if</span> ( lockData != <span class="literal">null</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将锁的重入次数+1</span></span><br><span class="line">        lockData.lockCount.incrementAndGet();</span><br><span class="line">        <span class="comment">// 获取锁成功，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 第一次进入 需要尝试获取锁</span></span><br><span class="line">    <span class="comment">// 通过LockInternals的attemptLock方法获取锁</span></span><br><span class="line">    <span class="comment">// getLockNodeBytes方法默认返回的是null，留给子类实现</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lockPath</span> <span class="operator">=</span> internals.attemptLock(time, unit, getLockNodeBytes());</span><br><span class="line">    <span class="comment">// 如果获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span> ( lockPath != <span class="literal">null</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将当前线程信息和锁信息存入threadData缓存，便于锁的重入</span></span><br><span class="line">        <span class="type">LockData</span> <span class="variable">newLockData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LockData</span>(currentThread, lockPath);</span><br><span class="line">        threadData.put(currentThread, newLockData);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LockInternals的<code>attemptLock</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">attemptLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit, <span class="type">byte</span>[] lockNodeBytes)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">// 相对不重要的参数</span></span><br><span class="line">       <span class="keyword">final</span> <span class="type">long</span>      <span class="variable">startMillis</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">       <span class="keyword">final</span> <span class="type">Long</span>      <span class="variable">millisToWait</span> <span class="operator">=</span> (unit != <span class="literal">null</span>) ? unit.toMillis(time) : <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">final</span> <span class="type">byte</span>[]    localLockNodeBytes = (revocable.get() != <span class="literal">null</span>) ? <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0</span>] : lockNodeBytes;</span><br><span class="line">       <span class="type">int</span>             <span class="variable">retryCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="type">String</span>          <span class="variable">ourPath</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="type">boolean</span>         <span class="variable">hasTheLock</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="type">boolean</span>         <span class="variable">isDone</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="comment">// 循环</span></span><br><span class="line">       <span class="keyword">while</span> ( !isDone )</span><br><span class="line">       &#123;</span><br><span class="line">           isDone = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span></span><br><span class="line">           &#123;</span><br><span class="line">               <span class="comment">// 通过StandardLockInternalsDriver的createsTheLock方法创建锁结点</span></span><br><span class="line">               <span class="comment">// 只是创建结点，并不一定能获取到锁</span></span><br><span class="line">               ourPath = driver.createsTheLock(client, path, localLockNodeBytes);</span><br><span class="line">               <span class="comment">// 通过internalLockLoop方法判断是否获取到锁</span></span><br><span class="line">               hasTheLock = internalLockLoop(startMillis, millisToWait, ourPath);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">catch</span> ( KeeperException.NoNodeException e )</span><br><span class="line">           &#123;</span><br><span class="line">               ....</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 如果获取到锁</span></span><br><span class="line">       <span class="keyword">if</span> ( hasTheLock )</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">// 返回锁结点路径</span></span><br><span class="line">           <span class="keyword">return</span> ourPath;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>StandardLockInternalsDriver的<code>createsTheLock</code>方法创建锁结点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">createsTheLock</span><span class="params">(CuratorFramework client, String path, <span class="type">byte</span>[] lockNodeBytes)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">&#123;</span><br><span class="line">    String ourPath;</span><br><span class="line">    <span class="comment">// 这里传入的lockNodeBytes默认为null，所以会进入else</span></span><br><span class="line">    <span class="keyword">if</span> ( lockNodeBytes != <span class="literal">null</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        ourPath = client.create().creatingParentContainersIfNeeded().withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath(path, lockNodeBytes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 通过Curator客户端创建节点</span></span><br><span class="line">        ourPath = client.create()</span><br><span class="line">            .creatingParentContainersIfNeeded() <span class="comment">// 创建的锁节点是容器节点</span></span><br><span class="line">            .withProtection() <span class="comment">// 通过Protection模式创建，防止僵尸节点</span></span><br><span class="line">            .withMode(CreateMode.EPHEMERAL_SEQUENTIAL) <span class="comment">// 每个客户端创建的是临时顺序节点</span></span><br><span class="line">            .forPath(path); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ourPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Curator客户端创建顺序节点成功后，如果由于网络问题没有收到服务器的返回结果，会进行重试，如果不进行任何处理操作，那么会创建一个新的顺序节点，那么之前的节点就被称为<strong>僵尸节点</strong>。</p>
<p>Curator提供了一种Protection模式，创建节点时会给节点加一个uuid作为前缀，由于网络问题没有收到服务器的返回结果进行重试的时候，会先用uuid检查是否已经创建过，这样就可以防止僵尸节点的产生。 </p>
</blockquote>
<p>创建完节点后，再回到LockInternals的<code>internalLockLoop</code>节点判断是否能获取锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">internalLockLoop</span><span class="params">(<span class="type">long</span> startMillis, Long millisToWait, String ourPath)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="type">boolean</span>     <span class="variable">haveTheLock</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="type">boolean</span>     <span class="variable">doDelete</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">try</span></span><br><span class="line">       &#123;</span><br><span class="line">          ...</span><br><span class="line">          <span class="keyword">while</span> ( (client.getState() == CuratorFrameworkState.STARTED) &amp;&amp; !haveTheLock )</span><br><span class="line">          &#123;</span><br><span class="line">               </span><br><span class="line">               <span class="comment">// 通过getSortedChildren方法获得锁节点下的所有顺序节点</span></span><br><span class="line">               <span class="comment">// 并且按照序号从小到大排序</span></span><br><span class="line">               List&lt;String&gt;  children = getSortedChildren();</span><br><span class="line">               <span class="comment">// 获取顺序节点名称，截去父节点</span></span><br><span class="line">               <span class="type">String</span>   <span class="variable">sequenceNodeName</span> </span><br><span class="line">                   <span class="operator">=</span> ourPath.substring(basePath.length() + <span class="number">1</span>); </span><br><span class="line">              <span class="comment">//  通过StandardLockInternalsDriver的getsTheLock方法判断是否获取到锁</span></span><br><span class="line">              <span class="comment">// 如果获取锁失败，会返回当前顺序结点的前一个结点</span></span><br><span class="line">              <span class="comment">// 如果获取锁成功，会返回null</span></span><br><span class="line">              <span class="comment">// 公平锁的话这里传入的maxLeases=1</span></span><br><span class="line">               <span class="type">PredicateResults</span>    <span class="variable">predicateResults</span> <span class="operator">=</span> driver.getsTheLock(client, children, sequenceNodeName, maxLeases);</span><br><span class="line">              </span><br><span class="line">               <span class="comment">// 如果获取到锁</span></span><br><span class="line">               <span class="keyword">if</span> ( predicateResults.getsTheLock() )</span><br><span class="line">               &#123;</span><br><span class="line">                   haveTheLock = <span class="literal">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">              <span class="comment">// 如果没获取到锁</span></span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="comment">// 得到当前顺序结点的前一个结点路径，也就是需要监听的结点</span></span><br><span class="line">                   <span class="type">String</span>  <span class="variable">previousSequencePath</span> <span class="operator">=</span> basePath + <span class="string">&quot;/&quot;</span> + predicateResults.getPathToWatch();</span><br><span class="line">                   <span class="keyword">synchronized</span>(<span class="built_in">this</span>)</span><br><span class="line">                   &#123;</span><br><span class="line">                       <span class="keyword">try</span></span><br><span class="line">                       &#123;</span><br><span class="line">                           <span class="comment">// 通过Curator客户端添加监听，监听的是当前顺序节点的前一个结点</span></span><br><span class="line">                           client.getData()</span><br><span class="line">                               .usingWatcher(watcher)</span><br><span class="line">                               .forPath(previousSequencePath);</span><br><span class="line">                           <span class="keyword">if</span> ( millisToWait != <span class="literal">null</span> )</span><br><span class="line">                           &#123;</span><br><span class="line">                               millisToWait -= (System.currentTimeMillis() - startMillis);</span><br><span class="line">                               startMillis = System.currentTimeMillis();</span><br><span class="line">                               <span class="keyword">if</span> ( millisToWait &lt;= <span class="number">0</span> )</span><br><span class="line">                               &#123;</span><br><span class="line">                                   doDelete = <span class="literal">true</span>;    <span class="comment">// timed out - delete our node</span></span><br><span class="line">                                   <span class="keyword">break</span>;</span><br><span class="line">                               &#125;</span><br><span class="line">							<span class="comment">// 线程等待</span></span><br><span class="line">                               <span class="comment">// 当监听到前一个顺序结点被删除的事件后</span></span><br><span class="line">                               <span class="comment">// 监听器会通过notify唤醒当前线程</span></span><br><span class="line">                               wait(millisToWait);</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="keyword">else</span></span><br><span class="line">                           &#123;</span><br><span class="line">                               wait();</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       ...</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       ...</span><br><span class="line">       <span class="keyword">return</span> haveTheLock;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>StandardLockInternalsDriver的<code>getsTheLock</code>方法判断是否获取到锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 公平锁的话这里传入的maxLeases=1，在创建InterProcessMutex对象时确定</span></span><br><span class="line"><span class="keyword">public</span> PredicateResults <span class="title function_">getsTheLock</span><span class="params">(CuratorFramework client, List&lt;String&gt; children, String sequenceNodeName, <span class="type">int</span> maxLeases)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">// 获取当前顺序结点的索引</span></span><br><span class="line">       <span class="type">int</span>             <span class="variable">ourIndex</span> <span class="operator">=</span> children.indexOf(sequenceNodeName);</span><br><span class="line">       validateOurIndex(sequenceNodeName, ourIndex);</span><br><span class="line">	   <span class="comment">// 如果索引小于1，也就是索引为0 [maxLeases=1]</span></span><br><span class="line">       <span class="type">boolean</span>         <span class="variable">getsTheLock</span> <span class="operator">=</span> ourIndex &lt; maxLeases;</span><br><span class="line">       <span class="comment">// 说明当前线程排在第一个，可以获取锁</span></span><br><span class="line">       <span class="comment">// 否则不能获取锁，需要监听前一个顺序结点</span></span><br><span class="line">       <span class="type">String</span>          <span class="variable">pathToWatch</span> <span class="operator">=</span> getsTheLock ? <span class="literal">null</span> : children.get(ourIndex - maxLeases);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PredicateResults</span>(pathToWatch, getsTheLock);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>Curator公平锁的实现流程大致如下：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/06/06/uN5qWTzrlsUd3wB.jpg"
                      alt="Screenshot_98.jpg"
                ></p>
<h3 id="zookeeper和redis区别"><a href="#zookeeper和redis区别" class="headerlink" title="zookeeper和redis区别"></a>zookeeper和redis区别</h3><p>两者做分布式锁的区别在于两者的集群结构不一致</p>
<p>redis是主从分布结构，写入时是在Master中写入，然后再同步到到从机中</p>
<p>zookeeper是Leader和Follower结构，每次写入是需要根据Follower写入成功的次数进行判断的【比如有三个Follower，需要3&#x2F;2+1&#x3D;2，也就是两个Follower写入成功才被认为写入成功。【也被称为zb协议</p>
<p>那么在redis中如果写入成功，但是还未完成同步时宕机了，那么也就导致信息丢失了。</p>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>前面这两种加锁方式有一个共同的特质，就是都是<strong>互斥锁</strong>，同一时间只能有一个请求占用，如果是大量的并发上来，性能是会急剧下降的。Curator还实现了读写锁，在读多写少的情况下性能会有很大提升。</p>
<h4 id="实现思路-1"><a href="#实现思路-1" class="headerlink" title="实现思路"></a>实现思路</h4><p>读写锁和公平锁的思路类似，同样需要借助顺序节点实现：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/01/30/zg5pivh8YdbROwL.png"
                      alt="zk11.jpg"
                ></p>
<p>根据读写锁的特性，之前公平锁的监听方式需要稍作修改：</p>
<ul>
<li>读节点监听在它前面最近的一个写节点</li>
<li>写节点监听它的前一个节点，和公平锁一样</li>
</ul>
<p>这样就可以实现一个读写锁。</p>
<h4 id="Curator源码分析-1"><a href="#Curator源码分析-1" class="headerlink" title="Curator源码分析"></a>Curator源码分析</h4><p>Curator客户端实现了读写锁，使用方法也很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建读写锁</span></span><br><span class="line"><span class="type">InterProcessReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InterProcessReadWriteLock</span>(curatorFramework, <span class="string">&quot;/readwritelock&quot;</span>);</span><br><span class="line"><span class="comment">// 读锁</span></span><br><span class="line"><span class="type">InterProcessMutex</span> <span class="variable">readLock</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line"><span class="comment">// 写锁</span></span><br><span class="line"><span class="type">InterProcessMutex</span> <span class="variable">writeLock</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line"><span class="comment">// 获取读锁</span></span><br><span class="line">readLock.acquire();</span><br><span class="line"><span class="comment">// 释放读锁</span></span><br><span class="line">readLock.release();</span><br><span class="line"><span class="comment">// 获取写锁</span></span><br><span class="line">writeLock.acquire();</span><br><span class="line"><span class="comment">// 释放写锁</span></span><br><span class="line">writeLock.release();</span><br></pre></td></tr></table></figure>

<p>首先来看一下读写锁InterProcessReadWriteLock的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">InterProcessReadWriteLock</span><span class="params">(CuratorFramework client, String basePath, <span class="type">byte</span>[] lockData)</span></span><br><span class="line">&#123;</span><br><span class="line">    lockData = (lockData == <span class="literal">null</span>) ? <span class="literal">null</span> : Arrays.copyOf(lockData, lockData.length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写锁</span></span><br><span class="line">    writeMutex = <span class="keyword">new</span> <span class="title class_">InternalInterProcessMutex</span></span><br><span class="line">    (</span><br><span class="line">        client,</span><br><span class="line">        basePath,</span><br><span class="line">        WRITE_LOCK_NAME,</span><br><span class="line">        lockData,</span><br><span class="line">        <span class="comment">// 这里是区分读写锁的关键，写锁传入的是1</span></span><br><span class="line">        <span class="number">1</span>,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SortingLockInternalsDriver</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="comment">// 这里重写了StandardLockInternalsDriver的getsTheLock方法</span></span><br><span class="line">            <span class="keyword">public</span> PredicateResults <span class="title function_">getsTheLock</span><span class="params">(CuratorFramework client, List&lt;String&gt; children, String sequenceNodeName, <span class="type">int</span> maxLeases)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 直接调用原来的方法，相当于没重写</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">super</span>.getsTheLock(client, children, sequenceNodeName, maxLeases);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读锁</span></span><br><span class="line">    readMutex = <span class="keyword">new</span> <span class="title class_">InternalInterProcessMutex</span></span><br><span class="line">    (</span><br><span class="line">        client,</span><br><span class="line">        basePath,</span><br><span class="line">        READ_LOCK_NAME,</span><br><span class="line">        lockData,</span><br><span class="line">        <span class="comment">// 这里是区分读写锁的关键，读锁传入的是Integer.MAX_VALUE</span></span><br><span class="line">        Integer.MAX_VALUE,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SortingLockInternalsDriver</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="comment">// 这里重写了StandardLockInternalsDriver的getsTheLock方法</span></span><br><span class="line">            <span class="keyword">public</span> PredicateResults <span class="title function_">getsTheLock</span><span class="params">(CuratorFramework client, List&lt;String&gt; children, String sequenceNodeName, <span class="type">int</span> maxLeases)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 调用了readLockPredicate方法</span></span><br><span class="line">                <span class="keyword">return</span> readLockPredicate(children, sequenceNodeName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写锁的创建和执行流程和公平锁几乎一模一样，都是获取锁失败失败监听前一个结点。</p>
<p>但是读锁略有不同，它在获取锁失败后需要，监听在它之前最近的一个写结点。</p>
<p>读锁创建时，重写了StandardLockInternalsDriver的<code>getsTheLock</code>方法，该方法用于判断是否获取到锁并且添加监听。重写的方法回调用InterProcessReadWriteLock的<code>readLockPredicate</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> PredicateResults <span class="title function_">readLockPredicate</span><span class="params">(List&lt;String&gt; children, String sequenceNodeName)</span> <span class="keyword">throws</span> Exception</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span> ( writeMutex.isOwnedByCurrentThread() )</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PredicateResults</span>(<span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="type">int</span>         <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">     <span class="type">int</span>         <span class="variable">firstWriteIndex</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">     <span class="type">int</span>         <span class="variable">ourIndex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">     <span class="comment">// 遍历锁结点下的所有顺序结点</span></span><br><span class="line">     <span class="keyword">for</span> ( String node : children )</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">// 如果当前节点是写节点</span></span><br><span class="line">         <span class="keyword">if</span> ( node.contains(WRITE_LOCK_NAME) )</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="comment">// 记录它的索引</span></span><br><span class="line">             firstWriteIndex = Math.min(index, firstWriteIndex);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 如果当前节点就是自己</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> ( node.startsWith(sequenceNodeName) )</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="comment">// ourIndex表示自己的位置</span></span><br><span class="line">             ourIndex = index;</span><br><span class="line">             <span class="comment">// 退出循环</span></span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line"><span class="comment">// 索引加1</span></span><br><span class="line">         ++index;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     StandardLockInternalsDriver.validateOurIndex(sequenceNodeName, ourIndex);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 如果自己的索引小于第一个写节点的索引，表示前面没有写节点，直接获取锁</span></span><br><span class="line">     <span class="comment">// 否则需要接听该写节点</span></span><br><span class="line">     <span class="type">boolean</span>     <span class="variable">getsTheLock</span> <span class="operator">=</span> (ourIndex &lt; firstWriteIndex);</span><br><span class="line">     <span class="type">String</span>      <span class="variable">pathToWatch</span> <span class="operator">=</span> getsTheLock ? <span class="literal">null</span> : children.get(firstWriteIndex);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PredicateResults</span>(pathToWatch, getsTheLock);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>按照以上代码的逻辑，就实现了读锁的共享。</p>
<h2 id="Leader选举"><a href="#Leader选举" class="headerlink" title="Leader选举"></a>Leader选举</h2><blockquote>
<p>这里的Leader选举并不是Zookeeper集群中的Leader选举。</p>
</blockquote>
<p>在分布式场景中，我们常常会启动很多微服务节点作为一个微服务集群，它们的代码都是一样的，只是用作负载均衡。但是如果我们要进行类似<strong>缓存预热</strong>的操作，只需要一个微服务节点进行操作，该如何操作？</p>
<p>【也就是从集群中找一个节点来提供服务  </p>
<p>其实分布式锁就可以实现，但是Curator为我们提供了一个更加方便的Leader选举功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个LeaderSelectorListenerAdapter</span></span><br><span class="line"><span class="type">LeaderSelectorListener</span> <span class="variable">listener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LeaderSelectorListenerAdapter</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 实现takeLeadership方法</span></span><br><span class="line">    <span class="comment">// 如果当前节点成为了Leader，就会执行该方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">takeLeadership</span><span class="params">(CuratorFramework client)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="comment">// 执行业务逻辑，比如缓存预热</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个LeaderSelector节点选举器</span></span><br><span class="line"><span class="comment">// 传入参数：Curator客户端、一个节点路径、LeaderSelectorListenerAdapter对象</span></span><br><span class="line"><span class="type">LeaderSelector</span> <span class="variable">selector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LeaderSelector</span>(curatorFramework, <span class="string">&quot;/leader&quot;</span>, listener);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果调用了autoRequeue方法，那么选出的Leader节点执行完takeLeadership方法后会开始下一轮选举</span></span><br><span class="line"><span class="comment">// 如果没调用autoRequeue方法，只会进行一轮选举</span></span><br><span class="line">selector.autoRequeue(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始选举</span></span><br><span class="line">selector.start();</span><br></pre></td></tr></table></figure>

<p>Leader选举功能的实现其实就是基于锁的，不过该功能的使用场景较少，在一些特殊场景可能会用到。</p>
<h2 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h2><p>用Zookeeper实现注册中心是非常常见的一个应用场景。</p>
<p>在复杂的微服务系统中，各个微服务节点都有自己不同的IP和端口号，并且在复杂的调用关系中，维护每个微服务节点的地址是一件不容易的事情，特别是在风云多变的网络环境中。</p>
<p>所以使用注册中心，用于管理、维护整个系统的服务，并且便于服务间的调用，还是非常必要的。</p>
<h3 id="原理简介"><a href="#原理简介" class="headerlink" title="原理简介"></a>原理简介</h3><p>Zookeeper实现注册中的原理其实并不复杂。假设A服务要调用B服务：</p>
<ul>
<li>B服务集群启动后，每个微服务节点向Zookeeper中创建一个临时节点，比如：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设服务B集群有三个微服务节点</span></span><br><span class="line"><span class="comment"># 节点路径             # 节点内容</span></span><br><span class="line">service-B/node1  &#123;<span class="string">&quot;ip&quot;</span>:<span class="string">&quot;192.168.77.88&quot;</span>,<span class="string">&quot;port&quot;</span>:<span class="string">&quot;8081&quot;</span>&#125;</span><br><span class="line">service-B/node2  &#123;<span class="string">&quot;ip&quot;</span>:<span class="string">&quot;192.168.77.89&quot;</span>,<span class="string">&quot;port&quot;</span>:<span class="string">&quot;8082&quot;</span>&#125;</span><br><span class="line">service-B/node3  &#123;<span class="string">&quot;ip&quot;</span>:<span class="string">&quot;192.168.77.90&quot;</span>,<span class="string">&quot;port&quot;</span>:<span class="string">&quot;8083&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>由于是临时节点，服务需要每隔一段时间向Zookeeper发送一次<strong>心跳</strong>，用于通知自己状态正常。如果Zookeeper超过一定时间没有收到某个节点的心跳，会将该节点删除。</li>
<li>A服务<strong>监听</strong>B服务集群在Zookeeper中的节点，将数据缓存在本地。一旦B服务集群状态有了变化，可以立刻收到事件通知，修改缓存。</li>
<li>A服务调用B服务时，直接从本地缓存中就可以拿到B服务集群中所有节点的地址，可以进行负载均衡、失败重试等操作。</li>
</ul>
<p>在zookeeper中，进行服务注册，实际上就是在zookeeper中创建了一个znode节点，该节点存储了该服务的IP、端口、调用方式(协议、序列化方式)等。</p>
<p>该节点承担着最重要的职责，它由服务提供者(发布服务时)创建，以供服务消费者获取节点中的信息，从而定位到服务提供者真正网络拓扑位置以及得知如何调用。</p>
<p>同时zookeeper服务需要对服务的宕机和新增进行信息更新，这就是zookeeper的监听机制了，由于zookeeper使用的是临时节点，那么需要服务端给节点发送心跳，如果心跳终止，那么认为节点宕机了，需要删除节点。</p>
<p>此时客户端由于监听了节点信息，发现某个节点消失，那么会更新本地缓存信息，同时再次监听节点。</p>
<h3 id="Spring-Cloud案例"><a href="#Spring-Cloud案例" class="headerlink" title="Spring Cloud案例"></a>Spring Cloud案例</h3><p>之前在介绍<a class="link"   target="_blank" rel="noopener" href="https://jimmyz.top/2020/08/15/dubbo/" >Dubbo<i class="fas fa-external-link-alt"></i></a>的时候，我们就通过Zookeeper作为注册中心搭建了一个最简单的微服务架构。其实<strong>Spring Cloud</strong>也支持使用Zookeeper作为注册中心。我们就通过Zookeeper作为注册中心搭建一个简单的Spring Cloud架构：</p>
<h4 id="消费端"><a href="#消费端" class="headerlink" title="消费端"></a>消费端</h4><ul>
<li>导入依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- spring boot--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- spring boot web模块 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- zookeeper注册中心 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zookeeper-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- spring cloud--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>Hoxton.SR8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>配置文件</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8080</span></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">consumer</span></span><br><span class="line"><span class="comment"># zookeeper 连接地址</span></span><br><span class="line"><span class="attr">spring.cloud.zookeeper.connect-string</span>=<span class="string">192.168.74.88:2181</span></span><br></pre></td></tr></table></figure>

<ul>
<li>启动类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserCenterApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(UserCenterApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入RestTemplate用于http调用</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">// 加上@LoadBalanced注解可以实现负载均衡</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">RestTemplate</span> <span class="variable">restTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">         <span class="keyword">return</span> restTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Controller</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入负载均衡客户端</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoadBalancerClient loadBalancerClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 通过负载均衡客户端可以用过服务名称，查看服务地址</span></span><br><span class="line">        <span class="comment">// 能实现这样的功能就是因为注册中心</span></span><br><span class="line">        <span class="type">ServiceInstance</span> <span class="variable">choose</span> <span class="operator">=</span> loadBalancerClient.choose(<span class="string">&quot;server&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">serviceId</span> <span class="operator">=</span> choose.getServiceId();</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> choose.getPort();</span><br><span class="line">        System.out.println(serviceId + <span class="string">&quot; : &quot;</span>+port);</span><br><span class="line">        <span class="comment">// 通过restTemplate调用服务端</span></span><br><span class="line">        <span class="comment">// 直接通过服务名就能够调用</span></span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">&quot;http://service/getinfo&quot;</span>, String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><ul>
<li>导入依赖：与消费端相同</li>
<li>配置文件</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8082</span></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">server</span></span><br><span class="line"><span class="comment"># zookeeper 连接地址</span></span><br><span class="line"><span class="attr">spring.cloud.zookeeper.connect-string</span>=<span class="string">192.168.74.88:2181</span></span><br><span class="line"><span class="comment"># 将本服务注册到zookeeper</span></span><br><span class="line"><span class="attr">spring.cloud.zookeeper.discovery.register</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 配置会话超时时间</span></span><br><span class="line"><span class="attr">spring.cloud.zookeeper.session-timeout</span>=<span class="string">30000</span></span><br></pre></td></tr></table></figure>

<ul>
<li>启动类省略</li>
<li>Controller</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerController</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@GetMapping(&quot;/getinfo&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getServerPortAndName</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;调用成功&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
            </div>

            
                <div class="post-copyright-info">
                    
<div class="article-copyright-info-container">
    <ul class="copyright-info-content">
        <li class="post-title">
            <span class="type">本文标题</span>：<span class="content">Zookeeper</span>
        </li>
        <li class="post-author">
            <span class="type">本文作者</span>：<span class="content">liduoan.efls</span>
        </li>
        <li class="post-time">
            <span class="type">创建时间</span>：<span class="content">2021-06-02 18:13:54</span>
        </li>
        <li class="post-link">
            <span class="type">本文链接</span>：<span class="content">2021/06/02/2021/Zookeeper/</span>
        </li>
        <li class="post-license">
            <span class="type">版权声明</span>：<span class="content">本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！</span>
        </li>
    </ul>
    <div class="copy-copyright-info flex-center tooltip" data-content="复制版权信息" data-offset-y="-2px">
        <i class="fa-solid fa-copy"></i>
    </div>
</div>

                </div>
            

            
                <ul class="post-tags-box">
                    
                        <li class="tag-item">
                            <a href="/tags/2021/">#2021</a>&nbsp;
                        </li>
                    
                </ul>
            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                               rel="prev"
                               href="/2021/06/07/2021/RabbitMQ/"
                            >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                                <span class="title flex-center">
                                <span class="post-nav-title-item">RabbitMQ</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                               rel="next"
                               href="/2021/05/21/2021/Mybatis%E7%A9%B6%E6%9E%81%E8%A7%A3%E6%9E%90/"
                            >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Mybatis究极解析</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                                <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                            </a>
                        </div>
                    
                </div>
            

            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Zookeeper%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">Zookeeper简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.</span> <span class="nav-text">核心概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.1.</span> <span class="nav-text">文件系统数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%91%E5%90%AC%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6"><span class="nav-number">1.1.2.</span> <span class="nav-text">监听通知机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Zookeeper%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.2.</span> <span class="nav-text">Zookeeper应用场景</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Zookeeper%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-number">2.</span> <span class="nav-text">Zookeeper基本使用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85"><span class="nav-number">2.1.</span> <span class="nav-text">下载与安装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA"><span class="nav-number">2.2.</span> <span class="nav-text">集群搭建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Zookeeper%E9%9B%86%E7%BE%A4%E7%AE%80%E4%BB%8B"><span class="nav-number">2.2.1.</span> <span class="nav-text">Zookeeper集群简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="nav-number">2.2.2.</span> <span class="nav-text">集群配置文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE-%E6%96%B0"><span class="nav-number">2.2.3.</span> <span class="nav-text">集群动态配置(新)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9CZookeeper"><span class="nav-number">2.3.</span> <span class="nav-text">命令行操作Zookeeper</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%8A%82%E7%82%B9"><span class="nav-number">2.3.1.</span> <span class="nav-text">创建节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E8%8A%82%E7%82%B9"><span class="nav-number">2.3.2.</span> <span class="nav-text">修改节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E8%8A%82%E7%82%B9"><span class="nav-number">2.3.3.</span> <span class="nav-text">查看节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%9B%91%E5%90%AC"><span class="nav-number">2.3.4.</span> <span class="nav-text">创建监听</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ACL%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6"><span class="nav-number">2.3.5.</span> <span class="nav-text">ACL权限控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">2.3.5.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="nav-number">2.3.5.2.</span> <span class="nav-text">相关命令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">2.3.6.</span> <span class="nav-text">持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97log"><span class="nav-number">2.3.6.1.</span> <span class="nav-text">事务日志log</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BF%AB%E7%85%A7snapshot"><span class="nav-number">2.3.6.2.</span> <span class="nav-text">数据快照snapshot</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8"><span class="nav-number">2.4.</span> <span class="nav-text">客户端使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Zookeeper%E5%8E%9F%E7%94%9F%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-number">2.4.1.</span> <span class="nav-text">Zookeeper原生客户端</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%9E%E4%BE%8B"><span class="nav-number">2.4.1.1.</span> <span class="nav-text">创建客户端实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%8A%82%E7%82%B9-1"><span class="nav-number">2.4.1.2.</span> <span class="nav-text">创建节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E8%8A%82%E7%82%B9-1"><span class="nav-number">2.4.1.3.</span> <span class="nav-text">修改节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9"><span class="nav-number">2.4.1.4.</span> <span class="nav-text">删除节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%9B%91%E5%90%AC-1"><span class="nav-number">2.4.1.5.</span> <span class="nav-text">创建监听</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Curator%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-number">2.4.2.</span> <span class="nav-text">Curator客户端</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%9E%E4%BE%8B-1"><span class="nav-number">2.4.2.1.</span> <span class="nav-text">创建客户端实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%8A%82%E7%82%B9-2"><span class="nav-number">2.4.2.2.</span> <span class="nav-text">创建节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="nav-number">2.4.2.3.</span> <span class="nav-text">获取数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E8%8A%82%E7%82%B9-2"><span class="nav-number">2.4.2.4.</span> <span class="nav-text">修改节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9-1"><span class="nav-number">2.4.2.5.</span> <span class="nav-text">删除节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.4.2.6.</span> <span class="nav-text">异步接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Curator-Caches%EF%BC%88%E8%BF%87%E6%97%B6%EF%BC%89"><span class="nav-number">2.4.2.7.</span> <span class="nav-text">Curator Caches（过时）</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Zookeeper%E5%AE%9E%E6%88%98%E5%9C%BA%E6%99%AF"><span class="nav-number">3.</span> <span class="nav-text">Zookeeper实战场景</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">3.1.</span> <span class="nav-text">分布式锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="nav-number">3.1.1.</span> <span class="nav-text">非公平锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81"><span class="nav-number">3.1.2.</span> <span class="nav-text">公平锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="nav-number">3.1.2.1.</span> <span class="nav-text">实现思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Curator%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">3.1.2.2.</span> <span class="nav-text">Curator源码分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">3.1.2.3.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#zookeeper%E5%92%8Credis%E5%8C%BA%E5%88%AB"><span class="nav-number">3.1.3.</span> <span class="nav-text">zookeeper和redis区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-number">3.1.4.</span> <span class="nav-text">读写锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF-1"><span class="nav-number">3.1.4.1.</span> <span class="nav-text">实现思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Curator%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1"><span class="nav-number">3.1.4.2.</span> <span class="nav-text">Curator源码分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Leader%E9%80%89%E4%B8%BE"><span class="nav-number">3.2.</span> <span class="nav-text">Leader选举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="nav-number">3.3.</span> <span class="nav-text">注册中心</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%90%86%E7%AE%80%E4%BB%8B"><span class="nav-number">3.3.1.</span> <span class="nav-text">原理简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-Cloud%E6%A1%88%E4%BE%8B"><span class="nav-number">3.3.2.</span> <span class="nav-text">Spring Cloud案例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E7%AB%AF"><span class="nav-number">3.3.2.1.</span> <span class="nav-text">消费端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="nav-number">3.3.2.2.</span> <span class="nav-text">服务端</span></a></li></ol></li></ol></li></ol></li></ol>
    </div>
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            
<footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
                <span>2020</span> -
            
            2023
            
                &nbsp;<i class="fas fa-heart icon-animate"></i>
                &nbsp;<a href="/">liduoan.efls</a>
            
        </div>
        
            <script async data-pjax
                    src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                
                
                    总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.6.1</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item flex-center toggle-show-toc">
                <i class="fas fa-list"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="close-popup-btn">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/dark-light-toggle.js"></script>




    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/code-block.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/lazyload.js"></script>


<div class="post-scripts pjax">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/post-helper.js"></script>
        
            <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/libs/anime.min.js"></script>
        
        
            <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/toc.js"></script>
        
    
</div>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
